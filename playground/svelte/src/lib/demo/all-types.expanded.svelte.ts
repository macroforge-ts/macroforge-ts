import { SerializeContext } from "macroforge/serde";
import { DeserializeContext } from "macroforge/serde";
import { DeserializeError } from "macroforge/serde";
import type { DeserializeOptions } from "macroforge/serde";
import { PendingRef } from "macroforge/serde";
import { Result } from "macroforge/utils";
import { Option } from "macroforge/utils";
import type { FieldController } from "@playground/macro/gigaform";
import type { ArrayFieldController } from "@playground/macro/gigaform";
/** import macro {Gigaform} from "@playground/macro"; */


export interface User {
    id: string;
    email: string | null;
    
    firstName: string;
    
    lastName: string;
    password: string | null;
    metadata: Metadata | null;
    settings: Settings;
    
    role: UserRole;
    emailVerified: boolean;
    verificationToken: string | null;
    verificationExpires: string | null;
    passwordResetToken: string | null;
    passwordResetExpires: string | null;
    permissions: AppPermissions;
}

export function userDefaultValue(): User {return {id: "",
                            email: null,
                            firstName: "",
                            lastName: "",
                            password: null,
                            metadata: null,
                            settings: settingsDefaultValue(),
                            role: "Administrator",
                            emailVerified: false,
                            verificationToken: null,
                            verificationExpires: null,
                            passwordResetToken: null,
                            passwordResetExpires: null,
                            permissions: appPermissionsDefaultValue(), }as User;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function userSerialize(value: User): string {const ctx = SerializeContext.create(); return JSON.stringify(userSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function userSerializeWithContext(value: User, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "User" , __id,}; result["id" ]= value.id; result["email" ]= value.email; result["firstName" ]= value.firstName; result["lastName" ]= value.lastName; result["password" ]= value.password; if(value.metadata!== null){result["metadata" ]= metadataSerializeWithContext(value.metadata, ctx); }else {result["metadata" ]= null;}result["settings" ]= settingsSerializeWithContext(value.settings, ctx); result["role" ]= userRoleSerializeWithContext(value.role, ctx); result["emailVerified" ]= value.emailVerified; result["verificationToken" ]= value.verificationToken; result["verificationExpires" ]= value.verificationExpires; result["passwordResetToken" ]= value.passwordResetToken; result["passwordResetExpires" ]= value.passwordResetExpires; result["permissions" ]= appPermissionsSerializeWithContext(value.permissions, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function userDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: User } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = userDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "User.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function userDeserializeWithContext(value: any, ctx: DeserializeContext): User | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "User.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("firstName" in obj)){errors.push({field: "firstName" , message: "missing required field" });}if(!("lastName" in obj)){errors.push({field: "lastName" , message: "missing required field" });}if(!("password" in obj)){errors.push({field: "password" , message: "missing required field" });}if(!("metadata" in obj)){errors.push({field: "metadata" , message: "missing required field" });}if(!("settings" in obj)){errors.push({field: "settings" , message: "missing required field" });}if(!("role" in obj)){errors.push({field: "role" , message: "missing required field" });}if(!("emailVerified" in obj)){errors.push({field: "emailVerified" , message: "missing required field" });}if(!("verificationToken" in obj)){errors.push({field: "verificationToken" , message: "missing required field" });}if(!("verificationExpires" in obj)){errors.push({field: "verificationExpires" , message: "missing required field" });}if(!("passwordResetToken" in obj)){errors.push({field: "passwordResetToken" , message: "missing required field" });}if(!("passwordResetExpires" in obj)){errors.push({field: "passwordResetExpires" , message: "missing required field" });}if(!("permissions" in obj)){errors.push({field: "permissions" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_email = obj["email" ]as string | null; instance.email = __raw_email; }{const __raw_firstName = obj["firstName" ]as string; 
                if (__raw_firstName.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
 instance.firstName = __raw_firstName; }{const __raw_lastName = obj["lastName" ]as string; 
                if (__raw_lastName.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
 instance.lastName = __raw_lastName; }{const __raw_password = obj["password" ]as string | null; instance.password = __raw_password; }{const __raw_metadata = obj["metadata" ]as Metadata | null; if(__raw_metadata === null){instance.metadata = null;}else {const __result = metadataDeserializeWithContext(__raw_metadata, ctx); ctx.assignOrDefer(instance, "metadata" , __result); }}{const __raw_settings = obj["settings" ]as Settings; {const __result = settingsDeserializeWithContext(__raw_settings, ctx); ctx.assignOrDefer(instance, "settings" , __result);}}{const __raw_role = obj["role" ]as UserRole; {const __result = userRoleDeserializeWithContext(__raw_role, ctx); ctx.assignOrDefer(instance, "role" , __result);}}{const __raw_emailVerified = obj["emailVerified" ]as boolean; instance.emailVerified = __raw_emailVerified; }{const __raw_verificationToken = obj["verificationToken" ]as string | null; instance.verificationToken = __raw_verificationToken; }{const __raw_verificationExpires = obj["verificationExpires" ]as string | null; instance.verificationExpires = __raw_verificationExpires; }{const __raw_passwordResetToken = obj["passwordResetToken" ]as string | null; instance.passwordResetToken = __raw_passwordResetToken; }{const __raw_passwordResetExpires = obj["passwordResetExpires" ]as string | null; instance.passwordResetExpires = __raw_passwordResetExpires; }{const __raw_permissions = obj["permissions" ]as AppPermissions; {const __result = appPermissionsDeserializeWithContext(__raw_permissions, ctx); ctx.assignOrDefer(instance, "permissions" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as User;}export function userValidateField<K extends keyof User>(field: K, value: User[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "firstName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
 break;}case "lastName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
 break;}}return errors; }export function userValidateFields(partial: Partial<User>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("firstName" in partial && partial.firstName!== undefined){const __val = partial.firstName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
}if("lastName" in partial && partial.lastName!== undefined){const __val = partial.lastName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
}return errors; }export function userHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "email" in o && "firstName" in o && "lastName" in o && "password" in o && "metadata" in o && "settings" in o && "role" in o && "emailVerified" in o && "verificationToken" in o && "verificationExpires" in o && "passwordResetToken" in o && "passwordResetExpires" in o && "permissions" in o;}export function userIs(obj: unknown): obj is User {if(!userHasShape(obj)){return false;}const result = userDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type UserErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; email: Option<Array<string>>; firstName: Option<Array<string>>; lastName: Option<Array<string>>; password: Option<Array<string>>; metadata: Option<Array<string>>; settings: Option<Array<string>>; role: Option<Array<string>>; emailVerified: Option<Array<string>>; verificationToken: Option<Array<string>>; verificationExpires: Option<Array<string>>; passwordResetToken: Option<Array<string>>; passwordResetExpires: Option<Array<string>>; permissions: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type UserTainted = {id: Option<boolean>; email: Option<boolean>; firstName: Option<boolean>; lastName: Option<boolean>; password: Option<boolean>; metadata: Option<boolean>; settings: Option<boolean>; role: Option<boolean>; emailVerified: Option<boolean>; verificationToken: Option<boolean>; verificationExpires: Option<boolean>; passwordResetToken: Option<boolean>; passwordResetExpires: Option<boolean>; permissions: Option<boolean>; }; /** Type-safe field controllers for this form */export interface UserFieldControllers {readonly id: FieldController<string>; readonly email: FieldController<string | null>; readonly firstName: FieldController<string>; readonly lastName: FieldController<string>; readonly password: FieldController<string | null>; readonly metadata: FieldController<Metadata | null>; readonly settings: FieldController<Settings>; readonly role: FieldController<UserRole>; readonly emailVerified: FieldController<boolean>; readonly verificationToken: FieldController<string | null>; readonly verificationExpires: FieldController<string | null>; readonly passwordResetToken: FieldController<string | null>; readonly passwordResetExpires: FieldController<string | null>; readonly permissions: FieldController<AppPermissions>; }/** Gigaform instance containing reactive state and field controllers */export interface UserGigaform {readonly data: User; readonly errors: UserErrors; readonly tainted: UserTainted; readonly fields: UserFieldControllers; validate(): Result<User, Array<{field: string; message: string}>>; reset(overrides?: Partial<User>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function userCreateForm(overrides?: Partial<User>): UserGigaform {let data = $state({...userDefaultValue(),...overrides}); let errors = $state<UserErrors>({_errors: Option.none(), id: Option.none(), email: Option.none(), firstName: Option.none(), lastName: Option.none(), password: Option.none(), metadata: Option.none(), settings: Option.none(), role: Option.none(), emailVerified: Option.none(), verificationToken: Option.none(), verificationExpires: Option.none(), passwordResetToken: Option.none(), passwordResetExpires: Option.none(), permissions: Option.none(), }); let tainted = $state<UserTainted>({id: Option.none(), email: Option.none(), firstName: Option.none(), lastName: Option.none(), password: Option.none(), metadata: Option.none(), settings: Option.none(), role: Option.none(), emailVerified: Option.none(), verificationToken: Option.none(), verificationExpires: Option.none(), passwordResetToken: Option.none(), passwordResetExpires: Option.none(), permissions: Option.none(), }); const fields: UserFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},email: {path: ["email" ]as const, name: "email" , constraints: { required: true }, get: ()=>data.email, set: (value: string | null)=>{data.email = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.email, setError: (value: Option<Array<string>>)=>{errors.email = value;}, getTainted: ()=>tainted.email, setTainted: (value: Option<boolean>)=>{tainted.email = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("email", data.email); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},firstName: {path: ["firstName" ]as const, name: "firstName" , constraints: { required: true }, get: ()=>data.firstName, set: (value: string)=>{data.firstName = value;}, transform: (value: string): string =>value,getError: ()=>errors.firstName, setError: (value: Option<Array<string>>)=>{errors.firstName = value;}, getTainted: ()=>tainted.firstName, setTainted: (value: Option<boolean>)=>{tainted.firstName = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("firstName", data.firstName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},lastName: {path: ["lastName" ]as const, name: "lastName" , constraints: { required: true }, get: ()=>data.lastName, set: (value: string)=>{data.lastName = value;}, transform: (value: string): string =>value,getError: ()=>errors.lastName, setError: (value: Option<Array<string>>)=>{errors.lastName = value;}, getTainted: ()=>tainted.lastName, setTainted: (value: Option<boolean>)=>{tainted.lastName = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("lastName", data.lastName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},password: {path: ["password" ]as const, name: "password" , constraints: { required: true }, get: ()=>data.password, set: (value: string | null)=>{data.password = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.password, setError: (value: Option<Array<string>>)=>{errors.password = value;}, getTainted: ()=>tainted.password, setTainted: (value: Option<boolean>)=>{tainted.password = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("password", data.password); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},metadata: {path: ["metadata" ]as const, name: "metadata" , constraints: { required: true }, get: ()=>data.metadata, set: (value: Metadata | null)=>{data.metadata = value;}, transform: (value: Metadata | null): Metadata | null =>value,getError: ()=>errors.metadata, setError: (value: Option<Array<string>>)=>{errors.metadata = value;}, getTainted: ()=>tainted.metadata, setTainted: (value: Option<boolean>)=>{tainted.metadata = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("metadata", data.metadata); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},settings: {path: ["settings" ]as const, name: "settings" , constraints: { required: true }, get: ()=>data.settings, set: (value: Settings)=>{data.settings = value;}, transform: (value: Settings): Settings =>value,getError: ()=>errors.settings, setError: (value: Option<Array<string>>)=>{errors.settings = value;}, getTainted: ()=>tainted.settings, setTainted: (value: Option<boolean>)=>{tainted.settings = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("settings", data.settings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},role: {path: ["role" ]as const, name: "role" , constraints: { required: true }, get: ()=>data.role, set: (value: UserRole)=>{data.role = value;}, transform: (value: UserRole): UserRole =>value,getError: ()=>errors.role, setError: (value: Option<Array<string>>)=>{errors.role = value;}, getTainted: ()=>tainted.role, setTainted: (value: Option<boolean>)=>{tainted.role = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("role", data.role); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},emailVerified: {path: ["emailVerified" ]as const, name: "emailVerified" , constraints: { required: true }, get: ()=>data.emailVerified, set: (value: boolean)=>{data.emailVerified = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.emailVerified, setError: (value: Option<Array<string>>)=>{errors.emailVerified = value;}, getTainted: ()=>tainted.emailVerified, setTainted: (value: Option<boolean>)=>{tainted.emailVerified = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("emailVerified", data.emailVerified); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},verificationToken: {path: ["verificationToken" ]as const, name: "verificationToken" , constraints: { required: true }, get: ()=>data.verificationToken, set: (value: string | null)=>{data.verificationToken = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.verificationToken, setError: (value: Option<Array<string>>)=>{errors.verificationToken = value;}, getTainted: ()=>tainted.verificationToken, setTainted: (value: Option<boolean>)=>{tainted.verificationToken = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("verificationToken", data.verificationToken); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},verificationExpires: {path: ["verificationExpires" ]as const, name: "verificationExpires" , constraints: { required: true }, get: ()=>data.verificationExpires, set: (value: string | null)=>{data.verificationExpires = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.verificationExpires, setError: (value: Option<Array<string>>)=>{errors.verificationExpires = value;}, getTainted: ()=>tainted.verificationExpires, setTainted: (value: Option<boolean>)=>{tainted.verificationExpires = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("verificationExpires", data.verificationExpires); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},passwordResetToken: {path: ["passwordResetToken" ]as const, name: "passwordResetToken" , constraints: { required: true }, get: ()=>data.passwordResetToken, set: (value: string | null)=>{data.passwordResetToken = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.passwordResetToken, setError: (value: Option<Array<string>>)=>{errors.passwordResetToken = value;}, getTainted: ()=>tainted.passwordResetToken, setTainted: (value: Option<boolean>)=>{tainted.passwordResetToken = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("passwordResetToken", data.passwordResetToken); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},passwordResetExpires: {path: ["passwordResetExpires" ]as const, name: "passwordResetExpires" , constraints: { required: true }, get: ()=>data.passwordResetExpires, set: (value: string | null)=>{data.passwordResetExpires = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.passwordResetExpires, setError: (value: Option<Array<string>>)=>{errors.passwordResetExpires = value;}, getTainted: ()=>tainted.passwordResetExpires, setTainted: (value: Option<boolean>)=>{tainted.passwordResetExpires = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("passwordResetExpires", data.passwordResetExpires); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},permissions: {path: ["permissions" ]as const, name: "permissions" , constraints: { required: true }, get: ()=>data.permissions, set: (value: AppPermissions)=>{data.permissions = value;}, transform: (value: AppPermissions): AppPermissions =>value,getError: ()=>errors.permissions, setError: (value: Option<Array<string>>)=>{errors.permissions = value;}, getTainted: ()=>tainted.permissions, setTainted: (value: Option<boolean>)=>{tainted.permissions = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("permissions", data.permissions); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<User, Array<{field: string; message: string}>>{return userDeserialize(data);}function reset(newOverrides?: Partial<User>): void {data = {...userDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), email: Option.none(), firstName: Option.none(), lastName: Option.none(), password: Option.none(), metadata: Option.none(), settings: Option.none(), role: Option.none(), emailVerified: Option.none(), verificationToken: Option.none(), verificationExpires: Option.none(), passwordResetToken: Option.none(), passwordResetExpires: Option.none(), permissions: Option.none(), }; tainted = {id: Option.none(), email: Option.none(), firstName: Option.none(), lastName: Option.none(), password: Option.none(), metadata: Option.none(), settings: Option.none(), role: Option.none(), emailVerified: Option.none(), verificationToken: Option.none(), verificationExpires: Option.none(), passwordResetToken: Option.none(), passwordResetExpires: Option.none(), permissions: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function userFromFormData(formData: FormData): Result<User, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.email = formData.get("email" )?? "" ;obj.firstName = formData.get("firstName" )?? "" ;obj.lastName = formData.get("lastName" )?? "" ;obj.password = formData.get("password" )?? "" ;obj.metadata = formData.get("metadata" )?? "" ;{const settings Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("settings." )){const fieldName = key.slice("settings." .length); const parts = fieldName.split("." ); let current = settings Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.settings = settings Obj;}{const role Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("role." )){const fieldName = key.slice("role." .length); const parts = fieldName.split("." ); let current = role Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.role = role Obj;}{const emailVerified Val = formData.get("emailVerified" ); obj.emailVerified = emailVerified Val === "true" || emailVerified Val === "on" || emailVerified Val === "1" ;}obj.verificationToken = formData.get("verificationToken" )?? "" ;obj.verificationExpires = formData.get("verificationExpires" )?? "" ;obj.passwordResetToken = formData.get("passwordResetToken" )?? "" ;obj.passwordResetExpires = formData.get("passwordResetExpires" )?? "" ;{const permissions Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("permissions." )){const fieldName = key.slice("permissions." .length); const parts = fieldName.split("." ); let current = permissions Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.permissions = permissions Obj;}return userDeserialize(obj);}

export const User = {
  defaultValue: userDefaultValue,
  serialize: userSerialize,
  serializeWithContext: userSerializeWithContext,
  deserialize: userDeserialize,
  deserializeWithContext: userDeserializeWithContext,
  validateFields: userValidateFields,
  hasShape: userHasShape,
  is: userIs,
  createForm: userCreateForm,
  fromFormData: userFromFormData
} as const;


export interface Service {
    
    id: string;
    
    
    name: string;
    
    
    quickCode: string;
    
    group: string | null;
    
    subgroup: string | null;
    
    unit: string | null;
    
    active: boolean;
    
    commission: boolean;
    
    favorite: boolean;
    
    averageTime: string | null;
    defaults: ServiceDefaults;
}

export function serviceDefaultValue(): Service {return {id: "",
                            name: "",
                            quickCode: "",
                            group: null,
                            subgroup: null,
                            unit: null,
                            active: false,
                            commission: false,
                            favorite: false,
                            averageTime: null,
                            defaults: serviceDefaultsDefaultValue(), }as Service;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function serviceSerialize(value: Service): string {const ctx = SerializeContext.create(); return JSON.stringify(serviceSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function serviceSerializeWithContext(value: Service, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Service" , __id,}; result["id" ]= value.id; result["name" ]= value.name; result["quickCode" ]= value.quickCode; result["group" ]= value.group; result["subgroup" ]= value.subgroup; result["unit" ]= value.unit; result["active" ]= value.active; result["commission" ]= value.commission; result["favorite" ]= value.favorite; result["averageTime" ]= value.averageTime; result["defaults" ]= serviceDefaultsSerializeWithContext(value.defaults, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function serviceDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Service } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = serviceDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Service.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function serviceDeserializeWithContext(value: any, ctx: DeserializeContext): Service | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Service.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("quickCode" in obj)){errors.push({field: "quickCode" , message: "missing required field" });}if(!("group" in obj)){errors.push({field: "group" , message: "missing required field" });}if(!("subgroup" in obj)){errors.push({field: "subgroup" , message: "missing required field" });}if(!("unit" in obj)){errors.push({field: "unit" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(!("commission" in obj)){errors.push({field: "commission" , message: "missing required field" });}if(!("favorite" in obj)){errors.push({field: "favorite" , message: "missing required field" });}if(!("averageTime" in obj)){errors.push({field: "averageTime" , message: "missing required field" });}if(!("defaults" in obj)){errors.push({field: "defaults" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_quickCode = obj["quickCode" ]as string; 
                if (__raw_quickCode.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
 instance.quickCode = __raw_quickCode; }{const __raw_group = obj["group" ]as string | null; instance.group = __raw_group; }{const __raw_subgroup = obj["subgroup" ]as string | null; instance.subgroup = __raw_subgroup; }{const __raw_unit = obj["unit" ]as string | null; instance.unit = __raw_unit; }{const __raw_active = obj["active" ]as boolean; instance.active = __raw_active; }{const __raw_commission = obj["commission" ]as boolean; instance.commission = __raw_commission; }{const __raw_favorite = obj["favorite" ]as boolean; instance.favorite = __raw_favorite; }{const __raw_averageTime = obj["averageTime" ]as string | null; instance.averageTime = __raw_averageTime; }{const __raw_defaults = obj["defaults" ]as ServiceDefaults; {const __result = serviceDefaultsDeserializeWithContext(__raw_defaults, ctx); ctx.assignOrDefer(instance, "defaults" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Service;}export function serviceValidateField<K extends keyof Service>(field: K, value: Service[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "quickCode" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
 break;}}return errors; }export function serviceValidateFields(partial: Partial<Service>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("quickCode" in partial && partial.quickCode!== undefined){const __val = partial.quickCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
}return errors; }export function serviceHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "name" in o && "quickCode" in o && "group" in o && "subgroup" in o && "unit" in o && "active" in o && "commission" in o && "favorite" in o && "averageTime" in o && "defaults" in o;}export function serviceIs(obj: unknown): obj is Service {if(!serviceHasShape(obj)){return false;}const result = serviceDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ServiceErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; name: Option<Array<string>>; quickCode: Option<Array<string>>; group: Option<Array<string>>; subgroup: Option<Array<string>>; unit: Option<Array<string>>; active: Option<Array<string>>; commission: Option<Array<string>>; favorite: Option<Array<string>>; averageTime: Option<Array<string>>; defaults: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ServiceTainted = {id: Option<boolean>; name: Option<boolean>; quickCode: Option<boolean>; group: Option<boolean>; subgroup: Option<boolean>; unit: Option<boolean>; active: Option<boolean>; commission: Option<boolean>; favorite: Option<boolean>; averageTime: Option<boolean>; defaults: Option<boolean>; }; /** Type-safe field controllers for this form */export interface ServiceFieldControllers {readonly id: FieldController<string>; readonly name: FieldController<string>; readonly quickCode: FieldController<string>; readonly group: FieldController<string | null>; readonly subgroup: FieldController<string | null>; readonly unit: FieldController<string | null>; readonly active: FieldController<boolean>; readonly commission: FieldController<boolean>; readonly favorite: FieldController<boolean>; readonly averageTime: FieldController<string | null>; readonly defaults: FieldController<ServiceDefaults>; }/** Gigaform instance containing reactive state and field controllers */export interface ServiceGigaform {readonly data: Service; readonly errors: ServiceErrors; readonly tainted: ServiceTainted; readonly fields: ServiceFieldControllers; validate(): Result<Service, Array<{field: string; message: string}>>; reset(overrides?: Partial<Service>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function serviceCreateForm(overrides?: Partial<Service>): ServiceGigaform {let data = $state({...serviceDefaultValue(),...overrides}); let errors = $state<ServiceErrors>({_errors: Option.none(), id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), averageTime: Option.none(), defaults: Option.none(), }); let tainted = $state<ServiceTainted>({id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), averageTime: Option.none(), defaults: Option.none(), }); const fields: ServiceFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, label: "Name" , get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},quickCode: {path: ["quickCode" ]as const, name: "quickCode" , constraints: { required: true }, label: "Quick Code" , get: ()=>data.quickCode, set: (value: string)=>{data.quickCode = value;}, transform: (value: string): string =>value,getError: ()=>errors.quickCode, setError: (value: Option<Array<string>>)=>{errors.quickCode = value;}, getTainted: ()=>tainted.quickCode, setTainted: (value: Option<boolean>)=>{tainted.quickCode = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("quickCode", data.quickCode); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},group: {path: ["group" ]as const, name: "group" , constraints: { required: true }, label: "Group" , get: ()=>data.group, set: (value: string | null)=>{data.group = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.group, setError: (value: Option<Array<string>>)=>{errors.group = value;}, getTainted: ()=>tainted.group, setTainted: (value: Option<boolean>)=>{tainted.group = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("group", data.group); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},subgroup: {path: ["subgroup" ]as const, name: "subgroup" , constraints: { required: true }, label: "Subgroup" , get: ()=>data.subgroup, set: (value: string | null)=>{data.subgroup = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.subgroup, setError: (value: Option<Array<string>>)=>{errors.subgroup = value;}, getTainted: ()=>tainted.subgroup, setTainted: (value: Option<boolean>)=>{tainted.subgroup = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("subgroup", data.subgroup); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},unit: {path: ["unit" ]as const, name: "unit" , constraints: { required: true }, label: "Unit" , get: ()=>data.unit, set: (value: string | null)=>{data.unit = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.unit, setError: (value: Option<Array<string>>)=>{errors.unit = value;}, getTainted: ()=>tainted.unit, setTainted: (value: Option<boolean>)=>{tainted.unit = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("unit", data.unit); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},active: {path: ["active" ]as const, name: "active" , constraints: { required: true }, label: "Active" , get: ()=>data.active, set: (value: boolean)=>{data.active = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.active, setError: (value: Option<Array<string>>)=>{errors.active = value;}, getTainted: ()=>tainted.active, setTainted: (value: Option<boolean>)=>{tainted.active = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("active", data.active); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},commission: {path: ["commission" ]as const, name: "commission" , constraints: { required: true }, label: "Commission" , get: ()=>data.commission, set: (value: boolean)=>{data.commission = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.commission, setError: (value: Option<Array<string>>)=>{errors.commission = value;}, getTainted: ()=>tainted.commission, setTainted: (value: Option<boolean>)=>{tainted.commission = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("commission", data.commission); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},favorite: {path: ["favorite" ]as const, name: "favorite" , constraints: { required: true }, label: "Favorite" , get: ()=>data.favorite, set: (value: boolean)=>{data.favorite = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.favorite, setError: (value: Option<Array<string>>)=>{errors.favorite = value;}, getTainted: ()=>tainted.favorite, setTainted: (value: Option<boolean>)=>{tainted.favorite = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("favorite", data.favorite); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},averageTime: {path: ["averageTime" ]as const, name: "averageTime" , constraints: { required: true }, label: "Average Time" , get: ()=>data.averageTime, set: (value: string | null)=>{data.averageTime = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.averageTime, setError: (value: Option<Array<string>>)=>{errors.averageTime = value;}, getTainted: ()=>tainted.averageTime, setTainted: (value: Option<boolean>)=>{tainted.averageTime = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("averageTime", data.averageTime); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},defaults: {path: ["defaults" ]as const, name: "defaults" , constraints: { required: true }, get: ()=>data.defaults, set: (value: ServiceDefaults)=>{data.defaults = value;}, transform: (value: ServiceDefaults): ServiceDefaults =>value,getError: ()=>errors.defaults, setError: (value: Option<Array<string>>)=>{errors.defaults = value;}, getTainted: ()=>tainted.defaults, setTainted: (value: Option<boolean>)=>{tainted.defaults = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("defaults", data.defaults); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Service, Array<{field: string; message: string}>>{return serviceDeserialize(data);}function reset(newOverrides?: Partial<Service>): void {data = {...serviceDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), averageTime: Option.none(), defaults: Option.none(), }; tainted = {id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), averageTime: Option.none(), defaults: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function serviceFromFormData(formData: FormData): Result<Service, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.name = formData.get("name" )?? "" ;obj.quickCode = formData.get("quickCode" )?? "" ;obj.group = formData.get("group" )?? "" ;obj.subgroup = formData.get("subgroup" )?? "" ;obj.unit = formData.get("unit" )?? "" ;{const active Val = formData.get("active" ); obj.active = active Val === "true" || active Val === "on" || active Val === "1" ;}{const commission Val = formData.get("commission" ); obj.commission = commission Val === "true" || commission Val === "on" || commission Val === "1" ;}{const favorite Val = formData.get("favorite" ); obj.favorite = favorite Val === "true" || favorite Val === "on" || favorite Val === "1" ;}obj.averageTime = formData.get("averageTime" )?? "" ;{const defaults Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("defaults." )){const fieldName = key.slice("defaults." .length); const parts = fieldName.split("." ); let current = defaults Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.defaults = defaults Obj;}return serviceDeserialize(obj);}

export const Service = {
  defaultValue: serviceDefaultValue,
  serialize: serviceSerialize,
  serializeWithContext: serviceSerializeWithContext,
  deserialize: serviceDeserialize,
  deserializeWithContext: serviceDeserializeWithContext,
  validateFields: serviceValidateFields,
  hasShape: serviceHasShape,
  is: serviceIs,
  createForm: serviceCreateForm,
  fromFormData: serviceFromFormData
} as const;


export interface ServiceDefaults {
    
    price: number;
    
    
    description: string;
}

export function serviceDefaultsDefaultValue(): ServiceDefaults {return {price: 0,
                            description: "", }as ServiceDefaults;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function serviceDefaultsSerialize(value: ServiceDefaults): string {const ctx = SerializeContext.create(); return JSON.stringify(serviceDefaultsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function serviceDefaultsSerializeWithContext(value: ServiceDefaults, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "ServiceDefaults" , __id,}; result["price" ]= value.price; result["description" ]= value.description; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function serviceDefaultsDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: ServiceDefaults } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = serviceDefaultsDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "ServiceDefaults.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function serviceDefaultsDeserializeWithContext(value: any, ctx: DeserializeContext): ServiceDefaults | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "ServiceDefaults.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("price" in obj)){errors.push({field: "price" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_price = obj["price" ]as number; instance.price = __raw_price; }{const __raw_description = obj["description" ]as string; 
                if (__raw_description.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 instance.description = __raw_description; }if(errors.length>0){throw new DeserializeError(errors);}return instance as ServiceDefaults;}export function serviceDefaultsValidateField<K extends keyof ServiceDefaults>(field: K, value: ServiceDefaults[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "description" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 break;}}return errors; }export function serviceDefaultsValidateFields(partial: Partial<ServiceDefaults>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("description" in partial && partial.description!== undefined){const __val = partial.description as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
}return errors; }export function serviceDefaultsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "price" in o && "description" in o;}export function serviceDefaultsIs(obj: unknown): obj is ServiceDefaults {if(!serviceDefaultsHasShape(obj)){return false;}const result = serviceDefaultsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ServiceDefaultsErrors = {_errors: Option<Array<string>>; price: Option<Array<string>>; description: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ServiceDefaultsTainted = {price: Option<boolean>; description: Option<boolean>; }; /** Type-safe field controllers for this form */export interface ServiceDefaultsFieldControllers {readonly price: FieldController<number>; readonly description: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface ServiceDefaultsGigaform {readonly data: ServiceDefaults; readonly errors: ServiceDefaultsErrors; readonly tainted: ServiceDefaultsTainted; readonly fields: ServiceDefaultsFieldControllers; validate(): Result<ServiceDefaults, Array<{field: string; message: string}>>; reset(overrides?: Partial<ServiceDefaults>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function serviceDefaultsCreateForm(overrides?: Partial<ServiceDefaults>): ServiceDefaultsGigaform {let data = $state({...serviceDefaultsDefaultValue(),...overrides}); let errors = $state<ServiceDefaultsErrors>({_errors: Option.none(), price: Option.none(), description: Option.none(), }); let tainted = $state<ServiceDefaultsTainted>({price: Option.none(), description: Option.none(), }); const fields: ServiceDefaultsFieldControllers = {price: {path: ["price" ]as const, name: "price" , constraints: { required: true }, label: "Price" , get: ()=>data.price, set: (value: number)=>{data.price = value;}, transform: (value: number): number =>value,getError: ()=>errors.price, setError: (value: Option<Array<string>>)=>{errors.price = value;}, getTainted: ()=>tainted.price, setTainted: (value: Option<boolean>)=>{tainted.price = value;}, validate: (): Array<string>=>{const fieldErrors = serviceDefaultsValidateField("price", data.price); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},description: {path: ["description" ]as const, name: "description" , constraints: { required: true }, label: "Description" , get: ()=>data.description, set: (value: string)=>{data.description = value;}, transform: (value: string): string =>value,getError: ()=>errors.description, setError: (value: Option<Array<string>>)=>{errors.description = value;}, getTainted: ()=>tainted.description, setTainted: (value: Option<boolean>)=>{tainted.description = value;}, validate: (): Array<string>=>{const fieldErrors = serviceDefaultsValidateField("description", data.description); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<ServiceDefaults, Array<{field: string; message: string}>>{return serviceDefaultsDeserialize(data);}function reset(newOverrides?: Partial<ServiceDefaults>): void {data = {...serviceDefaultsDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), price: Option.none(), description: Option.none(), }; tainted = {price: Option.none(), description: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function serviceDefaultsFromFormData(formData: FormData): Result<ServiceDefaults, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const price Str = formData.get("price" ); obj.price = price Str? parseFloat(price Str as string): 0; if(obj.price!== undefined && isNaN(obj.price as number))obj.price = 0;}obj.description = formData.get("description" )?? "" ;return serviceDefaultsDeserialize(obj);}

export const ServiceDefaults = {
  defaultValue: serviceDefaultsDefaultValue,
  serialize: serviceDefaultsSerialize,
  serializeWithContext: serviceDefaultsSerializeWithContext,
  deserialize: serviceDefaultsDeserialize,
  deserializeWithContext: serviceDefaultsDeserializeWithContext,
  validateFields: serviceDefaultsValidateFields,
  hasShape: serviceDefaultsHasShape,
  is: serviceDefaultsIs,
  createForm: serviceDefaultsCreateForm,
  fromFormData: serviceDefaultsFromFormData
} as const;


export interface Did {
    
    in: string | Actor;
    
    out: string | Target;
    id: string;
    activityType: ActivityType;
    createdAt: string;
    metadata: string | null;
}

export function didDefaultValue(): Did {return {in: "",
                            out: "",
                            id: "",
                            activityType: activityTypeDefaultValue(),
                            createdAt: "",
                            metadata: null, }as Did;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function didSerialize(value: Did): string {const ctx = SerializeContext.create(); return JSON.stringify(didSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function didSerializeWithContext(value: Did, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Did" , __id,}; result["in" ]= value.in; result["out" ]= value.out; result["id" ]= value.id; result["activityType" ]= activityTypeSerializeWithContext(value.activityType, ctx); result["createdAt" ]= value.createdAt; result["metadata" ]= value.metadata; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function didDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Did } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = didDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Did.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function didDeserializeWithContext(value: any, ctx: DeserializeContext): Did | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Did.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("in" in obj)){errors.push({field: "in" , message: "missing required field" });}if(!("out" in obj)){errors.push({field: "out" , message: "missing required field" });}if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("activityType" in obj)){errors.push({field: "activityType" , message: "missing required field" });}if(!("createdAt" in obj)){errors.push({field: "createdAt" , message: "missing required field" });}if(!("metadata" in obj)){errors.push({field: "metadata" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_in = obj["in" ]as string | Actor; instance.in = __raw_in; }{const __raw_out = obj["out" ]as string | Target; instance.out = __raw_out; }{const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_activityType = obj["activityType" ]as ActivityType; {const __result = activityTypeDeserializeWithContext(__raw_activityType, ctx); ctx.assignOrDefer(instance, "activityType" , __result);}}{const __raw_createdAt = obj["createdAt" ]as string; instance.createdAt = __raw_createdAt; }{const __raw_metadata = obj["metadata" ]as string | null; instance.metadata = __raw_metadata; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Did;}export function didValidateField<K extends keyof Did>(field: K, value: Did[K]): Array<{field: string; message: string}>{return[]; }export function didValidateFields(partial: Partial<Did>): Array<{field: string; message: string}>{return[]; }export function didHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "in" in o && "out" in o && "id" in o && "activityType" in o && "createdAt" in o && "metadata" in o;}export function didIs(obj: unknown): obj is Did {if(!didHasShape(obj)){return false;}const result = didDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type DidErrors = {_errors: Option<Array<string>>; in: Option<Array<string>>; out: Option<Array<string>>; id: Option<Array<string>>; activityType: Option<Array<string>>; createdAt: Option<Array<string>>; metadata: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type DidTainted = {in: Option<boolean>; out: Option<boolean>; id: Option<boolean>; activityType: Option<boolean>; createdAt: Option<boolean>; metadata: Option<boolean>; }; /** Type-safe field controllers for this form */export interface DidFieldControllers {readonly in: FieldController<string | Actor>; readonly out: FieldController<string | Target>; readonly id: FieldController<string>; readonly activityType: FieldController<ActivityType>; readonly createdAt: FieldController<string>; readonly metadata: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface DidGigaform {readonly data: Did; readonly errors: DidErrors; readonly tainted: DidTainted; readonly fields: DidFieldControllers; validate(): Result<Did, Array<{field: string; message: string}>>; reset(overrides?: Partial<Did>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function didCreateForm(overrides?: Partial<Did>): DidGigaform {let data = $state({...didDefaultValue(),...overrides}); let errors = $state<DidErrors>({_errors: Option.none(), in: Option.none(), out: Option.none(), id: Option.none(), activityType: Option.none(), createdAt: Option.none(), metadata: Option.none(), }); let tainted = $state<DidTainted>({in: Option.none(), out: Option.none(), id: Option.none(), activityType: Option.none(), createdAt: Option.none(), metadata: Option.none(), }); const fields: DidFieldControllers = {in: {path: ["in" ]as const, name: "in" , constraints: { required: true }, get: ()=>data.in, set: (value: string | Actor)=>{data.in = value;}, transform: (value: string | Actor): string | Actor =>value,getError: ()=>errors.in, setError: (value: Option<Array<string>>)=>{errors.in = value;}, getTainted: ()=>tainted.in, setTainted: (value: Option<boolean>)=>{tainted.in = value;}, validate: (): Array<string>=>{const fieldErrors = didValidateField("in", data.in); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},out: {path: ["out" ]as const, name: "out" , constraints: { required: true }, get: ()=>data.out, set: (value: string | Target)=>{data.out = value;}, transform: (value: string | Target): string | Target =>value,getError: ()=>errors.out, setError: (value: Option<Array<string>>)=>{errors.out = value;}, getTainted: ()=>tainted.out, setTainted: (value: Option<boolean>)=>{tainted.out = value;}, validate: (): Array<string>=>{const fieldErrors = didValidateField("out", data.out); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = didValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},activityType: {path: ["activityType" ]as const, name: "activityType" , constraints: { required: true }, get: ()=>data.activityType, set: (value: ActivityType)=>{data.activityType = value;}, transform: (value: ActivityType): ActivityType =>value,getError: ()=>errors.activityType, setError: (value: Option<Array<string>>)=>{errors.activityType = value;}, getTainted: ()=>tainted.activityType, setTainted: (value: Option<boolean>)=>{tainted.activityType = value;}, validate: (): Array<string>=>{const fieldErrors = didValidateField("activityType", data.activityType); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},createdAt: {path: ["createdAt" ]as const, name: "createdAt" , constraints: { required: true }, get: ()=>data.createdAt, set: (value: string)=>{data.createdAt = value;}, transform: (value: string): string =>value,getError: ()=>errors.createdAt, setError: (value: Option<Array<string>>)=>{errors.createdAt = value;}, getTainted: ()=>tainted.createdAt, setTainted: (value: Option<boolean>)=>{tainted.createdAt = value;}, validate: (): Array<string>=>{const fieldErrors = didValidateField("createdAt", data.createdAt); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},metadata: {path: ["metadata" ]as const, name: "metadata" , constraints: { required: true }, get: ()=>data.metadata, set: (value: string | null)=>{data.metadata = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.metadata, setError: (value: Option<Array<string>>)=>{errors.metadata = value;}, getTainted: ()=>tainted.metadata, setTainted: (value: Option<boolean>)=>{tainted.metadata = value;}, validate: (): Array<string>=>{const fieldErrors = didValidateField("metadata", data.metadata); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Did, Array<{field: string; message: string}>>{return didDeserialize(data);}function reset(newOverrides?: Partial<Did>): void {data = {...didDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), in: Option.none(), out: Option.none(), id: Option.none(), activityType: Option.none(), createdAt: Option.none(), metadata: Option.none(), }; tainted = {in: Option.none(), out: Option.none(), id: Option.none(), activityType: Option.none(), createdAt: Option.none(), metadata: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function didFromFormData(formData: FormData): Result<Did, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.in = formData.get("in" )?? "" ;obj.out = formData.get("out" )?? "" ;obj.id = formData.get("id" )?? "" ;{const activityType Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("activityType." )){const fieldName = key.slice("activityType." .length); const parts = fieldName.split("." ); let current = activityType Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.activityType = activityType Obj;}obj.createdAt = formData.get("createdAt" )?? "" ;obj.metadata = formData.get("metadata" )?? "" ;return didDeserialize(obj);}

export const Did = {
  defaultValue: didDefaultValue,
  serialize: didSerialize,
  serializeWithContext: didSerializeWithContext,
  deserialize: didDeserialize,
  deserializeWithContext: didDeserializeWithContext,
  validateFields: didValidateFields,
  hasShape: didHasShape,
  is: didIs,
  createForm: didCreateForm,
  fromFormData: didFromFormData
} as const;


export interface PersonName {
    
    
    firstName: string;
    
    
    lastName: string;
}

export function personNameDefaultValue(): PersonName {return {firstName: "",
                            lastName: "", }as PersonName;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function personNameSerialize(value: PersonName): string {const ctx = SerializeContext.create(); return JSON.stringify(personNameSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function personNameSerializeWithContext(value: PersonName, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "PersonName" , __id,}; result["firstName" ]= value.firstName; result["lastName" ]= value.lastName; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function personNameDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: PersonName } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = personNameDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "PersonName.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function personNameDeserializeWithContext(value: any, ctx: DeserializeContext): PersonName | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "PersonName.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("firstName" in obj)){errors.push({field: "firstName" , message: "missing required field" });}if(!("lastName" in obj)){errors.push({field: "lastName" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_firstName = obj["firstName" ]as string; 
                if (__raw_firstName.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
 instance.firstName = __raw_firstName; }{const __raw_lastName = obj["lastName" ]as string; 
                if (__raw_lastName.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
 instance.lastName = __raw_lastName; }if(errors.length>0){throw new DeserializeError(errors);}return instance as PersonName;}export function personNameValidateField<K extends keyof PersonName>(field: K, value: PersonName[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "firstName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
 break;}case "lastName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
 break;}}return errors; }export function personNameValidateFields(partial: Partial<PersonName>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("firstName" in partial && partial.firstName!== undefined){const __val = partial.firstName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
}if("lastName" in partial && partial.lastName!== undefined){const __val = partial.lastName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
}return errors; }export function personNameHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "firstName" in o && "lastName" in o;}export function personNameIs(obj: unknown): obj is PersonName {if(!personNameHasShape(obj)){return false;}const result = personNameDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type PersonNameErrors = {_errors: Option<Array<string>>; firstName: Option<Array<string>>; lastName: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type PersonNameTainted = {firstName: Option<boolean>; lastName: Option<boolean>; }; /** Type-safe field controllers for this form */export interface PersonNameFieldControllers {readonly firstName: FieldController<string>; readonly lastName: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface PersonNameGigaform {readonly data: PersonName; readonly errors: PersonNameErrors; readonly tainted: PersonNameTainted; readonly fields: PersonNameFieldControllers; validate(): Result<PersonName, Array<{field: string; message: string}>>; reset(overrides?: Partial<PersonName>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function personNameCreateForm(overrides?: Partial<PersonName>): PersonNameGigaform {let data = $state({...personNameDefaultValue(),...overrides}); let errors = $state<PersonNameErrors>({_errors: Option.none(), firstName: Option.none(), lastName: Option.none(), }); let tainted = $state<PersonNameTainted>({firstName: Option.none(), lastName: Option.none(), }); const fields: PersonNameFieldControllers = {firstName: {path: ["firstName" ]as const, name: "firstName" , constraints: { required: true }, label: "First Name" , get: ()=>data.firstName, set: (value: string)=>{data.firstName = value;}, transform: (value: string): string =>value,getError: ()=>errors.firstName, setError: (value: Option<Array<string>>)=>{errors.firstName = value;}, getTainted: ()=>tainted.firstName, setTainted: (value: Option<boolean>)=>{tainted.firstName = value;}, validate: (): Array<string>=>{const fieldErrors = personNameValidateField("firstName", data.firstName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},lastName: {path: ["lastName" ]as const, name: "lastName" , constraints: { required: true }, label: "Last Name" , get: ()=>data.lastName, set: (value: string)=>{data.lastName = value;}, transform: (value: string): string =>value,getError: ()=>errors.lastName, setError: (value: Option<Array<string>>)=>{errors.lastName = value;}, getTainted: ()=>tainted.lastName, setTainted: (value: Option<boolean>)=>{tainted.lastName = value;}, validate: (): Array<string>=>{const fieldErrors = personNameValidateField("lastName", data.lastName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<PersonName, Array<{field: string; message: string}>>{return personNameDeserialize(data);}function reset(newOverrides?: Partial<PersonName>): void {data = {...personNameDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), firstName: Option.none(), lastName: Option.none(), }; tainted = {firstName: Option.none(), lastName: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function personNameFromFormData(formData: FormData): Result<PersonName, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.firstName = formData.get("firstName" )?? "" ;obj.lastName = formData.get("lastName" )?? "" ;return personNameDeserialize(obj);}

export const PersonName = {
  defaultValue: personNameDefaultValue,
  serialize: personNameSerialize,
  serializeWithContext: personNameSerializeWithContext,
  deserialize: personNameDeserialize,
  deserializeWithContext: personNameDeserializeWithContext,
  validateFields: personNameValidateFields,
  hasShape: personNameHasShape,
  is: personNameIs,
  createForm: personNameCreateForm,
  fromFormData: personNameFromFormData
} as const;


export interface Promotion {
    id: string;
    date: string;
}

export function promotionDefaultValue(): Promotion {return {id: "",
                            date: "", }as Promotion;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function promotionSerialize(value: Promotion): string {const ctx = SerializeContext.create(); return JSON.stringify(promotionSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function promotionSerializeWithContext(value: Promotion, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Promotion" , __id,}; result["id" ]= value.id; result["date" ]= value.date; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function promotionDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Promotion } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = promotionDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Promotion.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function promotionDeserializeWithContext(value: any, ctx: DeserializeContext): Promotion | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Promotion.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("date" in obj)){errors.push({field: "date" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_date = obj["date" ]as string; instance.date = __raw_date; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Promotion;}export function promotionValidateField<K extends keyof Promotion>(field: K, value: Promotion[K]): Array<{field: string; message: string}>{return[]; }export function promotionValidateFields(partial: Partial<Promotion>): Array<{field: string; message: string}>{return[]; }export function promotionHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "date" in o;}export function promotionIs(obj: unknown): obj is Promotion {if(!promotionHasShape(obj)){return false;}const result = promotionDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type PromotionErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; date: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type PromotionTainted = {id: Option<boolean>; date: Option<boolean>; }; /** Type-safe field controllers for this form */export interface PromotionFieldControllers {readonly id: FieldController<string>; readonly date: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface PromotionGigaform {readonly data: Promotion; readonly errors: PromotionErrors; readonly tainted: PromotionTainted; readonly fields: PromotionFieldControllers; validate(): Result<Promotion, Array<{field: string; message: string}>>; reset(overrides?: Partial<Promotion>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function promotionCreateForm(overrides?: Partial<Promotion>): PromotionGigaform {let data = $state({...promotionDefaultValue(),...overrides}); let errors = $state<PromotionErrors>({_errors: Option.none(), id: Option.none(), date: Option.none(), }); let tainted = $state<PromotionTainted>({id: Option.none(), date: Option.none(), }); const fields: PromotionFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = promotionValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},date: {path: ["date" ]as const, name: "date" , constraints: { required: true }, get: ()=>data.date, set: (value: string)=>{data.date = value;}, transform: (value: string): string =>value,getError: ()=>errors.date, setError: (value: Option<Array<string>>)=>{errors.date = value;}, getTainted: ()=>tainted.date, setTainted: (value: Option<boolean>)=>{tainted.date = value;}, validate: (): Array<string>=>{const fieldErrors = promotionValidateField("date", data.date); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Promotion, Array<{field: string; message: string}>>{return promotionDeserialize(data);}function reset(newOverrides?: Partial<Promotion>): void {data = {...promotionDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), date: Option.none(), }; tainted = {id: Option.none(), date: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function promotionFromFormData(formData: FormData): Result<Promotion, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.date = formData.get("date" )?? "" ;return promotionDeserialize(obj);}

export const Promotion = {
  defaultValue: promotionDefaultValue,
  serialize: promotionSerialize,
  serializeWithContext: promotionSerializeWithContext,
  deserialize: promotionDeserialize,
  deserializeWithContext: promotionDeserializeWithContext,
  validateFields: promotionValidateFields,
  hasShape: promotionHasShape,
  is: promotionIs,
  createForm: promotionCreateForm,
  fromFormData: promotionFromFormData
} as const;


export interface Site {
    id: string;
    
    addressLine1: string;
    addressLine2: string | null;
    sublocalityLevel1: string | null;
    
    locality: string;
    administrativeAreaLevel3: string | null;
    administrativeAreaLevel2: string | null;
    
    administrativeAreaLevel1: string;
    
    country: string;
    
    postalCode: string;
    postalCodeSuffix: string | null;
    coordinates: Coordinates;
}

export function siteDefaultValue(): Site {return {id: "",
                            addressLine1: "",
                            addressLine2: null,
                            sublocalityLevel1: null,
                            locality: "",
                            administrativeAreaLevel3: null,
                            administrativeAreaLevel2: null,
                            administrativeAreaLevel1: "",
                            country: "",
                            postalCode: "",
                            postalCodeSuffix: null,
                            coordinates: coordinatesDefaultValue(), }as Site;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function siteSerialize(value: Site): string {const ctx = SerializeContext.create(); return JSON.stringify(siteSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function siteSerializeWithContext(value: Site, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Site" , __id,}; result["id" ]= value.id; result["addressLine1" ]= value.addressLine1; result["addressLine2" ]= value.addressLine2; result["sublocalityLevel1" ]= value.sublocalityLevel1; result["locality" ]= value.locality; result["administrativeAreaLevel3" ]= value.administrativeAreaLevel3; result["administrativeAreaLevel2" ]= value.administrativeAreaLevel2; result["administrativeAreaLevel1" ]= value.administrativeAreaLevel1; result["country" ]= value.country; result["postalCode" ]= value.postalCode; result["postalCodeSuffix" ]= value.postalCodeSuffix; result["coordinates" ]= coordinatesSerializeWithContext(value.coordinates, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function siteDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Site } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = siteDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Site.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function siteDeserializeWithContext(value: any, ctx: DeserializeContext): Site | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Site.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("addressLine1" in obj)){errors.push({field: "addressLine1" , message: "missing required field" });}if(!("addressLine2" in obj)){errors.push({field: "addressLine2" , message: "missing required field" });}if(!("sublocalityLevel1" in obj)){errors.push({field: "sublocalityLevel1" , message: "missing required field" });}if(!("locality" in obj)){errors.push({field: "locality" , message: "missing required field" });}if(!("administrativeAreaLevel3" in obj)){errors.push({field: "administrativeAreaLevel3" , message: "missing required field" });}if(!("administrativeAreaLevel2" in obj)){errors.push({field: "administrativeAreaLevel2" , message: "missing required field" });}if(!("administrativeAreaLevel1" in obj)){errors.push({field: "administrativeAreaLevel1" , message: "missing required field" });}if(!("country" in obj)){errors.push({field: "country" , message: "missing required field" });}if(!("postalCode" in obj)){errors.push({field: "postalCode" , message: "missing required field" });}if(!("postalCodeSuffix" in obj)){errors.push({field: "postalCodeSuffix" , message: "missing required field" });}if(!("coordinates" in obj)){errors.push({field: "coordinates" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_addressLine1 = obj["addressLine1" ]as string; 
                if (__raw_addressLine1.length === 0) {
                    errors.push({ field: "addressLine1", message: "must not be empty" });
                }
 instance.addressLine1 = __raw_addressLine1; }{const __raw_addressLine2 = obj["addressLine2" ]as string | null; instance.addressLine2 = __raw_addressLine2; }{const __raw_sublocalityLevel1 = obj["sublocalityLevel1" ]as string | null; instance.sublocalityLevel1 = __raw_sublocalityLevel1; }{const __raw_locality = obj["locality" ]as string; 
                if (__raw_locality.length === 0) {
                    errors.push({ field: "locality", message: "must not be empty" });
                }
 instance.locality = __raw_locality; }{const __raw_administrativeAreaLevel3 = obj["administrativeAreaLevel3" ]as string | null; instance.administrativeAreaLevel3 = __raw_administrativeAreaLevel3; }{const __raw_administrativeAreaLevel2 = obj["administrativeAreaLevel2" ]as string | null; instance.administrativeAreaLevel2 = __raw_administrativeAreaLevel2; }{const __raw_administrativeAreaLevel1 = obj["administrativeAreaLevel1" ]as string; 
                if (__raw_administrativeAreaLevel1.length === 0) {
                    errors.push({ field: "administrativeAreaLevel1", message: "must not be empty" });
                }
 instance.administrativeAreaLevel1 = __raw_administrativeAreaLevel1; }{const __raw_country = obj["country" ]as string; 
                if (__raw_country.length === 0) {
                    errors.push({ field: "country", message: "must not be empty" });
                }
 instance.country = __raw_country; }{const __raw_postalCode = obj["postalCode" ]as string; 
                if (__raw_postalCode.length === 0) {
                    errors.push({ field: "postalCode", message: "must not be empty" });
                }
 instance.postalCode = __raw_postalCode; }{const __raw_postalCodeSuffix = obj["postalCodeSuffix" ]as string | null; instance.postalCodeSuffix = __raw_postalCodeSuffix; }{const __raw_coordinates = obj["coordinates" ]as Coordinates; {const __result = coordinatesDeserializeWithContext(__raw_coordinates, ctx); ctx.assignOrDefer(instance, "coordinates" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Site;}export function siteValidateField<K extends keyof Site>(field: K, value: Site[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "addressLine1" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "addressLine1", message: "must not be empty" });
                }
 break;}case "locality" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "locality", message: "must not be empty" });
                }
 break;}case "administrativeAreaLevel1" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "administrativeAreaLevel1", message: "must not be empty" });
                }
 break;}case "country" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "country", message: "must not be empty" });
                }
 break;}case "postalCode" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "postalCode", message: "must not be empty" });
                }
 break;}}return errors; }export function siteValidateFields(partial: Partial<Site>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("addressLine1" in partial && partial.addressLine1!== undefined){const __val = partial.addressLine1 as string; 
                if (__val.length === 0) {
                    errors.push({ field: "addressLine1", message: "must not be empty" });
                }
}if("locality" in partial && partial.locality!== undefined){const __val = partial.locality as string; 
                if (__val.length === 0) {
                    errors.push({ field: "locality", message: "must not be empty" });
                }
}if("administrativeAreaLevel1" in partial && partial.administrativeAreaLevel1!== undefined){const __val = partial.administrativeAreaLevel1 as string; 
                if (__val.length === 0) {
                    errors.push({ field: "administrativeAreaLevel1", message: "must not be empty" });
                }
}if("country" in partial && partial.country!== undefined){const __val = partial.country as string; 
                if (__val.length === 0) {
                    errors.push({ field: "country", message: "must not be empty" });
                }
}if("postalCode" in partial && partial.postalCode!== undefined){const __val = partial.postalCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "postalCode", message: "must not be empty" });
                }
}return errors; }export function siteHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "addressLine1" in o && "addressLine2" in o && "sublocalityLevel1" in o && "locality" in o && "administrativeAreaLevel3" in o && "administrativeAreaLevel2" in o && "administrativeAreaLevel1" in o && "country" in o && "postalCode" in o && "postalCodeSuffix" in o && "coordinates" in o;}export function siteIs(obj: unknown): obj is Site {if(!siteHasShape(obj)){return false;}const result = siteDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type SiteErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; addressLine1: Option<Array<string>>; addressLine2: Option<Array<string>>; sublocalityLevel1: Option<Array<string>>; locality: Option<Array<string>>; administrativeAreaLevel3: Option<Array<string>>; administrativeAreaLevel2: Option<Array<string>>; administrativeAreaLevel1: Option<Array<string>>; country: Option<Array<string>>; postalCode: Option<Array<string>>; postalCodeSuffix: Option<Array<string>>; coordinates: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type SiteTainted = {id: Option<boolean>; addressLine1: Option<boolean>; addressLine2: Option<boolean>; sublocalityLevel1: Option<boolean>; locality: Option<boolean>; administrativeAreaLevel3: Option<boolean>; administrativeAreaLevel2: Option<boolean>; administrativeAreaLevel1: Option<boolean>; country: Option<boolean>; postalCode: Option<boolean>; postalCodeSuffix: Option<boolean>; coordinates: Option<boolean>; }; /** Type-safe field controllers for this form */export interface SiteFieldControllers {readonly id: FieldController<string>; readonly addressLine1: FieldController<string>; readonly addressLine2: FieldController<string | null>; readonly sublocalityLevel1: FieldController<string | null>; readonly locality: FieldController<string>; readonly administrativeAreaLevel3: FieldController<string | null>; readonly administrativeAreaLevel2: FieldController<string | null>; readonly administrativeAreaLevel1: FieldController<string>; readonly country: FieldController<string>; readonly postalCode: FieldController<string>; readonly postalCodeSuffix: FieldController<string | null>; readonly coordinates: FieldController<Coordinates>; }/** Gigaform instance containing reactive state and field controllers */export interface SiteGigaform {readonly data: Site; readonly errors: SiteErrors; readonly tainted: SiteTainted; readonly fields: SiteFieldControllers; validate(): Result<Site, Array<{field: string; message: string}>>; reset(overrides?: Partial<Site>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function siteCreateForm(overrides?: Partial<Site>): SiteGigaform {let data = $state({...siteDefaultValue(),...overrides}); let errors = $state<SiteErrors>({_errors: Option.none(), id: Option.none(), addressLine1: Option.none(), addressLine2: Option.none(), sublocalityLevel1: Option.none(), locality: Option.none(), administrativeAreaLevel3: Option.none(), administrativeAreaLevel2: Option.none(), administrativeAreaLevel1: Option.none(), country: Option.none(), postalCode: Option.none(), postalCodeSuffix: Option.none(), coordinates: Option.none(), }); let tainted = $state<SiteTainted>({id: Option.none(), addressLine1: Option.none(), addressLine2: Option.none(), sublocalityLevel1: Option.none(), locality: Option.none(), administrativeAreaLevel3: Option.none(), administrativeAreaLevel2: Option.none(), administrativeAreaLevel1: Option.none(), country: Option.none(), postalCode: Option.none(), postalCodeSuffix: Option.none(), coordinates: Option.none(), }); const fields: SiteFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},addressLine1: {path: ["addressLine1" ]as const, name: "addressLine1" , constraints: { required: true }, get: ()=>data.addressLine1, set: (value: string)=>{data.addressLine1 = value;}, transform: (value: string): string =>value,getError: ()=>errors.addressLine1, setError: (value: Option<Array<string>>)=>{errors.addressLine1 = value;}, getTainted: ()=>tainted.addressLine1, setTainted: (value: Option<boolean>)=>{tainted.addressLine1 = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("addressLine1", data.addressLine1); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},addressLine2: {path: ["addressLine2" ]as const, name: "addressLine2" , constraints: { required: true }, get: ()=>data.addressLine2, set: (value: string | null)=>{data.addressLine2 = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.addressLine2, setError: (value: Option<Array<string>>)=>{errors.addressLine2 = value;}, getTainted: ()=>tainted.addressLine2, setTainted: (value: Option<boolean>)=>{tainted.addressLine2 = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("addressLine2", data.addressLine2); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},sublocalityLevel1: {path: ["sublocalityLevel1" ]as const, name: "sublocalityLevel1" , constraints: { required: true }, get: ()=>data.sublocalityLevel1, set: (value: string | null)=>{data.sublocalityLevel1 = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.sublocalityLevel1, setError: (value: Option<Array<string>>)=>{errors.sublocalityLevel1 = value;}, getTainted: ()=>tainted.sublocalityLevel1, setTainted: (value: Option<boolean>)=>{tainted.sublocalityLevel1 = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("sublocalityLevel1", data.sublocalityLevel1); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},locality: {path: ["locality" ]as const, name: "locality" , constraints: { required: true }, get: ()=>data.locality, set: (value: string)=>{data.locality = value;}, transform: (value: string): string =>value,getError: ()=>errors.locality, setError: (value: Option<Array<string>>)=>{errors.locality = value;}, getTainted: ()=>tainted.locality, setTainted: (value: Option<boolean>)=>{tainted.locality = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("locality", data.locality); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},administrativeAreaLevel3: {path: ["administrativeAreaLevel3" ]as const, name: "administrativeAreaLevel3" , constraints: { required: true }, get: ()=>data.administrativeAreaLevel3, set: (value: string | null)=>{data.administrativeAreaLevel3 = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.administrativeAreaLevel3, setError: (value: Option<Array<string>>)=>{errors.administrativeAreaLevel3 = value;}, getTainted: ()=>tainted.administrativeAreaLevel3, setTainted: (value: Option<boolean>)=>{tainted.administrativeAreaLevel3 = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("administrativeAreaLevel3", data.administrativeAreaLevel3); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},administrativeAreaLevel2: {path: ["administrativeAreaLevel2" ]as const, name: "administrativeAreaLevel2" , constraints: { required: true }, get: ()=>data.administrativeAreaLevel2, set: (value: string | null)=>{data.administrativeAreaLevel2 = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.administrativeAreaLevel2, setError: (value: Option<Array<string>>)=>{errors.administrativeAreaLevel2 = value;}, getTainted: ()=>tainted.administrativeAreaLevel2, setTainted: (value: Option<boolean>)=>{tainted.administrativeAreaLevel2 = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("administrativeAreaLevel2", data.administrativeAreaLevel2); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},administrativeAreaLevel1: {path: ["administrativeAreaLevel1" ]as const, name: "administrativeAreaLevel1" , constraints: { required: true }, get: ()=>data.administrativeAreaLevel1, set: (value: string)=>{data.administrativeAreaLevel1 = value;}, transform: (value: string): string =>value,getError: ()=>errors.administrativeAreaLevel1, setError: (value: Option<Array<string>>)=>{errors.administrativeAreaLevel1 = value;}, getTainted: ()=>tainted.administrativeAreaLevel1, setTainted: (value: Option<boolean>)=>{tainted.administrativeAreaLevel1 = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("administrativeAreaLevel1", data.administrativeAreaLevel1); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},country: {path: ["country" ]as const, name: "country" , constraints: { required: true }, get: ()=>data.country, set: (value: string)=>{data.country = value;}, transform: (value: string): string =>value,getError: ()=>errors.country, setError: (value: Option<Array<string>>)=>{errors.country = value;}, getTainted: ()=>tainted.country, setTainted: (value: Option<boolean>)=>{tainted.country = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("country", data.country); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},postalCode: {path: ["postalCode" ]as const, name: "postalCode" , constraints: { required: true }, get: ()=>data.postalCode, set: (value: string)=>{data.postalCode = value;}, transform: (value: string): string =>value,getError: ()=>errors.postalCode, setError: (value: Option<Array<string>>)=>{errors.postalCode = value;}, getTainted: ()=>tainted.postalCode, setTainted: (value: Option<boolean>)=>{tainted.postalCode = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("postalCode", data.postalCode); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},postalCodeSuffix: {path: ["postalCodeSuffix" ]as const, name: "postalCodeSuffix" , constraints: { required: true }, get: ()=>data.postalCodeSuffix, set: (value: string | null)=>{data.postalCodeSuffix = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.postalCodeSuffix, setError: (value: Option<Array<string>>)=>{errors.postalCodeSuffix = value;}, getTainted: ()=>tainted.postalCodeSuffix, setTainted: (value: Option<boolean>)=>{tainted.postalCodeSuffix = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("postalCodeSuffix", data.postalCodeSuffix); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},coordinates: {path: ["coordinates" ]as const, name: "coordinates" , constraints: { required: true }, get: ()=>data.coordinates, set: (value: Coordinates)=>{data.coordinates = value;}, transform: (value: Coordinates): Coordinates =>value,getError: ()=>errors.coordinates, setError: (value: Option<Array<string>>)=>{errors.coordinates = value;}, getTainted: ()=>tainted.coordinates, setTainted: (value: Option<boolean>)=>{tainted.coordinates = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("coordinates", data.coordinates); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Site, Array<{field: string; message: string}>>{return siteDeserialize(data);}function reset(newOverrides?: Partial<Site>): void {data = {...siteDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), addressLine1: Option.none(), addressLine2: Option.none(), sublocalityLevel1: Option.none(), locality: Option.none(), administrativeAreaLevel3: Option.none(), administrativeAreaLevel2: Option.none(), administrativeAreaLevel1: Option.none(), country: Option.none(), postalCode: Option.none(), postalCodeSuffix: Option.none(), coordinates: Option.none(), }; tainted = {id: Option.none(), addressLine1: Option.none(), addressLine2: Option.none(), sublocalityLevel1: Option.none(), locality: Option.none(), administrativeAreaLevel3: Option.none(), administrativeAreaLevel2: Option.none(), administrativeAreaLevel1: Option.none(), country: Option.none(), postalCode: Option.none(), postalCodeSuffix: Option.none(), coordinates: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function siteFromFormData(formData: FormData): Result<Site, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.addressLine1 = formData.get("addressLine1" )?? "" ;obj.addressLine2 = formData.get("addressLine2" )?? "" ;obj.sublocalityLevel1 = formData.get("sublocalityLevel1" )?? "" ;obj.locality = formData.get("locality" )?? "" ;obj.administrativeAreaLevel3 = formData.get("administrativeAreaLevel3" )?? "" ;obj.administrativeAreaLevel2 = formData.get("administrativeAreaLevel2" )?? "" ;obj.administrativeAreaLevel1 = formData.get("administrativeAreaLevel1" )?? "" ;obj.country = formData.get("country" )?? "" ;obj.postalCode = formData.get("postalCode" )?? "" ;obj.postalCodeSuffix = formData.get("postalCodeSuffix" )?? "" ;{const coordinates Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("coordinates." )){const fieldName = key.slice("coordinates." .length); const parts = fieldName.split("." ); let current = coordinates Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.coordinates = coordinates Obj;}return siteDeserialize(obj);}

export const Site = {
  defaultValue: siteDefaultValue,
  serialize: siteSerialize,
  serializeWithContext: siteSerializeWithContext,
  deserialize: siteDeserialize,
  deserializeWithContext: siteDeserializeWithContext,
  validateFields: siteValidateFields,
  hasShape: siteHasShape,
  is: siteIs,
  createForm: siteCreateForm,
  fromFormData: siteFromFormData
} as const;


export interface Metadata {
    createdAt: string;
    lastLogin: string | null;
    isActive: boolean;
    roles: string[];
}

export function metadataDefaultValue(): Metadata {return {createdAt: "",
                            lastLogin: null,
                            isActive: false,
                            roles: [], }as Metadata;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function metadataSerialize(value: Metadata): string {const ctx = SerializeContext.create(); return JSON.stringify(metadataSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function metadataSerializeWithContext(value: Metadata, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Metadata" , __id,}; result["createdAt" ]= value.createdAt; result["lastLogin" ]= value.lastLogin; result["isActive" ]= value.isActive; result["roles" ]= value.roles; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function metadataDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Metadata } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = metadataDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Metadata.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function metadataDeserializeWithContext(value: any, ctx: DeserializeContext): Metadata | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Metadata.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("createdAt" in obj)){errors.push({field: "createdAt" , message: "missing required field" });}if(!("lastLogin" in obj)){errors.push({field: "lastLogin" , message: "missing required field" });}if(!("isActive" in obj)){errors.push({field: "isActive" , message: "missing required field" });}if(!("roles" in obj)){errors.push({field: "roles" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_createdAt = obj["createdAt" ]as string; instance.createdAt = __raw_createdAt; }{const __raw_lastLogin = obj["lastLogin" ]as string | null; instance.lastLogin = __raw_lastLogin; }{const __raw_isActive = obj["isActive" ]as boolean; instance.isActive = __raw_isActive; }{const __raw_roles = obj["roles" ]as string[]; if(Array.isArray(__raw_roles)){instance.roles = __raw_roles as string[];}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Metadata;}export function metadataValidateField<K extends keyof Metadata>(field: K, value: Metadata[K]): Array<{field: string; message: string}>{return[]; }export function metadataValidateFields(partial: Partial<Metadata>): Array<{field: string; message: string}>{return[]; }export function metadataHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "createdAt" in o && "lastLogin" in o && "isActive" in o && "roles" in o;}export function metadataIs(obj: unknown): obj is Metadata {if(!metadataHasShape(obj)){return false;}const result = metadataDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type MetadataErrors = {_errors: Option<Array<string>>; createdAt: Option<Array<string>>; lastLogin: Option<Array<string>>; isActive: Option<Array<string>>; roles: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type MetadataTainted = {createdAt: Option<boolean>; lastLogin: Option<boolean>; isActive: Option<boolean>; roles: Option<boolean>; }; /** Type-safe field controllers for this form */export interface MetadataFieldControllers {readonly createdAt: FieldController<string>; readonly lastLogin: FieldController<string | null>; readonly isActive: FieldController<boolean>; readonly roles: ArrayFieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface MetadataGigaform {readonly data: Metadata; readonly errors: MetadataErrors; readonly tainted: MetadataTainted; readonly fields: MetadataFieldControllers; validate(): Result<Metadata, Array<{field: string; message: string}>>; reset(overrides?: Partial<Metadata>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function metadataCreateForm(overrides?: Partial<Metadata>): MetadataGigaform {let data = $state({...metadataDefaultValue(),...overrides}); let errors = $state<MetadataErrors>({_errors: Option.none(), createdAt: Option.none(), lastLogin: Option.none(), isActive: Option.none(), roles: Option.none(), }); let tainted = $state<MetadataTainted>({createdAt: Option.none(), lastLogin: Option.none(), isActive: Option.none(), roles: Option.none(), }); const fields: MetadataFieldControllers = {createdAt: {path: ["createdAt" ]as const, name: "createdAt" , constraints: { required: true }, get: ()=>data.createdAt, set: (value: string)=>{data.createdAt = value;}, transform: (value: string): string =>value,getError: ()=>errors.createdAt, setError: (value: Option<Array<string>>)=>{errors.createdAt = value;}, getTainted: ()=>tainted.createdAt, setTainted: (value: Option<boolean>)=>{tainted.createdAt = value;}, validate: (): Array<string>=>{const fieldErrors = metadataValidateField("createdAt", data.createdAt); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},lastLogin: {path: ["lastLogin" ]as const, name: "lastLogin" , constraints: { required: true }, get: ()=>data.lastLogin, set: (value: string | null)=>{data.lastLogin = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.lastLogin, setError: (value: Option<Array<string>>)=>{errors.lastLogin = value;}, getTainted: ()=>tainted.lastLogin, setTainted: (value: Option<boolean>)=>{tainted.lastLogin = value;}, validate: (): Array<string>=>{const fieldErrors = metadataValidateField("lastLogin", data.lastLogin); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},isActive: {path: ["isActive" ]as const, name: "isActive" , constraints: { required: true }, get: ()=>data.isActive, set: (value: boolean)=>{data.isActive = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.isActive, setError: (value: Option<Array<string>>)=>{errors.isActive = value;}, getTainted: ()=>tainted.isActive, setTainted: (value: Option<boolean>)=>{tainted.isActive = value;}, validate: (): Array<string>=>{const fieldErrors = metadataValidateField("isActive", data.isActive); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},roles: {path: ["roles" ]as const, name: "roles" , constraints: { required: true }, get: ()=>data.roles, set: (value: string[])=>{data.roles = value;}, transform: (value: string[]): string[] =>value,getError: ()=>errors.roles, setError: (value: Option<Array<string>>)=>{errors.roles = value;}, getTainted: ()=>tainted.roles, setTainted: (value: Option<boolean>)=>{tainted.roles = value;}, validate: (): Array<string>=>{const fieldErrors = metadataValidateField("roles", data.roles); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["roles" , index]as const, name: `roles.${index}` , constraints: {required: true}, get: ()=>data.roles[index]!, set: (value: string)=>{data.roles[index]= value;}, transform: (value: string): string =>value, getError: ()=>errors.roles, setError: (value: Option<Array<string>>)=>{errors.roles = value;}, getTainted: ()=>tainted.roles, setTainted: (value: Option<boolean>)=>{tainted.roles = value;}, validate: (): Array<string>=>[],}), push: (item: string)=>{data.roles.push(item);}, remove: (index: number)=>{data.roles.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.roles[a]!; data.roles[a]= data.roles[b]!; data.roles[b]= tmp;},},}; function validate(): Result<Metadata, Array<{field: string; message: string}>>{return metadataDeserialize(data);}function reset(newOverrides?: Partial<Metadata>): void {data = {...metadataDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), createdAt: Option.none(), lastLogin: Option.none(), isActive: Option.none(), roles: Option.none(), }; tainted = {createdAt: Option.none(), lastLogin: Option.none(), isActive: Option.none(), roles: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function metadataFromFormData(formData: FormData): Result<Metadata, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.createdAt = formData.get("createdAt" )?? "" ;obj.lastLogin = formData.get("lastLogin" )?? "" ;{const isActive Val = formData.get("isActive" ); obj.isActive = isActive Val === "true" || isActive Val === "on" || isActive Val === "1" ;}obj.roles = formData.getAll("roles" )as Array<string>;return metadataDeserialize(obj);}

export const Metadata = {
  defaultValue: metadataDefaultValue,
  serialize: metadataSerialize,
  serializeWithContext: metadataSerializeWithContext,
  deserialize: metadataDeserialize,
  deserializeWithContext: metadataDeserializeWithContext,
  validateFields: metadataValidateFields,
  hasShape: metadataHasShape,
  is: metadataIs,
  createForm: metadataCreateForm,
  fromFormData: metadataFromFormData
} as const;


export interface ColumnConfig {
    
    heading: string;
    dataPath: DataPath;
}

export function columnConfigDefaultValue(): ColumnConfig {return {heading: "",
                            dataPath: dataPathDefaultValue(), }as ColumnConfig;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function columnConfigSerialize(value: ColumnConfig): string {const ctx = SerializeContext.create(); return JSON.stringify(columnConfigSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function columnConfigSerializeWithContext(value: ColumnConfig, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "ColumnConfig" , __id,}; result["heading" ]= value.heading; result["dataPath" ]= dataPathSerializeWithContext(value.dataPath, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function columnConfigDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: ColumnConfig } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = columnConfigDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "ColumnConfig.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function columnConfigDeserializeWithContext(value: any, ctx: DeserializeContext): ColumnConfig | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "ColumnConfig.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("heading" in obj)){errors.push({field: "heading" , message: "missing required field" });}if(!("dataPath" in obj)){errors.push({field: "dataPath" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_heading = obj["heading" ]as string; 
                if (__raw_heading.length === 0) {
                    errors.push({ field: "heading", message: "must not be empty" });
                }
 instance.heading = __raw_heading; }{const __raw_dataPath = obj["dataPath" ]as DataPath; {const __result = dataPathDeserializeWithContext(__raw_dataPath, ctx); ctx.assignOrDefer(instance, "dataPath" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as ColumnConfig;}export function columnConfigValidateField<K extends keyof ColumnConfig>(field: K, value: ColumnConfig[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "heading" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "heading", message: "must not be empty" });
                }
 break;}}return errors; }export function columnConfigValidateFields(partial: Partial<ColumnConfig>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("heading" in partial && partial.heading!== undefined){const __val = partial.heading as string; 
                if (__val.length === 0) {
                    errors.push({ field: "heading", message: "must not be empty" });
                }
}return errors; }export function columnConfigHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "heading" in o && "dataPath" in o;}export function columnConfigIs(obj: unknown): obj is ColumnConfig {if(!columnConfigHasShape(obj)){return false;}const result = columnConfigDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ColumnConfigErrors = {_errors: Option<Array<string>>; heading: Option<Array<string>>; dataPath: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ColumnConfigTainted = {heading: Option<boolean>; dataPath: Option<boolean>; }; /** Type-safe field controllers for this form */export interface ColumnConfigFieldControllers {readonly heading: FieldController<string>; readonly dataPath: FieldController<DataPath>; }/** Gigaform instance containing reactive state and field controllers */export interface ColumnConfigGigaform {readonly data: ColumnConfig; readonly errors: ColumnConfigErrors; readonly tainted: ColumnConfigTainted; readonly fields: ColumnConfigFieldControllers; validate(): Result<ColumnConfig, Array<{field: string; message: string}>>; reset(overrides?: Partial<ColumnConfig>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function columnConfigCreateForm(overrides?: Partial<ColumnConfig>): ColumnConfigGigaform {let data = $state({...columnConfigDefaultValue(),...overrides}); let errors = $state<ColumnConfigErrors>({_errors: Option.none(), heading: Option.none(), dataPath: Option.none(), }); let tainted = $state<ColumnConfigTainted>({heading: Option.none(), dataPath: Option.none(), }); const fields: ColumnConfigFieldControllers = {heading: {path: ["heading" ]as const, name: "heading" , constraints: { required: true }, get: ()=>data.heading, set: (value: string)=>{data.heading = value;}, transform: (value: string): string =>value,getError: ()=>errors.heading, setError: (value: Option<Array<string>>)=>{errors.heading = value;}, getTainted: ()=>tainted.heading, setTainted: (value: Option<boolean>)=>{tainted.heading = value;}, validate: (): Array<string>=>{const fieldErrors = columnConfigValidateField("heading", data.heading); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},dataPath: {path: ["dataPath" ]as const, name: "dataPath" , constraints: { required: true }, get: ()=>data.dataPath, set: (value: DataPath)=>{data.dataPath = value;}, transform: (value: DataPath): DataPath =>value,getError: ()=>errors.dataPath, setError: (value: Option<Array<string>>)=>{errors.dataPath = value;}, getTainted: ()=>tainted.dataPath, setTainted: (value: Option<boolean>)=>{tainted.dataPath = value;}, validate: (): Array<string>=>{const fieldErrors = columnConfigValidateField("dataPath", data.dataPath); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<ColumnConfig, Array<{field: string; message: string}>>{return columnConfigDeserialize(data);}function reset(newOverrides?: Partial<ColumnConfig>): void {data = {...columnConfigDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), heading: Option.none(), dataPath: Option.none(), }; tainted = {heading: Option.none(), dataPath: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function columnConfigFromFormData(formData: FormData): Result<ColumnConfig, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.heading = formData.get("heading" )?? "" ;{const dataPath Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("dataPath." )){const fieldName = key.slice("dataPath." .length); const parts = fieldName.split("." ); let current = dataPath Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.dataPath = dataPath Obj;}return columnConfigDeserialize(obj);}

export const ColumnConfig = {
  defaultValue: columnConfigDefaultValue,
  serialize: columnConfigSerialize,
  serializeWithContext: columnConfigSerializeWithContext,
  deserialize: columnConfigDeserialize,
  deserializeWithContext: columnConfigDeserializeWithContext,
  validateFields: columnConfigValidateFields,
  hasShape: columnConfigHasShape,
  is: columnConfigIs,
  createForm: columnConfigCreateForm,
  fromFormData: columnConfigFromFormData
} as const;


export interface PhoneNumber {
    
    main: boolean;
    
    
    phoneType: string;
    
    
    number: string;
    
    canText: boolean;
    
    canCall: boolean;
}

export function phoneNumberDefaultValue(): PhoneNumber {return {main: false,
                            phoneType: "",
                            number: "",
                            canText: false,
                            canCall: false, }as PhoneNumber;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function phoneNumberSerialize(value: PhoneNumber): string {const ctx = SerializeContext.create(); return JSON.stringify(phoneNumberSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function phoneNumberSerializeWithContext(value: PhoneNumber, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "PhoneNumber" , __id,}; result["main" ]= value.main; result["phoneType" ]= value.phoneType; result["number" ]= value.number; result["canText" ]= value.canText; result["canCall" ]= value.canCall; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function phoneNumberDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: PhoneNumber } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = phoneNumberDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "PhoneNumber.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function phoneNumberDeserializeWithContext(value: any, ctx: DeserializeContext): PhoneNumber | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "PhoneNumber.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("main" in obj)){errors.push({field: "main" , message: "missing required field" });}if(!("phoneType" in obj)){errors.push({field: "phoneType" , message: "missing required field" });}if(!("number" in obj)){errors.push({field: "number" , message: "missing required field" });}if(!("canText" in obj)){errors.push({field: "canText" , message: "missing required field" });}if(!("canCall" in obj)){errors.push({field: "canCall" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_main = obj["main" ]as boolean; instance.main = __raw_main; }{const __raw_phoneType = obj["phoneType" ]as string; 
                if (__raw_phoneType.length === 0) {
                    errors.push({ field: "phoneType", message: "must not be empty" });
                }
 instance.phoneType = __raw_phoneType; }{const __raw_number = obj["number" ]as string; 
                if (__raw_number.length === 0) {
                    errors.push({ field: "number", message: "must not be empty" });
                }
 instance.number = __raw_number; }{const __raw_canText = obj["canText" ]as boolean; instance.canText = __raw_canText; }{const __raw_canCall = obj["canCall" ]as boolean; instance.canCall = __raw_canCall; }if(errors.length>0){throw new DeserializeError(errors);}return instance as PhoneNumber;}export function phoneNumberValidateField<K extends keyof PhoneNumber>(field: K, value: PhoneNumber[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "phoneType" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "phoneType", message: "must not be empty" });
                }
 break;}case "number" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "number", message: "must not be empty" });
                }
 break;}}return errors; }export function phoneNumberValidateFields(partial: Partial<PhoneNumber>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("phoneType" in partial && partial.phoneType!== undefined){const __val = partial.phoneType as string; 
                if (__val.length === 0) {
                    errors.push({ field: "phoneType", message: "must not be empty" });
                }
}if("number" in partial && partial.number!== undefined){const __val = partial.number as string; 
                if (__val.length === 0) {
                    errors.push({ field: "number", message: "must not be empty" });
                }
}return errors; }export function phoneNumberHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "main" in o && "phoneType" in o && "number" in o && "canText" in o && "canCall" in o;}export function phoneNumberIs(obj: unknown): obj is PhoneNumber {if(!phoneNumberHasShape(obj)){return false;}const result = phoneNumberDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type PhoneNumberErrors = {_errors: Option<Array<string>>; main: Option<Array<string>>; phoneType: Option<Array<string>>; number: Option<Array<string>>; canText: Option<Array<string>>; canCall: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type PhoneNumberTainted = {main: Option<boolean>; phoneType: Option<boolean>; number: Option<boolean>; canText: Option<boolean>; canCall: Option<boolean>; }; /** Type-safe field controllers for this form */export interface PhoneNumberFieldControllers {readonly main: FieldController<boolean>; readonly phoneType: FieldController<string>; readonly number: FieldController<string>; readonly canText: FieldController<boolean>; readonly canCall: FieldController<boolean>; }/** Gigaform instance containing reactive state and field controllers */export interface PhoneNumberGigaform {readonly data: PhoneNumber; readonly errors: PhoneNumberErrors; readonly tainted: PhoneNumberTainted; readonly fields: PhoneNumberFieldControllers; validate(): Result<PhoneNumber, Array<{field: string; message: string}>>; reset(overrides?: Partial<PhoneNumber>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function phoneNumberCreateForm(overrides?: Partial<PhoneNumber>): PhoneNumberGigaform {let data = $state({...phoneNumberDefaultValue(),...overrides}); let errors = $state<PhoneNumberErrors>({_errors: Option.none(), main: Option.none(), phoneType: Option.none(), number: Option.none(), canText: Option.none(), canCall: Option.none(), }); let tainted = $state<PhoneNumberTainted>({main: Option.none(), phoneType: Option.none(), number: Option.none(), canText: Option.none(), canCall: Option.none(), }); const fields: PhoneNumberFieldControllers = {main: {path: ["main" ]as const, name: "main" , constraints: { required: true }, label: "Main" , get: ()=>data.main, set: (value: boolean)=>{data.main = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.main, setError: (value: Option<Array<string>>)=>{errors.main = value;}, getTainted: ()=>tainted.main, setTainted: (value: Option<boolean>)=>{tainted.main = value;}, validate: (): Array<string>=>{const fieldErrors = phoneNumberValidateField("main", data.main); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},phoneType: {path: ["phoneType" ]as const, name: "phoneType" , constraints: { required: true }, label: "Phone Type" , get: ()=>data.phoneType, set: (value: string)=>{data.phoneType = value;}, transform: (value: string): string =>value,getError: ()=>errors.phoneType, setError: (value: Option<Array<string>>)=>{errors.phoneType = value;}, getTainted: ()=>tainted.phoneType, setTainted: (value: Option<boolean>)=>{tainted.phoneType = value;}, validate: (): Array<string>=>{const fieldErrors = phoneNumberValidateField("phoneType", data.phoneType); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},number: {path: ["number" ]as const, name: "number" , constraints: { required: true }, label: "Number" , get: ()=>data.number, set: (value: string)=>{data.number = value;}, transform: (value: string): string =>value,getError: ()=>errors.number, setError: (value: Option<Array<string>>)=>{errors.number = value;}, getTainted: ()=>tainted.number, setTainted: (value: Option<boolean>)=>{tainted.number = value;}, validate: (): Array<string>=>{const fieldErrors = phoneNumberValidateField("number", data.number); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},canText: {path: ["canText" ]as const, name: "canText" , constraints: { required: true }, label: "Can Text" , get: ()=>data.canText, set: (value: boolean)=>{data.canText = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.canText, setError: (value: Option<Array<string>>)=>{errors.canText = value;}, getTainted: ()=>tainted.canText, setTainted: (value: Option<boolean>)=>{tainted.canText = value;}, validate: (): Array<string>=>{const fieldErrors = phoneNumberValidateField("canText", data.canText); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},canCall: {path: ["canCall" ]as const, name: "canCall" , constraints: { required: true }, label: "Can Call" , get: ()=>data.canCall, set: (value: boolean)=>{data.canCall = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.canCall, setError: (value: Option<Array<string>>)=>{errors.canCall = value;}, getTainted: ()=>tainted.canCall, setTainted: (value: Option<boolean>)=>{tainted.canCall = value;}, validate: (): Array<string>=>{const fieldErrors = phoneNumberValidateField("canCall", data.canCall); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<PhoneNumber, Array<{field: string; message: string}>>{return phoneNumberDeserialize(data);}function reset(newOverrides?: Partial<PhoneNumber>): void {data = {...phoneNumberDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), main: Option.none(), phoneType: Option.none(), number: Option.none(), canText: Option.none(), canCall: Option.none(), }; tainted = {main: Option.none(), phoneType: Option.none(), number: Option.none(), canText: Option.none(), canCall: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function phoneNumberFromFormData(formData: FormData): Result<PhoneNumber, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const main Val = formData.get("main" ); obj.main = main Val === "true" || main Val === "on" || main Val === "1" ;}obj.phoneType = formData.get("phoneType" )?? "" ;obj.number = formData.get("number" )?? "" ;{const canText Val = formData.get("canText" ); obj.canText = canText Val === "true" || canText Val === "on" || canText Val === "1" ;}{const canCall Val = formData.get("canCall" ); obj.canCall = canCall Val === "true" || canCall Val === "on" || canCall Val === "1" ;}return phoneNumberDeserialize(obj);}

export const PhoneNumber = {
  defaultValue: phoneNumberDefaultValue,
  serialize: phoneNumberSerialize,
  serializeWithContext: phoneNumberSerializeWithContext,
  deserialize: phoneNumberDeserialize,
  deserializeWithContext: phoneNumberDeserializeWithContext,
  validateFields: phoneNumberValidateFields,
  hasShape: phoneNumberHasShape,
  is: phoneNumberIs,
  createForm: phoneNumberCreateForm,
  fromFormData: phoneNumberFromFormData
} as const;


export interface Gradient {
    startHue: number;
}

export function gradientDefaultValue(): Gradient {return {startHue: 0, }as Gradient;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function gradientSerialize(value: Gradient): string {const ctx = SerializeContext.create(); return JSON.stringify(gradientSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function gradientSerializeWithContext(value: Gradient, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Gradient" , __id,}; result["startHue" ]= value.startHue; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function gradientDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Gradient } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = gradientDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Gradient.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function gradientDeserializeWithContext(value: any, ctx: DeserializeContext): Gradient | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Gradient.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("startHue" in obj)){errors.push({field: "startHue" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_startHue = obj["startHue" ]as number; instance.startHue = __raw_startHue; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Gradient;}export function gradientValidateField<K extends keyof Gradient>(field: K, value: Gradient[K]): Array<{field: string; message: string}>{return[]; }export function gradientValidateFields(partial: Partial<Gradient>): Array<{field: string; message: string}>{return[]; }export function gradientHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "startHue" in o;}export function gradientIs(obj: unknown): obj is Gradient {if(!gradientHasShape(obj)){return false;}const result = gradientDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type GradientErrors = {_errors: Option<Array<string>>; startHue: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type GradientTainted = {startHue: Option<boolean>; }; /** Type-safe field controllers for this form */export interface GradientFieldControllers {readonly startHue: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface GradientGigaform {readonly data: Gradient; readonly errors: GradientErrors; readonly tainted: GradientTainted; readonly fields: GradientFieldControllers; validate(): Result<Gradient, Array<{field: string; message: string}>>; reset(overrides?: Partial<Gradient>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function gradientCreateForm(overrides?: Partial<Gradient>): GradientGigaform {let data = $state({...gradientDefaultValue(),...overrides}); let errors = $state<GradientErrors>({_errors: Option.none(), startHue: Option.none(), }); let tainted = $state<GradientTainted>({startHue: Option.none(), }); const fields: GradientFieldControllers = {startHue: {path: ["startHue" ]as const, name: "startHue" , constraints: { required: true }, get: ()=>data.startHue, set: (value: number)=>{data.startHue = value;}, transform: (value: number): number =>value,getError: ()=>errors.startHue, setError: (value: Option<Array<string>>)=>{errors.startHue = value;}, getTainted: ()=>tainted.startHue, setTainted: (value: Option<boolean>)=>{tainted.startHue = value;}, validate: (): Array<string>=>{const fieldErrors = gradientValidateField("startHue", data.startHue); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Gradient, Array<{field: string; message: string}>>{return gradientDeserialize(data);}function reset(newOverrides?: Partial<Gradient>): void {data = {...gradientDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), startHue: Option.none(), }; tainted = {startHue: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function gradientFromFormData(formData: FormData): Result<Gradient, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const startHue Str = formData.get("startHue" ); obj.startHue = startHue Str? parseFloat(startHue Str as string): 0; if(obj.startHue!== undefined && isNaN(obj.startHue as number))obj.startHue = 0;}return gradientDeserialize(obj);}

export const Gradient = {
  defaultValue: gradientDefaultValue,
  serialize: gradientSerialize,
  serializeWithContext: gradientSerializeWithContext,
  deserialize: gradientDeserialize,
  deserializeWithContext: gradientDeserializeWithContext,
  validateFields: gradientValidateFields,
  hasShape: gradientHasShape,
  is: gradientIs,
  createForm: gradientCreateForm,
  fromFormData: gradientFromFormData
} as const;


export interface Product {
    
    id: string;
    
    
    name: string;
    
    
    quickCode: string;
    
    group: string | null;
    
    subgroup: string | null;
    
    unit: string | null;
    
    active: boolean;
    
    commission: boolean;
    
    favorite: boolean;
    defaults: ProductDefaults;
}

export function productDefaultValue(): Product {return {id: "",
                            name: "",
                            quickCode: "",
                            group: null,
                            subgroup: null,
                            unit: null,
                            active: false,
                            commission: false,
                            favorite: false,
                            defaults: productDefaultsDefaultValue(), }as Product;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function productSerialize(value: Product): string {const ctx = SerializeContext.create(); return JSON.stringify(productSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function productSerializeWithContext(value: Product, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Product" , __id,}; result["id" ]= value.id; result["name" ]= value.name; result["quickCode" ]= value.quickCode; result["group" ]= value.group; result["subgroup" ]= value.subgroup; result["unit" ]= value.unit; result["active" ]= value.active; result["commission" ]= value.commission; result["favorite" ]= value.favorite; result["defaults" ]= productDefaultsSerializeWithContext(value.defaults, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function productDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Product } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = productDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Product.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function productDeserializeWithContext(value: any, ctx: DeserializeContext): Product | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Product.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("quickCode" in obj)){errors.push({field: "quickCode" , message: "missing required field" });}if(!("group" in obj)){errors.push({field: "group" , message: "missing required field" });}if(!("subgroup" in obj)){errors.push({field: "subgroup" , message: "missing required field" });}if(!("unit" in obj)){errors.push({field: "unit" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(!("commission" in obj)){errors.push({field: "commission" , message: "missing required field" });}if(!("favorite" in obj)){errors.push({field: "favorite" , message: "missing required field" });}if(!("defaults" in obj)){errors.push({field: "defaults" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_quickCode = obj["quickCode" ]as string; 
                if (__raw_quickCode.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
 instance.quickCode = __raw_quickCode; }{const __raw_group = obj["group" ]as string | null; instance.group = __raw_group; }{const __raw_subgroup = obj["subgroup" ]as string | null; instance.subgroup = __raw_subgroup; }{const __raw_unit = obj["unit" ]as string | null; instance.unit = __raw_unit; }{const __raw_active = obj["active" ]as boolean; instance.active = __raw_active; }{const __raw_commission = obj["commission" ]as boolean; instance.commission = __raw_commission; }{const __raw_favorite = obj["favorite" ]as boolean; instance.favorite = __raw_favorite; }{const __raw_defaults = obj["defaults" ]as ProductDefaults; {const __result = productDefaultsDeserializeWithContext(__raw_defaults, ctx); ctx.assignOrDefer(instance, "defaults" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Product;}export function productValidateField<K extends keyof Product>(field: K, value: Product[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "quickCode" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
 break;}}return errors; }export function productValidateFields(partial: Partial<Product>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("quickCode" in partial && partial.quickCode!== undefined){const __val = partial.quickCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
}return errors; }export function productHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "name" in o && "quickCode" in o && "group" in o && "subgroup" in o && "unit" in o && "active" in o && "commission" in o && "favorite" in o && "defaults" in o;}export function productIs(obj: unknown): obj is Product {if(!productHasShape(obj)){return false;}const result = productDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ProductErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; name: Option<Array<string>>; quickCode: Option<Array<string>>; group: Option<Array<string>>; subgroup: Option<Array<string>>; unit: Option<Array<string>>; active: Option<Array<string>>; commission: Option<Array<string>>; favorite: Option<Array<string>>; defaults: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ProductTainted = {id: Option<boolean>; name: Option<boolean>; quickCode: Option<boolean>; group: Option<boolean>; subgroup: Option<boolean>; unit: Option<boolean>; active: Option<boolean>; commission: Option<boolean>; favorite: Option<boolean>; defaults: Option<boolean>; }; /** Type-safe field controllers for this form */export interface ProductFieldControllers {readonly id: FieldController<string>; readonly name: FieldController<string>; readonly quickCode: FieldController<string>; readonly group: FieldController<string | null>; readonly subgroup: FieldController<string | null>; readonly unit: FieldController<string | null>; readonly active: FieldController<boolean>; readonly commission: FieldController<boolean>; readonly favorite: FieldController<boolean>; readonly defaults: FieldController<ProductDefaults>; }/** Gigaform instance containing reactive state and field controllers */export interface ProductGigaform {readonly data: Product; readonly errors: ProductErrors; readonly tainted: ProductTainted; readonly fields: ProductFieldControllers; validate(): Result<Product, Array<{field: string; message: string}>>; reset(overrides?: Partial<Product>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function productCreateForm(overrides?: Partial<Product>): ProductGigaform {let data = $state({...productDefaultValue(),...overrides}); let errors = $state<ProductErrors>({_errors: Option.none(), id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), defaults: Option.none(), }); let tainted = $state<ProductTainted>({id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), defaults: Option.none(), }); const fields: ProductFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, label: "Name" , get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},quickCode: {path: ["quickCode" ]as const, name: "quickCode" , constraints: { required: true }, label: "Quick Code" , get: ()=>data.quickCode, set: (value: string)=>{data.quickCode = value;}, transform: (value: string): string =>value,getError: ()=>errors.quickCode, setError: (value: Option<Array<string>>)=>{errors.quickCode = value;}, getTainted: ()=>tainted.quickCode, setTainted: (value: Option<boolean>)=>{tainted.quickCode = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("quickCode", data.quickCode); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},group: {path: ["group" ]as const, name: "group" , constraints: { required: true }, label: "Group" , get: ()=>data.group, set: (value: string | null)=>{data.group = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.group, setError: (value: Option<Array<string>>)=>{errors.group = value;}, getTainted: ()=>tainted.group, setTainted: (value: Option<boolean>)=>{tainted.group = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("group", data.group); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},subgroup: {path: ["subgroup" ]as const, name: "subgroup" , constraints: { required: true }, label: "Subgroup" , get: ()=>data.subgroup, set: (value: string | null)=>{data.subgroup = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.subgroup, setError: (value: Option<Array<string>>)=>{errors.subgroup = value;}, getTainted: ()=>tainted.subgroup, setTainted: (value: Option<boolean>)=>{tainted.subgroup = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("subgroup", data.subgroup); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},unit: {path: ["unit" ]as const, name: "unit" , constraints: { required: true }, label: "Unit" , get: ()=>data.unit, set: (value: string | null)=>{data.unit = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.unit, setError: (value: Option<Array<string>>)=>{errors.unit = value;}, getTainted: ()=>tainted.unit, setTainted: (value: Option<boolean>)=>{tainted.unit = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("unit", data.unit); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},active: {path: ["active" ]as const, name: "active" , constraints: { required: true }, label: "Active" , get: ()=>data.active, set: (value: boolean)=>{data.active = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.active, setError: (value: Option<Array<string>>)=>{errors.active = value;}, getTainted: ()=>tainted.active, setTainted: (value: Option<boolean>)=>{tainted.active = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("active", data.active); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},commission: {path: ["commission" ]as const, name: "commission" , constraints: { required: true }, label: "Commission" , get: ()=>data.commission, set: (value: boolean)=>{data.commission = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.commission, setError: (value: Option<Array<string>>)=>{errors.commission = value;}, getTainted: ()=>tainted.commission, setTainted: (value: Option<boolean>)=>{tainted.commission = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("commission", data.commission); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},favorite: {path: ["favorite" ]as const, name: "favorite" , constraints: { required: true }, label: "Favorite" , get: ()=>data.favorite, set: (value: boolean)=>{data.favorite = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.favorite, setError: (value: Option<Array<string>>)=>{errors.favorite = value;}, getTainted: ()=>tainted.favorite, setTainted: (value: Option<boolean>)=>{tainted.favorite = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("favorite", data.favorite); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},defaults: {path: ["defaults" ]as const, name: "defaults" , constraints: { required: true }, get: ()=>data.defaults, set: (value: ProductDefaults)=>{data.defaults = value;}, transform: (value: ProductDefaults): ProductDefaults =>value,getError: ()=>errors.defaults, setError: (value: Option<Array<string>>)=>{errors.defaults = value;}, getTainted: ()=>tainted.defaults, setTainted: (value: Option<boolean>)=>{tainted.defaults = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("defaults", data.defaults); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Product, Array<{field: string; message: string}>>{return productDeserialize(data);}function reset(newOverrides?: Partial<Product>): void {data = {...productDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), defaults: Option.none(), }; tainted = {id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), defaults: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function productFromFormData(formData: FormData): Result<Product, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.name = formData.get("name" )?? "" ;obj.quickCode = formData.get("quickCode" )?? "" ;obj.group = formData.get("group" )?? "" ;obj.subgroup = formData.get("subgroup" )?? "" ;obj.unit = formData.get("unit" )?? "" ;{const active Val = formData.get("active" ); obj.active = active Val === "true" || active Val === "on" || active Val === "1" ;}{const commission Val = formData.get("commission" ); obj.commission = commission Val === "true" || commission Val === "on" || commission Val === "1" ;}{const favorite Val = formData.get("favorite" ); obj.favorite = favorite Val === "true" || favorite Val === "on" || favorite Val === "1" ;}{const defaults Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("defaults." )){const fieldName = key.slice("defaults." .length); const parts = fieldName.split("." ); let current = defaults Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.defaults = defaults Obj;}return productDeserialize(obj);}

export const Product = {
  defaultValue: productDefaultValue,
  serialize: productSerialize,
  serializeWithContext: productSerializeWithContext,
  deserialize: productDeserialize,
  deserializeWithContext: productDeserializeWithContext,
  validateFields: productValidateFields,
  hasShape: productHasShape,
  is: productIs,
  createForm: productCreateForm,
  fromFormData: productFromFormData
} as const;


export interface YearlyRecurrenceRule {
    quantityOfYears: number;
}

export function yearlyRecurrenceRuleDefaultValue(): YearlyRecurrenceRule {return {quantityOfYears: 0, }as YearlyRecurrenceRule;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function yearlyRecurrenceRuleSerialize(value: YearlyRecurrenceRule): string {const ctx = SerializeContext.create(); return JSON.stringify(yearlyRecurrenceRuleSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function yearlyRecurrenceRuleSerializeWithContext(value: YearlyRecurrenceRule, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "YearlyRecurrenceRule" , __id,}; result["quantityOfYears" ]= value.quantityOfYears; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function yearlyRecurrenceRuleDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: YearlyRecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = yearlyRecurrenceRuleDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "YearlyRecurrenceRule.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function yearlyRecurrenceRuleDeserializeWithContext(value: any, ctx: DeserializeContext): YearlyRecurrenceRule | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "YearlyRecurrenceRule.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("quantityOfYears" in obj)){errors.push({field: "quantityOfYears" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_quantityOfYears = obj["quantityOfYears" ]as number; instance.quantityOfYears = __raw_quantityOfYears; }if(errors.length>0){throw new DeserializeError(errors);}return instance as YearlyRecurrenceRule;}export function yearlyRecurrenceRuleValidateField<K extends keyof YearlyRecurrenceRule>(field: K, value: YearlyRecurrenceRule[K]): Array<{field: string; message: string}>{return[]; }export function yearlyRecurrenceRuleValidateFields(partial: Partial<YearlyRecurrenceRule>): Array<{field: string; message: string}>{return[]; }export function yearlyRecurrenceRuleHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "quantityOfYears" in o;}export function yearlyRecurrenceRuleIs(obj: unknown): obj is YearlyRecurrenceRule {if(!yearlyRecurrenceRuleHasShape(obj)){return false;}const result = yearlyRecurrenceRuleDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type YearlyRecurrenceRuleErrors = {_errors: Option<Array<string>>; quantityOfYears: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type YearlyRecurrenceRuleTainted = {quantityOfYears: Option<boolean>; }; /** Type-safe field controllers for this form */export interface YearlyRecurrenceRuleFieldControllers {readonly quantityOfYears: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface YearlyRecurrenceRuleGigaform {readonly data: YearlyRecurrenceRule; readonly errors: YearlyRecurrenceRuleErrors; readonly tainted: YearlyRecurrenceRuleTainted; readonly fields: YearlyRecurrenceRuleFieldControllers; validate(): Result<YearlyRecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<YearlyRecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function yearlyRecurrenceRuleCreateForm(overrides?: Partial<YearlyRecurrenceRule>): YearlyRecurrenceRuleGigaform {let data = $state({...yearlyRecurrenceRuleDefaultValue(),...overrides}); let errors = $state<YearlyRecurrenceRuleErrors>({_errors: Option.none(), quantityOfYears: Option.none(), }); let tainted = $state<YearlyRecurrenceRuleTainted>({quantityOfYears: Option.none(), }); const fields: YearlyRecurrenceRuleFieldControllers = {quantityOfYears: {path: ["quantityOfYears" ]as const, name: "quantityOfYears" , constraints: { required: true }, get: ()=>data.quantityOfYears, set: (value: number)=>{data.quantityOfYears = value;}, transform: (value: number): number =>value,getError: ()=>errors.quantityOfYears, setError: (value: Option<Array<string>>)=>{errors.quantityOfYears = value;}, getTainted: ()=>tainted.quantityOfYears, setTainted: (value: Option<boolean>)=>{tainted.quantityOfYears = value;}, validate: (): Array<string>=>{const fieldErrors = yearlyRecurrenceRuleValidateField("quantityOfYears", data.quantityOfYears); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<YearlyRecurrenceRule, Array<{field: string; message: string}>>{return yearlyRecurrenceRuleDeserialize(data);}function reset(newOverrides?: Partial<YearlyRecurrenceRule>): void {data = {...yearlyRecurrenceRuleDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), quantityOfYears: Option.none(), }; tainted = {quantityOfYears: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function yearlyRecurrenceRuleFromFormData(formData: FormData): Result<YearlyRecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const quantityOfYears Str = formData.get("quantityOfYears" ); obj.quantityOfYears = quantityOfYears Str? parseFloat(quantityOfYears Str as string): 0; if(obj.quantityOfYears!== undefined && isNaN(obj.quantityOfYears as number))obj.quantityOfYears = 0;}return yearlyRecurrenceRuleDeserialize(obj);}

export const YearlyRecurrenceRule = {
  defaultValue: yearlyRecurrenceRuleDefaultValue,
  serialize: yearlyRecurrenceRuleSerialize,
  serializeWithContext: yearlyRecurrenceRuleSerializeWithContext,
  deserialize: yearlyRecurrenceRuleDeserialize,
  deserializeWithContext: yearlyRecurrenceRuleDeserializeWithContext,
  validateFields: yearlyRecurrenceRuleValidateFields,
  hasShape: yearlyRecurrenceRuleHasShape,
  is: yearlyRecurrenceRuleIs,
  createForm: yearlyRecurrenceRuleCreateForm,
  fromFormData: yearlyRecurrenceRuleFromFormData
} as const;


export interface AppointmentNotifications {
    
    personalScheduleChangeNotifications: string;
    
    allScheduleChangeNotifications: string;
}

export function appointmentNotificationsDefaultValue(): AppointmentNotifications {return {personalScheduleChangeNotifications: "",
                            allScheduleChangeNotifications: "", }as AppointmentNotifications;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function appointmentNotificationsSerialize(value: AppointmentNotifications): string {const ctx = SerializeContext.create(); return JSON.stringify(appointmentNotificationsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function appointmentNotificationsSerializeWithContext(value: AppointmentNotifications, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "AppointmentNotifications" , __id,}; result["personalScheduleChangeNotifications" ]= value.personalScheduleChangeNotifications; result["allScheduleChangeNotifications" ]= value.allScheduleChangeNotifications; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function appointmentNotificationsDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: AppointmentNotifications } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = appointmentNotificationsDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "AppointmentNotifications.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function appointmentNotificationsDeserializeWithContext(value: any, ctx: DeserializeContext): AppointmentNotifications | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "AppointmentNotifications.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("personalScheduleChangeNotifications" in obj)){errors.push({field: "personalScheduleChangeNotifications" , message: "missing required field" });}if(!("allScheduleChangeNotifications" in obj)){errors.push({field: "allScheduleChangeNotifications" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_personalScheduleChangeNotifications = obj["personalScheduleChangeNotifications" ]as string; 
                if (__raw_personalScheduleChangeNotifications.length === 0) {
                    errors.push({ field: "personalScheduleChangeNotifications", message: "must not be empty" });
                }
 instance.personalScheduleChangeNotifications = __raw_personalScheduleChangeNotifications; }{const __raw_allScheduleChangeNotifications = obj["allScheduleChangeNotifications" ]as string; 
                if (__raw_allScheduleChangeNotifications.length === 0) {
                    errors.push({ field: "allScheduleChangeNotifications", message: "must not be empty" });
                }
 instance.allScheduleChangeNotifications = __raw_allScheduleChangeNotifications; }if(errors.length>0){throw new DeserializeError(errors);}return instance as AppointmentNotifications;}export function appointmentNotificationsValidateField<K extends keyof AppointmentNotifications>(field: K, value: AppointmentNotifications[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "personalScheduleChangeNotifications" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "personalScheduleChangeNotifications", message: "must not be empty" });
                }
 break;}case "allScheduleChangeNotifications" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "allScheduleChangeNotifications", message: "must not be empty" });
                }
 break;}}return errors; }export function appointmentNotificationsValidateFields(partial: Partial<AppointmentNotifications>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("personalScheduleChangeNotifications" in partial && partial.personalScheduleChangeNotifications!== undefined){const __val = partial.personalScheduleChangeNotifications as string; 
                if (__val.length === 0) {
                    errors.push({ field: "personalScheduleChangeNotifications", message: "must not be empty" });
                }
}if("allScheduleChangeNotifications" in partial && partial.allScheduleChangeNotifications!== undefined){const __val = partial.allScheduleChangeNotifications as string; 
                if (__val.length === 0) {
                    errors.push({ field: "allScheduleChangeNotifications", message: "must not be empty" });
                }
}return errors; }export function appointmentNotificationsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "personalScheduleChangeNotifications" in o && "allScheduleChangeNotifications" in o;}export function appointmentNotificationsIs(obj: unknown): obj is AppointmentNotifications {if(!appointmentNotificationsHasShape(obj)){return false;}const result = appointmentNotificationsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type AppointmentNotificationsErrors = {_errors: Option<Array<string>>; personalScheduleChangeNotifications: Option<Array<string>>; allScheduleChangeNotifications: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type AppointmentNotificationsTainted = {personalScheduleChangeNotifications: Option<boolean>; allScheduleChangeNotifications: Option<boolean>; }; /** Type-safe field controllers for this form */export interface AppointmentNotificationsFieldControllers {readonly personalScheduleChangeNotifications: FieldController<string>; readonly allScheduleChangeNotifications: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface AppointmentNotificationsGigaform {readonly data: AppointmentNotifications; readonly errors: AppointmentNotificationsErrors; readonly tainted: AppointmentNotificationsTainted; readonly fields: AppointmentNotificationsFieldControllers; validate(): Result<AppointmentNotifications, Array<{field: string; message: string}>>; reset(overrides?: Partial<AppointmentNotifications>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function appointmentNotificationsCreateForm(overrides?: Partial<AppointmentNotifications>): AppointmentNotificationsGigaform {let data = $state({...appointmentNotificationsDefaultValue(),...overrides}); let errors = $state<AppointmentNotificationsErrors>({_errors: Option.none(), personalScheduleChangeNotifications: Option.none(), allScheduleChangeNotifications: Option.none(), }); let tainted = $state<AppointmentNotificationsTainted>({personalScheduleChangeNotifications: Option.none(), allScheduleChangeNotifications: Option.none(), }); const fields: AppointmentNotificationsFieldControllers = {personalScheduleChangeNotifications: {path: ["personalScheduleChangeNotifications" ]as const, name: "personalScheduleChangeNotifications" , constraints: { required: true }, get: ()=>data.personalScheduleChangeNotifications, set: (value: string)=>{data.personalScheduleChangeNotifications = value;}, transform: (value: string): string =>value,getError: ()=>errors.personalScheduleChangeNotifications, setError: (value: Option<Array<string>>)=>{errors.personalScheduleChangeNotifications = value;}, getTainted: ()=>tainted.personalScheduleChangeNotifications, setTainted: (value: Option<boolean>)=>{tainted.personalScheduleChangeNotifications = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentNotificationsValidateField("personalScheduleChangeNotifications", data.personalScheduleChangeNotifications); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},allScheduleChangeNotifications: {path: ["allScheduleChangeNotifications" ]as const, name: "allScheduleChangeNotifications" , constraints: { required: true }, get: ()=>data.allScheduleChangeNotifications, set: (value: string)=>{data.allScheduleChangeNotifications = value;}, transform: (value: string): string =>value,getError: ()=>errors.allScheduleChangeNotifications, setError: (value: Option<Array<string>>)=>{errors.allScheduleChangeNotifications = value;}, getTainted: ()=>tainted.allScheduleChangeNotifications, setTainted: (value: Option<boolean>)=>{tainted.allScheduleChangeNotifications = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentNotificationsValidateField("allScheduleChangeNotifications", data.allScheduleChangeNotifications); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<AppointmentNotifications, Array<{field: string; message: string}>>{return appointmentNotificationsDeserialize(data);}function reset(newOverrides?: Partial<AppointmentNotifications>): void {data = {...appointmentNotificationsDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), personalScheduleChangeNotifications: Option.none(), allScheduleChangeNotifications: Option.none(), }; tainted = {personalScheduleChangeNotifications: Option.none(), allScheduleChangeNotifications: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function appointmentNotificationsFromFormData(formData: FormData): Result<AppointmentNotifications, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.personalScheduleChangeNotifications = formData.get("personalScheduleChangeNotifications" )?? "" ;obj.allScheduleChangeNotifications = formData.get("allScheduleChangeNotifications" )?? "" ;return appointmentNotificationsDeserialize(obj);}

export const AppointmentNotifications = {
  defaultValue: appointmentNotificationsDefaultValue,
  serialize: appointmentNotificationsSerialize,
  serializeWithContext: appointmentNotificationsSerializeWithContext,
  deserialize: appointmentNotificationsDeserialize,
  deserializeWithContext: appointmentNotificationsDeserializeWithContext,
  validateFields: appointmentNotificationsValidateFields,
  hasShape: appointmentNotificationsHasShape,
  is: appointmentNotificationsIs,
  createForm: appointmentNotificationsCreateForm,
  fromFormData: appointmentNotificationsFromFormData
} as const;


export interface DirectionHue {
    bearing: number;
    hue: number;
}

export function directionHueDefaultValue(): DirectionHue {return {bearing: 0,
                            hue: 0, }as DirectionHue;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function directionHueSerialize(value: DirectionHue): string {const ctx = SerializeContext.create(); return JSON.stringify(directionHueSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function directionHueSerializeWithContext(value: DirectionHue, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "DirectionHue" , __id,}; result["bearing" ]= value.bearing; result["hue" ]= value.hue; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function directionHueDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: DirectionHue } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = directionHueDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "DirectionHue.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function directionHueDeserializeWithContext(value: any, ctx: DeserializeContext): DirectionHue | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "DirectionHue.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("bearing" in obj)){errors.push({field: "bearing" , message: "missing required field" });}if(!("hue" in obj)){errors.push({field: "hue" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_bearing = obj["bearing" ]as number; instance.bearing = __raw_bearing; }{const __raw_hue = obj["hue" ]as number; instance.hue = __raw_hue; }if(errors.length>0){throw new DeserializeError(errors);}return instance as DirectionHue;}export function directionHueValidateField<K extends keyof DirectionHue>(field: K, value: DirectionHue[K]): Array<{field: string; message: string}>{return[]; }export function directionHueValidateFields(partial: Partial<DirectionHue>): Array<{field: string; message: string}>{return[]; }export function directionHueHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "bearing" in o && "hue" in o;}export function directionHueIs(obj: unknown): obj is DirectionHue {if(!directionHueHasShape(obj)){return false;}const result = directionHueDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type DirectionHueErrors = {_errors: Option<Array<string>>; bearing: Option<Array<string>>; hue: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type DirectionHueTainted = {bearing: Option<boolean>; hue: Option<boolean>; }; /** Type-safe field controllers for this form */export interface DirectionHueFieldControllers {readonly bearing: FieldController<number>; readonly hue: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface DirectionHueGigaform {readonly data: DirectionHue; readonly errors: DirectionHueErrors; readonly tainted: DirectionHueTainted; readonly fields: DirectionHueFieldControllers; validate(): Result<DirectionHue, Array<{field: string; message: string}>>; reset(overrides?: Partial<DirectionHue>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function directionHueCreateForm(overrides?: Partial<DirectionHue>): DirectionHueGigaform {let data = $state({...directionHueDefaultValue(),...overrides}); let errors = $state<DirectionHueErrors>({_errors: Option.none(), bearing: Option.none(), hue: Option.none(), }); let tainted = $state<DirectionHueTainted>({bearing: Option.none(), hue: Option.none(), }); const fields: DirectionHueFieldControllers = {bearing: {path: ["bearing" ]as const, name: "bearing" , constraints: { required: true }, get: ()=>data.bearing, set: (value: number)=>{data.bearing = value;}, transform: (value: number): number =>value,getError: ()=>errors.bearing, setError: (value: Option<Array<string>>)=>{errors.bearing = value;}, getTainted: ()=>tainted.bearing, setTainted: (value: Option<boolean>)=>{tainted.bearing = value;}, validate: (): Array<string>=>{const fieldErrors = directionHueValidateField("bearing", data.bearing); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hue: {path: ["hue" ]as const, name: "hue" , constraints: { required: true }, get: ()=>data.hue, set: (value: number)=>{data.hue = value;}, transform: (value: number): number =>value,getError: ()=>errors.hue, setError: (value: Option<Array<string>>)=>{errors.hue = value;}, getTainted: ()=>tainted.hue, setTainted: (value: Option<boolean>)=>{tainted.hue = value;}, validate: (): Array<string>=>{const fieldErrors = directionHueValidateField("hue", data.hue); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<DirectionHue, Array<{field: string; message: string}>>{return directionHueDeserialize(data);}function reset(newOverrides?: Partial<DirectionHue>): void {data = {...directionHueDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), bearing: Option.none(), hue: Option.none(), }; tainted = {bearing: Option.none(), hue: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function directionHueFromFormData(formData: FormData): Result<DirectionHue, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const bearing Str = formData.get("bearing" ); obj.bearing = bearing Str? parseFloat(bearing Str as string): 0; if(obj.bearing!== undefined && isNaN(obj.bearing as number))obj.bearing = 0;}{const hue Str = formData.get("hue" ); obj.hue = hue Str? parseFloat(hue Str as string): 0; if(obj.hue!== undefined && isNaN(obj.hue as number))obj.hue = 0;}return directionHueDeserialize(obj);}

export const DirectionHue = {
  defaultValue: directionHueDefaultValue,
  serialize: directionHueSerialize,
  serializeWithContext: directionHueSerializeWithContext,
  deserialize: directionHueDeserialize,
  deserializeWithContext: directionHueDeserializeWithContext,
  validateFields: directionHueValidateFields,
  hasShape: directionHueHasShape,
  is: directionHueIs,
  createForm: directionHueCreateForm,
  fromFormData: directionHueFromFormData
} as const;


export interface MonthlyRecurrenceRule {
    quantityOfMonths: number;
    day: number;
    
    name: string;
}

export function monthlyRecurrenceRuleDefaultValue(): MonthlyRecurrenceRule {return {quantityOfMonths: 0,
                            day: 0,
                            name: "", }as MonthlyRecurrenceRule;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function monthlyRecurrenceRuleSerialize(value: MonthlyRecurrenceRule): string {const ctx = SerializeContext.create(); return JSON.stringify(monthlyRecurrenceRuleSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function monthlyRecurrenceRuleSerializeWithContext(value: MonthlyRecurrenceRule, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "MonthlyRecurrenceRule" , __id,}; result["quantityOfMonths" ]= value.quantityOfMonths; result["day" ]= value.day; result["name" ]= value.name; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function monthlyRecurrenceRuleDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: MonthlyRecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = monthlyRecurrenceRuleDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "MonthlyRecurrenceRule.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function monthlyRecurrenceRuleDeserializeWithContext(value: any, ctx: DeserializeContext): MonthlyRecurrenceRule | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "MonthlyRecurrenceRule.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("quantityOfMonths" in obj)){errors.push({field: "quantityOfMonths" , message: "missing required field" });}if(!("day" in obj)){errors.push({field: "day" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_quantityOfMonths = obj["quantityOfMonths" ]as number; instance.quantityOfMonths = __raw_quantityOfMonths; }{const __raw_day = obj["day" ]as number; instance.day = __raw_day; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }if(errors.length>0){throw new DeserializeError(errors);}return instance as MonthlyRecurrenceRule;}export function monthlyRecurrenceRuleValidateField<K extends keyof MonthlyRecurrenceRule>(field: K, value: MonthlyRecurrenceRule[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}}return errors; }export function monthlyRecurrenceRuleValidateFields(partial: Partial<MonthlyRecurrenceRule>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}return errors; }export function monthlyRecurrenceRuleHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "quantityOfMonths" in o && "day" in o && "name" in o;}export function monthlyRecurrenceRuleIs(obj: unknown): obj is MonthlyRecurrenceRule {if(!monthlyRecurrenceRuleHasShape(obj)){return false;}const result = monthlyRecurrenceRuleDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type MonthlyRecurrenceRuleErrors = {_errors: Option<Array<string>>; quantityOfMonths: Option<Array<string>>; day: Option<Array<string>>; name: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type MonthlyRecurrenceRuleTainted = {quantityOfMonths: Option<boolean>; day: Option<boolean>; name: Option<boolean>; }; /** Type-safe field controllers for this form */export interface MonthlyRecurrenceRuleFieldControllers {readonly quantityOfMonths: FieldController<number>; readonly day: FieldController<number>; readonly name: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface MonthlyRecurrenceRuleGigaform {readonly data: MonthlyRecurrenceRule; readonly errors: MonthlyRecurrenceRuleErrors; readonly tainted: MonthlyRecurrenceRuleTainted; readonly fields: MonthlyRecurrenceRuleFieldControllers; validate(): Result<MonthlyRecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<MonthlyRecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function monthlyRecurrenceRuleCreateForm(overrides?: Partial<MonthlyRecurrenceRule>): MonthlyRecurrenceRuleGigaform {let data = $state({...monthlyRecurrenceRuleDefaultValue(),...overrides}); let errors = $state<MonthlyRecurrenceRuleErrors>({_errors: Option.none(), quantityOfMonths: Option.none(), day: Option.none(), name: Option.none(), }); let tainted = $state<MonthlyRecurrenceRuleTainted>({quantityOfMonths: Option.none(), day: Option.none(), name: Option.none(), }); const fields: MonthlyRecurrenceRuleFieldControllers = {quantityOfMonths: {path: ["quantityOfMonths" ]as const, name: "quantityOfMonths" , constraints: { required: true }, get: ()=>data.quantityOfMonths, set: (value: number)=>{data.quantityOfMonths = value;}, transform: (value: number): number =>value,getError: ()=>errors.quantityOfMonths, setError: (value: Option<Array<string>>)=>{errors.quantityOfMonths = value;}, getTainted: ()=>tainted.quantityOfMonths, setTainted: (value: Option<boolean>)=>{tainted.quantityOfMonths = value;}, validate: (): Array<string>=>{const fieldErrors = monthlyRecurrenceRuleValidateField("quantityOfMonths", data.quantityOfMonths); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},day: {path: ["day" ]as const, name: "day" , constraints: { required: true }, get: ()=>data.day, set: (value: number)=>{data.day = value;}, transform: (value: number): number =>value,getError: ()=>errors.day, setError: (value: Option<Array<string>>)=>{errors.day = value;}, getTainted: ()=>tainted.day, setTainted: (value: Option<boolean>)=>{tainted.day = value;}, validate: (): Array<string>=>{const fieldErrors = monthlyRecurrenceRuleValidateField("day", data.day); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = monthlyRecurrenceRuleValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<MonthlyRecurrenceRule, Array<{field: string; message: string}>>{return monthlyRecurrenceRuleDeserialize(data);}function reset(newOverrides?: Partial<MonthlyRecurrenceRule>): void {data = {...monthlyRecurrenceRuleDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), quantityOfMonths: Option.none(), day: Option.none(), name: Option.none(), }; tainted = {quantityOfMonths: Option.none(), day: Option.none(), name: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function monthlyRecurrenceRuleFromFormData(formData: FormData): Result<MonthlyRecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const quantityOfMonths Str = formData.get("quantityOfMonths" ); obj.quantityOfMonths = quantityOfMonths Str? parseFloat(quantityOfMonths Str as string): 0; if(obj.quantityOfMonths!== undefined && isNaN(obj.quantityOfMonths as number))obj.quantityOfMonths = 0;}{const day Str = formData.get("day" ); obj.day = day Str? parseFloat(day Str as string): 0; if(obj.day!== undefined && isNaN(obj.day as number))obj.day = 0;}obj.name = formData.get("name" )?? "" ;return monthlyRecurrenceRuleDeserialize(obj);}

export const MonthlyRecurrenceRule = {
  defaultValue: monthlyRecurrenceRuleDefaultValue,
  serialize: monthlyRecurrenceRuleSerialize,
  serializeWithContext: monthlyRecurrenceRuleSerializeWithContext,
  deserialize: monthlyRecurrenceRuleDeserialize,
  deserializeWithContext: monthlyRecurrenceRuleDeserializeWithContext,
  validateFields: monthlyRecurrenceRuleValidateFields,
  hasShape: monthlyRecurrenceRuleHasShape,
  is: monthlyRecurrenceRuleIs,
  createForm: monthlyRecurrenceRuleCreateForm,
  fromFormData: monthlyRecurrenceRuleFromFormData
} as const;


export interface Represents {
    
    in: string | Employee;
    
    out: string | Account;
    id: string;
    dateStarted: string;
}

export function representsDefaultValue(): Represents {return {in: "",
                            out: "",
                            id: "",
                            dateStarted: "", }as Represents;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function representsSerialize(value: Represents): string {const ctx = SerializeContext.create(); return JSON.stringify(representsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function representsSerializeWithContext(value: Represents, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Represents" , __id,}; result["in" ]= value.in; result["out" ]= value.out; result["id" ]= value.id; result["dateStarted" ]= value.dateStarted; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function representsDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Represents } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = representsDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Represents.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function representsDeserializeWithContext(value: any, ctx: DeserializeContext): Represents | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Represents.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("in" in obj)){errors.push({field: "in" , message: "missing required field" });}if(!("out" in obj)){errors.push({field: "out" , message: "missing required field" });}if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("dateStarted" in obj)){errors.push({field: "dateStarted" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_in = obj["in" ]as string | Employee; instance.in = __raw_in; }{const __raw_out = obj["out" ]as string | Account; instance.out = __raw_out; }{const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_dateStarted = obj["dateStarted" ]as string; instance.dateStarted = __raw_dateStarted; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Represents;}export function representsValidateField<K extends keyof Represents>(field: K, value: Represents[K]): Array<{field: string; message: string}>{return[]; }export function representsValidateFields(partial: Partial<Represents>): Array<{field: string; message: string}>{return[]; }export function representsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "in" in o && "out" in o && "id" in o && "dateStarted" in o;}export function representsIs(obj: unknown): obj is Represents {if(!representsHasShape(obj)){return false;}const result = representsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type RepresentsErrors = {_errors: Option<Array<string>>; in: Option<Array<string>>; out: Option<Array<string>>; id: Option<Array<string>>; dateStarted: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type RepresentsTainted = {in: Option<boolean>; out: Option<boolean>; id: Option<boolean>; dateStarted: Option<boolean>; }; /** Type-safe field controllers for this form */export interface RepresentsFieldControllers {readonly in: FieldController<string | Employee>; readonly out: FieldController<string | Account>; readonly id: FieldController<string>; readonly dateStarted: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface RepresentsGigaform {readonly data: Represents; readonly errors: RepresentsErrors; readonly tainted: RepresentsTainted; readonly fields: RepresentsFieldControllers; validate(): Result<Represents, Array<{field: string; message: string}>>; reset(overrides?: Partial<Represents>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function representsCreateForm(overrides?: Partial<Represents>): RepresentsGigaform {let data = $state({...representsDefaultValue(),...overrides}); let errors = $state<RepresentsErrors>({_errors: Option.none(), in: Option.none(), out: Option.none(), id: Option.none(), dateStarted: Option.none(), }); let tainted = $state<RepresentsTainted>({in: Option.none(), out: Option.none(), id: Option.none(), dateStarted: Option.none(), }); const fields: RepresentsFieldControllers = {in: {path: ["in" ]as const, name: "in" , constraints: { required: true }, get: ()=>data.in, set: (value: string | Employee)=>{data.in = value;}, transform: (value: string | Employee): string | Employee =>value,getError: ()=>errors.in, setError: (value: Option<Array<string>>)=>{errors.in = value;}, getTainted: ()=>tainted.in, setTainted: (value: Option<boolean>)=>{tainted.in = value;}, validate: (): Array<string>=>{const fieldErrors = representsValidateField("in", data.in); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},out: {path: ["out" ]as const, name: "out" , constraints: { required: true }, get: ()=>data.out, set: (value: string | Account)=>{data.out = value;}, transform: (value: string | Account): string | Account =>value,getError: ()=>errors.out, setError: (value: Option<Array<string>>)=>{errors.out = value;}, getTainted: ()=>tainted.out, setTainted: (value: Option<boolean>)=>{tainted.out = value;}, validate: (): Array<string>=>{const fieldErrors = representsValidateField("out", data.out); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = representsValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},dateStarted: {path: ["dateStarted" ]as const, name: "dateStarted" , constraints: { required: true }, get: ()=>data.dateStarted, set: (value: string)=>{data.dateStarted = value;}, transform: (value: string): string =>value,getError: ()=>errors.dateStarted, setError: (value: Option<Array<string>>)=>{errors.dateStarted = value;}, getTainted: ()=>tainted.dateStarted, setTainted: (value: Option<boolean>)=>{tainted.dateStarted = value;}, validate: (): Array<string>=>{const fieldErrors = representsValidateField("dateStarted", data.dateStarted); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Represents, Array<{field: string; message: string}>>{return representsDeserialize(data);}function reset(newOverrides?: Partial<Represents>): void {data = {...representsDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), in: Option.none(), out: Option.none(), id: Option.none(), dateStarted: Option.none(), }; tainted = {in: Option.none(), out: Option.none(), id: Option.none(), dateStarted: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function representsFromFormData(formData: FormData): Result<Represents, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.in = formData.get("in" )?? "" ;obj.out = formData.get("out" )?? "" ;obj.id = formData.get("id" )?? "" ;obj.dateStarted = formData.get("dateStarted" )?? "" ;return representsDeserialize(obj);}

export const Represents = {
  defaultValue: representsDefaultValue,
  serialize: representsSerialize,
  serializeWithContext: representsSerializeWithContext,
  deserialize: representsDeserialize,
  deserializeWithContext: representsDeserializeWithContext,
  validateFields: representsValidateFields,
  hasShape: representsHasShape,
  is: representsIs,
  createForm: representsCreateForm,
  fromFormData: representsFromFormData
} as const;


export interface Payment {
    id: string;
    date: string;
}

export function paymentDefaultValue(): Payment {return {id: "",
                            date: "", }as Payment;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function paymentSerialize(value: Payment): string {const ctx = SerializeContext.create(); return JSON.stringify(paymentSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function paymentSerializeWithContext(value: Payment, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Payment" , __id,}; result["id" ]= value.id; result["date" ]= value.date; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function paymentDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Payment } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = paymentDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Payment.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function paymentDeserializeWithContext(value: any, ctx: DeserializeContext): Payment | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Payment.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("date" in obj)){errors.push({field: "date" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_date = obj["date" ]as string; instance.date = __raw_date; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Payment;}export function paymentValidateField<K extends keyof Payment>(field: K, value: Payment[K]): Array<{field: string; message: string}>{return[]; }export function paymentValidateFields(partial: Partial<Payment>): Array<{field: string; message: string}>{return[]; }export function paymentHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "date" in o;}export function paymentIs(obj: unknown): obj is Payment {if(!paymentHasShape(obj)){return false;}const result = paymentDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type PaymentErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; date: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type PaymentTainted = {id: Option<boolean>; date: Option<boolean>; }; /** Type-safe field controllers for this form */export interface PaymentFieldControllers {readonly id: FieldController<string>; readonly date: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface PaymentGigaform {readonly data: Payment; readonly errors: PaymentErrors; readonly tainted: PaymentTainted; readonly fields: PaymentFieldControllers; validate(): Result<Payment, Array<{field: string; message: string}>>; reset(overrides?: Partial<Payment>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function paymentCreateForm(overrides?: Partial<Payment>): PaymentGigaform {let data = $state({...paymentDefaultValue(),...overrides}); let errors = $state<PaymentErrors>({_errors: Option.none(), id: Option.none(), date: Option.none(), }); let tainted = $state<PaymentTainted>({id: Option.none(), date: Option.none(), }); const fields: PaymentFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = paymentValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},date: {path: ["date" ]as const, name: "date" , constraints: { required: true }, get: ()=>data.date, set: (value: string)=>{data.date = value;}, transform: (value: string): string =>value,getError: ()=>errors.date, setError: (value: Option<Array<string>>)=>{errors.date = value;}, getTainted: ()=>tainted.date, setTainted: (value: Option<boolean>)=>{tainted.date = value;}, validate: (): Array<string>=>{const fieldErrors = paymentValidateField("date", data.date); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Payment, Array<{field: string; message: string}>>{return paymentDeserialize(data);}function reset(newOverrides?: Partial<Payment>): void {data = {...paymentDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), date: Option.none(), }; tainted = {id: Option.none(), date: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function paymentFromFormData(formData: FormData): Result<Payment, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.date = formData.get("date" )?? "" ;return paymentDeserialize(obj);}

export const Payment = {
  defaultValue: paymentDefaultValue,
  serialize: paymentSerialize,
  serializeWithContext: paymentSerializeWithContext,
  deserialize: paymentDeserialize,
  deserializeWithContext: paymentDeserializeWithContext,
  validateFields: paymentValidateFields,
  hasShape: paymentHasShape,
  is: paymentIs,
  createForm: paymentCreateForm,
  fromFormData: paymentFromFormData
} as const;


export interface Settings {
    appointmentNotifications: AppointmentNotifications | null;
    commissions: Commissions | null;
    scheduleSettings: ScheduleSettings;
    accountOverviewSettings: OverviewSettings;
    serviceOverviewSettings: OverviewSettings;
    appointmentOverviewSettings: OverviewSettings;
    leadOverviewSettings: OverviewSettings;
    packageOverviewSettings: OverviewSettings;
    productOverviewSettings: OverviewSettings;
    orderOverviewSettings: OverviewSettings;
    taxRateOverviewSettings: OverviewSettings;
    
    homePage: Page;
}

export function settingsDefaultValue(): Settings {return {appointmentNotifications: null,
                            commissions: null,
                            scheduleSettings: scheduleSettingsDefaultValue(),
                            accountOverviewSettings: overviewSettingsDefaultValue(),
                            serviceOverviewSettings: overviewSettingsDefaultValue(),
                            appointmentOverviewSettings: overviewSettingsDefaultValue(),
                            leadOverviewSettings: overviewSettingsDefaultValue(),
                            packageOverviewSettings: overviewSettingsDefaultValue(),
                            productOverviewSettings: overviewSettingsDefaultValue(),
                            orderOverviewSettings: overviewSettingsDefaultValue(),
                            taxRateOverviewSettings: overviewSettingsDefaultValue(),
                            homePage: "UserHome", }as Settings;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function settingsSerialize(value: Settings): string {const ctx = SerializeContext.create(); return JSON.stringify(settingsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function settingsSerializeWithContext(value: Settings, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Settings" , __id,}; if(value.appointmentNotifications!== null){result["appointmentNotifications" ]= appointmentNotificationsSerializeWithContext(value.appointmentNotifications, ctx); }else {result["appointmentNotifications" ]= null;}if(value.commissions!== null){result["commissions" ]= commissionsSerializeWithContext(value.commissions, ctx); }else {result["commissions" ]= null;}result["scheduleSettings" ]= scheduleSettingsSerializeWithContext(value.scheduleSettings, ctx); result["accountOverviewSettings" ]= overviewSettingsSerializeWithContext(value.accountOverviewSettings, ctx); result["serviceOverviewSettings" ]= overviewSettingsSerializeWithContext(value.serviceOverviewSettings, ctx); result["appointmentOverviewSettings" ]= overviewSettingsSerializeWithContext(value.appointmentOverviewSettings, ctx); result["leadOverviewSettings" ]= overviewSettingsSerializeWithContext(value.leadOverviewSettings, ctx); result["packageOverviewSettings" ]= overviewSettingsSerializeWithContext(value.packageOverviewSettings, ctx); result["productOverviewSettings" ]= overviewSettingsSerializeWithContext(value.productOverviewSettings, ctx); result["orderOverviewSettings" ]= overviewSettingsSerializeWithContext(value.orderOverviewSettings, ctx); result["taxRateOverviewSettings" ]= overviewSettingsSerializeWithContext(value.taxRateOverviewSettings, ctx); result["homePage" ]= pageSerializeWithContext(value.homePage, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function settingsDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Settings } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = settingsDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Settings.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function settingsDeserializeWithContext(value: any, ctx: DeserializeContext): Settings | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Settings.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("appointmentNotifications" in obj)){errors.push({field: "appointmentNotifications" , message: "missing required field" });}if(!("commissions" in obj)){errors.push({field: "commissions" , message: "missing required field" });}if(!("scheduleSettings" in obj)){errors.push({field: "scheduleSettings" , message: "missing required field" });}if(!("accountOverviewSettings" in obj)){errors.push({field: "accountOverviewSettings" , message: "missing required field" });}if(!("serviceOverviewSettings" in obj)){errors.push({field: "serviceOverviewSettings" , message: "missing required field" });}if(!("appointmentOverviewSettings" in obj)){errors.push({field: "appointmentOverviewSettings" , message: "missing required field" });}if(!("leadOverviewSettings" in obj)){errors.push({field: "leadOverviewSettings" , message: "missing required field" });}if(!("packageOverviewSettings" in obj)){errors.push({field: "packageOverviewSettings" , message: "missing required field" });}if(!("productOverviewSettings" in obj)){errors.push({field: "productOverviewSettings" , message: "missing required field" });}if(!("orderOverviewSettings" in obj)){errors.push({field: "orderOverviewSettings" , message: "missing required field" });}if(!("taxRateOverviewSettings" in obj)){errors.push({field: "taxRateOverviewSettings" , message: "missing required field" });}if(!("homePage" in obj)){errors.push({field: "homePage" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_appointmentNotifications = obj["appointmentNotifications" ]as AppointmentNotifications | null; if(__raw_appointmentNotifications === null){instance.appointmentNotifications = null;}else {const __result = appointmentNotificationsDeserializeWithContext(__raw_appointmentNotifications, ctx); ctx.assignOrDefer(instance, "appointmentNotifications" , __result); }}{const __raw_commissions = obj["commissions" ]as Commissions | null; if(__raw_commissions === null){instance.commissions = null;}else {const __result = commissionsDeserializeWithContext(__raw_commissions, ctx); ctx.assignOrDefer(instance, "commissions" , __result); }}{const __raw_scheduleSettings = obj["scheduleSettings" ]as ScheduleSettings; {const __result = scheduleSettingsDeserializeWithContext(__raw_scheduleSettings, ctx); ctx.assignOrDefer(instance, "scheduleSettings" , __result);}}{const __raw_accountOverviewSettings = obj["accountOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_accountOverviewSettings, ctx); ctx.assignOrDefer(instance, "accountOverviewSettings" , __result);}}{const __raw_serviceOverviewSettings = obj["serviceOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_serviceOverviewSettings, ctx); ctx.assignOrDefer(instance, "serviceOverviewSettings" , __result);}}{const __raw_appointmentOverviewSettings = obj["appointmentOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_appointmentOverviewSettings, ctx); ctx.assignOrDefer(instance, "appointmentOverviewSettings" , __result);}}{const __raw_leadOverviewSettings = obj["leadOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_leadOverviewSettings, ctx); ctx.assignOrDefer(instance, "leadOverviewSettings" , __result);}}{const __raw_packageOverviewSettings = obj["packageOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_packageOverviewSettings, ctx); ctx.assignOrDefer(instance, "packageOverviewSettings" , __result);}}{const __raw_productOverviewSettings = obj["productOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_productOverviewSettings, ctx); ctx.assignOrDefer(instance, "productOverviewSettings" , __result);}}{const __raw_orderOverviewSettings = obj["orderOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_orderOverviewSettings, ctx); ctx.assignOrDefer(instance, "orderOverviewSettings" , __result);}}{const __raw_taxRateOverviewSettings = obj["taxRateOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_taxRateOverviewSettings, ctx); ctx.assignOrDefer(instance, "taxRateOverviewSettings" , __result);}}{const __raw_homePage = obj["homePage" ]as Page; {const __result = pageDeserializeWithContext(__raw_homePage, ctx); ctx.assignOrDefer(instance, "homePage" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Settings;}export function settingsValidateField<K extends keyof Settings>(field: K, value: Settings[K]): Array<{field: string; message: string}>{return[]; }export function settingsValidateFields(partial: Partial<Settings>): Array<{field: string; message: string}>{return[]; }export function settingsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "appointmentNotifications" in o && "commissions" in o && "scheduleSettings" in o && "accountOverviewSettings" in o && "serviceOverviewSettings" in o && "appointmentOverviewSettings" in o && "leadOverviewSettings" in o && "packageOverviewSettings" in o && "productOverviewSettings" in o && "orderOverviewSettings" in o && "taxRateOverviewSettings" in o && "homePage" in o;}export function settingsIs(obj: unknown): obj is Settings {if(!settingsHasShape(obj)){return false;}const result = settingsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type SettingsErrors = {_errors: Option<Array<string>>; appointmentNotifications: Option<Array<string>>; commissions: Option<Array<string>>; scheduleSettings: Option<Array<string>>; accountOverviewSettings: Option<Array<string>>; serviceOverviewSettings: Option<Array<string>>; appointmentOverviewSettings: Option<Array<string>>; leadOverviewSettings: Option<Array<string>>; packageOverviewSettings: Option<Array<string>>; productOverviewSettings: Option<Array<string>>; orderOverviewSettings: Option<Array<string>>; taxRateOverviewSettings: Option<Array<string>>; homePage: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type SettingsTainted = {appointmentNotifications: Option<boolean>; commissions: Option<boolean>; scheduleSettings: Option<boolean>; accountOverviewSettings: Option<boolean>; serviceOverviewSettings: Option<boolean>; appointmentOverviewSettings: Option<boolean>; leadOverviewSettings: Option<boolean>; packageOverviewSettings: Option<boolean>; productOverviewSettings: Option<boolean>; orderOverviewSettings: Option<boolean>; taxRateOverviewSettings: Option<boolean>; homePage: Option<boolean>; }; /** Type-safe field controllers for this form */export interface SettingsFieldControllers {readonly appointmentNotifications: FieldController<AppointmentNotifications | null>; readonly commissions: FieldController<Commissions | null>; readonly scheduleSettings: FieldController<ScheduleSettings>; readonly accountOverviewSettings: FieldController<OverviewSettings>; readonly serviceOverviewSettings: FieldController<OverviewSettings>; readonly appointmentOverviewSettings: FieldController<OverviewSettings>; readonly leadOverviewSettings: FieldController<OverviewSettings>; readonly packageOverviewSettings: FieldController<OverviewSettings>; readonly productOverviewSettings: FieldController<OverviewSettings>; readonly orderOverviewSettings: FieldController<OverviewSettings>; readonly taxRateOverviewSettings: FieldController<OverviewSettings>; readonly homePage: FieldController<Page>; }/** Gigaform instance containing reactive state and field controllers */export interface SettingsGigaform {readonly data: Settings; readonly errors: SettingsErrors; readonly tainted: SettingsTainted; readonly fields: SettingsFieldControllers; validate(): Result<Settings, Array<{field: string; message: string}>>; reset(overrides?: Partial<Settings>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function settingsCreateForm(overrides?: Partial<Settings>): SettingsGigaform {let data = $state({...settingsDefaultValue(),...overrides}); let errors = $state<SettingsErrors>({_errors: Option.none(), appointmentNotifications: Option.none(), commissions: Option.none(), scheduleSettings: Option.none(), accountOverviewSettings: Option.none(), serviceOverviewSettings: Option.none(), appointmentOverviewSettings: Option.none(), leadOverviewSettings: Option.none(), packageOverviewSettings: Option.none(), productOverviewSettings: Option.none(), orderOverviewSettings: Option.none(), taxRateOverviewSettings: Option.none(), homePage: Option.none(), }); let tainted = $state<SettingsTainted>({appointmentNotifications: Option.none(), commissions: Option.none(), scheduleSettings: Option.none(), accountOverviewSettings: Option.none(), serviceOverviewSettings: Option.none(), appointmentOverviewSettings: Option.none(), leadOverviewSettings: Option.none(), packageOverviewSettings: Option.none(), productOverviewSettings: Option.none(), orderOverviewSettings: Option.none(), taxRateOverviewSettings: Option.none(), homePage: Option.none(), }); const fields: SettingsFieldControllers = {appointmentNotifications: {path: ["appointmentNotifications" ]as const, name: "appointmentNotifications" , constraints: { required: true }, get: ()=>data.appointmentNotifications, set: (value: AppointmentNotifications | null)=>{data.appointmentNotifications = value;}, transform: (value: AppointmentNotifications | null): AppointmentNotifications | null =>value,getError: ()=>errors.appointmentNotifications, setError: (value: Option<Array<string>>)=>{errors.appointmentNotifications = value;}, getTainted: ()=>tainted.appointmentNotifications, setTainted: (value: Option<boolean>)=>{tainted.appointmentNotifications = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("appointmentNotifications", data.appointmentNotifications); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},commissions: {path: ["commissions" ]as const, name: "commissions" , constraints: { required: true }, get: ()=>data.commissions, set: (value: Commissions | null)=>{data.commissions = value;}, transform: (value: Commissions | null): Commissions | null =>value,getError: ()=>errors.commissions, setError: (value: Option<Array<string>>)=>{errors.commissions = value;}, getTainted: ()=>tainted.commissions, setTainted: (value: Option<boolean>)=>{tainted.commissions = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("commissions", data.commissions); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},scheduleSettings: {path: ["scheduleSettings" ]as const, name: "scheduleSettings" , constraints: { required: true }, get: ()=>data.scheduleSettings, set: (value: ScheduleSettings)=>{data.scheduleSettings = value;}, transform: (value: ScheduleSettings): ScheduleSettings =>value,getError: ()=>errors.scheduleSettings, setError: (value: Option<Array<string>>)=>{errors.scheduleSettings = value;}, getTainted: ()=>tainted.scheduleSettings, setTainted: (value: Option<boolean>)=>{tainted.scheduleSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("scheduleSettings", data.scheduleSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},accountOverviewSettings: {path: ["accountOverviewSettings" ]as const, name: "accountOverviewSettings" , constraints: { required: true }, get: ()=>data.accountOverviewSettings, set: (value: OverviewSettings)=>{data.accountOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.accountOverviewSettings, setError: (value: Option<Array<string>>)=>{errors.accountOverviewSettings = value;}, getTainted: ()=>tainted.accountOverviewSettings, setTainted: (value: Option<boolean>)=>{tainted.accountOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("accountOverviewSettings", data.accountOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},serviceOverviewSettings: {path: ["serviceOverviewSettings" ]as const, name: "serviceOverviewSettings" , constraints: { required: true }, get: ()=>data.serviceOverviewSettings, set: (value: OverviewSettings)=>{data.serviceOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.serviceOverviewSettings, setError: (value: Option<Array<string>>)=>{errors.serviceOverviewSettings = value;}, getTainted: ()=>tainted.serviceOverviewSettings, setTainted: (value: Option<boolean>)=>{tainted.serviceOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("serviceOverviewSettings", data.serviceOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},appointmentOverviewSettings: {path: ["appointmentOverviewSettings" ]as const, name: "appointmentOverviewSettings" , constraints: { required: true }, get: ()=>data.appointmentOverviewSettings, set: (value: OverviewSettings)=>{data.appointmentOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.appointmentOverviewSettings, setError: (value: Option<Array<string>>)=>{errors.appointmentOverviewSettings = value;}, getTainted: ()=>tainted.appointmentOverviewSettings, setTainted: (value: Option<boolean>)=>{tainted.appointmentOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("appointmentOverviewSettings", data.appointmentOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},leadOverviewSettings: {path: ["leadOverviewSettings" ]as const, name: "leadOverviewSettings" , constraints: { required: true }, get: ()=>data.leadOverviewSettings, set: (value: OverviewSettings)=>{data.leadOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.leadOverviewSettings, setError: (value: Option<Array<string>>)=>{errors.leadOverviewSettings = value;}, getTainted: ()=>tainted.leadOverviewSettings, setTainted: (value: Option<boolean>)=>{tainted.leadOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("leadOverviewSettings", data.leadOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},packageOverviewSettings: {path: ["packageOverviewSettings" ]as const, name: "packageOverviewSettings" , constraints: { required: true }, get: ()=>data.packageOverviewSettings, set: (value: OverviewSettings)=>{data.packageOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.packageOverviewSettings, setError: (value: Option<Array<string>>)=>{errors.packageOverviewSettings = value;}, getTainted: ()=>tainted.packageOverviewSettings, setTainted: (value: Option<boolean>)=>{tainted.packageOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("packageOverviewSettings", data.packageOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},productOverviewSettings: {path: ["productOverviewSettings" ]as const, name: "productOverviewSettings" , constraints: { required: true }, get: ()=>data.productOverviewSettings, set: (value: OverviewSettings)=>{data.productOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.productOverviewSettings, setError: (value: Option<Array<string>>)=>{errors.productOverviewSettings = value;}, getTainted: ()=>tainted.productOverviewSettings, setTainted: (value: Option<boolean>)=>{tainted.productOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("productOverviewSettings", data.productOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},orderOverviewSettings: {path: ["orderOverviewSettings" ]as const, name: "orderOverviewSettings" , constraints: { required: true }, get: ()=>data.orderOverviewSettings, set: (value: OverviewSettings)=>{data.orderOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.orderOverviewSettings, setError: (value: Option<Array<string>>)=>{errors.orderOverviewSettings = value;}, getTainted: ()=>tainted.orderOverviewSettings, setTainted: (value: Option<boolean>)=>{tainted.orderOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("orderOverviewSettings", data.orderOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},taxRateOverviewSettings: {path: ["taxRateOverviewSettings" ]as const, name: "taxRateOverviewSettings" , constraints: { required: true }, get: ()=>data.taxRateOverviewSettings, set: (value: OverviewSettings)=>{data.taxRateOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.taxRateOverviewSettings, setError: (value: Option<Array<string>>)=>{errors.taxRateOverviewSettings = value;}, getTainted: ()=>tainted.taxRateOverviewSettings, setTainted: (value: Option<boolean>)=>{tainted.taxRateOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("taxRateOverviewSettings", data.taxRateOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},homePage: {path: ["homePage" ]as const, name: "homePage" , constraints: { required: true }, get: ()=>data.homePage, set: (value: Page)=>{data.homePage = value;}, transform: (value: Page): Page =>value,getError: ()=>errors.homePage, setError: (value: Option<Array<string>>)=>{errors.homePage = value;}, getTainted: ()=>tainted.homePage, setTainted: (value: Option<boolean>)=>{tainted.homePage = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("homePage", data.homePage); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Settings, Array<{field: string; message: string}>>{return settingsDeserialize(data);}function reset(newOverrides?: Partial<Settings>): void {data = {...settingsDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), appointmentNotifications: Option.none(), commissions: Option.none(), scheduleSettings: Option.none(), accountOverviewSettings: Option.none(), serviceOverviewSettings: Option.none(), appointmentOverviewSettings: Option.none(), leadOverviewSettings: Option.none(), packageOverviewSettings: Option.none(), productOverviewSettings: Option.none(), orderOverviewSettings: Option.none(), taxRateOverviewSettings: Option.none(), homePage: Option.none(), }; tainted = {appointmentNotifications: Option.none(), commissions: Option.none(), scheduleSettings: Option.none(), accountOverviewSettings: Option.none(), serviceOverviewSettings: Option.none(), appointmentOverviewSettings: Option.none(), leadOverviewSettings: Option.none(), packageOverviewSettings: Option.none(), productOverviewSettings: Option.none(), orderOverviewSettings: Option.none(), taxRateOverviewSettings: Option.none(), homePage: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function settingsFromFormData(formData: FormData): Result<Settings, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.appointmentNotifications = formData.get("appointmentNotifications" )?? "" ;obj.commissions = formData.get("commissions" )?? "" ;{const scheduleSettings Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("scheduleSettings." )){const fieldName = key.slice("scheduleSettings." .length); const parts = fieldName.split("." ); let current = scheduleSettings Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.scheduleSettings = scheduleSettings Obj;}{const accountOverviewSettings Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("accountOverviewSettings." )){const fieldName = key.slice("accountOverviewSettings." .length); const parts = fieldName.split("." ); let current = accountOverviewSettings Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.accountOverviewSettings = accountOverviewSettings Obj;}{const serviceOverviewSettings Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("serviceOverviewSettings." )){const fieldName = key.slice("serviceOverviewSettings." .length); const parts = fieldName.split("." ); let current = serviceOverviewSettings Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.serviceOverviewSettings = serviceOverviewSettings Obj;}{const appointmentOverviewSettings Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("appointmentOverviewSettings." )){const fieldName = key.slice("appointmentOverviewSettings." .length); const parts = fieldName.split("." ); let current = appointmentOverviewSettings Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.appointmentOverviewSettings = appointmentOverviewSettings Obj;}{const leadOverviewSettings Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("leadOverviewSettings." )){const fieldName = key.slice("leadOverviewSettings." .length); const parts = fieldName.split("." ); let current = leadOverviewSettings Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.leadOverviewSettings = leadOverviewSettings Obj;}{const packageOverviewSettings Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("packageOverviewSettings." )){const fieldName = key.slice("packageOverviewSettings." .length); const parts = fieldName.split("." ); let current = packageOverviewSettings Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.packageOverviewSettings = packageOverviewSettings Obj;}{const productOverviewSettings Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("productOverviewSettings." )){const fieldName = key.slice("productOverviewSettings." .length); const parts = fieldName.split("." ); let current = productOverviewSettings Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.productOverviewSettings = productOverviewSettings Obj;}{const orderOverviewSettings Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("orderOverviewSettings." )){const fieldName = key.slice("orderOverviewSettings." .length); const parts = fieldName.split("." ); let current = orderOverviewSettings Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.orderOverviewSettings = orderOverviewSettings Obj;}{const taxRateOverviewSettings Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("taxRateOverviewSettings." )){const fieldName = key.slice("taxRateOverviewSettings." .length); const parts = fieldName.split("." ); let current = taxRateOverviewSettings Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.taxRateOverviewSettings = taxRateOverviewSettings Obj;}{const homePage Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("homePage." )){const fieldName = key.slice("homePage." .length); const parts = fieldName.split("." ); let current = homePage Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.homePage = homePage Obj;}return settingsDeserialize(obj);}

export const Settings = {
  defaultValue: settingsDefaultValue,
  serialize: settingsSerialize,
  serializeWithContext: settingsSerializeWithContext,
  deserialize: settingsDeserialize,
  deserializeWithContext: settingsDeserializeWithContext,
  validateFields: settingsValidateFields,
  hasShape: settingsHasShape,
  is: settingsIs,
  createForm: settingsCreateForm,
  fromFormData: settingsFromFormData
} as const;


export interface Color {
    red: number;
    green: number;
    blue: number;
}

export function colorDefaultValue(): Color {return {red: 0,
                            green: 0,
                            blue: 0, }as Color;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function colorSerialize(value: Color): string {const ctx = SerializeContext.create(); return JSON.stringify(colorSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function colorSerializeWithContext(value: Color, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Color" , __id,}; result["red" ]= value.red; result["green" ]= value.green; result["blue" ]= value.blue; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function colorDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Color } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = colorDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Color.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function colorDeserializeWithContext(value: any, ctx: DeserializeContext): Color | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Color.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("red" in obj)){errors.push({field: "red" , message: "missing required field" });}if(!("green" in obj)){errors.push({field: "green" , message: "missing required field" });}if(!("blue" in obj)){errors.push({field: "blue" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_red = obj["red" ]as number; instance.red = __raw_red; }{const __raw_green = obj["green" ]as number; instance.green = __raw_green; }{const __raw_blue = obj["blue" ]as number; instance.blue = __raw_blue; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Color;}export function colorValidateField<K extends keyof Color>(field: K, value: Color[K]): Array<{field: string; message: string}>{return[]; }export function colorValidateFields(partial: Partial<Color>): Array<{field: string; message: string}>{return[]; }export function colorHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "red" in o && "green" in o && "blue" in o;}export function colorIs(obj: unknown): obj is Color {if(!colorHasShape(obj)){return false;}const result = colorDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ColorErrors = {_errors: Option<Array<string>>; red: Option<Array<string>>; green: Option<Array<string>>; blue: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ColorTainted = {red: Option<boolean>; green: Option<boolean>; blue: Option<boolean>; }; /** Type-safe field controllers for this form */export interface ColorFieldControllers {readonly red: FieldController<number>; readonly green: FieldController<number>; readonly blue: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface ColorGigaform {readonly data: Color; readonly errors: ColorErrors; readonly tainted: ColorTainted; readonly fields: ColorFieldControllers; validate(): Result<Color, Array<{field: string; message: string}>>; reset(overrides?: Partial<Color>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function colorCreateForm(overrides?: Partial<Color>): ColorGigaform {let data = $state({...colorDefaultValue(),...overrides}); let errors = $state<ColorErrors>({_errors: Option.none(), red: Option.none(), green: Option.none(), blue: Option.none(), }); let tainted = $state<ColorTainted>({red: Option.none(), green: Option.none(), blue: Option.none(), }); const fields: ColorFieldControllers = {red: {path: ["red" ]as const, name: "red" , constraints: { required: true }, get: ()=>data.red, set: (value: number)=>{data.red = value;}, transform: (value: number): number =>value,getError: ()=>errors.red, setError: (value: Option<Array<string>>)=>{errors.red = value;}, getTainted: ()=>tainted.red, setTainted: (value: Option<boolean>)=>{tainted.red = value;}, validate: (): Array<string>=>{const fieldErrors = colorValidateField("red", data.red); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},green: {path: ["green" ]as const, name: "green" , constraints: { required: true }, get: ()=>data.green, set: (value: number)=>{data.green = value;}, transform: (value: number): number =>value,getError: ()=>errors.green, setError: (value: Option<Array<string>>)=>{errors.green = value;}, getTainted: ()=>tainted.green, setTainted: (value: Option<boolean>)=>{tainted.green = value;}, validate: (): Array<string>=>{const fieldErrors = colorValidateField("green", data.green); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},blue: {path: ["blue" ]as const, name: "blue" , constraints: { required: true }, get: ()=>data.blue, set: (value: number)=>{data.blue = value;}, transform: (value: number): number =>value,getError: ()=>errors.blue, setError: (value: Option<Array<string>>)=>{errors.blue = value;}, getTainted: ()=>tainted.blue, setTainted: (value: Option<boolean>)=>{tainted.blue = value;}, validate: (): Array<string>=>{const fieldErrors = colorValidateField("blue", data.blue); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Color, Array<{field: string; message: string}>>{return colorDeserialize(data);}function reset(newOverrides?: Partial<Color>): void {data = {...colorDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), red: Option.none(), green: Option.none(), blue: Option.none(), }; tainted = {red: Option.none(), green: Option.none(), blue: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function colorFromFormData(formData: FormData): Result<Color, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const red Str = formData.get("red" ); obj.red = red Str? parseFloat(red Str as string): 0; if(obj.red!== undefined && isNaN(obj.red as number))obj.red = 0;}{const green Str = formData.get("green" ); obj.green = green Str? parseFloat(green Str as string): 0; if(obj.green!== undefined && isNaN(obj.green as number))obj.green = 0;}{const blue Str = formData.get("blue" ); obj.blue = blue Str? parseFloat(blue Str as string): 0; if(obj.blue!== undefined && isNaN(obj.blue as number))obj.blue = 0;}return colorDeserialize(obj);}

export const Color = {
  defaultValue: colorDefaultValue,
  serialize: colorSerialize,
  serializeWithContext: colorSerializeWithContext,
  deserialize: colorDeserialize,
  deserializeWithContext: colorDeserializeWithContext,
  validateFields: colorValidateFields,
  hasShape: colorHasShape,
  is: colorIs,
  createForm: colorCreateForm,
  fromFormData: colorFromFormData
} as const;


export interface CompanyName {
    
    
    companyName: string;
}

export function companyNameDefaultValue(): CompanyName {return {companyName: "", }as CompanyName;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function companyNameSerialize(value: CompanyName): string {const ctx = SerializeContext.create(); return JSON.stringify(companyNameSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function companyNameSerializeWithContext(value: CompanyName, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "CompanyName" , __id,}; result["companyName" ]= value.companyName; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function companyNameDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: CompanyName } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = companyNameDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "CompanyName.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function companyNameDeserializeWithContext(value: any, ctx: DeserializeContext): CompanyName | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "CompanyName.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("companyName" in obj)){errors.push({field: "companyName" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_companyName = obj["companyName" ]as string; 
                if (__raw_companyName.length === 0) {
                    errors.push({ field: "companyName", message: "must not be empty" });
                }
 instance.companyName = __raw_companyName; }if(errors.length>0){throw new DeserializeError(errors);}return instance as CompanyName;}export function companyNameValidateField<K extends keyof CompanyName>(field: K, value: CompanyName[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "companyName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "companyName", message: "must not be empty" });
                }
 break;}}return errors; }export function companyNameValidateFields(partial: Partial<CompanyName>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("companyName" in partial && partial.companyName!== undefined){const __val = partial.companyName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "companyName", message: "must not be empty" });
                }
}return errors; }export function companyNameHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "companyName" in o;}export function companyNameIs(obj: unknown): obj is CompanyName {if(!companyNameHasShape(obj)){return false;}const result = companyNameDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CompanyNameErrors = {_errors: Option<Array<string>>; companyName: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CompanyNameTainted = {companyName: Option<boolean>; }; /** Type-safe field controllers for this form */export interface CompanyNameFieldControllers {readonly companyName: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface CompanyNameGigaform {readonly data: CompanyName; readonly errors: CompanyNameErrors; readonly tainted: CompanyNameTainted; readonly fields: CompanyNameFieldControllers; validate(): Result<CompanyName, Array<{field: string; message: string}>>; reset(overrides?: Partial<CompanyName>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function companyNameCreateForm(overrides?: Partial<CompanyName>): CompanyNameGigaform {let data = $state({...companyNameDefaultValue(),...overrides}); let errors = $state<CompanyNameErrors>({_errors: Option.none(), companyName: Option.none(), }); let tainted = $state<CompanyNameTainted>({companyName: Option.none(), }); const fields: CompanyNameFieldControllers = {companyName: {path: ["companyName" ]as const, name: "companyName" , constraints: { required: true }, label: "Company Name" , get: ()=>data.companyName, set: (value: string)=>{data.companyName = value;}, transform: (value: string): string =>value,getError: ()=>errors.companyName, setError: (value: Option<Array<string>>)=>{errors.companyName = value;}, getTainted: ()=>tainted.companyName, setTainted: (value: Option<boolean>)=>{tainted.companyName = value;}, validate: (): Array<string>=>{const fieldErrors = companyNameValidateField("companyName", data.companyName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<CompanyName, Array<{field: string; message: string}>>{return companyNameDeserialize(data);}function reset(newOverrides?: Partial<CompanyName>): void {data = {...companyNameDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), companyName: Option.none(), }; tainted = {companyName: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function companyNameFromFormData(formData: FormData): Result<CompanyName, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.companyName = formData.get("companyName" )?? "" ;return companyNameDeserialize(obj);}

export const CompanyName = {
  defaultValue: companyNameDefaultValue,
  serialize: companyNameSerialize,
  serializeWithContext: companyNameSerializeWithContext,
  deserialize: companyNameDeserialize,
  deserializeWithContext: companyNameDeserializeWithContext,
  validateFields: companyNameValidateFields,
  hasShape: companyNameHasShape,
  is: companyNameIs,
  createForm: companyNameCreateForm,
  fromFormData: companyNameFromFormData
} as const;


export interface Appointment {
    
    id: string;
    
    
    title: string;
    
    
    status: Status;
    
    begins: string;
    
    duration: number;
    
    timeZone: string;
    
    offsetMs: number;
    
    allDay: boolean;
    
    multiDay: boolean;
    
    employees: (string | Employee)[];
    
    
    location: string | Site;
    
    description: string | null;
    
    
    colors: Colors;
    
    recurrenceRule: RecurrenceRule | null;
}

export function appointmentDefaultValue(): Appointment {return {id: "",
                            title: "",
                            status: "Scheduled",
                            begins: "",
                            duration: 0,
                            timeZone: "",
                            offsetMs: 0,
                            allDay: false,
                            multiDay: false,
                            employees: [],
                            location: "",
                            description: null,
                            colors: { main: "#000000", hover: "#333333", active: "#666666" },
                            recurrenceRule: null, }as Appointment;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function appointmentSerialize(value: Appointment): string {const ctx = SerializeContext.create(); return JSON.stringify(appointmentSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function appointmentSerializeWithContext(value: Appointment, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Appointment" , __id,}; result["id" ]= value.id; result["title" ]= value.title; result["status" ]= statusSerializeWithContext(value.status, ctx); result["begins" ]= value.begins; result["duration" ]= value.duration; result["timeZone" ]= value.timeZone; result["offsetMs" ]= value.offsetMs; result["allDay" ]= value.allDay; result["multiDay" ]= value.multiDay; result["employees" ]= value.employees; result["location" ]= value.location; result["description" ]= value.description; result["colors" ]= colorsSerializeWithContext(value.colors, ctx); if(value.recurrenceRule!== null){result["recurrenceRule" ]= recurrenceRuleSerializeWithContext(value.recurrenceRule, ctx); }else {result["recurrenceRule" ]= null;}return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function appointmentDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Appointment } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = appointmentDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Appointment.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function appointmentDeserializeWithContext(value: any, ctx: DeserializeContext): Appointment | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Appointment.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("title" in obj)){errors.push({field: "title" , message: "missing required field" });}if(!("status" in obj)){errors.push({field: "status" , message: "missing required field" });}if(!("begins" in obj)){errors.push({field: "begins" , message: "missing required field" });}if(!("duration" in obj)){errors.push({field: "duration" , message: "missing required field" });}if(!("timeZone" in obj)){errors.push({field: "timeZone" , message: "missing required field" });}if(!("offsetMs" in obj)){errors.push({field: "offsetMs" , message: "missing required field" });}if(!("allDay" in obj)){errors.push({field: "allDay" , message: "missing required field" });}if(!("multiDay" in obj)){errors.push({field: "multiDay" , message: "missing required field" });}if(!("employees" in obj)){errors.push({field: "employees" , message: "missing required field" });}if(!("location" in obj)){errors.push({field: "location" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(!("colors" in obj)){errors.push({field: "colors" , message: "missing required field" });}if(!("recurrenceRule" in obj)){errors.push({field: "recurrenceRule" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_title = obj["title" ]as string; 
                if (__raw_title.length === 0) {
                    errors.push({ field: "title", message: "must not be empty" });
                }
 instance.title = __raw_title; }{const __raw_status = obj["status" ]as Status; {const __result = statusDeserializeWithContext(__raw_status, ctx); ctx.assignOrDefer(instance, "status" , __result);}}{const __raw_begins = obj["begins" ]as string; instance.begins = __raw_begins; }{const __raw_duration = obj["duration" ]as number; instance.duration = __raw_duration; }{const __raw_timeZone = obj["timeZone" ]as string; instance.timeZone = __raw_timeZone; }{const __raw_offsetMs = obj["offsetMs" ]as number; instance.offsetMs = __raw_offsetMs; }{const __raw_allDay = obj["allDay" ]as boolean; instance.allDay = __raw_allDay; }{const __raw_multiDay = obj["multiDay" ]as boolean; instance.multiDay = __raw_multiDay; }{const __raw_employees = obj["employees" ]as (string | Employee)[]; if(Array.isArray(__raw_employees)){instance.employees = __raw_employees as (string | Employee)[];}}{const __raw_location = obj["location" ]as string | Site; instance.location = __raw_location; }{const __raw_description = obj["description" ]as string | null; instance.description = __raw_description; }{const __raw_colors = obj["colors" ]as Colors; {const __result = colorsDeserializeWithContext(__raw_colors, ctx); ctx.assignOrDefer(instance, "colors" , __result);}}{const __raw_recurrenceRule = obj["recurrenceRule" ]as RecurrenceRule | null; if(__raw_recurrenceRule === null){instance.recurrenceRule = null;}else {const __result = recurrenceRuleDeserializeWithContext(__raw_recurrenceRule, ctx); ctx.assignOrDefer(instance, "recurrenceRule" , __result); }}if(errors.length>0){throw new DeserializeError(errors);}return instance as Appointment;}export function appointmentValidateField<K extends keyof Appointment>(field: K, value: Appointment[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "title" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "title", message: "must not be empty" });
                }
 break;}}return errors; }export function appointmentValidateFields(partial: Partial<Appointment>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("title" in partial && partial.title!== undefined){const __val = partial.title as string; 
                if (__val.length === 0) {
                    errors.push({ field: "title", message: "must not be empty" });
                }
}return errors; }export function appointmentHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "title" in o && "status" in o && "begins" in o && "duration" in o && "timeZone" in o && "offsetMs" in o && "allDay" in o && "multiDay" in o && "employees" in o && "location" in o && "description" in o && "colors" in o && "recurrenceRule" in o;}export function appointmentIs(obj: unknown): obj is Appointment {if(!appointmentHasShape(obj)){return false;}const result = appointmentDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type AppointmentErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; title: Option<Array<string>>; status: Option<Array<string>>; begins: Option<Array<string>>; duration: Option<Array<string>>; timeZone: Option<Array<string>>; offsetMs: Option<Array<string>>; allDay: Option<Array<string>>; multiDay: Option<Array<string>>; employees: Option<Array<string>>; location: Option<Array<string>>; description: Option<Array<string>>; colors: Option<Array<string>>; recurrenceRule: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type AppointmentTainted = {id: Option<boolean>; title: Option<boolean>; status: Option<boolean>; begins: Option<boolean>; duration: Option<boolean>; timeZone: Option<boolean>; offsetMs: Option<boolean>; allDay: Option<boolean>; multiDay: Option<boolean>; employees: Option<boolean>; location: Option<boolean>; description: Option<boolean>; colors: Option<boolean>; recurrenceRule: Option<boolean>; }; /** Type-safe field controllers for this form */export interface AppointmentFieldControllers {readonly id: FieldController<string>; readonly title: FieldController<string>; readonly status: FieldController<Status>; readonly begins: FieldController<string>; readonly duration: FieldController<number>; readonly timeZone: FieldController<string>; readonly offsetMs: FieldController<number>; readonly allDay: FieldController<boolean>; readonly multiDay: FieldController<boolean>; readonly employees: ArrayFieldController<(string | Employee)>; readonly location: FieldController<string | Site>; readonly description: FieldController<string | null>; readonly colors: FieldController<Colors>; readonly recurrenceRule: FieldController<RecurrenceRule | null>; }/** Gigaform instance containing reactive state and field controllers */export interface AppointmentGigaform {readonly data: Appointment; readonly errors: AppointmentErrors; readonly tainted: AppointmentTainted; readonly fields: AppointmentFieldControllers; validate(): Result<Appointment, Array<{field: string; message: string}>>; reset(overrides?: Partial<Appointment>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function appointmentCreateForm(overrides?: Partial<Appointment>): AppointmentGigaform {let data = $state({...appointmentDefaultValue(),...overrides}); let errors = $state<AppointmentErrors>({_errors: Option.none(), id: Option.none(), title: Option.none(), status: Option.none(), begins: Option.none(), duration: Option.none(), timeZone: Option.none(), offsetMs: Option.none(), allDay: Option.none(), multiDay: Option.none(), employees: Option.none(), location: Option.none(), description: Option.none(), colors: Option.none(), recurrenceRule: Option.none(), }); let tainted = $state<AppointmentTainted>({id: Option.none(), title: Option.none(), status: Option.none(), begins: Option.none(), duration: Option.none(), timeZone: Option.none(), offsetMs: Option.none(), allDay: Option.none(), multiDay: Option.none(), employees: Option.none(), location: Option.none(), description: Option.none(), colors: Option.none(), recurrenceRule: Option.none(), }); const fields: AppointmentFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},title: {path: ["title" ]as const, name: "title" , constraints: { required: true }, label: "Title" , get: ()=>data.title, set: (value: string)=>{data.title = value;}, transform: (value: string): string =>value,getError: ()=>errors.title, setError: (value: Option<Array<string>>)=>{errors.title = value;}, getTainted: ()=>tainted.title, setTainted: (value: Option<boolean>)=>{tainted.title = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("title", data.title); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},status: {path: ["status" ]as const, name: "status" , constraints: { required: true }, label: "Status" , get: ()=>data.status, set: (value: Status)=>{data.status = value;}, transform: (value: Status): Status =>value,getError: ()=>errors.status, setError: (value: Option<Array<string>>)=>{errors.status = value;}, getTainted: ()=>tainted.status, setTainted: (value: Option<boolean>)=>{tainted.status = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("status", data.status); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},begins: {path: ["begins" ]as const, name: "begins" , constraints: { required: true }, label: "Begins" , get: ()=>data.begins, set: (value: string)=>{data.begins = value;}, transform: (value: string): string =>value,getError: ()=>errors.begins, setError: (value: Option<Array<string>>)=>{errors.begins = value;}, getTainted: ()=>tainted.begins, setTainted: (value: Option<boolean>)=>{tainted.begins = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("begins", data.begins); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},duration: {path: ["duration" ]as const, name: "duration" , constraints: { required: true }, label: "Duration" , get: ()=>data.duration, set: (value: number)=>{data.duration = value;}, transform: (value: number): number =>value,getError: ()=>errors.duration, setError: (value: Option<Array<string>>)=>{errors.duration = value;}, getTainted: ()=>tainted.duration, setTainted: (value: Option<boolean>)=>{tainted.duration = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("duration", data.duration); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},timeZone: {path: ["timeZone" ]as const, name: "timeZone" , constraints: { required: true }, label: "Time Zone" , get: ()=>data.timeZone, set: (value: string)=>{data.timeZone = value;}, transform: (value: string): string =>value,getError: ()=>errors.timeZone, setError: (value: Option<Array<string>>)=>{errors.timeZone = value;}, getTainted: ()=>tainted.timeZone, setTainted: (value: Option<boolean>)=>{tainted.timeZone = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("timeZone", data.timeZone); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},offsetMs: {path: ["offsetMs" ]as const, name: "offsetMs" , constraints: { required: true }, get: ()=>data.offsetMs, set: (value: number)=>{data.offsetMs = value;}, transform: (value: number): number =>value,getError: ()=>errors.offsetMs, setError: (value: Option<Array<string>>)=>{errors.offsetMs = value;}, getTainted: ()=>tainted.offsetMs, setTainted: (value: Option<boolean>)=>{tainted.offsetMs = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("offsetMs", data.offsetMs); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},allDay: {path: ["allDay" ]as const, name: "allDay" , constraints: { required: true }, label: "All Day" , get: ()=>data.allDay, set: (value: boolean)=>{data.allDay = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.allDay, setError: (value: Option<Array<string>>)=>{errors.allDay = value;}, getTainted: ()=>tainted.allDay, setTainted: (value: Option<boolean>)=>{tainted.allDay = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("allDay", data.allDay); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},multiDay: {path: ["multiDay" ]as const, name: "multiDay" , constraints: { required: true }, label: "Multi Day" , get: ()=>data.multiDay, set: (value: boolean)=>{data.multiDay = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.multiDay, setError: (value: Option<Array<string>>)=>{errors.multiDay = value;}, getTainted: ()=>tainted.multiDay, setTainted: (value: Option<boolean>)=>{tainted.multiDay = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("multiDay", data.multiDay); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},employees: {path: ["employees" ]as const, name: "employees" , constraints: { required: true }, label: "Employees" , get: ()=>data.employees, set: (value: (string | Employee)[])=>{data.employees = value;}, transform: (value: (string | Employee)[]): (string | Employee)[] =>value,getError: ()=>errors.employees, setError: (value: Option<Array<string>>)=>{errors.employees = value;}, getTainted: ()=>tainted.employees, setTainted: (value: Option<boolean>)=>{tainted.employees = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("employees", data.employees); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["employees" , index]as const, name: `employees.${index}` , constraints: {required: true}, get: ()=>data.employees[index]!, set: (value: (string | Employee))=>{data.employees[index]= value;}, transform: (value: (string | Employee)): (string | Employee) =>value, getError: ()=>errors.employees, setError: (value: Option<Array<string>>)=>{errors.employees = value;}, getTainted: ()=>tainted.employees, setTainted: (value: Option<boolean>)=>{tainted.employees = value;}, validate: (): Array<string>=>[],}), push: (item: (string | Employee))=>{data.employees.push(item);}, remove: (index: number)=>{data.employees.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.employees[a]!; data.employees[a]= data.employees[b]!; data.employees[b]= tmp;},},location: {path: ["location" ]as const, name: "location" , constraints: { required: true }, label: "Location" , get: ()=>data.location, set: (value: string | Site)=>{data.location = value;}, transform: (value: string | Site): string | Site =>value,getError: ()=>errors.location, setError: (value: Option<Array<string>>)=>{errors.location = value;}, getTainted: ()=>tainted.location, setTainted: (value: Option<boolean>)=>{tainted.location = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("location", data.location); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},description: {path: ["description" ]as const, name: "description" , constraints: { required: true }, label: "Description" , get: ()=>data.description, set: (value: string | null)=>{data.description = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.description, setError: (value: Option<Array<string>>)=>{errors.description = value;}, getTainted: ()=>tainted.description, setTainted: (value: Option<boolean>)=>{tainted.description = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("description", data.description); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},colors: {path: ["colors" ]as const, name: "colors" , constraints: { required: true }, get: ()=>data.colors, set: (value: Colors)=>{data.colors = value;}, transform: (value: Colors): Colors =>value,getError: ()=>errors.colors, setError: (value: Option<Array<string>>)=>{errors.colors = value;}, getTainted: ()=>tainted.colors, setTainted: (value: Option<boolean>)=>{tainted.colors = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("colors", data.colors); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},recurrenceRule: {path: ["recurrenceRule" ]as const, name: "recurrenceRule" , constraints: { required: true }, get: ()=>data.recurrenceRule, set: (value: RecurrenceRule | null)=>{data.recurrenceRule = value;}, transform: (value: RecurrenceRule | null): RecurrenceRule | null =>value,getError: ()=>errors.recurrenceRule, setError: (value: Option<Array<string>>)=>{errors.recurrenceRule = value;}, getTainted: ()=>tainted.recurrenceRule, setTainted: (value: Option<boolean>)=>{tainted.recurrenceRule = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("recurrenceRule", data.recurrenceRule); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Appointment, Array<{field: string; message: string}>>{return appointmentDeserialize(data);}function reset(newOverrides?: Partial<Appointment>): void {data = {...appointmentDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), title: Option.none(), status: Option.none(), begins: Option.none(), duration: Option.none(), timeZone: Option.none(), offsetMs: Option.none(), allDay: Option.none(), multiDay: Option.none(), employees: Option.none(), location: Option.none(), description: Option.none(), colors: Option.none(), recurrenceRule: Option.none(), }; tainted = {id: Option.none(), title: Option.none(), status: Option.none(), begins: Option.none(), duration: Option.none(), timeZone: Option.none(), offsetMs: Option.none(), allDay: Option.none(), multiDay: Option.none(), employees: Option.none(), location: Option.none(), description: Option.none(), colors: Option.none(), recurrenceRule: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function appointmentFromFormData(formData: FormData): Result<Appointment, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.title = formData.get("title" )?? "" ;{const status Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("status." )){const fieldName = key.slice("status." .length); const parts = fieldName.split("." ); let current = status Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.status = status Obj;}obj.begins = formData.get("begins" )?? "" ;{const duration Str = formData.get("duration" ); obj.duration = duration Str? parseFloat(duration Str as string): 0; if(obj.duration!== undefined && isNaN(obj.duration as number))obj.duration = 0;}obj.timeZone = formData.get("timeZone" )?? "" ;{const offsetMs Str = formData.get("offsetMs" ); obj.offsetMs = offsetMs Str? parseFloat(offsetMs Str as string): 0; if(obj.offsetMs!== undefined && isNaN(obj.offsetMs as number))obj.offsetMs = 0;}{const allDay Val = formData.get("allDay" ); obj.allDay = allDay Val === "true" || allDay Val === "on" || allDay Val === "1" ;}{const multiDay Val = formData.get("multiDay" ); obj.multiDay = multiDay Val === "true" || multiDay Val === "on" || multiDay Val === "1" ;}{const employees Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("employees." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("employees." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("employees." + idx + "." )){const fieldName = key.slice("employees." .length + String(idx).length + 1); item[fieldName]= value;}}employees Items.push(item);}idx ++; if(idx>1000)break;}obj.employees = employees Items;}obj.location = formData.get("location" )?? "" ;obj.description = formData.get("description" )?? "" ;{const colors Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("colors." )){const fieldName = key.slice("colors." .length); const parts = fieldName.split("." ); let current = colors Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.colors = colors Obj;}obj.recurrenceRule = formData.get("recurrenceRule" )?? "" ;return appointmentDeserialize(obj);}

export const Appointment = {
  defaultValue: appointmentDefaultValue,
  serialize: appointmentSerialize,
  serializeWithContext: appointmentSerializeWithContext,
  deserialize: appointmentDeserialize,
  deserializeWithContext: appointmentDeserializeWithContext,
  validateFields: appointmentValidateFields,
  hasShape: appointmentHasShape,
  is: appointmentIs,
  createForm: appointmentCreateForm,
  fromFormData: appointmentFromFormData
} as const;


export interface Package {
    
    id: string;
    
    date: string;
}

export function packageDefaultValue(): Package {return {id: "",
                            date: "", }as Package;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function packageSerialize(value: Package): string {const ctx = SerializeContext.create(); return JSON.stringify(packageSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function packageSerializeWithContext(value: Package, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Package" , __id,}; result["id" ]= value.id; result["date" ]= value.date; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function packageDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Package } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = packageDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Package.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function packageDeserializeWithContext(value: any, ctx: DeserializeContext): Package | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Package.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("date" in obj)){errors.push({field: "date" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_date = obj["date" ]as string; instance.date = __raw_date; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Package;}export function packageValidateField<K extends keyof Package>(field: K, value: Package[K]): Array<{field: string; message: string}>{return[]; }export function packageValidateFields(partial: Partial<Package>): Array<{field: string; message: string}>{return[]; }export function packageHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "date" in o;}export function packageIs(obj: unknown): obj is Package {if(!packageHasShape(obj)){return false;}const result = packageDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type PackageErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; date: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type PackageTainted = {id: Option<boolean>; date: Option<boolean>; }; /** Type-safe field controllers for this form */export interface PackageFieldControllers {readonly id: FieldController<string>; readonly date: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface PackageGigaform {readonly data: Package; readonly errors: PackageErrors; readonly tainted: PackageTainted; readonly fields: PackageFieldControllers; validate(): Result<Package, Array<{field: string; message: string}>>; reset(overrides?: Partial<Package>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function packageCreateForm(overrides?: Partial<Package>): PackageGigaform {let data = $state({...packageDefaultValue(),...overrides}); let errors = $state<PackageErrors>({_errors: Option.none(), id: Option.none(), date: Option.none(), }); let tainted = $state<PackageTainted>({id: Option.none(), date: Option.none(), }); const fields: PackageFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = packageValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},date: {path: ["date" ]as const, name: "date" , constraints: { required: true }, label: "Date" , get: ()=>data.date, set: (value: string)=>{data.date = value;}, transform: (value: string): string =>value,getError: ()=>errors.date, setError: (value: Option<Array<string>>)=>{errors.date = value;}, getTainted: ()=>tainted.date, setTainted: (value: Option<boolean>)=>{tainted.date = value;}, validate: (): Array<string>=>{const fieldErrors = packageValidateField("date", data.date); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Package, Array<{field: string; message: string}>>{return packageDeserialize(data);}function reset(newOverrides?: Partial<Package>): void {data = {...packageDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), date: Option.none(), }; tainted = {id: Option.none(), date: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function packageFromFormData(formData: FormData): Result<Package, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.date = formData.get("date" )?? "" ;return packageDeserialize(obj);}

export const Package = {
  defaultValue: packageDefaultValue,
  serialize: packageSerialize,
  serializeWithContext: packageSerializeWithContext,
  deserialize: packageDeserialize,
  deserializeWithContext: packageDeserializeWithContext,
  validateFields: packageValidateFields,
  hasShape: packageHasShape,
  is: packageIs,
  createForm: packageCreateForm,
  fromFormData: packageFromFormData
} as const;


export interface ScheduleSettings {
    daysPerWeek: number;
    
    rowHeight: RowHeight;
    visibleRoutes: string[];
    detailedCards: boolean;
}

export function scheduleSettingsDefaultValue(): ScheduleSettings {return {daysPerWeek: 0,
                            rowHeight: "Medium",
                            visibleRoutes: [],
                            detailedCards: false, }as ScheduleSettings;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function scheduleSettingsSerialize(value: ScheduleSettings): string {const ctx = SerializeContext.create(); return JSON.stringify(scheduleSettingsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function scheduleSettingsSerializeWithContext(value: ScheduleSettings, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "ScheduleSettings" , __id,}; result["daysPerWeek" ]= value.daysPerWeek; result["rowHeight" ]= rowHeightSerializeWithContext(value.rowHeight, ctx); result["visibleRoutes" ]= value.visibleRoutes; result["detailedCards" ]= value.detailedCards; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function scheduleSettingsDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: ScheduleSettings } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = scheduleSettingsDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "ScheduleSettings.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function scheduleSettingsDeserializeWithContext(value: any, ctx: DeserializeContext): ScheduleSettings | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "ScheduleSettings.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("daysPerWeek" in obj)){errors.push({field: "daysPerWeek" , message: "missing required field" });}if(!("rowHeight" in obj)){errors.push({field: "rowHeight" , message: "missing required field" });}if(!("visibleRoutes" in obj)){errors.push({field: "visibleRoutes" , message: "missing required field" });}if(!("detailedCards" in obj)){errors.push({field: "detailedCards" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_daysPerWeek = obj["daysPerWeek" ]as number; instance.daysPerWeek = __raw_daysPerWeek; }{const __raw_rowHeight = obj["rowHeight" ]as RowHeight; {const __result = rowHeightDeserializeWithContext(__raw_rowHeight, ctx); ctx.assignOrDefer(instance, "rowHeight" , __result);}}{const __raw_visibleRoutes = obj["visibleRoutes" ]as string[]; if(Array.isArray(__raw_visibleRoutes)){instance.visibleRoutes = __raw_visibleRoutes as string[];}}{const __raw_detailedCards = obj["detailedCards" ]as boolean; instance.detailedCards = __raw_detailedCards; }if(errors.length>0){throw new DeserializeError(errors);}return instance as ScheduleSettings;}export function scheduleSettingsValidateField<K extends keyof ScheduleSettings>(field: K, value: ScheduleSettings[K]): Array<{field: string; message: string}>{return[]; }export function scheduleSettingsValidateFields(partial: Partial<ScheduleSettings>): Array<{field: string; message: string}>{return[]; }export function scheduleSettingsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "daysPerWeek" in o && "rowHeight" in o && "visibleRoutes" in o && "detailedCards" in o;}export function scheduleSettingsIs(obj: unknown): obj is ScheduleSettings {if(!scheduleSettingsHasShape(obj)){return false;}const result = scheduleSettingsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ScheduleSettingsErrors = {_errors: Option<Array<string>>; daysPerWeek: Option<Array<string>>; rowHeight: Option<Array<string>>; visibleRoutes: Option<Array<string>>; detailedCards: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ScheduleSettingsTainted = {daysPerWeek: Option<boolean>; rowHeight: Option<boolean>; visibleRoutes: Option<boolean>; detailedCards: Option<boolean>; }; /** Type-safe field controllers for this form */export interface ScheduleSettingsFieldControllers {readonly daysPerWeek: FieldController<number>; readonly rowHeight: FieldController<RowHeight>; readonly visibleRoutes: ArrayFieldController<string>; readonly detailedCards: FieldController<boolean>; }/** Gigaform instance containing reactive state and field controllers */export interface ScheduleSettingsGigaform {readonly data: ScheduleSettings; readonly errors: ScheduleSettingsErrors; readonly tainted: ScheduleSettingsTainted; readonly fields: ScheduleSettingsFieldControllers; validate(): Result<ScheduleSettings, Array<{field: string; message: string}>>; reset(overrides?: Partial<ScheduleSettings>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function scheduleSettingsCreateForm(overrides?: Partial<ScheduleSettings>): ScheduleSettingsGigaform {let data = $state({...scheduleSettingsDefaultValue(),...overrides}); let errors = $state<ScheduleSettingsErrors>({_errors: Option.none(), daysPerWeek: Option.none(), rowHeight: Option.none(), visibleRoutes: Option.none(), detailedCards: Option.none(), }); let tainted = $state<ScheduleSettingsTainted>({daysPerWeek: Option.none(), rowHeight: Option.none(), visibleRoutes: Option.none(), detailedCards: Option.none(), }); const fields: ScheduleSettingsFieldControllers = {daysPerWeek: {path: ["daysPerWeek" ]as const, name: "daysPerWeek" , constraints: { required: true }, get: ()=>data.daysPerWeek, set: (value: number)=>{data.daysPerWeek = value;}, transform: (value: number): number =>value,getError: ()=>errors.daysPerWeek, setError: (value: Option<Array<string>>)=>{errors.daysPerWeek = value;}, getTainted: ()=>tainted.daysPerWeek, setTainted: (value: Option<boolean>)=>{tainted.daysPerWeek = value;}, validate: (): Array<string>=>{const fieldErrors = scheduleSettingsValidateField("daysPerWeek", data.daysPerWeek); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},rowHeight: {path: ["rowHeight" ]as const, name: "rowHeight" , constraints: { required: true }, get: ()=>data.rowHeight, set: (value: RowHeight)=>{data.rowHeight = value;}, transform: (value: RowHeight): RowHeight =>value,getError: ()=>errors.rowHeight, setError: (value: Option<Array<string>>)=>{errors.rowHeight = value;}, getTainted: ()=>tainted.rowHeight, setTainted: (value: Option<boolean>)=>{tainted.rowHeight = value;}, validate: (): Array<string>=>{const fieldErrors = scheduleSettingsValidateField("rowHeight", data.rowHeight); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},visibleRoutes: {path: ["visibleRoutes" ]as const, name: "visibleRoutes" , constraints: { required: true }, get: ()=>data.visibleRoutes, set: (value: string[])=>{data.visibleRoutes = value;}, transform: (value: string[]): string[] =>value,getError: ()=>errors.visibleRoutes, setError: (value: Option<Array<string>>)=>{errors.visibleRoutes = value;}, getTainted: ()=>tainted.visibleRoutes, setTainted: (value: Option<boolean>)=>{tainted.visibleRoutes = value;}, validate: (): Array<string>=>{const fieldErrors = scheduleSettingsValidateField("visibleRoutes", data.visibleRoutes); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["visibleRoutes" , index]as const, name: `visibleRoutes.${index}` , constraints: {required: true}, get: ()=>data.visibleRoutes[index]!, set: (value: string)=>{data.visibleRoutes[index]= value;}, transform: (value: string): string =>value, getError: ()=>errors.visibleRoutes, setError: (value: Option<Array<string>>)=>{errors.visibleRoutes = value;}, getTainted: ()=>tainted.visibleRoutes, setTainted: (value: Option<boolean>)=>{tainted.visibleRoutes = value;}, validate: (): Array<string>=>[],}), push: (item: string)=>{data.visibleRoutes.push(item);}, remove: (index: number)=>{data.visibleRoutes.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.visibleRoutes[a]!; data.visibleRoutes[a]= data.visibleRoutes[b]!; data.visibleRoutes[b]= tmp;},},detailedCards: {path: ["detailedCards" ]as const, name: "detailedCards" , constraints: { required: true }, get: ()=>data.detailedCards, set: (value: boolean)=>{data.detailedCards = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.detailedCards, setError: (value: Option<Array<string>>)=>{errors.detailedCards = value;}, getTainted: ()=>tainted.detailedCards, setTainted: (value: Option<boolean>)=>{tainted.detailedCards = value;}, validate: (): Array<string>=>{const fieldErrors = scheduleSettingsValidateField("detailedCards", data.detailedCards); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<ScheduleSettings, Array<{field: string; message: string}>>{return scheduleSettingsDeserialize(data);}function reset(newOverrides?: Partial<ScheduleSettings>): void {data = {...scheduleSettingsDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), daysPerWeek: Option.none(), rowHeight: Option.none(), visibleRoutes: Option.none(), detailedCards: Option.none(), }; tainted = {daysPerWeek: Option.none(), rowHeight: Option.none(), visibleRoutes: Option.none(), detailedCards: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function scheduleSettingsFromFormData(formData: FormData): Result<ScheduleSettings, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const daysPerWeek Str = formData.get("daysPerWeek" ); obj.daysPerWeek = daysPerWeek Str? parseFloat(daysPerWeek Str as string): 0; if(obj.daysPerWeek!== undefined && isNaN(obj.daysPerWeek as number))obj.daysPerWeek = 0;}{const rowHeight Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("rowHeight." )){const fieldName = key.slice("rowHeight." .length); const parts = fieldName.split("." ); let current = rowHeight Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.rowHeight = rowHeight Obj;}obj.visibleRoutes = formData.getAll("visibleRoutes" )as Array<string>;{const detailedCards Val = formData.get("detailedCards" ); obj.detailedCards = detailedCards Val === "true" || detailedCards Val === "on" || detailedCards Val === "1" ;}return scheduleSettingsDeserialize(obj);}

export const ScheduleSettings = {
  defaultValue: scheduleSettingsDefaultValue,
  serialize: scheduleSettingsSerialize,
  serializeWithContext: scheduleSettingsSerializeWithContext,
  deserialize: scheduleSettingsDeserialize,
  deserializeWithContext: scheduleSettingsDeserializeWithContext,
  validateFields: scheduleSettingsValidateFields,
  hasShape: scheduleSettingsHasShape,
  is: scheduleSettingsIs,
  createForm: scheduleSettingsCreateForm,
  fromFormData: scheduleSettingsFromFormData
} as const;


export interface DailyRecurrenceRule {
    quantityOfDays: number;
}

export function dailyRecurrenceRuleDefaultValue(): DailyRecurrenceRule {return {quantityOfDays: 0, }as DailyRecurrenceRule;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function dailyRecurrenceRuleSerialize(value: DailyRecurrenceRule): string {const ctx = SerializeContext.create(); return JSON.stringify(dailyRecurrenceRuleSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function dailyRecurrenceRuleSerializeWithContext(value: DailyRecurrenceRule, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "DailyRecurrenceRule" , __id,}; result["quantityOfDays" ]= value.quantityOfDays; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function dailyRecurrenceRuleDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: DailyRecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = dailyRecurrenceRuleDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "DailyRecurrenceRule.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function dailyRecurrenceRuleDeserializeWithContext(value: any, ctx: DeserializeContext): DailyRecurrenceRule | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "DailyRecurrenceRule.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("quantityOfDays" in obj)){errors.push({field: "quantityOfDays" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_quantityOfDays = obj["quantityOfDays" ]as number; instance.quantityOfDays = __raw_quantityOfDays; }if(errors.length>0){throw new DeserializeError(errors);}return instance as DailyRecurrenceRule;}export function dailyRecurrenceRuleValidateField<K extends keyof DailyRecurrenceRule>(field: K, value: DailyRecurrenceRule[K]): Array<{field: string; message: string}>{return[]; }export function dailyRecurrenceRuleValidateFields(partial: Partial<DailyRecurrenceRule>): Array<{field: string; message: string}>{return[]; }export function dailyRecurrenceRuleHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "quantityOfDays" in o;}export function dailyRecurrenceRuleIs(obj: unknown): obj is DailyRecurrenceRule {if(!dailyRecurrenceRuleHasShape(obj)){return false;}const result = dailyRecurrenceRuleDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type DailyRecurrenceRuleErrors = {_errors: Option<Array<string>>; quantityOfDays: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type DailyRecurrenceRuleTainted = {quantityOfDays: Option<boolean>; }; /** Type-safe field controllers for this form */export interface DailyRecurrenceRuleFieldControllers {readonly quantityOfDays: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface DailyRecurrenceRuleGigaform {readonly data: DailyRecurrenceRule; readonly errors: DailyRecurrenceRuleErrors; readonly tainted: DailyRecurrenceRuleTainted; readonly fields: DailyRecurrenceRuleFieldControllers; validate(): Result<DailyRecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<DailyRecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function dailyRecurrenceRuleCreateForm(overrides?: Partial<DailyRecurrenceRule>): DailyRecurrenceRuleGigaform {let data = $state({...dailyRecurrenceRuleDefaultValue(),...overrides}); let errors = $state<DailyRecurrenceRuleErrors>({_errors: Option.none(), quantityOfDays: Option.none(), }); let tainted = $state<DailyRecurrenceRuleTainted>({quantityOfDays: Option.none(), }); const fields: DailyRecurrenceRuleFieldControllers = {quantityOfDays: {path: ["quantityOfDays" ]as const, name: "quantityOfDays" , constraints: { required: true }, get: ()=>data.quantityOfDays, set: (value: number)=>{data.quantityOfDays = value;}, transform: (value: number): number =>value,getError: ()=>errors.quantityOfDays, setError: (value: Option<Array<string>>)=>{errors.quantityOfDays = value;}, getTainted: ()=>tainted.quantityOfDays, setTainted: (value: Option<boolean>)=>{tainted.quantityOfDays = value;}, validate: (): Array<string>=>{const fieldErrors = dailyRecurrenceRuleValidateField("quantityOfDays", data.quantityOfDays); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<DailyRecurrenceRule, Array<{field: string; message: string}>>{return dailyRecurrenceRuleDeserialize(data);}function reset(newOverrides?: Partial<DailyRecurrenceRule>): void {data = {...dailyRecurrenceRuleDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), quantityOfDays: Option.none(), }; tainted = {quantityOfDays: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function dailyRecurrenceRuleFromFormData(formData: FormData): Result<DailyRecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const quantityOfDays Str = formData.get("quantityOfDays" ); obj.quantityOfDays = quantityOfDays Str? parseFloat(quantityOfDays Str as string): 0; if(obj.quantityOfDays!== undefined && isNaN(obj.quantityOfDays as number))obj.quantityOfDays = 0;}return dailyRecurrenceRuleDeserialize(obj);}

export const DailyRecurrenceRule = {
  defaultValue: dailyRecurrenceRuleDefaultValue,
  serialize: dailyRecurrenceRuleSerialize,
  serializeWithContext: dailyRecurrenceRuleSerializeWithContext,
  deserialize: dailyRecurrenceRuleDeserialize,
  deserializeWithContext: dailyRecurrenceRuleDeserializeWithContext,
  validateFields: dailyRecurrenceRuleValidateFields,
  hasShape: dailyRecurrenceRuleHasShape,
  is: dailyRecurrenceRuleIs,
  createForm: dailyRecurrenceRuleCreateForm,
  fromFormData: dailyRecurrenceRuleFromFormData
} as const;


export interface SignUpCredentials {
    firstName: FirstName;
    lastName: LastName;
    email: EmailParts;
    password: Password;
    rememberMe: boolean;
}

export function signUpCredentialsDefaultValue(): SignUpCredentials {return {firstName: firstNameDefaultValue(),
                            lastName: lastNameDefaultValue(),
                            email: emailPartsDefaultValue(),
                            password: passwordDefaultValue(),
                            rememberMe: false, }as SignUpCredentials;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function signUpCredentialsSerialize(value: SignUpCredentials): string {const ctx = SerializeContext.create(); return JSON.stringify(signUpCredentialsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function signUpCredentialsSerializeWithContext(value: SignUpCredentials, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "SignUpCredentials" , __id,}; result["firstName" ]= firstNameSerializeWithContext(value.firstName, ctx); result["lastName" ]= lastNameSerializeWithContext(value.lastName, ctx); result["email" ]= emailPartsSerializeWithContext(value.email, ctx); result["password" ]= passwordSerializeWithContext(value.password, ctx); result["rememberMe" ]= value.rememberMe; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function signUpCredentialsDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: SignUpCredentials } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = signUpCredentialsDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "SignUpCredentials.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function signUpCredentialsDeserializeWithContext(value: any, ctx: DeserializeContext): SignUpCredentials | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "SignUpCredentials.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("firstName" in obj)){errors.push({field: "firstName" , message: "missing required field" });}if(!("lastName" in obj)){errors.push({field: "lastName" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("password" in obj)){errors.push({field: "password" , message: "missing required field" });}if(!("rememberMe" in obj)){errors.push({field: "rememberMe" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_firstName = obj["firstName" ]as FirstName; {const __result = firstNameDeserializeWithContext(__raw_firstName, ctx); ctx.assignOrDefer(instance, "firstName" , __result);}}{const __raw_lastName = obj["lastName" ]as LastName; {const __result = lastNameDeserializeWithContext(__raw_lastName, ctx); ctx.assignOrDefer(instance, "lastName" , __result);}}{const __raw_email = obj["email" ]as EmailParts; {const __result = emailPartsDeserializeWithContext(__raw_email, ctx); ctx.assignOrDefer(instance, "email" , __result);}}{const __raw_password = obj["password" ]as Password; {const __result = passwordDeserializeWithContext(__raw_password, ctx); ctx.assignOrDefer(instance, "password" , __result);}}{const __raw_rememberMe = obj["rememberMe" ]as boolean; instance.rememberMe = __raw_rememberMe; }if(errors.length>0){throw new DeserializeError(errors);}return instance as SignUpCredentials;}export function signUpCredentialsValidateField<K extends keyof SignUpCredentials>(field: K, value: SignUpCredentials[K]): Array<{field: string; message: string}>{return[]; }export function signUpCredentialsValidateFields(partial: Partial<SignUpCredentials>): Array<{field: string; message: string}>{return[]; }export function signUpCredentialsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "firstName" in o && "lastName" in o && "email" in o && "password" in o && "rememberMe" in o;}export function signUpCredentialsIs(obj: unknown): obj is SignUpCredentials {if(!signUpCredentialsHasShape(obj)){return false;}const result = signUpCredentialsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type SignUpCredentialsErrors = {_errors: Option<Array<string>>; firstName: Option<Array<string>>; lastName: Option<Array<string>>; email: Option<Array<string>>; password: Option<Array<string>>; rememberMe: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type SignUpCredentialsTainted = {firstName: Option<boolean>; lastName: Option<boolean>; email: Option<boolean>; password: Option<boolean>; rememberMe: Option<boolean>; }; /** Type-safe field controllers for this form */export interface SignUpCredentialsFieldControllers {readonly firstName: FieldController<FirstName>; readonly lastName: FieldController<LastName>; readonly email: FieldController<EmailParts>; readonly password: FieldController<Password>; readonly rememberMe: FieldController<boolean>; }/** Gigaform instance containing reactive state and field controllers */export interface SignUpCredentialsGigaform {readonly data: SignUpCredentials; readonly errors: SignUpCredentialsErrors; readonly tainted: SignUpCredentialsTainted; readonly fields: SignUpCredentialsFieldControllers; validate(): Result<SignUpCredentials, Array<{field: string; message: string}>>; reset(overrides?: Partial<SignUpCredentials>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function signUpCredentialsCreateForm(overrides?: Partial<SignUpCredentials>): SignUpCredentialsGigaform {let data = $state({...signUpCredentialsDefaultValue(),...overrides}); let errors = $state<SignUpCredentialsErrors>({_errors: Option.none(), firstName: Option.none(), lastName: Option.none(), email: Option.none(), password: Option.none(), rememberMe: Option.none(), }); let tainted = $state<SignUpCredentialsTainted>({firstName: Option.none(), lastName: Option.none(), email: Option.none(), password: Option.none(), rememberMe: Option.none(), }); const fields: SignUpCredentialsFieldControllers = {firstName: {path: ["firstName" ]as const, name: "firstName" , constraints: { required: true }, get: ()=>data.firstName, set: (value: FirstName)=>{data.firstName = value;}, transform: (value: FirstName): FirstName =>value,getError: ()=>errors.firstName, setError: (value: Option<Array<string>>)=>{errors.firstName = value;}, getTainted: ()=>tainted.firstName, setTainted: (value: Option<boolean>)=>{tainted.firstName = value;}, validate: (): Array<string>=>{const fieldErrors = signUpCredentialsValidateField("firstName", data.firstName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},lastName: {path: ["lastName" ]as const, name: "lastName" , constraints: { required: true }, get: ()=>data.lastName, set: (value: LastName)=>{data.lastName = value;}, transform: (value: LastName): LastName =>value,getError: ()=>errors.lastName, setError: (value: Option<Array<string>>)=>{errors.lastName = value;}, getTainted: ()=>tainted.lastName, setTainted: (value: Option<boolean>)=>{tainted.lastName = value;}, validate: (): Array<string>=>{const fieldErrors = signUpCredentialsValidateField("lastName", data.lastName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},email: {path: ["email" ]as const, name: "email" , constraints: { required: true }, get: ()=>data.email, set: (value: EmailParts)=>{data.email = value;}, transform: (value: EmailParts): EmailParts =>value,getError: ()=>errors.email, setError: (value: Option<Array<string>>)=>{errors.email = value;}, getTainted: ()=>tainted.email, setTainted: (value: Option<boolean>)=>{tainted.email = value;}, validate: (): Array<string>=>{const fieldErrors = signUpCredentialsValidateField("email", data.email); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},password: {path: ["password" ]as const, name: "password" , constraints: { required: true }, get: ()=>data.password, set: (value: Password)=>{data.password = value;}, transform: (value: Password): Password =>value,getError: ()=>errors.password, setError: (value: Option<Array<string>>)=>{errors.password = value;}, getTainted: ()=>tainted.password, setTainted: (value: Option<boolean>)=>{tainted.password = value;}, validate: (): Array<string>=>{const fieldErrors = signUpCredentialsValidateField("password", data.password); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},rememberMe: {path: ["rememberMe" ]as const, name: "rememberMe" , constraints: { required: true }, get: ()=>data.rememberMe, set: (value: boolean)=>{data.rememberMe = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.rememberMe, setError: (value: Option<Array<string>>)=>{errors.rememberMe = value;}, getTainted: ()=>tainted.rememberMe, setTainted: (value: Option<boolean>)=>{tainted.rememberMe = value;}, validate: (): Array<string>=>{const fieldErrors = signUpCredentialsValidateField("rememberMe", data.rememberMe); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<SignUpCredentials, Array<{field: string; message: string}>>{return signUpCredentialsDeserialize(data);}function reset(newOverrides?: Partial<SignUpCredentials>): void {data = {...signUpCredentialsDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), firstName: Option.none(), lastName: Option.none(), email: Option.none(), password: Option.none(), rememberMe: Option.none(), }; tainted = {firstName: Option.none(), lastName: Option.none(), email: Option.none(), password: Option.none(), rememberMe: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function signUpCredentialsFromFormData(formData: FormData): Result<SignUpCredentials, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const firstName Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("firstName." )){const fieldName = key.slice("firstName." .length); const parts = fieldName.split("." ); let current = firstName Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.firstName = firstName Obj;}{const lastName Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("lastName." )){const fieldName = key.slice("lastName." .length); const parts = fieldName.split("." ); let current = lastName Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.lastName = lastName Obj;}{const email Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("email." )){const fieldName = key.slice("email." .length); const parts = fieldName.split("." ); let current = email Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.email = email Obj;}{const password Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("password." )){const fieldName = key.slice("password." .length); const parts = fieldName.split("." ); let current = password Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.password = password Obj;}{const rememberMe Val = formData.get("rememberMe" ); obj.rememberMe = rememberMe Val === "true" || rememberMe Val === "on" || rememberMe Val === "1" ;}return signUpCredentialsDeserialize(obj);}

export const SignUpCredentials = {
  defaultValue: signUpCredentialsDefaultValue,
  serialize: signUpCredentialsSerialize,
  serializeWithContext: signUpCredentialsSerializeWithContext,
  deserialize: signUpCredentialsDeserialize,
  deserializeWithContext: signUpCredentialsDeserializeWithContext,
  validateFields: signUpCredentialsValidateFields,
  hasShape: signUpCredentialsHasShape,
  is: signUpCredentialsIs,
  createForm: signUpCredentialsCreateForm,
  fromFormData: signUpCredentialsFromFormData
} as const;


export interface OverviewSettings {
    
    rowHeight: RowHeight;
    
    cardOrRow: OverviewDisplay;
    perPage: number;
    columnConfigs: ColumnConfig[];
}

export function overviewSettingsDefaultValue(): OverviewSettings {return {rowHeight: "Medium",
                            cardOrRow: "Table",
                            perPage: 0,
                            columnConfigs: [], }as OverviewSettings;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function overviewSettingsSerialize(value: OverviewSettings): string {const ctx = SerializeContext.create(); return JSON.stringify(overviewSettingsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function overviewSettingsSerializeWithContext(value: OverviewSettings, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "OverviewSettings" , __id,}; result["rowHeight" ]= rowHeightSerializeWithContext(value.rowHeight, ctx); result["cardOrRow" ]= overviewDisplaySerializeWithContext(value.cardOrRow, ctx); result["perPage" ]= value.perPage; result["columnConfigs" ]= value.columnConfigs.map((item)=>columnConfigSerializeWithContext(item, ctx)); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function overviewSettingsDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: OverviewSettings } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = overviewSettingsDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "OverviewSettings.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function overviewSettingsDeserializeWithContext(value: any, ctx: DeserializeContext): OverviewSettings | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "OverviewSettings.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("rowHeight" in obj)){errors.push({field: "rowHeight" , message: "missing required field" });}if(!("cardOrRow" in obj)){errors.push({field: "cardOrRow" , message: "missing required field" });}if(!("perPage" in obj)){errors.push({field: "perPage" , message: "missing required field" });}if(!("columnConfigs" in obj)){errors.push({field: "columnConfigs" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_rowHeight = obj["rowHeight" ]as RowHeight; {const __result = rowHeightDeserializeWithContext(__raw_rowHeight, ctx); ctx.assignOrDefer(instance, "rowHeight" , __result);}}{const __raw_cardOrRow = obj["cardOrRow" ]as OverviewDisplay; {const __result = overviewDisplayDeserializeWithContext(__raw_cardOrRow, ctx); ctx.assignOrDefer(instance, "cardOrRow" , __result);}}{const __raw_perPage = obj["perPage" ]as number; instance.perPage = __raw_perPage; }{const __raw_columnConfigs = obj["columnConfigs" ]as ColumnConfig[]; if(Array.isArray(__raw_columnConfigs)){instance.columnConfigs = __raw_columnConfigs as ColumnConfig[];}}if(errors.length>0){throw new DeserializeError(errors);}return instance as OverviewSettings;}export function overviewSettingsValidateField<K extends keyof OverviewSettings>(field: K, value: OverviewSettings[K]): Array<{field: string; message: string}>{return[]; }export function overviewSettingsValidateFields(partial: Partial<OverviewSettings>): Array<{field: string; message: string}>{return[]; }export function overviewSettingsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "rowHeight" in o && "cardOrRow" in o && "perPage" in o && "columnConfigs" in o;}export function overviewSettingsIs(obj: unknown): obj is OverviewSettings {if(!overviewSettingsHasShape(obj)){return false;}const result = overviewSettingsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type OverviewSettingsErrors = {_errors: Option<Array<string>>; rowHeight: Option<Array<string>>; cardOrRow: Option<Array<string>>; perPage: Option<Array<string>>; columnConfigs: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type OverviewSettingsTainted = {rowHeight: Option<boolean>; cardOrRow: Option<boolean>; perPage: Option<boolean>; columnConfigs: Option<boolean>; }; /** Type-safe field controllers for this form */export interface OverviewSettingsFieldControllers {readonly rowHeight: FieldController<RowHeight>; readonly cardOrRow: FieldController<OverviewDisplay>; readonly perPage: FieldController<number>; readonly columnConfigs: ArrayFieldController<ColumnConfig>; }/** Gigaform instance containing reactive state and field controllers */export interface OverviewSettingsGigaform {readonly data: OverviewSettings; readonly errors: OverviewSettingsErrors; readonly tainted: OverviewSettingsTainted; readonly fields: OverviewSettingsFieldControllers; validate(): Result<OverviewSettings, Array<{field: string; message: string}>>; reset(overrides?: Partial<OverviewSettings>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function overviewSettingsCreateForm(overrides?: Partial<OverviewSettings>): OverviewSettingsGigaform {let data = $state({...overviewSettingsDefaultValue(),...overrides}); let errors = $state<OverviewSettingsErrors>({_errors: Option.none(), rowHeight: Option.none(), cardOrRow: Option.none(), perPage: Option.none(), columnConfigs: Option.none(), }); let tainted = $state<OverviewSettingsTainted>({rowHeight: Option.none(), cardOrRow: Option.none(), perPage: Option.none(), columnConfigs: Option.none(), }); const fields: OverviewSettingsFieldControllers = {rowHeight: {path: ["rowHeight" ]as const, name: "rowHeight" , constraints: { required: true }, get: ()=>data.rowHeight, set: (value: RowHeight)=>{data.rowHeight = value;}, transform: (value: RowHeight): RowHeight =>value,getError: ()=>errors.rowHeight, setError: (value: Option<Array<string>>)=>{errors.rowHeight = value;}, getTainted: ()=>tainted.rowHeight, setTainted: (value: Option<boolean>)=>{tainted.rowHeight = value;}, validate: (): Array<string>=>{const fieldErrors = overviewSettingsValidateField("rowHeight", data.rowHeight); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},cardOrRow: {path: ["cardOrRow" ]as const, name: "cardOrRow" , constraints: { required: true }, get: ()=>data.cardOrRow, set: (value: OverviewDisplay)=>{data.cardOrRow = value;}, transform: (value: OverviewDisplay): OverviewDisplay =>value,getError: ()=>errors.cardOrRow, setError: (value: Option<Array<string>>)=>{errors.cardOrRow = value;}, getTainted: ()=>tainted.cardOrRow, setTainted: (value: Option<boolean>)=>{tainted.cardOrRow = value;}, validate: (): Array<string>=>{const fieldErrors = overviewSettingsValidateField("cardOrRow", data.cardOrRow); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},perPage: {path: ["perPage" ]as const, name: "perPage" , constraints: { required: true }, get: ()=>data.perPage, set: (value: number)=>{data.perPage = value;}, transform: (value: number): number =>value,getError: ()=>errors.perPage, setError: (value: Option<Array<string>>)=>{errors.perPage = value;}, getTainted: ()=>tainted.perPage, setTainted: (value: Option<boolean>)=>{tainted.perPage = value;}, validate: (): Array<string>=>{const fieldErrors = overviewSettingsValidateField("perPage", data.perPage); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},columnConfigs: {path: ["columnConfigs" ]as const, name: "columnConfigs" , constraints: { required: true }, get: ()=>data.columnConfigs, set: (value: ColumnConfig[])=>{data.columnConfigs = value;}, transform: (value: ColumnConfig[]): ColumnConfig[] =>value,getError: ()=>errors.columnConfigs, setError: (value: Option<Array<string>>)=>{errors.columnConfigs = value;}, getTainted: ()=>tainted.columnConfigs, setTainted: (value: Option<boolean>)=>{tainted.columnConfigs = value;}, validate: (): Array<string>=>{const fieldErrors = overviewSettingsValidateField("columnConfigs", data.columnConfigs); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["columnConfigs" , index]as const, name: `columnConfigs.${index}` , constraints: {required: true}, get: ()=>data.columnConfigs[index]!, set: (value: ColumnConfig)=>{data.columnConfigs[index]= value;}, transform: (value: ColumnConfig): ColumnConfig =>value, getError: ()=>errors.columnConfigs, setError: (value: Option<Array<string>>)=>{errors.columnConfigs = value;}, getTainted: ()=>tainted.columnConfigs, setTainted: (value: Option<boolean>)=>{tainted.columnConfigs = value;}, validate: (): Array<string>=>[],}), push: (item: ColumnConfig)=>{data.columnConfigs.push(item);}, remove: (index: number)=>{data.columnConfigs.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.columnConfigs[a]!; data.columnConfigs[a]= data.columnConfigs[b]!; data.columnConfigs[b]= tmp;},},}; function validate(): Result<OverviewSettings, Array<{field: string; message: string}>>{return overviewSettingsDeserialize(data);}function reset(newOverrides?: Partial<OverviewSettings>): void {data = {...overviewSettingsDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), rowHeight: Option.none(), cardOrRow: Option.none(), perPage: Option.none(), columnConfigs: Option.none(), }; tainted = {rowHeight: Option.none(), cardOrRow: Option.none(), perPage: Option.none(), columnConfigs: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function overviewSettingsFromFormData(formData: FormData): Result<OverviewSettings, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const rowHeight Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("rowHeight." )){const fieldName = key.slice("rowHeight." .length); const parts = fieldName.split("." ); let current = rowHeight Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.rowHeight = rowHeight Obj;}{const cardOrRow Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("cardOrRow." )){const fieldName = key.slice("cardOrRow." .length); const parts = fieldName.split("." ); let current = cardOrRow Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.cardOrRow = cardOrRow Obj;}{const perPage Str = formData.get("perPage" ); obj.perPage = perPage Str? parseFloat(perPage Str as string): 0; if(obj.perPage!== undefined && isNaN(obj.perPage as number))obj.perPage = 0;}{const columnConfigs Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("columnConfigs." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("columnConfigs." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("columnConfigs." + idx + "." )){const fieldName = key.slice("columnConfigs." .length + String(idx).length + 1); item[fieldName]= value;}}columnConfigs Items.push(item);}idx ++; if(idx>1000)break;}obj.columnConfigs = columnConfigs Items;}return overviewSettingsDeserialize(obj);}

export const OverviewSettings = {
  defaultValue: overviewSettingsDefaultValue,
  serialize: overviewSettingsSerialize,
  serializeWithContext: overviewSettingsSerializeWithContext,
  deserialize: overviewSettingsDeserialize,
  deserializeWithContext: overviewSettingsDeserializeWithContext,
  validateFields: overviewSettingsValidateFields,
  hasShape: overviewSettingsHasShape,
  is: overviewSettingsIs,
  createForm: overviewSettingsCreateForm,
  fromFormData: overviewSettingsFromFormData
} as const;


export interface FirstName {
    
    name: string;
}

export function firstNameDefaultValue(): FirstName {return {name: "", }as FirstName;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function firstNameSerialize(value: FirstName): string {const ctx = SerializeContext.create(); return JSON.stringify(firstNameSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function firstNameSerializeWithContext(value: FirstName, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "FirstName" , __id,}; result["name" ]= value.name; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function firstNameDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: FirstName } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = firstNameDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "FirstName.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function firstNameDeserializeWithContext(value: any, ctx: DeserializeContext): FirstName | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "FirstName.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }if(errors.length>0){throw new DeserializeError(errors);}return instance as FirstName;}export function firstNameValidateField<K extends keyof FirstName>(field: K, value: FirstName[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}}return errors; }export function firstNameValidateFields(partial: Partial<FirstName>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}return errors; }export function firstNameHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "name" in o;}export function firstNameIs(obj: unknown): obj is FirstName {if(!firstNameHasShape(obj)){return false;}const result = firstNameDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type FirstNameErrors = {_errors: Option<Array<string>>; name: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type FirstNameTainted = {name: Option<boolean>; }; /** Type-safe field controllers for this form */export interface FirstNameFieldControllers {readonly name: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface FirstNameGigaform {readonly data: FirstName; readonly errors: FirstNameErrors; readonly tainted: FirstNameTainted; readonly fields: FirstNameFieldControllers; validate(): Result<FirstName, Array<{field: string; message: string}>>; reset(overrides?: Partial<FirstName>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function firstNameCreateForm(overrides?: Partial<FirstName>): FirstNameGigaform {let data = $state({...firstNameDefaultValue(),...overrides}); let errors = $state<FirstNameErrors>({_errors: Option.none(), name: Option.none(), }); let tainted = $state<FirstNameTainted>({name: Option.none(), }); const fields: FirstNameFieldControllers = {name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = firstNameValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<FirstName, Array<{field: string; message: string}>>{return firstNameDeserialize(data);}function reset(newOverrides?: Partial<FirstName>): void {data = {...firstNameDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), name: Option.none(), }; tainted = {name: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function firstNameFromFormData(formData: FormData): Result<FirstName, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.name = formData.get("name" )?? "" ;return firstNameDeserialize(obj);}

export const FirstName = {
  defaultValue: firstNameDefaultValue,
  serialize: firstNameSerialize,
  serializeWithContext: firstNameSerializeWithContext,
  deserialize: firstNameDeserialize,
  deserializeWithContext: firstNameDeserializeWithContext,
  validateFields: firstNameValidateFields,
  hasShape: firstNameHasShape,
  is: firstNameIs,
  createForm: firstNameCreateForm,
  fromFormData: firstNameFromFormData
} as const;


export interface Account {
    
    id: string;
    
    
    taxRate: string | TaxRate;
    
    
    site: string | Site;
    
    salesRep: Represents[] | null;
    
    orders: Ordered[];
    
    activity: Did[];
    
    customFields: [string, string][];
    
    accountName: AccountName;
    
    
    sector: Sector;
    
    memo: string | null;
    
    phones: PhoneNumber[];
    
    email: Email;
    
    
    leadSource: string;
    
    colors: Colors;
    
    needsReview: boolean;
    
    hasAlert: boolean;
    
    
    accountType: string;
    
    
    subtype: string;
    
    isTaxExempt: boolean;
    
    
    paymentTerms: string;
    
    tags: string[];
    
    dateAdded: string;
}

export function accountDefaultValue(): Account {return {id: "",
                            taxRate: "",
                            site: "",
                            salesRep: null,
                            orders: [],
                            activity: [],
                            customFields: [],
                            accountName: accountNameDefaultValue(),
                            sector: "Residential",
                            memo: null,
                            phones: [],
                            email: emailDefaultValue(),
                            leadSource: "",
                            colors: colorsDefaultValue(),
                            needsReview: false,
                            hasAlert: false,
                            accountType: "",
                            subtype: "",
                            isTaxExempt: false,
                            paymentTerms: "",
                            tags: [],
                            dateAdded: "", }as Account;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function accountSerialize(value: Account): string {const ctx = SerializeContext.create(); return JSON.stringify(accountSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function accountSerializeWithContext(value: Account, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Account" , __id,}; result["id" ]= value.id; result["taxRate" ]= value.taxRate; result["site" ]= value.site; if(value.salesRep!== null){result["salesRep" ]= value.salesRep; }else {result["salesRep" ]= null;}result["orders" ]= value.orders.map((item)=>orderedSerializeWithContext(item, ctx)); result["activity" ]= value.activity.map((item)=>didSerializeWithContext(item, ctx)); result["customFields" ]= value.customFields; result["accountName" ]= accountNameSerializeWithContext(value.accountName, ctx); result["sector" ]= sectorSerializeWithContext(value.sector, ctx); result["memo" ]= value.memo; result["phones" ]= value.phones.map((item)=>phoneNumberSerializeWithContext(item, ctx)); result["email" ]= emailSerializeWithContext(value.email, ctx); result["leadSource" ]= value.leadSource; result["colors" ]= colorsSerializeWithContext(value.colors, ctx); result["needsReview" ]= value.needsReview; result["hasAlert" ]= value.hasAlert; result["accountType" ]= value.accountType; result["subtype" ]= value.subtype; result["isTaxExempt" ]= value.isTaxExempt; result["paymentTerms" ]= value.paymentTerms; result["tags" ]= value.tags; result["dateAdded" ]= value.dateAdded; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function accountDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Account } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = accountDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Account.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function accountDeserializeWithContext(value: any, ctx: DeserializeContext): Account | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Account.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("taxRate" in obj)){errors.push({field: "taxRate" , message: "missing required field" });}if(!("site" in obj)){errors.push({field: "site" , message: "missing required field" });}if(!("salesRep" in obj)){errors.push({field: "salesRep" , message: "missing required field" });}if(!("orders" in obj)){errors.push({field: "orders" , message: "missing required field" });}if(!("activity" in obj)){errors.push({field: "activity" , message: "missing required field" });}if(!("customFields" in obj)){errors.push({field: "customFields" , message: "missing required field" });}if(!("accountName" in obj)){errors.push({field: "accountName" , message: "missing required field" });}if(!("sector" in obj)){errors.push({field: "sector" , message: "missing required field" });}if(!("memo" in obj)){errors.push({field: "memo" , message: "missing required field" });}if(!("phones" in obj)){errors.push({field: "phones" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("leadSource" in obj)){errors.push({field: "leadSource" , message: "missing required field" });}if(!("colors" in obj)){errors.push({field: "colors" , message: "missing required field" });}if(!("needsReview" in obj)){errors.push({field: "needsReview" , message: "missing required field" });}if(!("hasAlert" in obj)){errors.push({field: "hasAlert" , message: "missing required field" });}if(!("accountType" in obj)){errors.push({field: "accountType" , message: "missing required field" });}if(!("subtype" in obj)){errors.push({field: "subtype" , message: "missing required field" });}if(!("isTaxExempt" in obj)){errors.push({field: "isTaxExempt" , message: "missing required field" });}if(!("paymentTerms" in obj)){errors.push({field: "paymentTerms" , message: "missing required field" });}if(!("tags" in obj)){errors.push({field: "tags" , message: "missing required field" });}if(!("dateAdded" in obj)){errors.push({field: "dateAdded" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_taxRate = obj["taxRate" ]as string | TaxRate; instance.taxRate = __raw_taxRate; }{const __raw_site = obj["site" ]as string | Site; instance.site = __raw_site; }{const __raw_salesRep = obj["salesRep" ]as Represents[] | null; if(__raw_salesRep === null){instance.salesRep = null;}else {instance.salesRep = __raw_salesRep; }}{const __raw_orders = obj["orders" ]as Ordered[]; if(Array.isArray(__raw_orders)){instance.orders = __raw_orders as Ordered[];}}{const __raw_activity = obj["activity" ]as Did[]; if(Array.isArray(__raw_activity)){instance.activity = __raw_activity as Did[];}}{const __raw_customFields = obj["customFields" ]as [string, string][]; if(Array.isArray(__raw_customFields)){instance.customFields = __raw_customFields as [string, string][];}}{const __raw_accountName = obj["accountName" ]as AccountName; {const __result = accountNameDeserializeWithContext(__raw_accountName, ctx); ctx.assignOrDefer(instance, "accountName" , __result);}}{const __raw_sector = obj["sector" ]as Sector; {const __result = sectorDeserializeWithContext(__raw_sector, ctx); ctx.assignOrDefer(instance, "sector" , __result);}}{const __raw_memo = obj["memo" ]as string | null; instance.memo = __raw_memo; }{const __raw_phones = obj["phones" ]as PhoneNumber[]; if(Array.isArray(__raw_phones)){instance.phones = __raw_phones as PhoneNumber[];}}{const __raw_email = obj["email" ]as Email; {const __result = emailDeserializeWithContext(__raw_email, ctx); ctx.assignOrDefer(instance, "email" , __result);}}{const __raw_leadSource = obj["leadSource" ]as string; 
                if (__raw_leadSource.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
 instance.leadSource = __raw_leadSource; }{const __raw_colors = obj["colors" ]as Colors; {const __result = colorsDeserializeWithContext(__raw_colors, ctx); ctx.assignOrDefer(instance, "colors" , __result);}}{const __raw_needsReview = obj["needsReview" ]as boolean; instance.needsReview = __raw_needsReview; }{const __raw_hasAlert = obj["hasAlert" ]as boolean; instance.hasAlert = __raw_hasAlert; }{const __raw_accountType = obj["accountType" ]as string; 
                if (__raw_accountType.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
 instance.accountType = __raw_accountType; }{const __raw_subtype = obj["subtype" ]as string; 
                if (__raw_subtype.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
 instance.subtype = __raw_subtype; }{const __raw_isTaxExempt = obj["isTaxExempt" ]as boolean; instance.isTaxExempt = __raw_isTaxExempt; }{const __raw_paymentTerms = obj["paymentTerms" ]as string; 
                if (__raw_paymentTerms.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
 instance.paymentTerms = __raw_paymentTerms; }{const __raw_tags = obj["tags" ]as string[]; if(Array.isArray(__raw_tags)){instance.tags = __raw_tags as string[];}}{const __raw_dateAdded = obj["dateAdded" ]as string; instance.dateAdded = __raw_dateAdded; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Account;}export function accountValidateField<K extends keyof Account>(field: K, value: Account[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "leadSource" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
 break;}case "accountType" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
 break;}case "subtype" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
 break;}case "paymentTerms" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
 break;}}return errors; }export function accountValidateFields(partial: Partial<Account>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("leadSource" in partial && partial.leadSource!== undefined){const __val = partial.leadSource as string; 
                if (__val.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
}if("accountType" in partial && partial.accountType!== undefined){const __val = partial.accountType as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
}if("subtype" in partial && partial.subtype!== undefined){const __val = partial.subtype as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
}if("paymentTerms" in partial && partial.paymentTerms!== undefined){const __val = partial.paymentTerms as string; 
                if (__val.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
}return errors; }export function accountHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "taxRate" in o && "site" in o && "salesRep" in o && "orders" in o && "activity" in o && "customFields" in o && "accountName" in o && "sector" in o && "memo" in o && "phones" in o && "email" in o && "leadSource" in o && "colors" in o && "needsReview" in o && "hasAlert" in o && "accountType" in o && "subtype" in o && "isTaxExempt" in o && "paymentTerms" in o && "tags" in o && "dateAdded" in o;}export function accountIs(obj: unknown): obj is Account {if(!accountHasShape(obj)){return false;}const result = accountDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type AccountErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; taxRate: Option<Array<string>>; site: Option<Array<string>>; salesRep: Option<Array<string>>; orders: Option<Array<string>>; activity: Option<Array<string>>; customFields: Option<Array<string>>; accountName: Option<Array<string>>; sector: Option<Array<string>>; memo: Option<Array<string>>; phones: Option<Array<string>>; email: Option<Array<string>>; leadSource: Option<Array<string>>; colors: Option<Array<string>>; needsReview: Option<Array<string>>; hasAlert: Option<Array<string>>; accountType: Option<Array<string>>; subtype: Option<Array<string>>; isTaxExempt: Option<Array<string>>; paymentTerms: Option<Array<string>>; tags: Option<Array<string>>; dateAdded: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type AccountTainted = {id: Option<boolean>; taxRate: Option<boolean>; site: Option<boolean>; salesRep: Option<boolean>; orders: Option<boolean>; activity: Option<boolean>; customFields: Option<boolean>; accountName: Option<boolean>; sector: Option<boolean>; memo: Option<boolean>; phones: Option<boolean>; email: Option<boolean>; leadSource: Option<boolean>; colors: Option<boolean>; needsReview: Option<boolean>; hasAlert: Option<boolean>; accountType: Option<boolean>; subtype: Option<boolean>; isTaxExempt: Option<boolean>; paymentTerms: Option<boolean>; tags: Option<boolean>; dateAdded: Option<boolean>; }; /** Type-safe field controllers for this form */export interface AccountFieldControllers {readonly id: FieldController<string>; readonly taxRate: FieldController<string | TaxRate>; readonly site: FieldController<string | Site>; readonly salesRep: FieldController<Represents[] | null>; readonly orders: ArrayFieldController<Ordered>; readonly activity: ArrayFieldController<Did>; readonly customFields: ArrayFieldController<[string, string]>; readonly accountName: FieldController<AccountName>; readonly sector: FieldController<Sector>; readonly memo: FieldController<string | null>; readonly phones: ArrayFieldController<PhoneNumber>; readonly email: FieldController<Email>; readonly leadSource: FieldController<string>; readonly colors: FieldController<Colors>; readonly needsReview: FieldController<boolean>; readonly hasAlert: FieldController<boolean>; readonly accountType: FieldController<string>; readonly subtype: FieldController<string>; readonly isTaxExempt: FieldController<boolean>; readonly paymentTerms: FieldController<string>; readonly tags: ArrayFieldController<string>; readonly dateAdded: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface AccountGigaform {readonly data: Account; readonly errors: AccountErrors; readonly tainted: AccountTainted; readonly fields: AccountFieldControllers; validate(): Result<Account, Array<{field: string; message: string}>>; reset(overrides?: Partial<Account>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function accountCreateForm(overrides?: Partial<Account>): AccountGigaform {let data = $state({...accountDefaultValue(),...overrides}); let errors = $state<AccountErrors>({_errors: Option.none(), id: Option.none(), taxRate: Option.none(), site: Option.none(), salesRep: Option.none(), orders: Option.none(), activity: Option.none(), customFields: Option.none(), accountName: Option.none(), sector: Option.none(), memo: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), colors: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), dateAdded: Option.none(), }); let tainted = $state<AccountTainted>({id: Option.none(), taxRate: Option.none(), site: Option.none(), salesRep: Option.none(), orders: Option.none(), activity: Option.none(), customFields: Option.none(), accountName: Option.none(), sector: Option.none(), memo: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), colors: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), dateAdded: Option.none(), }); const fields: AccountFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},taxRate: {path: ["taxRate" ]as const, name: "taxRate" , constraints: { required: true }, label: "Tax Rate" , get: ()=>data.taxRate, set: (value: string | TaxRate)=>{data.taxRate = value;}, transform: (value: string | TaxRate): string | TaxRate =>value,getError: ()=>errors.taxRate, setError: (value: Option<Array<string>>)=>{errors.taxRate = value;}, getTainted: ()=>tainted.taxRate, setTainted: (value: Option<boolean>)=>{tainted.taxRate = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("taxRate", data.taxRate); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},site: {path: ["site" ]as const, name: "site" , constraints: { required: true }, label: "Site" , get: ()=>data.site, set: (value: string | Site)=>{data.site = value;}, transform: (value: string | Site): string | Site =>value,getError: ()=>errors.site, setError: (value: Option<Array<string>>)=>{errors.site = value;}, getTainted: ()=>tainted.site, setTainted: (value: Option<boolean>)=>{tainted.site = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("site", data.site); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},salesRep: {path: ["salesRep" ]as const, name: "salesRep" , constraints: { required: true }, label: "Sales Rep" , get: ()=>data.salesRep, set: (value: Represents[] | null)=>{data.salesRep = value;}, transform: (value: Represents[] | null): Represents[] | null =>value,getError: ()=>errors.salesRep, setError: (value: Option<Array<string>>)=>{errors.salesRep = value;}, getTainted: ()=>tainted.salesRep, setTainted: (value: Option<boolean>)=>{tainted.salesRep = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("salesRep", data.salesRep); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},orders: {path: ["orders" ]as const, name: "orders" , constraints: { required: true }, get: ()=>data.orders, set: (value: Ordered[])=>{data.orders = value;}, transform: (value: Ordered[]): Ordered[] =>value,getError: ()=>errors.orders, setError: (value: Option<Array<string>>)=>{errors.orders = value;}, getTainted: ()=>tainted.orders, setTainted: (value: Option<boolean>)=>{tainted.orders = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("orders", data.orders); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["orders" , index]as const, name: `orders.${index}` , constraints: {required: true}, get: ()=>data.orders[index]!, set: (value: Ordered)=>{data.orders[index]= value;}, transform: (value: Ordered): Ordered =>value, getError: ()=>errors.orders, setError: (value: Option<Array<string>>)=>{errors.orders = value;}, getTainted: ()=>tainted.orders, setTainted: (value: Option<boolean>)=>{tainted.orders = value;}, validate: (): Array<string>=>[],}), push: (item: Ordered)=>{data.orders.push(item);}, remove: (index: number)=>{data.orders.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.orders[a]!; data.orders[a]= data.orders[b]!; data.orders[b]= tmp;},},activity: {path: ["activity" ]as const, name: "activity" , constraints: { required: true }, get: ()=>data.activity, set: (value: Did[])=>{data.activity = value;}, transform: (value: Did[]): Did[] =>value,getError: ()=>errors.activity, setError: (value: Option<Array<string>>)=>{errors.activity = value;}, getTainted: ()=>tainted.activity, setTainted: (value: Option<boolean>)=>{tainted.activity = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("activity", data.activity); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["activity" , index]as const, name: `activity.${index}` , constraints: {required: true}, get: ()=>data.activity[index]!, set: (value: Did)=>{data.activity[index]= value;}, transform: (value: Did): Did =>value, getError: ()=>errors.activity, setError: (value: Option<Array<string>>)=>{errors.activity = value;}, getTainted: ()=>tainted.activity, setTainted: (value: Option<boolean>)=>{tainted.activity = value;}, validate: (): Array<string>=>[],}), push: (item: Did)=>{data.activity.push(item);}, remove: (index: number)=>{data.activity.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.activity[a]!; data.activity[a]= data.activity[b]!; data.activity[b]= tmp;},},customFields: {path: ["customFields" ]as const, name: "customFields" , constraints: { required: true }, get: ()=>data.customFields, set: (value: [string, string][])=>{data.customFields = value;}, transform: (value: [string, string][]): [string, string][] =>value,getError: ()=>errors.customFields, setError: (value: Option<Array<string>>)=>{errors.customFields = value;}, getTainted: ()=>tainted.customFields, setTainted: (value: Option<boolean>)=>{tainted.customFields = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("customFields", data.customFields); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["customFields" , index]as const, name: `customFields.${index}` , constraints: {required: true}, get: ()=>data.customFields[index]!, set: (value: [string, string])=>{data.customFields[index]= value;}, transform: (value: [string, string]): [string, string] =>value, getError: ()=>errors.customFields, setError: (value: Option<Array<string>>)=>{errors.customFields = value;}, getTainted: ()=>tainted.customFields, setTainted: (value: Option<boolean>)=>{tainted.customFields = value;}, validate: (): Array<string>=>[],}), push: (item: [string, string])=>{data.customFields.push(item);}, remove: (index: number)=>{data.customFields.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.customFields[a]!; data.customFields[a]= data.customFields[b]!; data.customFields[b]= tmp;},},accountName: {path: ["accountName" ]as const, name: "accountName" , constraints: { required: true }, get: ()=>data.accountName, set: (value: AccountName)=>{data.accountName = value;}, transform: (value: AccountName): AccountName =>value,getError: ()=>errors.accountName, setError: (value: Option<Array<string>>)=>{errors.accountName = value;}, getTainted: ()=>tainted.accountName, setTainted: (value: Option<boolean>)=>{tainted.accountName = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("accountName", data.accountName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},sector: {path: ["sector" ]as const, name: "sector" , constraints: { required: true }, label: "Sector" , get: ()=>data.sector, set: (value: Sector)=>{data.sector = value;}, transform: (value: Sector): Sector =>value,getError: ()=>errors.sector, setError: (value: Option<Array<string>>)=>{errors.sector = value;}, getTainted: ()=>tainted.sector, setTainted: (value: Option<boolean>)=>{tainted.sector = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("sector", data.sector); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},memo: {path: ["memo" ]as const, name: "memo" , constraints: { required: true }, label: "Memo" , get: ()=>data.memo, set: (value: string | null)=>{data.memo = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.memo, setError: (value: Option<Array<string>>)=>{errors.memo = value;}, getTainted: ()=>tainted.memo, setTainted: (value: Option<boolean>)=>{tainted.memo = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("memo", data.memo); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},phones: {path: ["phones" ]as const, name: "phones" , constraints: { required: true }, get: ()=>data.phones, set: (value: PhoneNumber[])=>{data.phones = value;}, transform: (value: PhoneNumber[]): PhoneNumber[] =>value,getError: ()=>errors.phones, setError: (value: Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("phones", data.phones); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["phones" , index]as const, name: `phones.${index}` , constraints: {required: true}, get: ()=>data.phones[index]!, set: (value: PhoneNumber)=>{data.phones[index]= value;}, transform: (value: PhoneNumber): PhoneNumber =>value, getError: ()=>errors.phones, setError: (value: Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>[],}), push: (item: PhoneNumber)=>{data.phones.push(item);}, remove: (index: number)=>{data.phones.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.phones[a]!; data.phones[a]= data.phones[b]!; data.phones[b]= tmp;},},email: {path: ["email" ]as const, name: "email" , constraints: { required: true }, label: "Email" , get: ()=>data.email, set: (value: Email)=>{data.email = value;}, transform: (value: Email): Email =>value,getError: ()=>errors.email, setError: (value: Option<Array<string>>)=>{errors.email = value;}, getTainted: ()=>tainted.email, setTainted: (value: Option<boolean>)=>{tainted.email = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("email", data.email); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},leadSource: {path: ["leadSource" ]as const, name: "leadSource" , constraints: { required: true }, label: "Lead Source" , get: ()=>data.leadSource, set: (value: string)=>{data.leadSource = value;}, transform: (value: string): string =>value,getError: ()=>errors.leadSource, setError: (value: Option<Array<string>>)=>{errors.leadSource = value;}, getTainted: ()=>tainted.leadSource, setTainted: (value: Option<boolean>)=>{tainted.leadSource = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("leadSource", data.leadSource); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},colors: {path: ["colors" ]as const, name: "colors" , constraints: { required: true }, get: ()=>data.colors, set: (value: Colors)=>{data.colors = value;}, transform: (value: Colors): Colors =>value,getError: ()=>errors.colors, setError: (value: Option<Array<string>>)=>{errors.colors = value;}, getTainted: ()=>tainted.colors, setTainted: (value: Option<boolean>)=>{tainted.colors = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("colors", data.colors); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},needsReview: {path: ["needsReview" ]as const, name: "needsReview" , constraints: { required: true }, label: "Needs Review" , get: ()=>data.needsReview, set: (value: boolean)=>{data.needsReview = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.needsReview, setError: (value: Option<Array<string>>)=>{errors.needsReview = value;}, getTainted: ()=>tainted.needsReview, setTainted: (value: Option<boolean>)=>{tainted.needsReview = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("needsReview", data.needsReview); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasAlert: {path: ["hasAlert" ]as const, name: "hasAlert" , constraints: { required: true }, label: "Has Alert" , get: ()=>data.hasAlert, set: (value: boolean)=>{data.hasAlert = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasAlert, setError: (value: Option<Array<string>>)=>{errors.hasAlert = value;}, getTainted: ()=>tainted.hasAlert, setTainted: (value: Option<boolean>)=>{tainted.hasAlert = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("hasAlert", data.hasAlert); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},accountType: {path: ["accountType" ]as const, name: "accountType" , constraints: { required: true }, label: "Account Type" , get: ()=>data.accountType, set: (value: string)=>{data.accountType = value;}, transform: (value: string): string =>value,getError: ()=>errors.accountType, setError: (value: Option<Array<string>>)=>{errors.accountType = value;}, getTainted: ()=>tainted.accountType, setTainted: (value: Option<boolean>)=>{tainted.accountType = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("accountType", data.accountType); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},subtype: {path: ["subtype" ]as const, name: "subtype" , constraints: { required: true }, label: "Subtype" , get: ()=>data.subtype, set: (value: string)=>{data.subtype = value;}, transform: (value: string): string =>value,getError: ()=>errors.subtype, setError: (value: Option<Array<string>>)=>{errors.subtype = value;}, getTainted: ()=>tainted.subtype, setTainted: (value: Option<boolean>)=>{tainted.subtype = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("subtype", data.subtype); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},isTaxExempt: {path: ["isTaxExempt" ]as const, name: "isTaxExempt" , constraints: { required: true }, label: "Tax Exempt" , get: ()=>data.isTaxExempt, set: (value: boolean)=>{data.isTaxExempt = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.isTaxExempt, setError: (value: Option<Array<string>>)=>{errors.isTaxExempt = value;}, getTainted: ()=>tainted.isTaxExempt, setTainted: (value: Option<boolean>)=>{tainted.isTaxExempt = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("isTaxExempt", data.isTaxExempt); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},paymentTerms: {path: ["paymentTerms" ]as const, name: "paymentTerms" , constraints: { required: true }, label: "Payment Terms" , get: ()=>data.paymentTerms, set: (value: string)=>{data.paymentTerms = value;}, transform: (value: string): string =>value,getError: ()=>errors.paymentTerms, setError: (value: Option<Array<string>>)=>{errors.paymentTerms = value;}, getTainted: ()=>tainted.paymentTerms, setTainted: (value: Option<boolean>)=>{tainted.paymentTerms = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("paymentTerms", data.paymentTerms); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},tags: {path: ["tags" ]as const, name: "tags" , constraints: { required: true }, label: "Tags" , get: ()=>data.tags, set: (value: string[])=>{data.tags = value;}, transform: (value: string[]): string[] =>value,getError: ()=>errors.tags, setError: (value: Option<Array<string>>)=>{errors.tags = value;}, getTainted: ()=>tainted.tags, setTainted: (value: Option<boolean>)=>{tainted.tags = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("tags", data.tags); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["tags" , index]as const, name: `tags.${index}` , constraints: {required: true}, get: ()=>data.tags[index]!, set: (value: string)=>{data.tags[index]= value;}, transform: (value: string): string =>value, getError: ()=>errors.tags, setError: (value: Option<Array<string>>)=>{errors.tags = value;}, getTainted: ()=>tainted.tags, setTainted: (value: Option<boolean>)=>{tainted.tags = value;}, validate: (): Array<string>=>[],}), push: (item: string)=>{data.tags.push(item);}, remove: (index: number)=>{data.tags.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.tags[a]!; data.tags[a]= data.tags[b]!; data.tags[b]= tmp;},},dateAdded: {path: ["dateAdded" ]as const, name: "dateAdded" , constraints: { required: true }, get: ()=>data.dateAdded, set: (value: string)=>{data.dateAdded = value;}, transform: (value: string): string =>value,getError: ()=>errors.dateAdded, setError: (value: Option<Array<string>>)=>{errors.dateAdded = value;}, getTainted: ()=>tainted.dateAdded, setTainted: (value: Option<boolean>)=>{tainted.dateAdded = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("dateAdded", data.dateAdded); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Account, Array<{field: string; message: string}>>{return accountDeserialize(data);}function reset(newOverrides?: Partial<Account>): void {data = {...accountDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), taxRate: Option.none(), site: Option.none(), salesRep: Option.none(), orders: Option.none(), activity: Option.none(), customFields: Option.none(), accountName: Option.none(), sector: Option.none(), memo: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), colors: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), dateAdded: Option.none(), }; tainted = {id: Option.none(), taxRate: Option.none(), site: Option.none(), salesRep: Option.none(), orders: Option.none(), activity: Option.none(), customFields: Option.none(), accountName: Option.none(), sector: Option.none(), memo: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), colors: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), dateAdded: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function accountFromFormData(formData: FormData): Result<Account, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.taxRate = formData.get("taxRate" )?? "" ;obj.site = formData.get("site" )?? "" ;obj.salesRep = formData.get("salesRep" )?? "" ;{const orders Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("orders." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("orders." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("orders." + idx + "." )){const fieldName = key.slice("orders." .length + String(idx).length + 1); item[fieldName]= value;}}orders Items.push(item);}idx ++; if(idx>1000)break;}obj.orders = orders Items;}{const activity Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("activity." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("activity." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("activity." + idx + "." )){const fieldName = key.slice("activity." .length + String(idx).length + 1); item[fieldName]= value;}}activity Items.push(item);}idx ++; if(idx>1000)break;}obj.activity = activity Items;}{const customFields Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("customFields." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("customFields." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("customFields." + idx + "." )){const fieldName = key.slice("customFields." .length + String(idx).length + 1); item[fieldName]= value;}}customFields Items.push(item);}idx ++; if(idx>1000)break;}obj.customFields = customFields Items;}{const accountName Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("accountName." )){const fieldName = key.slice("accountName." .length); const parts = fieldName.split("." ); let current = accountName Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.accountName = accountName Obj;}{const sector Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("sector." )){const fieldName = key.slice("sector." .length); const parts = fieldName.split("." ); let current = sector Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.sector = sector Obj;}obj.memo = formData.get("memo" )?? "" ;{const phones Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("phones." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("phones." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("phones." + idx + "." )){const fieldName = key.slice("phones." .length + String(idx).length + 1); item[fieldName]= value;}}phones Items.push(item);}idx ++; if(idx>1000)break;}obj.phones = phones Items;}{const email Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("email." )){const fieldName = key.slice("email." .length); const parts = fieldName.split("." ); let current = email Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.email = email Obj;}obj.leadSource = formData.get("leadSource" )?? "" ;{const colors Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("colors." )){const fieldName = key.slice("colors." .length); const parts = fieldName.split("." ); let current = colors Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.colors = colors Obj;}{const needsReview Val = formData.get("needsReview" ); obj.needsReview = needsReview Val === "true" || needsReview Val === "on" || needsReview Val === "1" ;}{const hasAlert Val = formData.get("hasAlert" ); obj.hasAlert = hasAlert Val === "true" || hasAlert Val === "on" || hasAlert Val === "1" ;}obj.accountType = formData.get("accountType" )?? "" ;obj.subtype = formData.get("subtype" )?? "" ;{const isTaxExempt Val = formData.get("isTaxExempt" ); obj.isTaxExempt = isTaxExempt Val === "true" || isTaxExempt Val === "on" || isTaxExempt Val === "1" ;}obj.paymentTerms = formData.get("paymentTerms" )?? "" ;obj.tags = formData.getAll("tags" )as Array<string>;obj.dateAdded = formData.get("dateAdded" )?? "" ;return accountDeserialize(obj);}

export const Account = {
  defaultValue: accountDefaultValue,
  serialize: accountSerialize,
  serializeWithContext: accountSerializeWithContext,
  deserialize: accountDeserialize,
  deserializeWithContext: accountDeserializeWithContext,
  validateFields: accountValidateFields,
  hasShape: accountHasShape,
  is: accountIs,
  createForm: accountCreateForm,
  fromFormData: accountFromFormData
} as const;


export interface Edited {
    
    fieldName: string;
    oldValue: string | null;
    newValue: string | null;
}

export function editedDefaultValue(): Edited {return {fieldName: "",
                            oldValue: null,
                            newValue: null, }as Edited;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function editedSerialize(value: Edited): string {const ctx = SerializeContext.create(); return JSON.stringify(editedSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function editedSerializeWithContext(value: Edited, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Edited" , __id,}; result["fieldName" ]= value.fieldName; result["oldValue" ]= value.oldValue; result["newValue" ]= value.newValue; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function editedDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Edited } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = editedDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Edited.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function editedDeserializeWithContext(value: any, ctx: DeserializeContext): Edited | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Edited.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("fieldName" in obj)){errors.push({field: "fieldName" , message: "missing required field" });}if(!("oldValue" in obj)){errors.push({field: "oldValue" , message: "missing required field" });}if(!("newValue" in obj)){errors.push({field: "newValue" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_fieldName = obj["fieldName" ]as string; 
                if (__raw_fieldName.length === 0) {
                    errors.push({ field: "fieldName", message: "must not be empty" });
                }
 instance.fieldName = __raw_fieldName; }{const __raw_oldValue = obj["oldValue" ]as string | null; instance.oldValue = __raw_oldValue; }{const __raw_newValue = obj["newValue" ]as string | null; instance.newValue = __raw_newValue; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Edited;}export function editedValidateField<K extends keyof Edited>(field: K, value: Edited[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "fieldName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "fieldName", message: "must not be empty" });
                }
 break;}}return errors; }export function editedValidateFields(partial: Partial<Edited>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("fieldName" in partial && partial.fieldName!== undefined){const __val = partial.fieldName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "fieldName", message: "must not be empty" });
                }
}return errors; }export function editedHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "fieldName" in o && "oldValue" in o && "newValue" in o;}export function editedIs(obj: unknown): obj is Edited {if(!editedHasShape(obj)){return false;}const result = editedDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type EditedErrors = {_errors: Option<Array<string>>; fieldName: Option<Array<string>>; oldValue: Option<Array<string>>; newValue: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type EditedTainted = {fieldName: Option<boolean>; oldValue: Option<boolean>; newValue: Option<boolean>; }; /** Type-safe field controllers for this form */export interface EditedFieldControllers {readonly fieldName: FieldController<string>; readonly oldValue: FieldController<string | null>; readonly newValue: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface EditedGigaform {readonly data: Edited; readonly errors: EditedErrors; readonly tainted: EditedTainted; readonly fields: EditedFieldControllers; validate(): Result<Edited, Array<{field: string; message: string}>>; reset(overrides?: Partial<Edited>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function editedCreateForm(overrides?: Partial<Edited>): EditedGigaform {let data = $state({...editedDefaultValue(),...overrides}); let errors = $state<EditedErrors>({_errors: Option.none(), fieldName: Option.none(), oldValue: Option.none(), newValue: Option.none(), }); let tainted = $state<EditedTainted>({fieldName: Option.none(), oldValue: Option.none(), newValue: Option.none(), }); const fields: EditedFieldControllers = {fieldName: {path: ["fieldName" ]as const, name: "fieldName" , constraints: { required: true }, get: ()=>data.fieldName, set: (value: string)=>{data.fieldName = value;}, transform: (value: string): string =>value,getError: ()=>errors.fieldName, setError: (value: Option<Array<string>>)=>{errors.fieldName = value;}, getTainted: ()=>tainted.fieldName, setTainted: (value: Option<boolean>)=>{tainted.fieldName = value;}, validate: (): Array<string>=>{const fieldErrors = editedValidateField("fieldName", data.fieldName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},oldValue: {path: ["oldValue" ]as const, name: "oldValue" , constraints: { required: true }, get: ()=>data.oldValue, set: (value: string | null)=>{data.oldValue = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.oldValue, setError: (value: Option<Array<string>>)=>{errors.oldValue = value;}, getTainted: ()=>tainted.oldValue, setTainted: (value: Option<boolean>)=>{tainted.oldValue = value;}, validate: (): Array<string>=>{const fieldErrors = editedValidateField("oldValue", data.oldValue); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},newValue: {path: ["newValue" ]as const, name: "newValue" , constraints: { required: true }, get: ()=>data.newValue, set: (value: string | null)=>{data.newValue = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.newValue, setError: (value: Option<Array<string>>)=>{errors.newValue = value;}, getTainted: ()=>tainted.newValue, setTainted: (value: Option<boolean>)=>{tainted.newValue = value;}, validate: (): Array<string>=>{const fieldErrors = editedValidateField("newValue", data.newValue); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Edited, Array<{field: string; message: string}>>{return editedDeserialize(data);}function reset(newOverrides?: Partial<Edited>): void {data = {...editedDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), fieldName: Option.none(), oldValue: Option.none(), newValue: Option.none(), }; tainted = {fieldName: Option.none(), oldValue: Option.none(), newValue: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function editedFromFormData(formData: FormData): Result<Edited, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.fieldName = formData.get("fieldName" )?? "" ;obj.oldValue = formData.get("oldValue" )?? "" ;obj.newValue = formData.get("newValue" )?? "" ;return editedDeserialize(obj);}

export const Edited = {
  defaultValue: editedDefaultValue,
  serialize: editedSerialize,
  serializeWithContext: editedSerializeWithContext,
  deserialize: editedDeserialize,
  deserializeWithContext: editedDeserializeWithContext,
  validateFields: editedValidateFields,
  hasShape: editedHasShape,
  is: editedIs,
  createForm: editedCreateForm,
  fromFormData: editedFromFormData
} as const;


export interface Order {
    
    id: string;
    
    
    account: string | Account;
    
    
    stage: OrderStage;
    
    number: number;
    
    payments: (string | Payment)[];
    
    
    opportunity: string;
    
    
    reference: string;
    
    
    leadSource: string;
    
    
    salesRep: string | Employee;
    
    
    group: string;
    
    
    subgroup: string;
    
    isPosted: boolean;
    
    needsReview: boolean;
    
    
    actionItem: string;
    
    upsale: number;
    
    dateCreated: string;
    
    
    appointment: string | Appointment;
    
    lastTechs: (string | Employee)[];
    
    package: (string | Package)[] | null;
    
    promotion: (string | Promotion)[] | null;
    
    balance: number;
    
    due: string;
    
    total: number;
    
    
    site: string | Site;
    
    billedItems: BilledItem[];
    
    
    memo: string;
    
    discount: number;
    
    tip: number;
    
    commissions: number[];
}

export function orderDefaultValue(): Order {return {id: "",
                            account: "",
                            stage: "Estimate",
                            number: 0,
                            payments: [],
                            opportunity: "",
                            reference: "",
                            leadSource: "",
                            salesRep: "",
                            group: "",
                            subgroup: "",
                            isPosted: false,
                            needsReview: false,
                            actionItem: "",
                            upsale: 0,
                            dateCreated: "",
                            appointment: "",
                            lastTechs: [],
                            package: null,
                            promotion: null,
                            balance: 0,
                            due: "",
                            total: 0,
                            site: "",
                            billedItems: [],
                            memo: "",
                            discount: 0,
                            tip: 0,
                            commissions: [], }as Order;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function orderSerialize(value: Order): string {const ctx = SerializeContext.create(); return JSON.stringify(orderSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function orderSerializeWithContext(value: Order, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Order" , __id,}; result["id" ]= value.id; result["account" ]= value.account; result["stage" ]= orderStageSerializeWithContext(value.stage, ctx); result["number" ]= value.number; result["payments" ]= value.payments; result["opportunity" ]= value.opportunity; result["reference" ]= value.reference; result["leadSource" ]= value.leadSource; result["salesRep" ]= value.salesRep; result["group" ]= value.group; result["subgroup" ]= value.subgroup; result["isPosted" ]= value.isPosted; result["needsReview" ]= value.needsReview; result["actionItem" ]= value.actionItem; result["upsale" ]= value.upsale; result["dateCreated" ]= value.dateCreated; result["appointment" ]= value.appointment; result["lastTechs" ]= value.lastTechs; if(value.package!== null){result["package" ]= value.package; }else {result["package" ]= null;}if(value.promotion!== null){result["promotion" ]= value.promotion; }else {result["promotion" ]= null;}result["balance" ]= value.balance; result["due" ]= value.due; result["total" ]= value.total; result["site" ]= value.site; result["billedItems" ]= value.billedItems.map((item)=>billedItemSerializeWithContext(item, ctx)); result["memo" ]= value.memo; result["discount" ]= value.discount; result["tip" ]= value.tip; result["commissions" ]= value.commissions; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function orderDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Order } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = orderDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Order.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function orderDeserializeWithContext(value: any, ctx: DeserializeContext): Order | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Order.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("account" in obj)){errors.push({field: "account" , message: "missing required field" });}if(!("stage" in obj)){errors.push({field: "stage" , message: "missing required field" });}if(!("number" in obj)){errors.push({field: "number" , message: "missing required field" });}if(!("payments" in obj)){errors.push({field: "payments" , message: "missing required field" });}if(!("opportunity" in obj)){errors.push({field: "opportunity" , message: "missing required field" });}if(!("reference" in obj)){errors.push({field: "reference" , message: "missing required field" });}if(!("leadSource" in obj)){errors.push({field: "leadSource" , message: "missing required field" });}if(!("salesRep" in obj)){errors.push({field: "salesRep" , message: "missing required field" });}if(!("group" in obj)){errors.push({field: "group" , message: "missing required field" });}if(!("subgroup" in obj)){errors.push({field: "subgroup" , message: "missing required field" });}if(!("isPosted" in obj)){errors.push({field: "isPosted" , message: "missing required field" });}if(!("needsReview" in obj)){errors.push({field: "needsReview" , message: "missing required field" });}if(!("actionItem" in obj)){errors.push({field: "actionItem" , message: "missing required field" });}if(!("upsale" in obj)){errors.push({field: "upsale" , message: "missing required field" });}if(!("dateCreated" in obj)){errors.push({field: "dateCreated" , message: "missing required field" });}if(!("appointment" in obj)){errors.push({field: "appointment" , message: "missing required field" });}if(!("lastTechs" in obj)){errors.push({field: "lastTechs" , message: "missing required field" });}if(!("package" in obj)){errors.push({field: "package" , message: "missing required field" });}if(!("promotion" in obj)){errors.push({field: "promotion" , message: "missing required field" });}if(!("balance" in obj)){errors.push({field: "balance" , message: "missing required field" });}if(!("due" in obj)){errors.push({field: "due" , message: "missing required field" });}if(!("total" in obj)){errors.push({field: "total" , message: "missing required field" });}if(!("site" in obj)){errors.push({field: "site" , message: "missing required field" });}if(!("billedItems" in obj)){errors.push({field: "billedItems" , message: "missing required field" });}if(!("memo" in obj)){errors.push({field: "memo" , message: "missing required field" });}if(!("discount" in obj)){errors.push({field: "discount" , message: "missing required field" });}if(!("tip" in obj)){errors.push({field: "tip" , message: "missing required field" });}if(!("commissions" in obj)){errors.push({field: "commissions" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_account = obj["account" ]as string | Account; instance.account = __raw_account; }{const __raw_stage = obj["stage" ]as OrderStage; {const __result = orderStageDeserializeWithContext(__raw_stage, ctx); ctx.assignOrDefer(instance, "stage" , __result);}}{const __raw_number = obj["number" ]as number; instance.number = __raw_number; }{const __raw_payments = obj["payments" ]as (string | Payment)[]; if(Array.isArray(__raw_payments)){instance.payments = __raw_payments as (string | Payment)[];}}{const __raw_opportunity = obj["opportunity" ]as string; 
                if (__raw_opportunity.length === 0) {
                    errors.push({ field: "opportunity", message: "must not be empty" });
                }
 instance.opportunity = __raw_opportunity; }{const __raw_reference = obj["reference" ]as string; 
                if (__raw_reference.length === 0) {
                    errors.push({ field: "reference", message: "must not be empty" });
                }
 instance.reference = __raw_reference; }{const __raw_leadSource = obj["leadSource" ]as string; 
                if (__raw_leadSource.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
 instance.leadSource = __raw_leadSource; }{const __raw_salesRep = obj["salesRep" ]as string | Employee; instance.salesRep = __raw_salesRep; }{const __raw_group = obj["group" ]as string; 
                if (__raw_group.length === 0) {
                    errors.push({ field: "group", message: "must not be empty" });
                }
 instance.group = __raw_group; }{const __raw_subgroup = obj["subgroup" ]as string; 
                if (__raw_subgroup.length === 0) {
                    errors.push({ field: "subgroup", message: "must not be empty" });
                }
 instance.subgroup = __raw_subgroup; }{const __raw_isPosted = obj["isPosted" ]as boolean; instance.isPosted = __raw_isPosted; }{const __raw_needsReview = obj["needsReview" ]as boolean; instance.needsReview = __raw_needsReview; }{const __raw_actionItem = obj["actionItem" ]as string; 
                if (__raw_actionItem.length === 0) {
                    errors.push({ field: "actionItem", message: "must not be empty" });
                }
 instance.actionItem = __raw_actionItem; }{const __raw_upsale = obj["upsale" ]as number; instance.upsale = __raw_upsale; }{const __raw_dateCreated = obj["dateCreated" ]as string; instance.dateCreated = __raw_dateCreated; }{const __raw_appointment = obj["appointment" ]as string | Appointment; instance.appointment = __raw_appointment; }{const __raw_lastTechs = obj["lastTechs" ]as (string | Employee)[]; if(Array.isArray(__raw_lastTechs)){instance.lastTechs = __raw_lastTechs as (string | Employee)[];}}{const __raw_package = obj["package" ]as (string | Package)[] | null; if(__raw_package === null){instance.package = null;}else {instance.package = __raw_package; }}{const __raw_promotion = obj["promotion" ]as (string | Promotion)[] | null; if(__raw_promotion === null){instance.promotion = null;}else {instance.promotion = __raw_promotion; }}{const __raw_balance = obj["balance" ]as number; instance.balance = __raw_balance; }{const __raw_due = obj["due" ]as string; instance.due = __raw_due; }{const __raw_total = obj["total" ]as number; instance.total = __raw_total; }{const __raw_site = obj["site" ]as string | Site; instance.site = __raw_site; }{const __raw_billedItems = obj["billedItems" ]as BilledItem[]; if(Array.isArray(__raw_billedItems)){instance.billedItems = __raw_billedItems as BilledItem[];}}{const __raw_memo = obj["memo" ]as string; 
                if (__raw_memo.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
 instance.memo = __raw_memo; }{const __raw_discount = obj["discount" ]as number; instance.discount = __raw_discount; }{const __raw_tip = obj["tip" ]as number; instance.tip = __raw_tip; }{const __raw_commissions = obj["commissions" ]as number[]; if(Array.isArray(__raw_commissions)){instance.commissions = __raw_commissions as number[];}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Order;}export function orderValidateField<K extends keyof Order>(field: K, value: Order[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "opportunity" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "opportunity", message: "must not be empty" });
                }
 break;}case "reference" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "reference", message: "must not be empty" });
                }
 break;}case "leadSource" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
 break;}case "group" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "group", message: "must not be empty" });
                }
 break;}case "subgroup" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subgroup", message: "must not be empty" });
                }
 break;}case "actionItem" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "actionItem", message: "must not be empty" });
                }
 break;}case "memo" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
 break;}}return errors; }export function orderValidateFields(partial: Partial<Order>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("opportunity" in partial && partial.opportunity!== undefined){const __val = partial.opportunity as string; 
                if (__val.length === 0) {
                    errors.push({ field: "opportunity", message: "must not be empty" });
                }
}if("reference" in partial && partial.reference!== undefined){const __val = partial.reference as string; 
                if (__val.length === 0) {
                    errors.push({ field: "reference", message: "must not be empty" });
                }
}if("leadSource" in partial && partial.leadSource!== undefined){const __val = partial.leadSource as string; 
                if (__val.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
}if("group" in partial && partial.group!== undefined){const __val = partial.group as string; 
                if (__val.length === 0) {
                    errors.push({ field: "group", message: "must not be empty" });
                }
}if("subgroup" in partial && partial.subgroup!== undefined){const __val = partial.subgroup as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subgroup", message: "must not be empty" });
                }
}if("actionItem" in partial && partial.actionItem!== undefined){const __val = partial.actionItem as string; 
                if (__val.length === 0) {
                    errors.push({ field: "actionItem", message: "must not be empty" });
                }
}if("memo" in partial && partial.memo!== undefined){const __val = partial.memo as string; 
                if (__val.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
}return errors; }export function orderHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "account" in o && "stage" in o && "number" in o && "payments" in o && "opportunity" in o && "reference" in o && "leadSource" in o && "salesRep" in o && "group" in o && "subgroup" in o && "isPosted" in o && "needsReview" in o && "actionItem" in o && "upsale" in o && "dateCreated" in o && "appointment" in o && "lastTechs" in o && "package" in o && "promotion" in o && "balance" in o && "due" in o && "total" in o && "site" in o && "billedItems" in o && "memo" in o && "discount" in o && "tip" in o && "commissions" in o;}export function orderIs(obj: unknown): obj is Order {if(!orderHasShape(obj)){return false;}const result = orderDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type OrderErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; account: Option<Array<string>>; stage: Option<Array<string>>; number: Option<Array<string>>; payments: Option<Array<string>>; opportunity: Option<Array<string>>; reference: Option<Array<string>>; leadSource: Option<Array<string>>; salesRep: Option<Array<string>>; group: Option<Array<string>>; subgroup: Option<Array<string>>; isPosted: Option<Array<string>>; needsReview: Option<Array<string>>; actionItem: Option<Array<string>>; upsale: Option<Array<string>>; dateCreated: Option<Array<string>>; appointment: Option<Array<string>>; lastTechs: Option<Array<string>>; package: Option<Array<string>>; promotion: Option<Array<string>>; balance: Option<Array<string>>; due: Option<Array<string>>; total: Option<Array<string>>; site: Option<Array<string>>; billedItems: Option<Array<string>>; memo: Option<Array<string>>; discount: Option<Array<string>>; tip: Option<Array<string>>; commissions: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type OrderTainted = {id: Option<boolean>; account: Option<boolean>; stage: Option<boolean>; number: Option<boolean>; payments: Option<boolean>; opportunity: Option<boolean>; reference: Option<boolean>; leadSource: Option<boolean>; salesRep: Option<boolean>; group: Option<boolean>; subgroup: Option<boolean>; isPosted: Option<boolean>; needsReview: Option<boolean>; actionItem: Option<boolean>; upsale: Option<boolean>; dateCreated: Option<boolean>; appointment: Option<boolean>; lastTechs: Option<boolean>; package: Option<boolean>; promotion: Option<boolean>; balance: Option<boolean>; due: Option<boolean>; total: Option<boolean>; site: Option<boolean>; billedItems: Option<boolean>; memo: Option<boolean>; discount: Option<boolean>; tip: Option<boolean>; commissions: Option<boolean>; }; /** Type-safe field controllers for this form */export interface OrderFieldControllers {readonly id: FieldController<string>; readonly account: FieldController<string | Account>; readonly stage: FieldController<OrderStage>; readonly number: FieldController<number>; readonly payments: ArrayFieldController<(string | Payment)>; readonly opportunity: FieldController<string>; readonly reference: FieldController<string>; readonly leadSource: FieldController<string>; readonly salesRep: FieldController<string | Employee>; readonly group: FieldController<string>; readonly subgroup: FieldController<string>; readonly isPosted: FieldController<boolean>; readonly needsReview: FieldController<boolean>; readonly actionItem: FieldController<string>; readonly upsale: FieldController<number>; readonly dateCreated: FieldController<string>; readonly appointment: FieldController<string | Appointment>; readonly lastTechs: ArrayFieldController<(string | Employee)>; readonly package: FieldController<(string | Package)[] | null>; readonly promotion: FieldController<(string | Promotion)[] | null>; readonly balance: FieldController<number>; readonly due: FieldController<string>; readonly total: FieldController<number>; readonly site: FieldController<string | Site>; readonly billedItems: ArrayFieldController<BilledItem>; readonly memo: FieldController<string>; readonly discount: FieldController<number>; readonly tip: FieldController<number>; readonly commissions: ArrayFieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface OrderGigaform {readonly data: Order; readonly errors: OrderErrors; readonly tainted: OrderTainted; readonly fields: OrderFieldControllers; validate(): Result<Order, Array<{field: string; message: string}>>; reset(overrides?: Partial<Order>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function orderCreateForm(overrides?: Partial<Order>): OrderGigaform {let data = $state({...orderDefaultValue(),...overrides}); let errors = $state<OrderErrors>({_errors: Option.none(), id: Option.none(), account: Option.none(), stage: Option.none(), number: Option.none(), payments: Option.none(), opportunity: Option.none(), reference: Option.none(), leadSource: Option.none(), salesRep: Option.none(), group: Option.none(), subgroup: Option.none(), isPosted: Option.none(), needsReview: Option.none(), actionItem: Option.none(), upsale: Option.none(), dateCreated: Option.none(), appointment: Option.none(), lastTechs: Option.none(), package: Option.none(), promotion: Option.none(), balance: Option.none(), due: Option.none(), total: Option.none(), site: Option.none(), billedItems: Option.none(), memo: Option.none(), discount: Option.none(), tip: Option.none(), commissions: Option.none(), }); let tainted = $state<OrderTainted>({id: Option.none(), account: Option.none(), stage: Option.none(), number: Option.none(), payments: Option.none(), opportunity: Option.none(), reference: Option.none(), leadSource: Option.none(), salesRep: Option.none(), group: Option.none(), subgroup: Option.none(), isPosted: Option.none(), needsReview: Option.none(), actionItem: Option.none(), upsale: Option.none(), dateCreated: Option.none(), appointment: Option.none(), lastTechs: Option.none(), package: Option.none(), promotion: Option.none(), balance: Option.none(), due: Option.none(), total: Option.none(), site: Option.none(), billedItems: Option.none(), memo: Option.none(), discount: Option.none(), tip: Option.none(), commissions: Option.none(), }); const fields: OrderFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},account: {path: ["account" ]as const, name: "account" , constraints: { required: true }, label: "Account" , get: ()=>data.account, set: (value: string | Account)=>{data.account = value;}, transform: (value: string | Account): string | Account =>value,getError: ()=>errors.account, setError: (value: Option<Array<string>>)=>{errors.account = value;}, getTainted: ()=>tainted.account, setTainted: (value: Option<boolean>)=>{tainted.account = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("account", data.account); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},stage: {path: ["stage" ]as const, name: "stage" , constraints: { required: true }, label: "Stage" , get: ()=>data.stage, set: (value: OrderStage)=>{data.stage = value;}, transform: (value: OrderStage): OrderStage =>value,getError: ()=>errors.stage, setError: (value: Option<Array<string>>)=>{errors.stage = value;}, getTainted: ()=>tainted.stage, setTainted: (value: Option<boolean>)=>{tainted.stage = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("stage", data.stage); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},number: {path: ["number" ]as const, name: "number" , constraints: { required: true }, get: ()=>data.number, set: (value: number)=>{data.number = value;}, transform: (value: number): number =>value,getError: ()=>errors.number, setError: (value: Option<Array<string>>)=>{errors.number = value;}, getTainted: ()=>tainted.number, setTainted: (value: Option<boolean>)=>{tainted.number = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("number", data.number); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},payments: {path: ["payments" ]as const, name: "payments" , constraints: { required: true }, get: ()=>data.payments, set: (value: (string | Payment)[])=>{data.payments = value;}, transform: (value: (string | Payment)[]): (string | Payment)[] =>value,getError: ()=>errors.payments, setError: (value: Option<Array<string>>)=>{errors.payments = value;}, getTainted: ()=>tainted.payments, setTainted: (value: Option<boolean>)=>{tainted.payments = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("payments", data.payments); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["payments" , index]as const, name: `payments.${index}` , constraints: {required: true}, get: ()=>data.payments[index]!, set: (value: (string | Payment))=>{data.payments[index]= value;}, transform: (value: (string | Payment)): (string | Payment) =>value, getError: ()=>errors.payments, setError: (value: Option<Array<string>>)=>{errors.payments = value;}, getTainted: ()=>tainted.payments, setTainted: (value: Option<boolean>)=>{tainted.payments = value;}, validate: (): Array<string>=>[],}), push: (item: (string | Payment))=>{data.payments.push(item);}, remove: (index: number)=>{data.payments.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.payments[a]!; data.payments[a]= data.payments[b]!; data.payments[b]= tmp;},},opportunity: {path: ["opportunity" ]as const, name: "opportunity" , constraints: { required: true }, label: "Opportunity" , get: ()=>data.opportunity, set: (value: string)=>{data.opportunity = value;}, transform: (value: string): string =>value,getError: ()=>errors.opportunity, setError: (value: Option<Array<string>>)=>{errors.opportunity = value;}, getTainted: ()=>tainted.opportunity, setTainted: (value: Option<boolean>)=>{tainted.opportunity = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("opportunity", data.opportunity); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},reference: {path: ["reference" ]as const, name: "reference" , constraints: { required: true }, label: "Reference" , get: ()=>data.reference, set: (value: string)=>{data.reference = value;}, transform: (value: string): string =>value,getError: ()=>errors.reference, setError: (value: Option<Array<string>>)=>{errors.reference = value;}, getTainted: ()=>tainted.reference, setTainted: (value: Option<boolean>)=>{tainted.reference = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("reference", data.reference); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},leadSource: {path: ["leadSource" ]as const, name: "leadSource" , constraints: { required: true }, label: "Lead Source" , get: ()=>data.leadSource, set: (value: string)=>{data.leadSource = value;}, transform: (value: string): string =>value,getError: ()=>errors.leadSource, setError: (value: Option<Array<string>>)=>{errors.leadSource = value;}, getTainted: ()=>tainted.leadSource, setTainted: (value: Option<boolean>)=>{tainted.leadSource = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("leadSource", data.leadSource); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},salesRep: {path: ["salesRep" ]as const, name: "salesRep" , constraints: { required: true }, label: "Sales Rep" , get: ()=>data.salesRep, set: (value: string | Employee)=>{data.salesRep = value;}, transform: (value: string | Employee): string | Employee =>value,getError: ()=>errors.salesRep, setError: (value: Option<Array<string>>)=>{errors.salesRep = value;}, getTainted: ()=>tainted.salesRep, setTainted: (value: Option<boolean>)=>{tainted.salesRep = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("salesRep", data.salesRep); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},group: {path: ["group" ]as const, name: "group" , constraints: { required: true }, label: "Group" , get: ()=>data.group, set: (value: string)=>{data.group = value;}, transform: (value: string): string =>value,getError: ()=>errors.group, setError: (value: Option<Array<string>>)=>{errors.group = value;}, getTainted: ()=>tainted.group, setTainted: (value: Option<boolean>)=>{tainted.group = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("group", data.group); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},subgroup: {path: ["subgroup" ]as const, name: "subgroup" , constraints: { required: true }, label: "Subgroup" , get: ()=>data.subgroup, set: (value: string)=>{data.subgroup = value;}, transform: (value: string): string =>value,getError: ()=>errors.subgroup, setError: (value: Option<Array<string>>)=>{errors.subgroup = value;}, getTainted: ()=>tainted.subgroup, setTainted: (value: Option<boolean>)=>{tainted.subgroup = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("subgroup", data.subgroup); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},isPosted: {path: ["isPosted" ]as const, name: "isPosted" , constraints: { required: true }, label: "Posted" , get: ()=>data.isPosted, set: (value: boolean)=>{data.isPosted = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.isPosted, setError: (value: Option<Array<string>>)=>{errors.isPosted = value;}, getTainted: ()=>tainted.isPosted, setTainted: (value: Option<boolean>)=>{tainted.isPosted = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("isPosted", data.isPosted); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},needsReview: {path: ["needsReview" ]as const, name: "needsReview" , constraints: { required: true }, label: "Needs Review" , get: ()=>data.needsReview, set: (value: boolean)=>{data.needsReview = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.needsReview, setError: (value: Option<Array<string>>)=>{errors.needsReview = value;}, getTainted: ()=>tainted.needsReview, setTainted: (value: Option<boolean>)=>{tainted.needsReview = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("needsReview", data.needsReview); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},actionItem: {path: ["actionItem" ]as const, name: "actionItem" , constraints: { required: true }, label: "Action Item" , get: ()=>data.actionItem, set: (value: string)=>{data.actionItem = value;}, transform: (value: string): string =>value,getError: ()=>errors.actionItem, setError: (value: Option<Array<string>>)=>{errors.actionItem = value;}, getTainted: ()=>tainted.actionItem, setTainted: (value: Option<boolean>)=>{tainted.actionItem = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("actionItem", data.actionItem); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},upsale: {path: ["upsale" ]as const, name: "upsale" , constraints: { required: true }, get: ()=>data.upsale, set: (value: number)=>{data.upsale = value;}, transform: (value: number): number =>value,getError: ()=>errors.upsale, setError: (value: Option<Array<string>>)=>{errors.upsale = value;}, getTainted: ()=>tainted.upsale, setTainted: (value: Option<boolean>)=>{tainted.upsale = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("upsale", data.upsale); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},dateCreated: {path: ["dateCreated" ]as const, name: "dateCreated" , constraints: { required: true }, get: ()=>data.dateCreated, set: (value: string)=>{data.dateCreated = value;}, transform: (value: string): string =>value,getError: ()=>errors.dateCreated, setError: (value: Option<Array<string>>)=>{errors.dateCreated = value;}, getTainted: ()=>tainted.dateCreated, setTainted: (value: Option<boolean>)=>{tainted.dateCreated = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("dateCreated", data.dateCreated); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},appointment: {path: ["appointment" ]as const, name: "appointment" , constraints: { required: true }, label: "Appointment" , get: ()=>data.appointment, set: (value: string | Appointment)=>{data.appointment = value;}, transform: (value: string | Appointment): string | Appointment =>value,getError: ()=>errors.appointment, setError: (value: Option<Array<string>>)=>{errors.appointment = value;}, getTainted: ()=>tainted.appointment, setTainted: (value: Option<boolean>)=>{tainted.appointment = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("appointment", data.appointment); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},lastTechs: {path: ["lastTechs" ]as const, name: "lastTechs" , constraints: { required: true }, label: "Technicians" , get: ()=>data.lastTechs, set: (value: (string | Employee)[])=>{data.lastTechs = value;}, transform: (value: (string | Employee)[]): (string | Employee)[] =>value,getError: ()=>errors.lastTechs, setError: (value: Option<Array<string>>)=>{errors.lastTechs = value;}, getTainted: ()=>tainted.lastTechs, setTainted: (value: Option<boolean>)=>{tainted.lastTechs = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("lastTechs", data.lastTechs); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["lastTechs" , index]as const, name: `lastTechs.${index}` , constraints: {required: true}, get: ()=>data.lastTechs[index]!, set: (value: (string | Employee))=>{data.lastTechs[index]= value;}, transform: (value: (string | Employee)): (string | Employee) =>value, getError: ()=>errors.lastTechs, setError: (value: Option<Array<string>>)=>{errors.lastTechs = value;}, getTainted: ()=>tainted.lastTechs, setTainted: (value: Option<boolean>)=>{tainted.lastTechs = value;}, validate: (): Array<string>=>[],}), push: (item: (string | Employee))=>{data.lastTechs.push(item);}, remove: (index: number)=>{data.lastTechs.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.lastTechs[a]!; data.lastTechs[a]= data.lastTechs[b]!; data.lastTechs[b]= tmp;},},package: {path: ["package" ]as const, name: "package" , constraints: { required: true }, get: ()=>data.package, set: (value: (string | Package)[] | null)=>{data.package = value;}, transform: (value: (string | Package)[] | null): (string | Package)[] | null =>value,getError: ()=>errors.package, setError: (value: Option<Array<string>>)=>{errors.package = value;}, getTainted: ()=>tainted.package, setTainted: (value: Option<boolean>)=>{tainted.package = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("package", data.package); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},promotion: {path: ["promotion" ]as const, name: "promotion" , constraints: { required: true }, get: ()=>data.promotion, set: (value: (string | Promotion)[] | null)=>{data.promotion = value;}, transform: (value: (string | Promotion)[] | null): (string | Promotion)[] | null =>value,getError: ()=>errors.promotion, setError: (value: Option<Array<string>>)=>{errors.promotion = value;}, getTainted: ()=>tainted.promotion, setTainted: (value: Option<boolean>)=>{tainted.promotion = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("promotion", data.promotion); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},balance: {path: ["balance" ]as const, name: "balance" , constraints: { required: true }, get: ()=>data.balance, set: (value: number)=>{data.balance = value;}, transform: (value: number): number =>value,getError: ()=>errors.balance, setError: (value: Option<Array<string>>)=>{errors.balance = value;}, getTainted: ()=>tainted.balance, setTainted: (value: Option<boolean>)=>{tainted.balance = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("balance", data.balance); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},due: {path: ["due" ]as const, name: "due" , constraints: { required: true }, label: "Due" , get: ()=>data.due, set: (value: string)=>{data.due = value;}, transform: (value: string): string =>value,getError: ()=>errors.due, setError: (value: Option<Array<string>>)=>{errors.due = value;}, getTainted: ()=>tainted.due, setTainted: (value: Option<boolean>)=>{tainted.due = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("due", data.due); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},total: {path: ["total" ]as const, name: "total" , constraints: { required: true }, get: ()=>data.total, set: (value: number)=>{data.total = value;}, transform: (value: number): number =>value,getError: ()=>errors.total, setError: (value: Option<Array<string>>)=>{errors.total = value;}, getTainted: ()=>tainted.total, setTainted: (value: Option<boolean>)=>{tainted.total = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("total", data.total); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},site: {path: ["site" ]as const, name: "site" , constraints: { required: true }, label: "Site" , get: ()=>data.site, set: (value: string | Site)=>{data.site = value;}, transform: (value: string | Site): string | Site =>value,getError: ()=>errors.site, setError: (value: Option<Array<string>>)=>{errors.site = value;}, getTainted: ()=>tainted.site, setTainted: (value: Option<boolean>)=>{tainted.site = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("site", data.site); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},billedItems: {path: ["billedItems" ]as const, name: "billedItems" , constraints: { required: true }, get: ()=>data.billedItems, set: (value: BilledItem[])=>{data.billedItems = value;}, transform: (value: BilledItem[]): BilledItem[] =>value,getError: ()=>errors.billedItems, setError: (value: Option<Array<string>>)=>{errors.billedItems = value;}, getTainted: ()=>tainted.billedItems, setTainted: (value: Option<boolean>)=>{tainted.billedItems = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("billedItems", data.billedItems); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["billedItems" , index]as const, name: `billedItems.${index}` , constraints: {required: true}, get: ()=>data.billedItems[index]!, set: (value: BilledItem)=>{data.billedItems[index]= value;}, transform: (value: BilledItem): BilledItem =>value, getError: ()=>errors.billedItems, setError: (value: Option<Array<string>>)=>{errors.billedItems = value;}, getTainted: ()=>tainted.billedItems, setTainted: (value: Option<boolean>)=>{tainted.billedItems = value;}, validate: (): Array<string>=>[],}), push: (item: BilledItem)=>{data.billedItems.push(item);}, remove: (index: number)=>{data.billedItems.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.billedItems[a]!; data.billedItems[a]= data.billedItems[b]!; data.billedItems[b]= tmp;},},memo: {path: ["memo" ]as const, name: "memo" , constraints: { required: true }, label: "Memo" , get: ()=>data.memo, set: (value: string)=>{data.memo = value;}, transform: (value: string): string =>value,getError: ()=>errors.memo, setError: (value: Option<Array<string>>)=>{errors.memo = value;}, getTainted: ()=>tainted.memo, setTainted: (value: Option<boolean>)=>{tainted.memo = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("memo", data.memo); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},discount: {path: ["discount" ]as const, name: "discount" , constraints: { required: true }, get: ()=>data.discount, set: (value: number)=>{data.discount = value;}, transform: (value: number): number =>value,getError: ()=>errors.discount, setError: (value: Option<Array<string>>)=>{errors.discount = value;}, getTainted: ()=>tainted.discount, setTainted: (value: Option<boolean>)=>{tainted.discount = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("discount", data.discount); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},tip: {path: ["tip" ]as const, name: "tip" , constraints: { required: true }, get: ()=>data.tip, set: (value: number)=>{data.tip = value;}, transform: (value: number): number =>value,getError: ()=>errors.tip, setError: (value: Option<Array<string>>)=>{errors.tip = value;}, getTainted: ()=>tainted.tip, setTainted: (value: Option<boolean>)=>{tainted.tip = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("tip", data.tip); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},commissions: {path: ["commissions" ]as const, name: "commissions" , constraints: { required: true }, get: ()=>data.commissions, set: (value: number[])=>{data.commissions = value;}, transform: (value: number[]): number[] =>value,getError: ()=>errors.commissions, setError: (value: Option<Array<string>>)=>{errors.commissions = value;}, getTainted: ()=>tainted.commissions, setTainted: (value: Option<boolean>)=>{tainted.commissions = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("commissions", data.commissions); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["commissions" , index]as const, name: `commissions.${index}` , constraints: {required: true}, get: ()=>data.commissions[index]!, set: (value: number)=>{data.commissions[index]= value;}, transform: (value: number): number =>value, getError: ()=>errors.commissions, setError: (value: Option<Array<string>>)=>{errors.commissions = value;}, getTainted: ()=>tainted.commissions, setTainted: (value: Option<boolean>)=>{tainted.commissions = value;}, validate: (): Array<string>=>[],}), push: (item: number)=>{data.commissions.push(item);}, remove: (index: number)=>{data.commissions.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.commissions[a]!; data.commissions[a]= data.commissions[b]!; data.commissions[b]= tmp;},},}; function validate(): Result<Order, Array<{field: string; message: string}>>{return orderDeserialize(data);}function reset(newOverrides?: Partial<Order>): void {data = {...orderDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), account: Option.none(), stage: Option.none(), number: Option.none(), payments: Option.none(), opportunity: Option.none(), reference: Option.none(), leadSource: Option.none(), salesRep: Option.none(), group: Option.none(), subgroup: Option.none(), isPosted: Option.none(), needsReview: Option.none(), actionItem: Option.none(), upsale: Option.none(), dateCreated: Option.none(), appointment: Option.none(), lastTechs: Option.none(), package: Option.none(), promotion: Option.none(), balance: Option.none(), due: Option.none(), total: Option.none(), site: Option.none(), billedItems: Option.none(), memo: Option.none(), discount: Option.none(), tip: Option.none(), commissions: Option.none(), }; tainted = {id: Option.none(), account: Option.none(), stage: Option.none(), number: Option.none(), payments: Option.none(), opportunity: Option.none(), reference: Option.none(), leadSource: Option.none(), salesRep: Option.none(), group: Option.none(), subgroup: Option.none(), isPosted: Option.none(), needsReview: Option.none(), actionItem: Option.none(), upsale: Option.none(), dateCreated: Option.none(), appointment: Option.none(), lastTechs: Option.none(), package: Option.none(), promotion: Option.none(), balance: Option.none(), due: Option.none(), total: Option.none(), site: Option.none(), billedItems: Option.none(), memo: Option.none(), discount: Option.none(), tip: Option.none(), commissions: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function orderFromFormData(formData: FormData): Result<Order, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.account = formData.get("account" )?? "" ;{const stage Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("stage." )){const fieldName = key.slice("stage." .length); const parts = fieldName.split("." ); let current = stage Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.stage = stage Obj;}{const number Str = formData.get("number" ); obj.number = number Str? parseFloat(number Str as string): 0; if(obj.number!== undefined && isNaN(obj.number as number))obj.number = 0;}{const payments Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("payments." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("payments." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("payments." + idx + "." )){const fieldName = key.slice("payments." .length + String(idx).length + 1); item[fieldName]= value;}}payments Items.push(item);}idx ++; if(idx>1000)break;}obj.payments = payments Items;}obj.opportunity = formData.get("opportunity" )?? "" ;obj.reference = formData.get("reference" )?? "" ;obj.leadSource = formData.get("leadSource" )?? "" ;obj.salesRep = formData.get("salesRep" )?? "" ;obj.group = formData.get("group" )?? "" ;obj.subgroup = formData.get("subgroup" )?? "" ;{const isPosted Val = formData.get("isPosted" ); obj.isPosted = isPosted Val === "true" || isPosted Val === "on" || isPosted Val === "1" ;}{const needsReview Val = formData.get("needsReview" ); obj.needsReview = needsReview Val === "true" || needsReview Val === "on" || needsReview Val === "1" ;}obj.actionItem = formData.get("actionItem" )?? "" ;{const upsale Str = formData.get("upsale" ); obj.upsale = upsale Str? parseFloat(upsale Str as string): 0; if(obj.upsale!== undefined && isNaN(obj.upsale as number))obj.upsale = 0;}obj.dateCreated = formData.get("dateCreated" )?? "" ;obj.appointment = formData.get("appointment" )?? "" ;{const lastTechs Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("lastTechs." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("lastTechs." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("lastTechs." + idx + "." )){const fieldName = key.slice("lastTechs." .length + String(idx).length + 1); item[fieldName]= value;}}lastTechs Items.push(item);}idx ++; if(idx>1000)break;}obj.lastTechs = lastTechs Items;}obj.package = formData.get("package" )?? "" ;obj.promotion = formData.get("promotion" )?? "" ;{const balance Str = formData.get("balance" ); obj.balance = balance Str? parseFloat(balance Str as string): 0; if(obj.balance!== undefined && isNaN(obj.balance as number))obj.balance = 0;}obj.due = formData.get("due" )?? "" ;{const total Str = formData.get("total" ); obj.total = total Str? parseFloat(total Str as string): 0; if(obj.total!== undefined && isNaN(obj.total as number))obj.total = 0;}obj.site = formData.get("site" )?? "" ;{const billedItems Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("billedItems." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("billedItems." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("billedItems." + idx + "." )){const fieldName = key.slice("billedItems." .length + String(idx).length + 1); item[fieldName]= value;}}billedItems Items.push(item);}idx ++; if(idx>1000)break;}obj.billedItems = billedItems Items;}obj.memo = formData.get("memo" )?? "" ;{const discount Str = formData.get("discount" ); obj.discount = discount Str? parseFloat(discount Str as string): 0; if(obj.discount!== undefined && isNaN(obj.discount as number))obj.discount = 0;}{const tip Str = formData.get("tip" ); obj.tip = tip Str? parseFloat(tip Str as string): 0; if(obj.tip!== undefined && isNaN(obj.tip as number))obj.tip = 0;}obj.commissions = formData.getAll("commissions" ).map(v =>parseFloat(v as string)).filter(n =>!isNaN(n));return orderDeserialize(obj);}

export const Order = {
  defaultValue: orderDefaultValue,
  serialize: orderSerialize,
  serializeWithContext: orderSerializeWithContext,
  deserialize: orderDeserialize,
  deserializeWithContext: orderDeserializeWithContext,
  validateFields: orderValidateFields,
  hasShape: orderHasShape,
  is: orderIs,
  createForm: orderCreateForm,
  fromFormData: orderFromFormData
} as const;


export interface Commented {
    
    comment: string;
    replyTo: string | null;
}

export function commentedDefaultValue(): Commented {return {comment: "",
                            replyTo: null, }as Commented;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function commentedSerialize(value: Commented): string {const ctx = SerializeContext.create(); return JSON.stringify(commentedSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function commentedSerializeWithContext(value: Commented, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Commented" , __id,}; result["comment" ]= value.comment; result["replyTo" ]= value.replyTo; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function commentedDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Commented } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = commentedDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Commented.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function commentedDeserializeWithContext(value: any, ctx: DeserializeContext): Commented | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Commented.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("comment" in obj)){errors.push({field: "comment" , message: "missing required field" });}if(!("replyTo" in obj)){errors.push({field: "replyTo" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_comment = obj["comment" ]as string; 
                if (__raw_comment.length === 0) {
                    errors.push({ field: "comment", message: "must not be empty" });
                }
 instance.comment = __raw_comment; }{const __raw_replyTo = obj["replyTo" ]as string | null; instance.replyTo = __raw_replyTo; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Commented;}export function commentedValidateField<K extends keyof Commented>(field: K, value: Commented[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "comment" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "comment", message: "must not be empty" });
                }
 break;}}return errors; }export function commentedValidateFields(partial: Partial<Commented>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("comment" in partial && partial.comment!== undefined){const __val = partial.comment as string; 
                if (__val.length === 0) {
                    errors.push({ field: "comment", message: "must not be empty" });
                }
}return errors; }export function commentedHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "comment" in o && "replyTo" in o;}export function commentedIs(obj: unknown): obj is Commented {if(!commentedHasShape(obj)){return false;}const result = commentedDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CommentedErrors = {_errors: Option<Array<string>>; comment: Option<Array<string>>; replyTo: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CommentedTainted = {comment: Option<boolean>; replyTo: Option<boolean>; }; /** Type-safe field controllers for this form */export interface CommentedFieldControllers {readonly comment: FieldController<string>; readonly replyTo: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface CommentedGigaform {readonly data: Commented; readonly errors: CommentedErrors; readonly tainted: CommentedTainted; readonly fields: CommentedFieldControllers; validate(): Result<Commented, Array<{field: string; message: string}>>; reset(overrides?: Partial<Commented>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function commentedCreateForm(overrides?: Partial<Commented>): CommentedGigaform {let data = $state({...commentedDefaultValue(),...overrides}); let errors = $state<CommentedErrors>({_errors: Option.none(), comment: Option.none(), replyTo: Option.none(), }); let tainted = $state<CommentedTainted>({comment: Option.none(), replyTo: Option.none(), }); const fields: CommentedFieldControllers = {comment: {path: ["comment" ]as const, name: "comment" , constraints: { required: true }, get: ()=>data.comment, set: (value: string)=>{data.comment = value;}, transform: (value: string): string =>value,getError: ()=>errors.comment, setError: (value: Option<Array<string>>)=>{errors.comment = value;}, getTainted: ()=>tainted.comment, setTainted: (value: Option<boolean>)=>{tainted.comment = value;}, validate: (): Array<string>=>{const fieldErrors = commentedValidateField("comment", data.comment); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},replyTo: {path: ["replyTo" ]as const, name: "replyTo" , constraints: { required: true }, get: ()=>data.replyTo, set: (value: string | null)=>{data.replyTo = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.replyTo, setError: (value: Option<Array<string>>)=>{errors.replyTo = value;}, getTainted: ()=>tainted.replyTo, setTainted: (value: Option<boolean>)=>{tainted.replyTo = value;}, validate: (): Array<string>=>{const fieldErrors = commentedValidateField("replyTo", data.replyTo); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Commented, Array<{field: string; message: string}>>{return commentedDeserialize(data);}function reset(newOverrides?: Partial<Commented>): void {data = {...commentedDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), comment: Option.none(), replyTo: Option.none(), }; tainted = {comment: Option.none(), replyTo: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function commentedFromFormData(formData: FormData): Result<Commented, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.comment = formData.get("comment" )?? "" ;obj.replyTo = formData.get("replyTo" )?? "" ;return commentedDeserialize(obj);}

export const Commented = {
  defaultValue: commentedDefaultValue,
  serialize: commentedSerialize,
  serializeWithContext: commentedSerializeWithContext,
  deserialize: commentedDeserialize,
  deserializeWithContext: commentedDeserializeWithContext,
  validateFields: commentedValidateFields,
  hasShape: commentedHasShape,
  is: commentedIs,
  createForm: commentedCreateForm,
  fromFormData: commentedFromFormData
} as const;


export interface Custom {
    mappings: DirectionHue[];
}

export function customDefaultValue(): Custom {return {mappings: [], }as Custom;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function customSerialize(value: Custom): string {const ctx = SerializeContext.create(); return JSON.stringify(customSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function customSerializeWithContext(value: Custom, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Custom" , __id,}; result["mappings" ]= value.mappings.map((item)=>directionHueSerializeWithContext(item, ctx)); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function customDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Custom } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = customDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Custom.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function customDeserializeWithContext(value: any, ctx: DeserializeContext): Custom | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Custom.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("mappings" in obj)){errors.push({field: "mappings" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_mappings = obj["mappings" ]as DirectionHue[]; if(Array.isArray(__raw_mappings)){instance.mappings = __raw_mappings as DirectionHue[];}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Custom;}export function customValidateField<K extends keyof Custom>(field: K, value: Custom[K]): Array<{field: string; message: string}>{return[]; }export function customValidateFields(partial: Partial<Custom>): Array<{field: string; message: string}>{return[]; }export function customHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "mappings" in o;}export function customIs(obj: unknown): obj is Custom {if(!customHasShape(obj)){return false;}const result = customDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CustomErrors = {_errors: Option<Array<string>>; mappings: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CustomTainted = {mappings: Option<boolean>; }; /** Type-safe field controllers for this form */export interface CustomFieldControllers {readonly mappings: ArrayFieldController<DirectionHue>; }/** Gigaform instance containing reactive state and field controllers */export interface CustomGigaform {readonly data: Custom; readonly errors: CustomErrors; readonly tainted: CustomTainted; readonly fields: CustomFieldControllers; validate(): Result<Custom, Array<{field: string; message: string}>>; reset(overrides?: Partial<Custom>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function customCreateForm(overrides?: Partial<Custom>): CustomGigaform {let data = $state({...customDefaultValue(),...overrides}); let errors = $state<CustomErrors>({_errors: Option.none(), mappings: Option.none(), }); let tainted = $state<CustomTainted>({mappings: Option.none(), }); const fields: CustomFieldControllers = {mappings: {path: ["mappings" ]as const, name: "mappings" , constraints: { required: true }, get: ()=>data.mappings, set: (value: DirectionHue[])=>{data.mappings = value;}, transform: (value: DirectionHue[]): DirectionHue[] =>value,getError: ()=>errors.mappings, setError: (value: Option<Array<string>>)=>{errors.mappings = value;}, getTainted: ()=>tainted.mappings, setTainted: (value: Option<boolean>)=>{tainted.mappings = value;}, validate: (): Array<string>=>{const fieldErrors = customValidateField("mappings", data.mappings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["mappings" , index]as const, name: `mappings.${index}` , constraints: {required: true}, get: ()=>data.mappings[index]!, set: (value: DirectionHue)=>{data.mappings[index]= value;}, transform: (value: DirectionHue): DirectionHue =>value, getError: ()=>errors.mappings, setError: (value: Option<Array<string>>)=>{errors.mappings = value;}, getTainted: ()=>tainted.mappings, setTainted: (value: Option<boolean>)=>{tainted.mappings = value;}, validate: (): Array<string>=>[],}), push: (item: DirectionHue)=>{data.mappings.push(item);}, remove: (index: number)=>{data.mappings.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.mappings[a]!; data.mappings[a]= data.mappings[b]!; data.mappings[b]= tmp;},},}; function validate(): Result<Custom, Array<{field: string; message: string}>>{return customDeserialize(data);}function reset(newOverrides?: Partial<Custom>): void {data = {...customDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), mappings: Option.none(), }; tainted = {mappings: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function customFromFormData(formData: FormData): Result<Custom, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const mappings Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("mappings." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("mappings." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("mappings." + idx + "." )){const fieldName = key.slice("mappings." .length + String(idx).length + 1); item[fieldName]= value;}}mappings Items.push(item);}idx ++; if(idx>1000)break;}obj.mappings = mappings Items;}return customDeserialize(obj);}

export const Custom = {
  defaultValue: customDefaultValue,
  serialize: customSerialize,
  serializeWithContext: customSerializeWithContext,
  deserialize: customDeserialize,
  deserializeWithContext: customDeserializeWithContext,
  validateFields: customValidateFields,
  hasShape: customHasShape,
  is: customIs,
  createForm: customCreateForm,
  fromFormData: customFromFormData
} as const;


export interface Colors {
    
    main: string;
    
    hover: string;
    
    active: string;
}

export function colorsDefaultValue(): Colors {return {main: "",
                            hover: "",
                            active: "", }as Colors;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function colorsSerialize(value: Colors): string {const ctx = SerializeContext.create(); return JSON.stringify(colorsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function colorsSerializeWithContext(value: Colors, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Colors" , __id,}; result["main" ]= value.main; result["hover" ]= value.hover; result["active" ]= value.active; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function colorsDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Colors } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = colorsDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Colors.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function colorsDeserializeWithContext(value: any, ctx: DeserializeContext): Colors | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Colors.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("main" in obj)){errors.push({field: "main" , message: "missing required field" });}if(!("hover" in obj)){errors.push({field: "hover" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_main = obj["main" ]as string; 
                if (__raw_main.length === 0) {
                    errors.push({ field: "main", message: "must not be empty" });
                }
 instance.main = __raw_main; }{const __raw_hover = obj["hover" ]as string; 
                if (__raw_hover.length === 0) {
                    errors.push({ field: "hover", message: "must not be empty" });
                }
 instance.hover = __raw_hover; }{const __raw_active = obj["active" ]as string; 
                if (__raw_active.length === 0) {
                    errors.push({ field: "active", message: "must not be empty" });
                }
 instance.active = __raw_active; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Colors;}export function colorsValidateField<K extends keyof Colors>(field: K, value: Colors[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "main" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "main", message: "must not be empty" });
                }
 break;}case "hover" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "hover", message: "must not be empty" });
                }
 break;}case "active" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "active", message: "must not be empty" });
                }
 break;}}return errors; }export function colorsValidateFields(partial: Partial<Colors>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("main" in partial && partial.main!== undefined){const __val = partial.main as string; 
                if (__val.length === 0) {
                    errors.push({ field: "main", message: "must not be empty" });
                }
}if("hover" in partial && partial.hover!== undefined){const __val = partial.hover as string; 
                if (__val.length === 0) {
                    errors.push({ field: "hover", message: "must not be empty" });
                }
}if("active" in partial && partial.active!== undefined){const __val = partial.active as string; 
                if (__val.length === 0) {
                    errors.push({ field: "active", message: "must not be empty" });
                }
}return errors; }export function colorsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "main" in o && "hover" in o && "active" in o;}export function colorsIs(obj: unknown): obj is Colors {if(!colorsHasShape(obj)){return false;}const result = colorsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ColorsErrors = {_errors: Option<Array<string>>; main: Option<Array<string>>; hover: Option<Array<string>>; active: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ColorsTainted = {main: Option<boolean>; hover: Option<boolean>; active: Option<boolean>; }; /** Type-safe field controllers for this form */export interface ColorsFieldControllers {readonly main: FieldController<string>; readonly hover: FieldController<string>; readonly active: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface ColorsGigaform {readonly data: Colors; readonly errors: ColorsErrors; readonly tainted: ColorsTainted; readonly fields: ColorsFieldControllers; validate(): Result<Colors, Array<{field: string; message: string}>>; reset(overrides?: Partial<Colors>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function colorsCreateForm(overrides?: Partial<Colors>): ColorsGigaform {let data = $state({...colorsDefaultValue(),...overrides}); let errors = $state<ColorsErrors>({_errors: Option.none(), main: Option.none(), hover: Option.none(), active: Option.none(), }); let tainted = $state<ColorsTainted>({main: Option.none(), hover: Option.none(), active: Option.none(), }); const fields: ColorsFieldControllers = {main: {path: ["main" ]as const, name: "main" , constraints: { required: true }, get: ()=>data.main, set: (value: string)=>{data.main = value;}, transform: (value: string): string =>value,getError: ()=>errors.main, setError: (value: Option<Array<string>>)=>{errors.main = value;}, getTainted: ()=>tainted.main, setTainted: (value: Option<boolean>)=>{tainted.main = value;}, validate: (): Array<string>=>{const fieldErrors = colorsValidateField("main", data.main); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hover: {path: ["hover" ]as const, name: "hover" , constraints: { required: true }, get: ()=>data.hover, set: (value: string)=>{data.hover = value;}, transform: (value: string): string =>value,getError: ()=>errors.hover, setError: (value: Option<Array<string>>)=>{errors.hover = value;}, getTainted: ()=>tainted.hover, setTainted: (value: Option<boolean>)=>{tainted.hover = value;}, validate: (): Array<string>=>{const fieldErrors = colorsValidateField("hover", data.hover); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},active: {path: ["active" ]as const, name: "active" , constraints: { required: true }, get: ()=>data.active, set: (value: string)=>{data.active = value;}, transform: (value: string): string =>value,getError: ()=>errors.active, setError: (value: Option<Array<string>>)=>{errors.active = value;}, getTainted: ()=>tainted.active, setTainted: (value: Option<boolean>)=>{tainted.active = value;}, validate: (): Array<string>=>{const fieldErrors = colorsValidateField("active", data.active); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Colors, Array<{field: string; message: string}>>{return colorsDeserialize(data);}function reset(newOverrides?: Partial<Colors>): void {data = {...colorsDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), main: Option.none(), hover: Option.none(), active: Option.none(), }; tainted = {main: Option.none(), hover: Option.none(), active: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function colorsFromFormData(formData: FormData): Result<Colors, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.main = formData.get("main" )?? "" ;obj.hover = formData.get("hover" )?? "" ;obj.active = formData.get("active" )?? "" ;return colorsDeserialize(obj);}

export const Colors = {
  defaultValue: colorsDefaultValue,
  serialize: colorsSerialize,
  serializeWithContext: colorsSerializeWithContext,
  deserialize: colorsDeserialize,
  deserializeWithContext: colorsDeserializeWithContext,
  validateFields: colorsValidateFields,
  hasShape: colorsHasShape,
  is: colorsIs,
  createForm: colorsCreateForm,
  fromFormData: colorsFromFormData
} as const;


export interface ProductDefaults {
    
    price: number;
    
    
    description: string;
}

export function productDefaultsDefaultValue(): ProductDefaults {return {price: 0,
                            description: "", }as ProductDefaults;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function productDefaultsSerialize(value: ProductDefaults): string {const ctx = SerializeContext.create(); return JSON.stringify(productDefaultsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function productDefaultsSerializeWithContext(value: ProductDefaults, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "ProductDefaults" , __id,}; result["price" ]= value.price; result["description" ]= value.description; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function productDefaultsDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: ProductDefaults } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = productDefaultsDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "ProductDefaults.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function productDefaultsDeserializeWithContext(value: any, ctx: DeserializeContext): ProductDefaults | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "ProductDefaults.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("price" in obj)){errors.push({field: "price" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_price = obj["price" ]as number; instance.price = __raw_price; }{const __raw_description = obj["description" ]as string; 
                if (__raw_description.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 instance.description = __raw_description; }if(errors.length>0){throw new DeserializeError(errors);}return instance as ProductDefaults;}export function productDefaultsValidateField<K extends keyof ProductDefaults>(field: K, value: ProductDefaults[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "description" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 break;}}return errors; }export function productDefaultsValidateFields(partial: Partial<ProductDefaults>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("description" in partial && partial.description!== undefined){const __val = partial.description as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
}return errors; }export function productDefaultsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "price" in o && "description" in o;}export function productDefaultsIs(obj: unknown): obj is ProductDefaults {if(!productDefaultsHasShape(obj)){return false;}const result = productDefaultsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ProductDefaultsErrors = {_errors: Option<Array<string>>; price: Option<Array<string>>; description: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ProductDefaultsTainted = {price: Option<boolean>; description: Option<boolean>; }; /** Type-safe field controllers for this form */export interface ProductDefaultsFieldControllers {readonly price: FieldController<number>; readonly description: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface ProductDefaultsGigaform {readonly data: ProductDefaults; readonly errors: ProductDefaultsErrors; readonly tainted: ProductDefaultsTainted; readonly fields: ProductDefaultsFieldControllers; validate(): Result<ProductDefaults, Array<{field: string; message: string}>>; reset(overrides?: Partial<ProductDefaults>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function productDefaultsCreateForm(overrides?: Partial<ProductDefaults>): ProductDefaultsGigaform {let data = $state({...productDefaultsDefaultValue(),...overrides}); let errors = $state<ProductDefaultsErrors>({_errors: Option.none(), price: Option.none(), description: Option.none(), }); let tainted = $state<ProductDefaultsTainted>({price: Option.none(), description: Option.none(), }); const fields: ProductDefaultsFieldControllers = {price: {path: ["price" ]as const, name: "price" , constraints: { required: true }, label: "Price" , get: ()=>data.price, set: (value: number)=>{data.price = value;}, transform: (value: number): number =>value,getError: ()=>errors.price, setError: (value: Option<Array<string>>)=>{errors.price = value;}, getTainted: ()=>tainted.price, setTainted: (value: Option<boolean>)=>{tainted.price = value;}, validate: (): Array<string>=>{const fieldErrors = productDefaultsValidateField("price", data.price); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},description: {path: ["description" ]as const, name: "description" , constraints: { required: true }, label: "Description" , get: ()=>data.description, set: (value: string)=>{data.description = value;}, transform: (value: string): string =>value,getError: ()=>errors.description, setError: (value: Option<Array<string>>)=>{errors.description = value;}, getTainted: ()=>tainted.description, setTainted: (value: Option<boolean>)=>{tainted.description = value;}, validate: (): Array<string>=>{const fieldErrors = productDefaultsValidateField("description", data.description); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<ProductDefaults, Array<{field: string; message: string}>>{return productDefaultsDeserialize(data);}function reset(newOverrides?: Partial<ProductDefaults>): void {data = {...productDefaultsDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), price: Option.none(), description: Option.none(), }; tainted = {price: Option.none(), description: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function productDefaultsFromFormData(formData: FormData): Result<ProductDefaults, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const price Str = formData.get("price" ); obj.price = price Str? parseFloat(price Str as string): 0; if(obj.price!== undefined && isNaN(obj.price as number))obj.price = 0;}obj.description = formData.get("description" )?? "" ;return productDefaultsDeserialize(obj);}

export const ProductDefaults = {
  defaultValue: productDefaultsDefaultValue,
  serialize: productDefaultsSerialize,
  serializeWithContext: productDefaultsSerializeWithContext,
  deserialize: productDefaultsDeserialize,
  deserializeWithContext: productDefaultsDeserializeWithContext,
  validateFields: productDefaultsValidateFields,
  hasShape: productDefaultsHasShape,
  is: productDefaultsIs,
  createForm: productDefaultsCreateForm,
  fromFormData: productDefaultsFromFormData
} as const;


export interface Viewed {
    durationSeconds: number | null;
    source: string | null;
}

export function viewedDefaultValue(): Viewed {return {durationSeconds: null,
                            source: null, }as Viewed;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function viewedSerialize(value: Viewed): string {const ctx = SerializeContext.create(); return JSON.stringify(viewedSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function viewedSerializeWithContext(value: Viewed, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Viewed" , __id,}; result["durationSeconds" ]= value.durationSeconds; result["source" ]= value.source; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function viewedDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Viewed } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = viewedDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Viewed.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function viewedDeserializeWithContext(value: any, ctx: DeserializeContext): Viewed | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Viewed.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("durationSeconds" in obj)){errors.push({field: "durationSeconds" , message: "missing required field" });}if(!("source" in obj)){errors.push({field: "source" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_durationSeconds = obj["durationSeconds" ]as number | null; instance.durationSeconds = __raw_durationSeconds; }{const __raw_source = obj["source" ]as string | null; instance.source = __raw_source; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Viewed;}export function viewedValidateField<K extends keyof Viewed>(field: K, value: Viewed[K]): Array<{field: string; message: string}>{return[]; }export function viewedValidateFields(partial: Partial<Viewed>): Array<{field: string; message: string}>{return[]; }export function viewedHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "durationSeconds" in o && "source" in o;}export function viewedIs(obj: unknown): obj is Viewed {if(!viewedHasShape(obj)){return false;}const result = viewedDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ViewedErrors = {_errors: Option<Array<string>>; durationSeconds: Option<Array<string>>; source: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ViewedTainted = {durationSeconds: Option<boolean>; source: Option<boolean>; }; /** Type-safe field controllers for this form */export interface ViewedFieldControllers {readonly durationSeconds: FieldController<number | null>; readonly source: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface ViewedGigaform {readonly data: Viewed; readonly errors: ViewedErrors; readonly tainted: ViewedTainted; readonly fields: ViewedFieldControllers; validate(): Result<Viewed, Array<{field: string; message: string}>>; reset(overrides?: Partial<Viewed>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function viewedCreateForm(overrides?: Partial<Viewed>): ViewedGigaform {let data = $state({...viewedDefaultValue(),...overrides}); let errors = $state<ViewedErrors>({_errors: Option.none(), durationSeconds: Option.none(), source: Option.none(), }); let tainted = $state<ViewedTainted>({durationSeconds: Option.none(), source: Option.none(), }); const fields: ViewedFieldControllers = {durationSeconds: {path: ["durationSeconds" ]as const, name: "durationSeconds" , constraints: { required: true }, get: ()=>data.durationSeconds, set: (value: number | null)=>{data.durationSeconds = value;}, transform: (value: number | null): number | null =>value,getError: ()=>errors.durationSeconds, setError: (value: Option<Array<string>>)=>{errors.durationSeconds = value;}, getTainted: ()=>tainted.durationSeconds, setTainted: (value: Option<boolean>)=>{tainted.durationSeconds = value;}, validate: (): Array<string>=>{const fieldErrors = viewedValidateField("durationSeconds", data.durationSeconds); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},source: {path: ["source" ]as const, name: "source" , constraints: { required: true }, get: ()=>data.source, set: (value: string | null)=>{data.source = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.source, setError: (value: Option<Array<string>>)=>{errors.source = value;}, getTainted: ()=>tainted.source, setTainted: (value: Option<boolean>)=>{tainted.source = value;}, validate: (): Array<string>=>{const fieldErrors = viewedValidateField("source", data.source); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Viewed, Array<{field: string; message: string}>>{return viewedDeserialize(data);}function reset(newOverrides?: Partial<Viewed>): void {data = {...viewedDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), durationSeconds: Option.none(), source: Option.none(), }; tainted = {durationSeconds: Option.none(), source: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function viewedFromFormData(formData: FormData): Result<Viewed, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const durationSeconds Str = formData.get("durationSeconds" ); obj.durationSeconds = durationSeconds Str? parseFloat(durationSeconds Str as string): 0; if(obj.durationSeconds!== undefined && isNaN(obj.durationSeconds as number))obj.durationSeconds = 0;}obj.source = formData.get("source" )?? "" ;return viewedDeserialize(obj);}

export const Viewed = {
  defaultValue: viewedDefaultValue,
  serialize: viewedSerialize,
  serializeWithContext: viewedSerializeWithContext,
  deserialize: viewedDeserialize,
  deserializeWithContext: viewedDeserializeWithContext,
  validateFields: viewedValidateFields,
  hasShape: viewedHasShape,
  is: viewedIs,
  createForm: viewedCreateForm,
  fromFormData: viewedFromFormData
} as const;


export interface WeeklyRecurrenceRule {
    quantityOfWeeks: number;
    weekdays: Weekday[];
}

export function weeklyRecurrenceRuleDefaultValue(): WeeklyRecurrenceRule {return {quantityOfWeeks: 0,
                            weekdays: [], }as WeeklyRecurrenceRule;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function weeklyRecurrenceRuleSerialize(value: WeeklyRecurrenceRule): string {const ctx = SerializeContext.create(); return JSON.stringify(weeklyRecurrenceRuleSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function weeklyRecurrenceRuleSerializeWithContext(value: WeeklyRecurrenceRule, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "WeeklyRecurrenceRule" , __id,}; result["quantityOfWeeks" ]= value.quantityOfWeeks; result["weekdays" ]= value.weekdays.map((item)=>weekdaySerializeWithContext(item, ctx)); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function weeklyRecurrenceRuleDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: WeeklyRecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = weeklyRecurrenceRuleDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "WeeklyRecurrenceRule.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function weeklyRecurrenceRuleDeserializeWithContext(value: any, ctx: DeserializeContext): WeeklyRecurrenceRule | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "WeeklyRecurrenceRule.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("quantityOfWeeks" in obj)){errors.push({field: "quantityOfWeeks" , message: "missing required field" });}if(!("weekdays" in obj)){errors.push({field: "weekdays" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_quantityOfWeeks = obj["quantityOfWeeks" ]as number; instance.quantityOfWeeks = __raw_quantityOfWeeks; }{const __raw_weekdays = obj["weekdays" ]as Weekday[]; if(Array.isArray(__raw_weekdays)){instance.weekdays = __raw_weekdays as Weekday[];}}if(errors.length>0){throw new DeserializeError(errors);}return instance as WeeklyRecurrenceRule;}export function weeklyRecurrenceRuleValidateField<K extends keyof WeeklyRecurrenceRule>(field: K, value: WeeklyRecurrenceRule[K]): Array<{field: string; message: string}>{return[]; }export function weeklyRecurrenceRuleValidateFields(partial: Partial<WeeklyRecurrenceRule>): Array<{field: string; message: string}>{return[]; }export function weeklyRecurrenceRuleHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "quantityOfWeeks" in o && "weekdays" in o;}export function weeklyRecurrenceRuleIs(obj: unknown): obj is WeeklyRecurrenceRule {if(!weeklyRecurrenceRuleHasShape(obj)){return false;}const result = weeklyRecurrenceRuleDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type WeeklyRecurrenceRuleErrors = {_errors: Option<Array<string>>; quantityOfWeeks: Option<Array<string>>; weekdays: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type WeeklyRecurrenceRuleTainted = {quantityOfWeeks: Option<boolean>; weekdays: Option<boolean>; }; /** Type-safe field controllers for this form */export interface WeeklyRecurrenceRuleFieldControllers {readonly quantityOfWeeks: FieldController<number>; readonly weekdays: ArrayFieldController<Weekday>; }/** Gigaform instance containing reactive state and field controllers */export interface WeeklyRecurrenceRuleGigaform {readonly data: WeeklyRecurrenceRule; readonly errors: WeeklyRecurrenceRuleErrors; readonly tainted: WeeklyRecurrenceRuleTainted; readonly fields: WeeklyRecurrenceRuleFieldControllers; validate(): Result<WeeklyRecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<WeeklyRecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function weeklyRecurrenceRuleCreateForm(overrides?: Partial<WeeklyRecurrenceRule>): WeeklyRecurrenceRuleGigaform {let data = $state({...weeklyRecurrenceRuleDefaultValue(),...overrides}); let errors = $state<WeeklyRecurrenceRuleErrors>({_errors: Option.none(), quantityOfWeeks: Option.none(), weekdays: Option.none(), }); let tainted = $state<WeeklyRecurrenceRuleTainted>({quantityOfWeeks: Option.none(), weekdays: Option.none(), }); const fields: WeeklyRecurrenceRuleFieldControllers = {quantityOfWeeks: {path: ["quantityOfWeeks" ]as const, name: "quantityOfWeeks" , constraints: { required: true }, get: ()=>data.quantityOfWeeks, set: (value: number)=>{data.quantityOfWeeks = value;}, transform: (value: number): number =>value,getError: ()=>errors.quantityOfWeeks, setError: (value: Option<Array<string>>)=>{errors.quantityOfWeeks = value;}, getTainted: ()=>tainted.quantityOfWeeks, setTainted: (value: Option<boolean>)=>{tainted.quantityOfWeeks = value;}, validate: (): Array<string>=>{const fieldErrors = weeklyRecurrenceRuleValidateField("quantityOfWeeks", data.quantityOfWeeks); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},weekdays: {path: ["weekdays" ]as const, name: "weekdays" , constraints: { required: true }, get: ()=>data.weekdays, set: (value: Weekday[])=>{data.weekdays = value;}, transform: (value: Weekday[]): Weekday[] =>value,getError: ()=>errors.weekdays, setError: (value: Option<Array<string>>)=>{errors.weekdays = value;}, getTainted: ()=>tainted.weekdays, setTainted: (value: Option<boolean>)=>{tainted.weekdays = value;}, validate: (): Array<string>=>{const fieldErrors = weeklyRecurrenceRuleValidateField("weekdays", data.weekdays); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["weekdays" , index]as const, name: `weekdays.${index}` , constraints: {required: true}, get: ()=>data.weekdays[index]!, set: (value: Weekday)=>{data.weekdays[index]= value;}, transform: (value: Weekday): Weekday =>value, getError: ()=>errors.weekdays, setError: (value: Option<Array<string>>)=>{errors.weekdays = value;}, getTainted: ()=>tainted.weekdays, setTainted: (value: Option<boolean>)=>{tainted.weekdays = value;}, validate: (): Array<string>=>[],}), push: (item: Weekday)=>{data.weekdays.push(item);}, remove: (index: number)=>{data.weekdays.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.weekdays[a]!; data.weekdays[a]= data.weekdays[b]!; data.weekdays[b]= tmp;},},}; function validate(): Result<WeeklyRecurrenceRule, Array<{field: string; message: string}>>{return weeklyRecurrenceRuleDeserialize(data);}function reset(newOverrides?: Partial<WeeklyRecurrenceRule>): void {data = {...weeklyRecurrenceRuleDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), quantityOfWeeks: Option.none(), weekdays: Option.none(), }; tainted = {quantityOfWeeks: Option.none(), weekdays: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function weeklyRecurrenceRuleFromFormData(formData: FormData): Result<WeeklyRecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const quantityOfWeeks Str = formData.get("quantityOfWeeks" ); obj.quantityOfWeeks = quantityOfWeeks Str? parseFloat(quantityOfWeeks Str as string): 0; if(obj.quantityOfWeeks!== undefined && isNaN(obj.quantityOfWeeks as number))obj.quantityOfWeeks = 0;}{const weekdays Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("weekdays." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("weekdays." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("weekdays." + idx + "." )){const fieldName = key.slice("weekdays." .length + String(idx).length + 1); item[fieldName]= value;}}weekdays Items.push(item);}idx ++; if(idx>1000)break;}obj.weekdays = weekdays Items;}return weeklyRecurrenceRuleDeserialize(obj);}

export const WeeklyRecurrenceRule = {
  defaultValue: weeklyRecurrenceRuleDefaultValue,
  serialize: weeklyRecurrenceRuleSerialize,
  serializeWithContext: weeklyRecurrenceRuleSerializeWithContext,
  deserialize: weeklyRecurrenceRuleDeserialize,
  deserializeWithContext: weeklyRecurrenceRuleDeserializeWithContext,
  validateFields: weeklyRecurrenceRuleValidateFields,
  hasShape: weeklyRecurrenceRuleHasShape,
  is: weeklyRecurrenceRuleIs,
  createForm: weeklyRecurrenceRuleCreateForm,
  fromFormData: weeklyRecurrenceRuleFromFormData
} as const;


export interface Paid {
    amount: number | null;
    currency: string | null;
    paymentMethod: string | null;
}

export function paidDefaultValue(): Paid {return {amount: null,
                            currency: null,
                            paymentMethod: null, }as Paid;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function paidSerialize(value: Paid): string {const ctx = SerializeContext.create(); return JSON.stringify(paidSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function paidSerializeWithContext(value: Paid, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Paid" , __id,}; result["amount" ]= value.amount; result["currency" ]= value.currency; result["paymentMethod" ]= value.paymentMethod; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function paidDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Paid } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = paidDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Paid.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function paidDeserializeWithContext(value: any, ctx: DeserializeContext): Paid | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Paid.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("amount" in obj)){errors.push({field: "amount" , message: "missing required field" });}if(!("currency" in obj)){errors.push({field: "currency" , message: "missing required field" });}if(!("paymentMethod" in obj)){errors.push({field: "paymentMethod" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_amount = obj["amount" ]as number | null; instance.amount = __raw_amount; }{const __raw_currency = obj["currency" ]as string | null; instance.currency = __raw_currency; }{const __raw_paymentMethod = obj["paymentMethod" ]as string | null; instance.paymentMethod = __raw_paymentMethod; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Paid;}export function paidValidateField<K extends keyof Paid>(field: K, value: Paid[K]): Array<{field: string; message: string}>{return[]; }export function paidValidateFields(partial: Partial<Paid>): Array<{field: string; message: string}>{return[]; }export function paidHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "amount" in o && "currency" in o && "paymentMethod" in o;}export function paidIs(obj: unknown): obj is Paid {if(!paidHasShape(obj)){return false;}const result = paidDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type PaidErrors = {_errors: Option<Array<string>>; amount: Option<Array<string>>; currency: Option<Array<string>>; paymentMethod: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type PaidTainted = {amount: Option<boolean>; currency: Option<boolean>; paymentMethod: Option<boolean>; }; /** Type-safe field controllers for this form */export interface PaidFieldControllers {readonly amount: FieldController<number | null>; readonly currency: FieldController<string | null>; readonly paymentMethod: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface PaidGigaform {readonly data: Paid; readonly errors: PaidErrors; readonly tainted: PaidTainted; readonly fields: PaidFieldControllers; validate(): Result<Paid, Array<{field: string; message: string}>>; reset(overrides?: Partial<Paid>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function paidCreateForm(overrides?: Partial<Paid>): PaidGigaform {let data = $state({...paidDefaultValue(),...overrides}); let errors = $state<PaidErrors>({_errors: Option.none(), amount: Option.none(), currency: Option.none(), paymentMethod: Option.none(), }); let tainted = $state<PaidTainted>({amount: Option.none(), currency: Option.none(), paymentMethod: Option.none(), }); const fields: PaidFieldControllers = {amount: {path: ["amount" ]as const, name: "amount" , constraints: { required: true }, get: ()=>data.amount, set: (value: number | null)=>{data.amount = value;}, transform: (value: number | null): number | null =>value,getError: ()=>errors.amount, setError: (value: Option<Array<string>>)=>{errors.amount = value;}, getTainted: ()=>tainted.amount, setTainted: (value: Option<boolean>)=>{tainted.amount = value;}, validate: (): Array<string>=>{const fieldErrors = paidValidateField("amount", data.amount); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},currency: {path: ["currency" ]as const, name: "currency" , constraints: { required: true }, get: ()=>data.currency, set: (value: string | null)=>{data.currency = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.currency, setError: (value: Option<Array<string>>)=>{errors.currency = value;}, getTainted: ()=>tainted.currency, setTainted: (value: Option<boolean>)=>{tainted.currency = value;}, validate: (): Array<string>=>{const fieldErrors = paidValidateField("currency", data.currency); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},paymentMethod: {path: ["paymentMethod" ]as const, name: "paymentMethod" , constraints: { required: true }, get: ()=>data.paymentMethod, set: (value: string | null)=>{data.paymentMethod = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.paymentMethod, setError: (value: Option<Array<string>>)=>{errors.paymentMethod = value;}, getTainted: ()=>tainted.paymentMethod, setTainted: (value: Option<boolean>)=>{tainted.paymentMethod = value;}, validate: (): Array<string>=>{const fieldErrors = paidValidateField("paymentMethod", data.paymentMethod); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Paid, Array<{field: string; message: string}>>{return paidDeserialize(data);}function reset(newOverrides?: Partial<Paid>): void {data = {...paidDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), amount: Option.none(), currency: Option.none(), paymentMethod: Option.none(), }; tainted = {amount: Option.none(), currency: Option.none(), paymentMethod: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function paidFromFormData(formData: FormData): Result<Paid, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const amount Str = formData.get("amount" ); obj.amount = amount Str? parseFloat(amount Str as string): 0; if(obj.amount!== undefined && isNaN(obj.amount as number))obj.amount = 0;}obj.currency = formData.get("currency" )?? "" ;obj.paymentMethod = formData.get("paymentMethod" )?? "" ;return paidDeserialize(obj);}

export const Paid = {
  defaultValue: paidDefaultValue,
  serialize: paidSerialize,
  serializeWithContext: paidSerializeWithContext,
  deserialize: paidDeserialize,
  deserializeWithContext: paidDeserializeWithContext,
  validateFields: paidValidateFields,
  hasShape: paidHasShape,
  is: paidIs,
  createForm: paidCreateForm,
  fromFormData: paidFromFormData
} as const;


export interface TaxRate {
    
    id: string;
    
    
    name: string;
    
    
    taxAgency: string;
    
    zip: number;
    
    
    city: string;
    
    
    county: string;
    
    
    state: string;
    
    isActive: boolean;
    
    
    description: string;
    
    
    taxComponents: { [key: string]: number };
}

export function taxRateDefaultValue(): TaxRate {return {id: "",
                            name: "",
                            taxAgency: "",
                            zip: 0,
                            city: "",
                            county: "",
                            state: "",
                            isActive: false,
                            description: "",
                            taxComponents: {}, }as TaxRate;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function taxRateSerialize(value: TaxRate): string {const ctx = SerializeContext.create(); return JSON.stringify(taxRateSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function taxRateSerializeWithContext(value: TaxRate, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "TaxRate" , __id,}; result["id" ]= value.id; result["name" ]= value.name; result["taxAgency" ]= value.taxAgency; result["zip" ]= value.zip; result["city" ]= value.city; result["county" ]= value.county; result["state" ]= value.state; result["isActive" ]= value.isActive; result["description" ]= value.description; result["taxComponents" ]= value.taxComponents; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function taxRateDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: TaxRate } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = taxRateDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "TaxRate.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function taxRateDeserializeWithContext(value: any, ctx: DeserializeContext): TaxRate | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "TaxRate.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("taxAgency" in obj)){errors.push({field: "taxAgency" , message: "missing required field" });}if(!("zip" in obj)){errors.push({field: "zip" , message: "missing required field" });}if(!("city" in obj)){errors.push({field: "city" , message: "missing required field" });}if(!("county" in obj)){errors.push({field: "county" , message: "missing required field" });}if(!("state" in obj)){errors.push({field: "state" , message: "missing required field" });}if(!("isActive" in obj)){errors.push({field: "isActive" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(!("taxComponents" in obj)){errors.push({field: "taxComponents" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_taxAgency = obj["taxAgency" ]as string; 
                if (__raw_taxAgency.length === 0) {
                    errors.push({ field: "taxAgency", message: "must not be empty" });
                }
 instance.taxAgency = __raw_taxAgency; }{const __raw_zip = obj["zip" ]as number; instance.zip = __raw_zip; }{const __raw_city = obj["city" ]as string; 
                if (__raw_city.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
 instance.city = __raw_city; }{const __raw_county = obj["county" ]as string; 
                if (__raw_county.length === 0) {
                    errors.push({ field: "county", message: "must not be empty" });
                }
 instance.county = __raw_county; }{const __raw_state = obj["state" ]as string; 
                if (__raw_state.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
 instance.state = __raw_state; }{const __raw_isActive = obj["isActive" ]as boolean; instance.isActive = __raw_isActive; }{const __raw_description = obj["description" ]as string; 
                if (__raw_description.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 instance.description = __raw_description; }{const __raw_taxComponents = obj["taxComponents" ]as { [key: string]: number }; instance.taxComponents = __raw_taxComponents; }if(errors.length>0){throw new DeserializeError(errors);}return instance as TaxRate;}export function taxRateValidateField<K extends keyof TaxRate>(field: K, value: TaxRate[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "taxAgency" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "taxAgency", message: "must not be empty" });
                }
 break;}case "city" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
 break;}case "county" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "county", message: "must not be empty" });
                }
 break;}case "state" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
 break;}case "description" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 break;}}return errors; }export function taxRateValidateFields(partial: Partial<TaxRate>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("taxAgency" in partial && partial.taxAgency!== undefined){const __val = partial.taxAgency as string; 
                if (__val.length === 0) {
                    errors.push({ field: "taxAgency", message: "must not be empty" });
                }
}if("city" in partial && partial.city!== undefined){const __val = partial.city as string; 
                if (__val.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
}if("county" in partial && partial.county!== undefined){const __val = partial.county as string; 
                if (__val.length === 0) {
                    errors.push({ field: "county", message: "must not be empty" });
                }
}if("state" in partial && partial.state!== undefined){const __val = partial.state as string; 
                if (__val.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
}if("description" in partial && partial.description!== undefined){const __val = partial.description as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
}return errors; }export function taxRateHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "name" in o && "taxAgency" in o && "zip" in o && "city" in o && "county" in o && "state" in o && "isActive" in o && "description" in o && "taxComponents" in o;}export function taxRateIs(obj: unknown): obj is TaxRate {if(!taxRateHasShape(obj)){return false;}const result = taxRateDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type TaxRateErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; name: Option<Array<string>>; taxAgency: Option<Array<string>>; zip: Option<Array<string>>; city: Option<Array<string>>; county: Option<Array<string>>; state: Option<Array<string>>; isActive: Option<Array<string>>; description: Option<Array<string>>; taxComponents: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type TaxRateTainted = {id: Option<boolean>; name: Option<boolean>; taxAgency: Option<boolean>; zip: Option<boolean>; city: Option<boolean>; county: Option<boolean>; state: Option<boolean>; isActive: Option<boolean>; description: Option<boolean>; taxComponents: Option<boolean>; }; /** Type-safe field controllers for this form */export interface TaxRateFieldControllers {readonly id: FieldController<string>; readonly name: FieldController<string>; readonly taxAgency: FieldController<string>; readonly zip: FieldController<number>; readonly city: FieldController<string>; readonly county: FieldController<string>; readonly state: FieldController<string>; readonly isActive: FieldController<boolean>; readonly description: FieldController<string>; readonly taxComponents: FieldController<{ [key: string]: number }>; }/** Gigaform instance containing reactive state and field controllers */export interface TaxRateGigaform {readonly data: TaxRate; readonly errors: TaxRateErrors; readonly tainted: TaxRateTainted; readonly fields: TaxRateFieldControllers; validate(): Result<TaxRate, Array<{field: string; message: string}>>; reset(overrides?: Partial<TaxRate>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function taxRateCreateForm(overrides?: Partial<TaxRate>): TaxRateGigaform {let data = $state({...taxRateDefaultValue(),...overrides}); let errors = $state<TaxRateErrors>({_errors: Option.none(), id: Option.none(), name: Option.none(), taxAgency: Option.none(), zip: Option.none(), city: Option.none(), county: Option.none(), state: Option.none(), isActive: Option.none(), description: Option.none(), taxComponents: Option.none(), }); let tainted = $state<TaxRateTainted>({id: Option.none(), name: Option.none(), taxAgency: Option.none(), zip: Option.none(), city: Option.none(), county: Option.none(), state: Option.none(), isActive: Option.none(), description: Option.none(), taxComponents: Option.none(), }); const fields: TaxRateFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, label: "Name" , get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},taxAgency: {path: ["taxAgency" ]as const, name: "taxAgency" , constraints: { required: true }, label: "Tax Agency" , get: ()=>data.taxAgency, set: (value: string)=>{data.taxAgency = value;}, transform: (value: string): string =>value,getError: ()=>errors.taxAgency, setError: (value: Option<Array<string>>)=>{errors.taxAgency = value;}, getTainted: ()=>tainted.taxAgency, setTainted: (value: Option<boolean>)=>{tainted.taxAgency = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("taxAgency", data.taxAgency); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},zip: {path: ["zip" ]as const, name: "zip" , constraints: { required: true }, label: "Zip" , get: ()=>data.zip, set: (value: number)=>{data.zip = value;}, transform: (value: number): number =>value,getError: ()=>errors.zip, setError: (value: Option<Array<string>>)=>{errors.zip = value;}, getTainted: ()=>tainted.zip, setTainted: (value: Option<boolean>)=>{tainted.zip = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("zip", data.zip); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},city: {path: ["city" ]as const, name: "city" , constraints: { required: true }, label: "City" , get: ()=>data.city, set: (value: string)=>{data.city = value;}, transform: (value: string): string =>value,getError: ()=>errors.city, setError: (value: Option<Array<string>>)=>{errors.city = value;}, getTainted: ()=>tainted.city, setTainted: (value: Option<boolean>)=>{tainted.city = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("city", data.city); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},county: {path: ["county" ]as const, name: "county" , constraints: { required: true }, label: "County" , get: ()=>data.county, set: (value: string)=>{data.county = value;}, transform: (value: string): string =>value,getError: ()=>errors.county, setError: (value: Option<Array<string>>)=>{errors.county = value;}, getTainted: ()=>tainted.county, setTainted: (value: Option<boolean>)=>{tainted.county = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("county", data.county); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},state: {path: ["state" ]as const, name: "state" , constraints: { required: true }, label: "State" , get: ()=>data.state, set: (value: string)=>{data.state = value;}, transform: (value: string): string =>value,getError: ()=>errors.state, setError: (value: Option<Array<string>>)=>{errors.state = value;}, getTainted: ()=>tainted.state, setTainted: (value: Option<boolean>)=>{tainted.state = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("state", data.state); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},isActive: {path: ["isActive" ]as const, name: "isActive" , constraints: { required: true }, label: "Active" , get: ()=>data.isActive, set: (value: boolean)=>{data.isActive = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.isActive, setError: (value: Option<Array<string>>)=>{errors.isActive = value;}, getTainted: ()=>tainted.isActive, setTainted: (value: Option<boolean>)=>{tainted.isActive = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("isActive", data.isActive); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},description: {path: ["description" ]as const, name: "description" , constraints: { required: true }, label: "Description" , get: ()=>data.description, set: (value: string)=>{data.description = value;}, transform: (value: string): string =>value,getError: ()=>errors.description, setError: (value: Option<Array<string>>)=>{errors.description = value;}, getTainted: ()=>tainted.description, setTainted: (value: Option<boolean>)=>{tainted.description = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("description", data.description); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},taxComponents: {path: ["taxComponents" ]as const, name: "taxComponents" , constraints: { required: true }, get: ()=>data.taxComponents, set: (value: { [key: string]: number })=>{data.taxComponents = value;}, transform: (value: { [key: string]: number }): { [key: string]: number } =>value,getError: ()=>errors.taxComponents, setError: (value: Option<Array<string>>)=>{errors.taxComponents = value;}, getTainted: ()=>tainted.taxComponents, setTainted: (value: Option<boolean>)=>{tainted.taxComponents = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("taxComponents", data.taxComponents); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<TaxRate, Array<{field: string; message: string}>>{return taxRateDeserialize(data);}function reset(newOverrides?: Partial<TaxRate>): void {data = {...taxRateDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), name: Option.none(), taxAgency: Option.none(), zip: Option.none(), city: Option.none(), county: Option.none(), state: Option.none(), isActive: Option.none(), description: Option.none(), taxComponents: Option.none(), }; tainted = {id: Option.none(), name: Option.none(), taxAgency: Option.none(), zip: Option.none(), city: Option.none(), county: Option.none(), state: Option.none(), isActive: Option.none(), description: Option.none(), taxComponents: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function taxRateFromFormData(formData: FormData): Result<TaxRate, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.name = formData.get("name" )?? "" ;obj.taxAgency = formData.get("taxAgency" )?? "" ;{const zip Str = formData.get("zip" ); obj.zip = zip Str? parseFloat(zip Str as string): 0; if(obj.zip!== undefined && isNaN(obj.zip as number))obj.zip = 0;}obj.city = formData.get("city" )?? "" ;obj.county = formData.get("county" )?? "" ;obj.state = formData.get("state" )?? "" ;{const isActive Val = formData.get("isActive" ); obj.isActive = isActive Val === "true" || isActive Val === "on" || isActive Val === "1" ;}obj.description = formData.get("description" )?? "" ;obj.taxComponents = formData.get("taxComponents" )?? "" ;return taxRateDeserialize(obj);}

export const TaxRate = {
  defaultValue: taxRateDefaultValue,
  serialize: taxRateSerialize,
  serializeWithContext: taxRateSerializeWithContext,
  deserialize: taxRateDeserialize,
  deserializeWithContext: taxRateDeserializeWithContext,
  validateFields: taxRateValidateFields,
  hasShape: taxRateHasShape,
  is: taxRateIs,
  createForm: taxRateCreateForm,
  fromFormData: taxRateFromFormData
} as const;


export interface Address {
    
    street: string;
    
    city: string;
    
    state: string;
    
    zipcode: string;
}

export function addressDefaultValue(): Address {return {street: "",
                            city: "",
                            state: "",
                            zipcode: "", }as Address;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function addressSerialize(value: Address): string {const ctx = SerializeContext.create(); return JSON.stringify(addressSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function addressSerializeWithContext(value: Address, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Address" , __id,}; result["street" ]= value.street; result["city" ]= value.city; result["state" ]= value.state; result["zipcode" ]= value.zipcode; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function addressDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Address } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = addressDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Address.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function addressDeserializeWithContext(value: any, ctx: DeserializeContext): Address | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Address.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("street" in obj)){errors.push({field: "street" , message: "missing required field" });}if(!("city" in obj)){errors.push({field: "city" , message: "missing required field" });}if(!("state" in obj)){errors.push({field: "state" , message: "missing required field" });}if(!("zipcode" in obj)){errors.push({field: "zipcode" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_street = obj["street" ]as string; 
                if (__raw_street.length === 0) {
                    errors.push({ field: "street", message: "must not be empty" });
                }
 instance.street = __raw_street; }{const __raw_city = obj["city" ]as string; 
                if (__raw_city.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
 instance.city = __raw_city; }{const __raw_state = obj["state" ]as string; 
                if (__raw_state.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
 instance.state = __raw_state; }{const __raw_zipcode = obj["zipcode" ]as string; 
                if (__raw_zipcode.length === 0) {
                    errors.push({ field: "zipcode", message: "must not be empty" });
                }
 instance.zipcode = __raw_zipcode; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Address;}export function addressValidateField<K extends keyof Address>(field: K, value: Address[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "street" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "street", message: "must not be empty" });
                }
 break;}case "city" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
 break;}case "state" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
 break;}case "zipcode" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "zipcode", message: "must not be empty" });
                }
 break;}}return errors; }export function addressValidateFields(partial: Partial<Address>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("street" in partial && partial.street!== undefined){const __val = partial.street as string; 
                if (__val.length === 0) {
                    errors.push({ field: "street", message: "must not be empty" });
                }
}if("city" in partial && partial.city!== undefined){const __val = partial.city as string; 
                if (__val.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
}if("state" in partial && partial.state!== undefined){const __val = partial.state as string; 
                if (__val.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
}if("zipcode" in partial && partial.zipcode!== undefined){const __val = partial.zipcode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "zipcode", message: "must not be empty" });
                }
}return errors; }export function addressHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "street" in o && "city" in o && "state" in o && "zipcode" in o;}export function addressIs(obj: unknown): obj is Address {if(!addressHasShape(obj)){return false;}const result = addressDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type AddressErrors = {_errors: Option<Array<string>>; street: Option<Array<string>>; city: Option<Array<string>>; state: Option<Array<string>>; zipcode: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type AddressTainted = {street: Option<boolean>; city: Option<boolean>; state: Option<boolean>; zipcode: Option<boolean>; }; /** Type-safe field controllers for this form */export interface AddressFieldControllers {readonly street: FieldController<string>; readonly city: FieldController<string>; readonly state: FieldController<string>; readonly zipcode: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface AddressGigaform {readonly data: Address; readonly errors: AddressErrors; readonly tainted: AddressTainted; readonly fields: AddressFieldControllers; validate(): Result<Address, Array<{field: string; message: string}>>; reset(overrides?: Partial<Address>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function addressCreateForm(overrides?: Partial<Address>): AddressGigaform {let data = $state({...addressDefaultValue(),...overrides}); let errors = $state<AddressErrors>({_errors: Option.none(), street: Option.none(), city: Option.none(), state: Option.none(), zipcode: Option.none(), }); let tainted = $state<AddressTainted>({street: Option.none(), city: Option.none(), state: Option.none(), zipcode: Option.none(), }); const fields: AddressFieldControllers = {street: {path: ["street" ]as const, name: "street" , constraints: { required: true }, get: ()=>data.street, set: (value: string)=>{data.street = value;}, transform: (value: string): string =>value,getError: ()=>errors.street, setError: (value: Option<Array<string>>)=>{errors.street = value;}, getTainted: ()=>tainted.street, setTainted: (value: Option<boolean>)=>{tainted.street = value;}, validate: (): Array<string>=>{const fieldErrors = addressValidateField("street", data.street); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},city: {path: ["city" ]as const, name: "city" , constraints: { required: true }, get: ()=>data.city, set: (value: string)=>{data.city = value;}, transform: (value: string): string =>value,getError: ()=>errors.city, setError: (value: Option<Array<string>>)=>{errors.city = value;}, getTainted: ()=>tainted.city, setTainted: (value: Option<boolean>)=>{tainted.city = value;}, validate: (): Array<string>=>{const fieldErrors = addressValidateField("city", data.city); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},state: {path: ["state" ]as const, name: "state" , constraints: { required: true }, get: ()=>data.state, set: (value: string)=>{data.state = value;}, transform: (value: string): string =>value,getError: ()=>errors.state, setError: (value: Option<Array<string>>)=>{errors.state = value;}, getTainted: ()=>tainted.state, setTainted: (value: Option<boolean>)=>{tainted.state = value;}, validate: (): Array<string>=>{const fieldErrors = addressValidateField("state", data.state); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},zipcode: {path: ["zipcode" ]as const, name: "zipcode" , constraints: { required: true }, get: ()=>data.zipcode, set: (value: string)=>{data.zipcode = value;}, transform: (value: string): string =>value,getError: ()=>errors.zipcode, setError: (value: Option<Array<string>>)=>{errors.zipcode = value;}, getTainted: ()=>tainted.zipcode, setTainted: (value: Option<boolean>)=>{tainted.zipcode = value;}, validate: (): Array<string>=>{const fieldErrors = addressValidateField("zipcode", data.zipcode); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Address, Array<{field: string; message: string}>>{return addressDeserialize(data);}function reset(newOverrides?: Partial<Address>): void {data = {...addressDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), street: Option.none(), city: Option.none(), state: Option.none(), zipcode: Option.none(), }; tainted = {street: Option.none(), city: Option.none(), state: Option.none(), zipcode: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function addressFromFormData(formData: FormData): Result<Address, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.street = formData.get("street" )?? "" ;obj.city = formData.get("city" )?? "" ;obj.state = formData.get("state" )?? "" ;obj.zipcode = formData.get("zipcode" )?? "" ;return addressDeserialize(obj);}

export const Address = {
  defaultValue: addressDefaultValue,
  serialize: addressSerialize,
  serializeWithContext: addressSerializeWithContext,
  deserialize: addressDeserialize,
  deserializeWithContext: addressDeserializeWithContext,
  validateFields: addressValidateFields,
  hasShape: addressHasShape,
  is: addressIs,
  createForm: addressCreateForm,
  fromFormData: addressFromFormData
} as const;


export interface Lead {
    
    id: string;
    
    number: number | null;
    
    accepted: boolean;
    
    probability: number;
    
    
    priority: Priority;
    
    dueDate: string | null;
    
    closeDate: string | null;
    
    value: number;
    
    
    stage: LeadStage;
    
    
    status: string;
    
    description: string | null;
    
    
    nextStep: NextStep;
    
    favorite: boolean;
    
    dateAdded: string | null;
    
    taxRate: (string | TaxRate) | null;
    
    
    sector: Sector;
    
    leadName: AccountName;
    
    phones: PhoneNumber[];
    
    email: Email;
    
    leadSource: string | null;
    
    
    site: string | Site;
    
    
    memo: string;
    
    needsReview: boolean;
    
    hasAlert: boolean;
    
    salesRep: Represents[] | null;
    
    color: string | null;
    
    
    accountType: string;
    
    
    subtype: string;
    
    isTaxExempt: boolean;
    
    
    paymentTerms: string;
    
    tags: string[];
    
    customFields: [string, string][];
}

export function leadDefaultValue(): Lead {return {id: "",
                            number: null,
                            accepted: false,
                            probability: 0,
                            priority: "Medium",
                            dueDate: null,
                            closeDate: null,
                            value: 0,
                            stage: "Open",
                            status: "",
                            description: null,
                            nextStep: "InitialContact",
                            favorite: false,
                            dateAdded: null,
                            taxRate: null,
                            sector: "Residential",
                            leadName: accountNameDefaultValue(),
                            phones: [],
                            email: emailDefaultValue(),
                            leadSource: null,
                            site: "",
                            memo: "",
                            needsReview: false,
                            hasAlert: false,
                            salesRep: null,
                            color: null,
                            accountType: "",
                            subtype: "",
                            isTaxExempt: false,
                            paymentTerms: "",
                            tags: [],
                            customFields: [], }as Lead;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function leadSerialize(value: Lead): string {const ctx = SerializeContext.create(); return JSON.stringify(leadSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function leadSerializeWithContext(value: Lead, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Lead" , __id,}; result["id" ]= value.id; result["number" ]= value.number; result["accepted" ]= value.accepted; result["probability" ]= value.probability; result["priority" ]= prioritySerializeWithContext(value.priority, ctx); result["dueDate" ]= value.dueDate; result["closeDate" ]= value.closeDate; result["value" ]= value.value; result["stage" ]= leadStageSerializeWithContext(value.stage, ctx); result["status" ]= value.status; result["description" ]= value.description; result["nextStep" ]= nextStepSerializeWithContext(value.nextStep, ctx); result["favorite" ]= value.favorite; result["dateAdded" ]= value.dateAdded; if(value.taxRate!== null){result["taxRate" ]= value.taxRate; }else {result["taxRate" ]= null;}result["sector" ]= sectorSerializeWithContext(value.sector, ctx); result["leadName" ]= accountNameSerializeWithContext(value.leadName, ctx); result["phones" ]= value.phones.map((item)=>phoneNumberSerializeWithContext(item, ctx)); result["email" ]= emailSerializeWithContext(value.email, ctx); result["leadSource" ]= value.leadSource; result["site" ]= value.site; result["memo" ]= value.memo; result["needsReview" ]= value.needsReview; result["hasAlert" ]= value.hasAlert; if(value.salesRep!== null){result["salesRep" ]= value.salesRep; }else {result["salesRep" ]= null;}result["color" ]= value.color; result["accountType" ]= value.accountType; result["subtype" ]= value.subtype; result["isTaxExempt" ]= value.isTaxExempt; result["paymentTerms" ]= value.paymentTerms; result["tags" ]= value.tags; result["customFields" ]= value.customFields; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function leadDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Lead } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = leadDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Lead.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function leadDeserializeWithContext(value: any, ctx: DeserializeContext): Lead | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Lead.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("number" in obj)){errors.push({field: "number" , message: "missing required field" });}if(!("accepted" in obj)){errors.push({field: "accepted" , message: "missing required field" });}if(!("probability" in obj)){errors.push({field: "probability" , message: "missing required field" });}if(!("priority" in obj)){errors.push({field: "priority" , message: "missing required field" });}if(!("dueDate" in obj)){errors.push({field: "dueDate" , message: "missing required field" });}if(!("closeDate" in obj)){errors.push({field: "closeDate" , message: "missing required field" });}if(!("value" in obj)){errors.push({field: "value" , message: "missing required field" });}if(!("stage" in obj)){errors.push({field: "stage" , message: "missing required field" });}if(!("status" in obj)){errors.push({field: "status" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(!("nextStep" in obj)){errors.push({field: "nextStep" , message: "missing required field" });}if(!("favorite" in obj)){errors.push({field: "favorite" , message: "missing required field" });}if(!("dateAdded" in obj)){errors.push({field: "dateAdded" , message: "missing required field" });}if(!("taxRate" in obj)){errors.push({field: "taxRate" , message: "missing required field" });}if(!("sector" in obj)){errors.push({field: "sector" , message: "missing required field" });}if(!("leadName" in obj)){errors.push({field: "leadName" , message: "missing required field" });}if(!("phones" in obj)){errors.push({field: "phones" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("leadSource" in obj)){errors.push({field: "leadSource" , message: "missing required field" });}if(!("site" in obj)){errors.push({field: "site" , message: "missing required field" });}if(!("memo" in obj)){errors.push({field: "memo" , message: "missing required field" });}if(!("needsReview" in obj)){errors.push({field: "needsReview" , message: "missing required field" });}if(!("hasAlert" in obj)){errors.push({field: "hasAlert" , message: "missing required field" });}if(!("salesRep" in obj)){errors.push({field: "salesRep" , message: "missing required field" });}if(!("color" in obj)){errors.push({field: "color" , message: "missing required field" });}if(!("accountType" in obj)){errors.push({field: "accountType" , message: "missing required field" });}if(!("subtype" in obj)){errors.push({field: "subtype" , message: "missing required field" });}if(!("isTaxExempt" in obj)){errors.push({field: "isTaxExempt" , message: "missing required field" });}if(!("paymentTerms" in obj)){errors.push({field: "paymentTerms" , message: "missing required field" });}if(!("tags" in obj)){errors.push({field: "tags" , message: "missing required field" });}if(!("customFields" in obj)){errors.push({field: "customFields" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_number = obj["number" ]as number | null; instance.number = __raw_number; }{const __raw_accepted = obj["accepted" ]as boolean; instance.accepted = __raw_accepted; }{const __raw_probability = obj["probability" ]as number; instance.probability = __raw_probability; }{const __raw_priority = obj["priority" ]as Priority; {const __result = priorityDeserializeWithContext(__raw_priority, ctx); ctx.assignOrDefer(instance, "priority" , __result);}}{const __raw_dueDate = obj["dueDate" ]as string | null; instance.dueDate = __raw_dueDate; }{const __raw_closeDate = obj["closeDate" ]as string | null; instance.closeDate = __raw_closeDate; }{const __raw_value = obj["value" ]as number; instance.value = __raw_value; }{const __raw_stage = obj["stage" ]as LeadStage; {const __result = leadStageDeserializeWithContext(__raw_stage, ctx); ctx.assignOrDefer(instance, "stage" , __result);}}{const __raw_status = obj["status" ]as string; 
                if (__raw_status.length === 0) {
                    errors.push({ field: "status", message: "must not be empty" });
                }
 instance.status = __raw_status; }{const __raw_description = obj["description" ]as string | null; instance.description = __raw_description; }{const __raw_nextStep = obj["nextStep" ]as NextStep; {const __result = nextStepDeserializeWithContext(__raw_nextStep, ctx); ctx.assignOrDefer(instance, "nextStep" , __result);}}{const __raw_favorite = obj["favorite" ]as boolean; instance.favorite = __raw_favorite; }{const __raw_dateAdded = obj["dateAdded" ]as string | null; instance.dateAdded = __raw_dateAdded; }{const __raw_taxRate = obj["taxRate" ]as (string | TaxRate) | null; if(__raw_taxRate === null){instance.taxRate = null;}else {instance.taxRate = __raw_taxRate; }}{const __raw_sector = obj["sector" ]as Sector; {const __result = sectorDeserializeWithContext(__raw_sector, ctx); ctx.assignOrDefer(instance, "sector" , __result);}}{const __raw_leadName = obj["leadName" ]as AccountName; {const __result = accountNameDeserializeWithContext(__raw_leadName, ctx); ctx.assignOrDefer(instance, "leadName" , __result);}}{const __raw_phones = obj["phones" ]as PhoneNumber[]; if(Array.isArray(__raw_phones)){instance.phones = __raw_phones as PhoneNumber[];}}{const __raw_email = obj["email" ]as Email; {const __result = emailDeserializeWithContext(__raw_email, ctx); ctx.assignOrDefer(instance, "email" , __result);}}{const __raw_leadSource = obj["leadSource" ]as string | null; instance.leadSource = __raw_leadSource; }{const __raw_site = obj["site" ]as string | Site; instance.site = __raw_site; }{const __raw_memo = obj["memo" ]as string; 
                if (__raw_memo.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
 instance.memo = __raw_memo; }{const __raw_needsReview = obj["needsReview" ]as boolean; instance.needsReview = __raw_needsReview; }{const __raw_hasAlert = obj["hasAlert" ]as boolean; instance.hasAlert = __raw_hasAlert; }{const __raw_salesRep = obj["salesRep" ]as Represents[] | null; if(__raw_salesRep === null){instance.salesRep = null;}else {instance.salesRep = __raw_salesRep; }}{const __raw_color = obj["color" ]as string | null; instance.color = __raw_color; }{const __raw_accountType = obj["accountType" ]as string; 
                if (__raw_accountType.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
 instance.accountType = __raw_accountType; }{const __raw_subtype = obj["subtype" ]as string; 
                if (__raw_subtype.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
 instance.subtype = __raw_subtype; }{const __raw_isTaxExempt = obj["isTaxExempt" ]as boolean; instance.isTaxExempt = __raw_isTaxExempt; }{const __raw_paymentTerms = obj["paymentTerms" ]as string; 
                if (__raw_paymentTerms.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
 instance.paymentTerms = __raw_paymentTerms; }{const __raw_tags = obj["tags" ]as string[]; if(Array.isArray(__raw_tags)){instance.tags = __raw_tags as string[];}}{const __raw_customFields = obj["customFields" ]as [string, string][]; if(Array.isArray(__raw_customFields)){instance.customFields = __raw_customFields as [string, string][];}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Lead;}export function leadValidateField<K extends keyof Lead>(field: K, value: Lead[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "status" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "status", message: "must not be empty" });
                }
 break;}case "memo" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
 break;}case "accountType" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
 break;}case "subtype" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
 break;}case "paymentTerms" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
 break;}}return errors; }export function leadValidateFields(partial: Partial<Lead>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("status" in partial && partial.status!== undefined){const __val = partial.status as string; 
                if (__val.length === 0) {
                    errors.push({ field: "status", message: "must not be empty" });
                }
}if("memo" in partial && partial.memo!== undefined){const __val = partial.memo as string; 
                if (__val.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
}if("accountType" in partial && partial.accountType!== undefined){const __val = partial.accountType as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
}if("subtype" in partial && partial.subtype!== undefined){const __val = partial.subtype as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
}if("paymentTerms" in partial && partial.paymentTerms!== undefined){const __val = partial.paymentTerms as string; 
                if (__val.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
}return errors; }export function leadHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "number" in o && "accepted" in o && "probability" in o && "priority" in o && "dueDate" in o && "closeDate" in o && "value" in o && "stage" in o && "status" in o && "description" in o && "nextStep" in o && "favorite" in o && "dateAdded" in o && "taxRate" in o && "sector" in o && "leadName" in o && "phones" in o && "email" in o && "leadSource" in o && "site" in o && "memo" in o && "needsReview" in o && "hasAlert" in o && "salesRep" in o && "color" in o && "accountType" in o && "subtype" in o && "isTaxExempt" in o && "paymentTerms" in o && "tags" in o && "customFields" in o;}export function leadIs(obj: unknown): obj is Lead {if(!leadHasShape(obj)){return false;}const result = leadDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type LeadErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; number: Option<Array<string>>; accepted: Option<Array<string>>; probability: Option<Array<string>>; priority: Option<Array<string>>; dueDate: Option<Array<string>>; closeDate: Option<Array<string>>; value: Option<Array<string>>; stage: Option<Array<string>>; status: Option<Array<string>>; description: Option<Array<string>>; nextStep: Option<Array<string>>; favorite: Option<Array<string>>; dateAdded: Option<Array<string>>; taxRate: Option<Array<string>>; sector: Option<Array<string>>; leadName: Option<Array<string>>; phones: Option<Array<string>>; email: Option<Array<string>>; leadSource: Option<Array<string>>; site: Option<Array<string>>; memo: Option<Array<string>>; needsReview: Option<Array<string>>; hasAlert: Option<Array<string>>; salesRep: Option<Array<string>>; color: Option<Array<string>>; accountType: Option<Array<string>>; subtype: Option<Array<string>>; isTaxExempt: Option<Array<string>>; paymentTerms: Option<Array<string>>; tags: Option<Array<string>>; customFields: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type LeadTainted = {id: Option<boolean>; number: Option<boolean>; accepted: Option<boolean>; probability: Option<boolean>; priority: Option<boolean>; dueDate: Option<boolean>; closeDate: Option<boolean>; value: Option<boolean>; stage: Option<boolean>; status: Option<boolean>; description: Option<boolean>; nextStep: Option<boolean>; favorite: Option<boolean>; dateAdded: Option<boolean>; taxRate: Option<boolean>; sector: Option<boolean>; leadName: Option<boolean>; phones: Option<boolean>; email: Option<boolean>; leadSource: Option<boolean>; site: Option<boolean>; memo: Option<boolean>; needsReview: Option<boolean>; hasAlert: Option<boolean>; salesRep: Option<boolean>; color: Option<boolean>; accountType: Option<boolean>; subtype: Option<boolean>; isTaxExempt: Option<boolean>; paymentTerms: Option<boolean>; tags: Option<boolean>; customFields: Option<boolean>; }; /** Type-safe field controllers for this form */export interface LeadFieldControllers {readonly id: FieldController<string>; readonly number: FieldController<number | null>; readonly accepted: FieldController<boolean>; readonly probability: FieldController<number>; readonly priority: FieldController<Priority>; readonly dueDate: FieldController<string | null>; readonly closeDate: FieldController<string | null>; readonly value: FieldController<number>; readonly stage: FieldController<LeadStage>; readonly status: FieldController<string>; readonly description: FieldController<string | null>; readonly nextStep: FieldController<NextStep>; readonly favorite: FieldController<boolean>; readonly dateAdded: FieldController<string | null>; readonly taxRate: FieldController<(string | TaxRate) | null>; readonly sector: FieldController<Sector>; readonly leadName: FieldController<AccountName>; readonly phones: ArrayFieldController<PhoneNumber>; readonly email: FieldController<Email>; readonly leadSource: FieldController<string | null>; readonly site: FieldController<string | Site>; readonly memo: FieldController<string>; readonly needsReview: FieldController<boolean>; readonly hasAlert: FieldController<boolean>; readonly salesRep: FieldController<Represents[] | null>; readonly color: FieldController<string | null>; readonly accountType: FieldController<string>; readonly subtype: FieldController<string>; readonly isTaxExempt: FieldController<boolean>; readonly paymentTerms: FieldController<string>; readonly tags: ArrayFieldController<string>; readonly customFields: ArrayFieldController<[string, string]>; }/** Gigaform instance containing reactive state and field controllers */export interface LeadGigaform {readonly data: Lead; readonly errors: LeadErrors; readonly tainted: LeadTainted; readonly fields: LeadFieldControllers; validate(): Result<Lead, Array<{field: string; message: string}>>; reset(overrides?: Partial<Lead>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function leadCreateForm(overrides?: Partial<Lead>): LeadGigaform {let data = $state({...leadDefaultValue(),...overrides}); let errors = $state<LeadErrors>({_errors: Option.none(), id: Option.none(), number: Option.none(), accepted: Option.none(), probability: Option.none(), priority: Option.none(), dueDate: Option.none(), closeDate: Option.none(), value: Option.none(), stage: Option.none(), status: Option.none(), description: Option.none(), nextStep: Option.none(), favorite: Option.none(), dateAdded: Option.none(), taxRate: Option.none(), sector: Option.none(), leadName: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), site: Option.none(), memo: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), salesRep: Option.none(), color: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), customFields: Option.none(), }); let tainted = $state<LeadTainted>({id: Option.none(), number: Option.none(), accepted: Option.none(), probability: Option.none(), priority: Option.none(), dueDate: Option.none(), closeDate: Option.none(), value: Option.none(), stage: Option.none(), status: Option.none(), description: Option.none(), nextStep: Option.none(), favorite: Option.none(), dateAdded: Option.none(), taxRate: Option.none(), sector: Option.none(), leadName: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), site: Option.none(), memo: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), salesRep: Option.none(), color: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), customFields: Option.none(), }); const fields: LeadFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},number: {path: ["number" ]as const, name: "number" , constraints: { required: true }, get: ()=>data.number, set: (value: number | null)=>{data.number = value;}, transform: (value: number | null): number | null =>value,getError: ()=>errors.number, setError: (value: Option<Array<string>>)=>{errors.number = value;}, getTainted: ()=>tainted.number, setTainted: (value: Option<boolean>)=>{tainted.number = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("number", data.number); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},accepted: {path: ["accepted" ]as const, name: "accepted" , constraints: { required: true }, get: ()=>data.accepted, set: (value: boolean)=>{data.accepted = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.accepted, setError: (value: Option<Array<string>>)=>{errors.accepted = value;}, getTainted: ()=>tainted.accepted, setTainted: (value: Option<boolean>)=>{tainted.accepted = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("accepted", data.accepted); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},probability: {path: ["probability" ]as const, name: "probability" , constraints: { required: true }, label: "Probability" , get: ()=>data.probability, set: (value: number)=>{data.probability = value;}, transform: (value: number): number =>value,getError: ()=>errors.probability, setError: (value: Option<Array<string>>)=>{errors.probability = value;}, getTainted: ()=>tainted.probability, setTainted: (value: Option<boolean>)=>{tainted.probability = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("probability", data.probability); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},priority: {path: ["priority" ]as const, name: "priority" , constraints: { required: true }, label: "Priority" , get: ()=>data.priority, set: (value: Priority)=>{data.priority = value;}, transform: (value: Priority): Priority =>value,getError: ()=>errors.priority, setError: (value: Option<Array<string>>)=>{errors.priority = value;}, getTainted: ()=>tainted.priority, setTainted: (value: Option<boolean>)=>{tainted.priority = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("priority", data.priority); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},dueDate: {path: ["dueDate" ]as const, name: "dueDate" , constraints: { required: true }, label: "Due Date" , get: ()=>data.dueDate, set: (value: string | null)=>{data.dueDate = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.dueDate, setError: (value: Option<Array<string>>)=>{errors.dueDate = value;}, getTainted: ()=>tainted.dueDate, setTainted: (value: Option<boolean>)=>{tainted.dueDate = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("dueDate", data.dueDate); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},closeDate: {path: ["closeDate" ]as const, name: "closeDate" , constraints: { required: true }, label: "Close Date" , get: ()=>data.closeDate, set: (value: string | null)=>{data.closeDate = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.closeDate, setError: (value: Option<Array<string>>)=>{errors.closeDate = value;}, getTainted: ()=>tainted.closeDate, setTainted: (value: Option<boolean>)=>{tainted.closeDate = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("closeDate", data.closeDate); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},value: {path: ["value" ]as const, name: "value" , constraints: { required: true }, label: "Value" , get: ()=>data.value, set: (value: number)=>{data.value = value;}, transform: (value: number): number =>value,getError: ()=>errors.value, setError: (value: Option<Array<string>>)=>{errors.value = value;}, getTainted: ()=>tainted.value, setTainted: (value: Option<boolean>)=>{tainted.value = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("value", data.value); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},stage: {path: ["stage" ]as const, name: "stage" , constraints: { required: true }, label: "Stage" , get: ()=>data.stage, set: (value: LeadStage)=>{data.stage = value;}, transform: (value: LeadStage): LeadStage =>value,getError: ()=>errors.stage, setError: (value: Option<Array<string>>)=>{errors.stage = value;}, getTainted: ()=>tainted.stage, setTainted: (value: Option<boolean>)=>{tainted.stage = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("stage", data.stage); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},status: {path: ["status" ]as const, name: "status" , constraints: { required: true }, label: "Status" , get: ()=>data.status, set: (value: string)=>{data.status = value;}, transform: (value: string): string =>value,getError: ()=>errors.status, setError: (value: Option<Array<string>>)=>{errors.status = value;}, getTainted: ()=>tainted.status, setTainted: (value: Option<boolean>)=>{tainted.status = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("status", data.status); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},description: {path: ["description" ]as const, name: "description" , constraints: { required: true }, label: "Description" , get: ()=>data.description, set: (value: string | null)=>{data.description = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.description, setError: (value: Option<Array<string>>)=>{errors.description = value;}, getTainted: ()=>tainted.description, setTainted: (value: Option<boolean>)=>{tainted.description = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("description", data.description); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},nextStep: {path: ["nextStep" ]as const, name: "nextStep" , constraints: { required: true }, get: ()=>data.nextStep, set: (value: NextStep)=>{data.nextStep = value;}, transform: (value: NextStep): NextStep =>value,getError: ()=>errors.nextStep, setError: (value: Option<Array<string>>)=>{errors.nextStep = value;}, getTainted: ()=>tainted.nextStep, setTainted: (value: Option<boolean>)=>{tainted.nextStep = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("nextStep", data.nextStep); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},favorite: {path: ["favorite" ]as const, name: "favorite" , constraints: { required: true }, label: "Favorite" , get: ()=>data.favorite, set: (value: boolean)=>{data.favorite = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.favorite, setError: (value: Option<Array<string>>)=>{errors.favorite = value;}, getTainted: ()=>tainted.favorite, setTainted: (value: Option<boolean>)=>{tainted.favorite = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("favorite", data.favorite); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},dateAdded: {path: ["dateAdded" ]as const, name: "dateAdded" , constraints: { required: true }, get: ()=>data.dateAdded, set: (value: string | null)=>{data.dateAdded = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.dateAdded, setError: (value: Option<Array<string>>)=>{errors.dateAdded = value;}, getTainted: ()=>tainted.dateAdded, setTainted: (value: Option<boolean>)=>{tainted.dateAdded = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("dateAdded", data.dateAdded); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},taxRate: {path: ["taxRate" ]as const, name: "taxRate" , constraints: { required: true }, label: "Tax Rate" , get: ()=>data.taxRate, set: (value: (string | TaxRate) | null)=>{data.taxRate = value;}, transform: (value: (string | TaxRate) | null): (string | TaxRate) | null =>value,getError: ()=>errors.taxRate, setError: (value: Option<Array<string>>)=>{errors.taxRate = value;}, getTainted: ()=>tainted.taxRate, setTainted: (value: Option<boolean>)=>{tainted.taxRate = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("taxRate", data.taxRate); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},sector: {path: ["sector" ]as const, name: "sector" , constraints: { required: true }, label: "Sector" , get: ()=>data.sector, set: (value: Sector)=>{data.sector = value;}, transform: (value: Sector): Sector =>value,getError: ()=>errors.sector, setError: (value: Option<Array<string>>)=>{errors.sector = value;}, getTainted: ()=>tainted.sector, setTainted: (value: Option<boolean>)=>{tainted.sector = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("sector", data.sector); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},leadName: {path: ["leadName" ]as const, name: "leadName" , constraints: { required: true }, get: ()=>data.leadName, set: (value: AccountName)=>{data.leadName = value;}, transform: (value: AccountName): AccountName =>value,getError: ()=>errors.leadName, setError: (value: Option<Array<string>>)=>{errors.leadName = value;}, getTainted: ()=>tainted.leadName, setTainted: (value: Option<boolean>)=>{tainted.leadName = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("leadName", data.leadName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},phones: {path: ["phones" ]as const, name: "phones" , constraints: { required: true }, get: ()=>data.phones, set: (value: PhoneNumber[])=>{data.phones = value;}, transform: (value: PhoneNumber[]): PhoneNumber[] =>value,getError: ()=>errors.phones, setError: (value: Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("phones", data.phones); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["phones" , index]as const, name: `phones.${index}` , constraints: {required: true}, get: ()=>data.phones[index]!, set: (value: PhoneNumber)=>{data.phones[index]= value;}, transform: (value: PhoneNumber): PhoneNumber =>value, getError: ()=>errors.phones, setError: (value: Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>[],}), push: (item: PhoneNumber)=>{data.phones.push(item);}, remove: (index: number)=>{data.phones.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.phones[a]!; data.phones[a]= data.phones[b]!; data.phones[b]= tmp;},},email: {path: ["email" ]as const, name: "email" , constraints: { required: true }, label: "Email" , get: ()=>data.email, set: (value: Email)=>{data.email = value;}, transform: (value: Email): Email =>value,getError: ()=>errors.email, setError: (value: Option<Array<string>>)=>{errors.email = value;}, getTainted: ()=>tainted.email, setTainted: (value: Option<boolean>)=>{tainted.email = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("email", data.email); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},leadSource: {path: ["leadSource" ]as const, name: "leadSource" , constraints: { required: true }, label: "Lead Source" , get: ()=>data.leadSource, set: (value: string | null)=>{data.leadSource = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.leadSource, setError: (value: Option<Array<string>>)=>{errors.leadSource = value;}, getTainted: ()=>tainted.leadSource, setTainted: (value: Option<boolean>)=>{tainted.leadSource = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("leadSource", data.leadSource); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},site: {path: ["site" ]as const, name: "site" , constraints: { required: true }, label: "Site" , get: ()=>data.site, set: (value: string | Site)=>{data.site = value;}, transform: (value: string | Site): string | Site =>value,getError: ()=>errors.site, setError: (value: Option<Array<string>>)=>{errors.site = value;}, getTainted: ()=>tainted.site, setTainted: (value: Option<boolean>)=>{tainted.site = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("site", data.site); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},memo: {path: ["memo" ]as const, name: "memo" , constraints: { required: true }, label: "Memo" , get: ()=>data.memo, set: (value: string)=>{data.memo = value;}, transform: (value: string): string =>value,getError: ()=>errors.memo, setError: (value: Option<Array<string>>)=>{errors.memo = value;}, getTainted: ()=>tainted.memo, setTainted: (value: Option<boolean>)=>{tainted.memo = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("memo", data.memo); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},needsReview: {path: ["needsReview" ]as const, name: "needsReview" , constraints: { required: true }, label: "Needs Review" , get: ()=>data.needsReview, set: (value: boolean)=>{data.needsReview = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.needsReview, setError: (value: Option<Array<string>>)=>{errors.needsReview = value;}, getTainted: ()=>tainted.needsReview, setTainted: (value: Option<boolean>)=>{tainted.needsReview = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("needsReview", data.needsReview); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasAlert: {path: ["hasAlert" ]as const, name: "hasAlert" , constraints: { required: true }, label: "Has Alert" , get: ()=>data.hasAlert, set: (value: boolean)=>{data.hasAlert = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasAlert, setError: (value: Option<Array<string>>)=>{errors.hasAlert = value;}, getTainted: ()=>tainted.hasAlert, setTainted: (value: Option<boolean>)=>{tainted.hasAlert = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("hasAlert", data.hasAlert); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},salesRep: {path: ["salesRep" ]as const, name: "salesRep" , constraints: { required: true }, label: "Sales Rep" , get: ()=>data.salesRep, set: (value: Represents[] | null)=>{data.salesRep = value;}, transform: (value: Represents[] | null): Represents[] | null =>value,getError: ()=>errors.salesRep, setError: (value: Option<Array<string>>)=>{errors.salesRep = value;}, getTainted: ()=>tainted.salesRep, setTainted: (value: Option<boolean>)=>{tainted.salesRep = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("salesRep", data.salesRep); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},color: {path: ["color" ]as const, name: "color" , constraints: { required: true }, get: ()=>data.color, set: (value: string | null)=>{data.color = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.color, setError: (value: Option<Array<string>>)=>{errors.color = value;}, getTainted: ()=>tainted.color, setTainted: (value: Option<boolean>)=>{tainted.color = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("color", data.color); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},accountType: {path: ["accountType" ]as const, name: "accountType" , constraints: { required: true }, label: "Account Type" , get: ()=>data.accountType, set: (value: string)=>{data.accountType = value;}, transform: (value: string): string =>value,getError: ()=>errors.accountType, setError: (value: Option<Array<string>>)=>{errors.accountType = value;}, getTainted: ()=>tainted.accountType, setTainted: (value: Option<boolean>)=>{tainted.accountType = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("accountType", data.accountType); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},subtype: {path: ["subtype" ]as const, name: "subtype" , constraints: { required: true }, label: "Subtype" , get: ()=>data.subtype, set: (value: string)=>{data.subtype = value;}, transform: (value: string): string =>value,getError: ()=>errors.subtype, setError: (value: Option<Array<string>>)=>{errors.subtype = value;}, getTainted: ()=>tainted.subtype, setTainted: (value: Option<boolean>)=>{tainted.subtype = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("subtype", data.subtype); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},isTaxExempt: {path: ["isTaxExempt" ]as const, name: "isTaxExempt" , constraints: { required: true }, label: "Tax Exempt" , get: ()=>data.isTaxExempt, set: (value: boolean)=>{data.isTaxExempt = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.isTaxExempt, setError: (value: Option<Array<string>>)=>{errors.isTaxExempt = value;}, getTainted: ()=>tainted.isTaxExempt, setTainted: (value: Option<boolean>)=>{tainted.isTaxExempt = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("isTaxExempt", data.isTaxExempt); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},paymentTerms: {path: ["paymentTerms" ]as const, name: "paymentTerms" , constraints: { required: true }, label: "Payment Terms" , get: ()=>data.paymentTerms, set: (value: string)=>{data.paymentTerms = value;}, transform: (value: string): string =>value,getError: ()=>errors.paymentTerms, setError: (value: Option<Array<string>>)=>{errors.paymentTerms = value;}, getTainted: ()=>tainted.paymentTerms, setTainted: (value: Option<boolean>)=>{tainted.paymentTerms = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("paymentTerms", data.paymentTerms); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},tags: {path: ["tags" ]as const, name: "tags" , constraints: { required: true }, label: "Tags" , get: ()=>data.tags, set: (value: string[])=>{data.tags = value;}, transform: (value: string[]): string[] =>value,getError: ()=>errors.tags, setError: (value: Option<Array<string>>)=>{errors.tags = value;}, getTainted: ()=>tainted.tags, setTainted: (value: Option<boolean>)=>{tainted.tags = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("tags", data.tags); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["tags" , index]as const, name: `tags.${index}` , constraints: {required: true}, get: ()=>data.tags[index]!, set: (value: string)=>{data.tags[index]= value;}, transform: (value: string): string =>value, getError: ()=>errors.tags, setError: (value: Option<Array<string>>)=>{errors.tags = value;}, getTainted: ()=>tainted.tags, setTainted: (value: Option<boolean>)=>{tainted.tags = value;}, validate: (): Array<string>=>[],}), push: (item: string)=>{data.tags.push(item);}, remove: (index: number)=>{data.tags.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.tags[a]!; data.tags[a]= data.tags[b]!; data.tags[b]= tmp;},},customFields: {path: ["customFields" ]as const, name: "customFields" , constraints: { required: true }, get: ()=>data.customFields, set: (value: [string, string][])=>{data.customFields = value;}, transform: (value: [string, string][]): [string, string][] =>value,getError: ()=>errors.customFields, setError: (value: Option<Array<string>>)=>{errors.customFields = value;}, getTainted: ()=>tainted.customFields, setTainted: (value: Option<boolean>)=>{tainted.customFields = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("customFields", data.customFields); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["customFields" , index]as const, name: `customFields.${index}` , constraints: {required: true}, get: ()=>data.customFields[index]!, set: (value: [string, string])=>{data.customFields[index]= value;}, transform: (value: [string, string]): [string, string] =>value, getError: ()=>errors.customFields, setError: (value: Option<Array<string>>)=>{errors.customFields = value;}, getTainted: ()=>tainted.customFields, setTainted: (value: Option<boolean>)=>{tainted.customFields = value;}, validate: (): Array<string>=>[],}), push: (item: [string, string])=>{data.customFields.push(item);}, remove: (index: number)=>{data.customFields.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.customFields[a]!; data.customFields[a]= data.customFields[b]!; data.customFields[b]= tmp;},},}; function validate(): Result<Lead, Array<{field: string; message: string}>>{return leadDeserialize(data);}function reset(newOverrides?: Partial<Lead>): void {data = {...leadDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), number: Option.none(), accepted: Option.none(), probability: Option.none(), priority: Option.none(), dueDate: Option.none(), closeDate: Option.none(), value: Option.none(), stage: Option.none(), status: Option.none(), description: Option.none(), nextStep: Option.none(), favorite: Option.none(), dateAdded: Option.none(), taxRate: Option.none(), sector: Option.none(), leadName: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), site: Option.none(), memo: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), salesRep: Option.none(), color: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), customFields: Option.none(), }; tainted = {id: Option.none(), number: Option.none(), accepted: Option.none(), probability: Option.none(), priority: Option.none(), dueDate: Option.none(), closeDate: Option.none(), value: Option.none(), stage: Option.none(), status: Option.none(), description: Option.none(), nextStep: Option.none(), favorite: Option.none(), dateAdded: Option.none(), taxRate: Option.none(), sector: Option.none(), leadName: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), site: Option.none(), memo: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), salesRep: Option.none(), color: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), customFields: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function leadFromFormData(formData: FormData): Result<Lead, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;{const number Str = formData.get("number" ); obj.number = number Str? parseFloat(number Str as string): 0; if(obj.number!== undefined && isNaN(obj.number as number))obj.number = 0;}{const accepted Val = formData.get("accepted" ); obj.accepted = accepted Val === "true" || accepted Val === "on" || accepted Val === "1" ;}{const probability Str = formData.get("probability" ); obj.probability = probability Str? parseFloat(probability Str as string): 0; if(obj.probability!== undefined && isNaN(obj.probability as number))obj.probability = 0;}{const priority Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("priority." )){const fieldName = key.slice("priority." .length); const parts = fieldName.split("." ); let current = priority Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.priority = priority Obj;}obj.dueDate = formData.get("dueDate" )?? "" ;obj.closeDate = formData.get("closeDate" )?? "" ;{const value Str = formData.get("value" ); obj.value = value Str? parseFloat(value Str as string): 0; if(obj.value!== undefined && isNaN(obj.value as number))obj.value = 0;}{const stage Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("stage." )){const fieldName = key.slice("stage." .length); const parts = fieldName.split("." ); let current = stage Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.stage = stage Obj;}obj.status = formData.get("status" )?? "" ;obj.description = formData.get("description" )?? "" ;{const nextStep Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("nextStep." )){const fieldName = key.slice("nextStep." .length); const parts = fieldName.split("." ); let current = nextStep Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.nextStep = nextStep Obj;}{const favorite Val = formData.get("favorite" ); obj.favorite = favorite Val === "true" || favorite Val === "on" || favorite Val === "1" ;}obj.dateAdded = formData.get("dateAdded" )?? "" ;obj.taxRate = formData.get("taxRate" )?? "" ;{const sector Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("sector." )){const fieldName = key.slice("sector." .length); const parts = fieldName.split("." ); let current = sector Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.sector = sector Obj;}{const leadName Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("leadName." )){const fieldName = key.slice("leadName." .length); const parts = fieldName.split("." ); let current = leadName Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.leadName = leadName Obj;}{const phones Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("phones." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("phones." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("phones." + idx + "." )){const fieldName = key.slice("phones." .length + String(idx).length + 1); item[fieldName]= value;}}phones Items.push(item);}idx ++; if(idx>1000)break;}obj.phones = phones Items;}{const email Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("email." )){const fieldName = key.slice("email." .length); const parts = fieldName.split("." ); let current = email Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.email = email Obj;}obj.leadSource = formData.get("leadSource" )?? "" ;obj.site = formData.get("site" )?? "" ;obj.memo = formData.get("memo" )?? "" ;{const needsReview Val = formData.get("needsReview" ); obj.needsReview = needsReview Val === "true" || needsReview Val === "on" || needsReview Val === "1" ;}{const hasAlert Val = formData.get("hasAlert" ); obj.hasAlert = hasAlert Val === "true" || hasAlert Val === "on" || hasAlert Val === "1" ;}obj.salesRep = formData.get("salesRep" )?? "" ;obj.color = formData.get("color" )?? "" ;obj.accountType = formData.get("accountType" )?? "" ;obj.subtype = formData.get("subtype" )?? "" ;{const isTaxExempt Val = formData.get("isTaxExempt" ); obj.isTaxExempt = isTaxExempt Val === "true" || isTaxExempt Val === "on" || isTaxExempt Val === "1" ;}obj.paymentTerms = formData.get("paymentTerms" )?? "" ;obj.tags = formData.getAll("tags" )as Array<string>;{const customFields Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("customFields." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("customFields." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("customFields." + idx + "." )){const fieldName = key.slice("customFields." .length + String(idx).length + 1); item[fieldName]= value;}}customFields Items.push(item);}idx ++; if(idx>1000)break;}obj.customFields = customFields Items;}return leadDeserialize(obj);}

export const Lead = {
  defaultValue: leadDefaultValue,
  serialize: leadSerialize,
  serializeWithContext: leadSerializeWithContext,
  deserialize: leadDeserialize,
  deserializeWithContext: leadDeserializeWithContext,
  validateFields: leadValidateFields,
  hasShape: leadHasShape,
  is: leadIs,
  createForm: leadCreateForm,
  fromFormData: leadFromFormData
} as const;


export interface AppPermissions {
    applications: Applications[];
    pages: Page[];
    data: Table[];
}

export function appPermissionsDefaultValue(): AppPermissions {return {applications: [],
                            pages: [],
                            data: [], }as AppPermissions;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function appPermissionsSerialize(value: AppPermissions): string {const ctx = SerializeContext.create(); return JSON.stringify(appPermissionsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function appPermissionsSerializeWithContext(value: AppPermissions, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "AppPermissions" , __id,}; result["applications" ]= value.applications.map((item)=>applicationsSerializeWithContext(item, ctx)); result["pages" ]= value.pages.map((item)=>pageSerializeWithContext(item, ctx)); result["data" ]= value.data.map((item)=>tableSerializeWithContext(item, ctx)); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function appPermissionsDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: AppPermissions } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = appPermissionsDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "AppPermissions.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function appPermissionsDeserializeWithContext(value: any, ctx: DeserializeContext): AppPermissions | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "AppPermissions.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("applications" in obj)){errors.push({field: "applications" , message: "missing required field" });}if(!("pages" in obj)){errors.push({field: "pages" , message: "missing required field" });}if(!("data" in obj)){errors.push({field: "data" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_applications = obj["applications" ]as Applications[]; if(Array.isArray(__raw_applications)){instance.applications = __raw_applications as Applications[];}}{const __raw_pages = obj["pages" ]as Page[]; if(Array.isArray(__raw_pages)){instance.pages = __raw_pages as Page[];}}{const __raw_data = obj["data" ]as Table[]; if(Array.isArray(__raw_data)){instance.data = __raw_data as Table[];}}if(errors.length>0){throw new DeserializeError(errors);}return instance as AppPermissions;}export function appPermissionsValidateField<K extends keyof AppPermissions>(field: K, value: AppPermissions[K]): Array<{field: string; message: string}>{return[]; }export function appPermissionsValidateFields(partial: Partial<AppPermissions>): Array<{field: string; message: string}>{return[]; }export function appPermissionsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "applications" in o && "pages" in o && "data" in o;}export function appPermissionsIs(obj: unknown): obj is AppPermissions {if(!appPermissionsHasShape(obj)){return false;}const result = appPermissionsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type AppPermissionsErrors = {_errors: Option<Array<string>>; applications: Option<Array<string>>; pages: Option<Array<string>>; data: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type AppPermissionsTainted = {applications: Option<boolean>; pages: Option<boolean>; data: Option<boolean>; }; /** Type-safe field controllers for this form */export interface AppPermissionsFieldControllers {readonly applications: ArrayFieldController<Applications>; readonly pages: ArrayFieldController<Page>; readonly data: ArrayFieldController<Table>; }/** Gigaform instance containing reactive state and field controllers */export interface AppPermissionsGigaform {readonly data: AppPermissions; readonly errors: AppPermissionsErrors; readonly tainted: AppPermissionsTainted; readonly fields: AppPermissionsFieldControllers; validate(): Result<AppPermissions, Array<{field: string; message: string}>>; reset(overrides?: Partial<AppPermissions>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function appPermissionsCreateForm(overrides?: Partial<AppPermissions>): AppPermissionsGigaform {let data = $state({...appPermissionsDefaultValue(),...overrides}); let errors = $state<AppPermissionsErrors>({_errors: Option.none(), applications: Option.none(), pages: Option.none(), data: Option.none(), }); let tainted = $state<AppPermissionsTainted>({applications: Option.none(), pages: Option.none(), data: Option.none(), }); const fields: AppPermissionsFieldControllers = {applications: {path: ["applications" ]as const, name: "applications" , constraints: { required: true }, get: ()=>data.applications, set: (value: Applications[])=>{data.applications = value;}, transform: (value: Applications[]): Applications[] =>value,getError: ()=>errors.applications, setError: (value: Option<Array<string>>)=>{errors.applications = value;}, getTainted: ()=>tainted.applications, setTainted: (value: Option<boolean>)=>{tainted.applications = value;}, validate: (): Array<string>=>{const fieldErrors = appPermissionsValidateField("applications", data.applications); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["applications" , index]as const, name: `applications.${index}` , constraints: {required: true}, get: ()=>data.applications[index]!, set: (value: Applications)=>{data.applications[index]= value;}, transform: (value: Applications): Applications =>value, getError: ()=>errors.applications, setError: (value: Option<Array<string>>)=>{errors.applications = value;}, getTainted: ()=>tainted.applications, setTainted: (value: Option<boolean>)=>{tainted.applications = value;}, validate: (): Array<string>=>[],}), push: (item: Applications)=>{data.applications.push(item);}, remove: (index: number)=>{data.applications.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.applications[a]!; data.applications[a]= data.applications[b]!; data.applications[b]= tmp;},},pages: {path: ["pages" ]as const, name: "pages" , constraints: { required: true }, get: ()=>data.pages, set: (value: Page[])=>{data.pages = value;}, transform: (value: Page[]): Page[] =>value,getError: ()=>errors.pages, setError: (value: Option<Array<string>>)=>{errors.pages = value;}, getTainted: ()=>tainted.pages, setTainted: (value: Option<boolean>)=>{tainted.pages = value;}, validate: (): Array<string>=>{const fieldErrors = appPermissionsValidateField("pages", data.pages); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["pages" , index]as const, name: `pages.${index}` , constraints: {required: true}, get: ()=>data.pages[index]!, set: (value: Page)=>{data.pages[index]= value;}, transform: (value: Page): Page =>value, getError: ()=>errors.pages, setError: (value: Option<Array<string>>)=>{errors.pages = value;}, getTainted: ()=>tainted.pages, setTainted: (value: Option<boolean>)=>{tainted.pages = value;}, validate: (): Array<string>=>[],}), push: (item: Page)=>{data.pages.push(item);}, remove: (index: number)=>{data.pages.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.pages[a]!; data.pages[a]= data.pages[b]!; data.pages[b]= tmp;},},data: {path: ["data" ]as const, name: "data" , constraints: { required: true }, get: ()=>data.data, set: (value: Table[])=>{data.data = value;}, transform: (value: Table[]): Table[] =>value,getError: ()=>errors.data, setError: (value: Option<Array<string>>)=>{errors.data = value;}, getTainted: ()=>tainted.data, setTainted: (value: Option<boolean>)=>{tainted.data = value;}, validate: (): Array<string>=>{const fieldErrors = appPermissionsValidateField("data", data.data); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["data" , index]as const, name: `data.${index}` , constraints: {required: true}, get: ()=>data.data[index]!, set: (value: Table)=>{data.data[index]= value;}, transform: (value: Table): Table =>value, getError: ()=>errors.data, setError: (value: Option<Array<string>>)=>{errors.data = value;}, getTainted: ()=>tainted.data, setTainted: (value: Option<boolean>)=>{tainted.data = value;}, validate: (): Array<string>=>[],}), push: (item: Table)=>{data.data.push(item);}, remove: (index: number)=>{data.data.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.data[a]!; data.data[a]= data.data[b]!; data.data[b]= tmp;},},}; function validate(): Result<AppPermissions, Array<{field: string; message: string}>>{return appPermissionsDeserialize(data);}function reset(newOverrides?: Partial<AppPermissions>): void {data = {...appPermissionsDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), applications: Option.none(), pages: Option.none(), data: Option.none(), }; tainted = {applications: Option.none(), pages: Option.none(), data: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function appPermissionsFromFormData(formData: FormData): Result<AppPermissions, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const applications Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("applications." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("applications." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("applications." + idx + "." )){const fieldName = key.slice("applications." .length + String(idx).length + 1); item[fieldName]= value;}}applications Items.push(item);}idx ++; if(idx>1000)break;}obj.applications = applications Items;}{const pages Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("pages." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("pages." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("pages." + idx + "." )){const fieldName = key.slice("pages." .length + String(idx).length + 1); item[fieldName]= value;}}pages Items.push(item);}idx ++; if(idx>1000)break;}obj.pages = pages Items;}{const data Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("data." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("data." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("data." + idx + "." )){const fieldName = key.slice("data." .length + String(idx).length + 1); item[fieldName]= value;}}data Items.push(item);}idx ++; if(idx>1000)break;}obj.data = data Items;}return appPermissionsDeserialize(obj);}

export const AppPermissions = {
  defaultValue: appPermissionsDefaultValue,
  serialize: appPermissionsSerialize,
  serializeWithContext: appPermissionsSerializeWithContext,
  deserialize: appPermissionsDeserialize,
  deserializeWithContext: appPermissionsDeserializeWithContext,
  validateFields: appPermissionsValidateFields,
  hasShape: appPermissionsHasShape,
  is: appPermissionsIs,
  createForm: appPermissionsCreateForm,
  fromFormData: appPermissionsFromFormData
} as const;


export interface Company {
    id: string;
    
    legalName: string;
    
    headquarters: string | Site;
    phones: PhoneNumber[];
    
    fax: string;
    
    email: string;
    
    website: string;
    
    taxId: string;
    referenceNumber: number;
    
    postalCodeLookup: string;
    timeZone: string;
    
    defaultTax: string | TaxRate;
    
    defaultTaxLocation: string;
    defaultAreaCode: number;
    
    defaultAccountType: string;
    
    lookupFormatting: string;
    
    accountNameFormat: string;
    merchantServiceProvider: string | null;
    
    dateDisplayStyle: string;
    hasAutoCommission: boolean;
    hasAutoDaylightSavings: boolean;
    hasAutoFmsTracking: boolean;
    hasNotifications: boolean;
    hasRequiredLeadSource: boolean;
    hasRequiredEmail: boolean;
    hasSortServiceItemsAlphabetically: boolean;
    hasAttachOrderToAppointmentEmails: boolean;
    scheduleInterval: number;
    colorsConfig: ColorsConfig;
}

export function companyDefaultValue(): Company {return {id: "",
                            legalName: "",
                            headquarters: "",
                            phones: [],
                            fax: "",
                            email: "",
                            website: "",
                            taxId: "",
                            referenceNumber: 0,
                            postalCodeLookup: "",
                            timeZone: "",
                            defaultTax: "",
                            defaultTaxLocation: "",
                            defaultAreaCode: 0,
                            defaultAccountType: "",
                            lookupFormatting: "",
                            accountNameFormat: "",
                            merchantServiceProvider: null,
                            dateDisplayStyle: "",
                            hasAutoCommission: false,
                            hasAutoDaylightSavings: false,
                            hasAutoFmsTracking: false,
                            hasNotifications: false,
                            hasRequiredLeadSource: false,
                            hasRequiredEmail: false,
                            hasSortServiceItemsAlphabetically: false,
                            hasAttachOrderToAppointmentEmails: false,
                            scheduleInterval: 0,
                            colorsConfig: colorsConfigDefaultValue(), }as Company;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function companySerialize(value: Company): string {const ctx = SerializeContext.create(); return JSON.stringify(companySerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function companySerializeWithContext(value: Company, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Company" , __id,}; result["id" ]= value.id; result["legalName" ]= value.legalName; result["headquarters" ]= value.headquarters; result["phones" ]= value.phones.map((item)=>phoneNumberSerializeWithContext(item, ctx)); result["fax" ]= value.fax; result["email" ]= value.email; result["website" ]= value.website; result["taxId" ]= value.taxId; result["referenceNumber" ]= value.referenceNumber; result["postalCodeLookup" ]= value.postalCodeLookup; result["timeZone" ]= value.timeZone; result["defaultTax" ]= value.defaultTax; result["defaultTaxLocation" ]= value.defaultTaxLocation; result["defaultAreaCode" ]= value.defaultAreaCode; result["defaultAccountType" ]= value.defaultAccountType; result["lookupFormatting" ]= value.lookupFormatting; result["accountNameFormat" ]= value.accountNameFormat; result["merchantServiceProvider" ]= value.merchantServiceProvider; result["dateDisplayStyle" ]= value.dateDisplayStyle; result["hasAutoCommission" ]= value.hasAutoCommission; result["hasAutoDaylightSavings" ]= value.hasAutoDaylightSavings; result["hasAutoFmsTracking" ]= value.hasAutoFmsTracking; result["hasNotifications" ]= value.hasNotifications; result["hasRequiredLeadSource" ]= value.hasRequiredLeadSource; result["hasRequiredEmail" ]= value.hasRequiredEmail; result["hasSortServiceItemsAlphabetically" ]= value.hasSortServiceItemsAlphabetically; result["hasAttachOrderToAppointmentEmails" ]= value.hasAttachOrderToAppointmentEmails; result["scheduleInterval" ]= value.scheduleInterval; result["colorsConfig" ]= colorsConfigSerializeWithContext(value.colorsConfig, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function companyDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Company } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = companyDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Company.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function companyDeserializeWithContext(value: any, ctx: DeserializeContext): Company | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Company.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("legalName" in obj)){errors.push({field: "legalName" , message: "missing required field" });}if(!("headquarters" in obj)){errors.push({field: "headquarters" , message: "missing required field" });}if(!("phones" in obj)){errors.push({field: "phones" , message: "missing required field" });}if(!("fax" in obj)){errors.push({field: "fax" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("website" in obj)){errors.push({field: "website" , message: "missing required field" });}if(!("taxId" in obj)){errors.push({field: "taxId" , message: "missing required field" });}if(!("referenceNumber" in obj)){errors.push({field: "referenceNumber" , message: "missing required field" });}if(!("postalCodeLookup" in obj)){errors.push({field: "postalCodeLookup" , message: "missing required field" });}if(!("timeZone" in obj)){errors.push({field: "timeZone" , message: "missing required field" });}if(!("defaultTax" in obj)){errors.push({field: "defaultTax" , message: "missing required field" });}if(!("defaultTaxLocation" in obj)){errors.push({field: "defaultTaxLocation" , message: "missing required field" });}if(!("defaultAreaCode" in obj)){errors.push({field: "defaultAreaCode" , message: "missing required field" });}if(!("defaultAccountType" in obj)){errors.push({field: "defaultAccountType" , message: "missing required field" });}if(!("lookupFormatting" in obj)){errors.push({field: "lookupFormatting" , message: "missing required field" });}if(!("accountNameFormat" in obj)){errors.push({field: "accountNameFormat" , message: "missing required field" });}if(!("merchantServiceProvider" in obj)){errors.push({field: "merchantServiceProvider" , message: "missing required field" });}if(!("dateDisplayStyle" in obj)){errors.push({field: "dateDisplayStyle" , message: "missing required field" });}if(!("hasAutoCommission" in obj)){errors.push({field: "hasAutoCommission" , message: "missing required field" });}if(!("hasAutoDaylightSavings" in obj)){errors.push({field: "hasAutoDaylightSavings" , message: "missing required field" });}if(!("hasAutoFmsTracking" in obj)){errors.push({field: "hasAutoFmsTracking" , message: "missing required field" });}if(!("hasNotifications" in obj)){errors.push({field: "hasNotifications" , message: "missing required field" });}if(!("hasRequiredLeadSource" in obj)){errors.push({field: "hasRequiredLeadSource" , message: "missing required field" });}if(!("hasRequiredEmail" in obj)){errors.push({field: "hasRequiredEmail" , message: "missing required field" });}if(!("hasSortServiceItemsAlphabetically" in obj)){errors.push({field: "hasSortServiceItemsAlphabetically" , message: "missing required field" });}if(!("hasAttachOrderToAppointmentEmails" in obj)){errors.push({field: "hasAttachOrderToAppointmentEmails" , message: "missing required field" });}if(!("scheduleInterval" in obj)){errors.push({field: "scheduleInterval" , message: "missing required field" });}if(!("colorsConfig" in obj)){errors.push({field: "colorsConfig" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_legalName = obj["legalName" ]as string; 
                if (__raw_legalName.length === 0) {
                    errors.push({ field: "legalName", message: "must not be empty" });
                }
 instance.legalName = __raw_legalName; }{const __raw_headquarters = obj["headquarters" ]as string | Site; instance.headquarters = __raw_headquarters; }{const __raw_phones = obj["phones" ]as PhoneNumber[]; if(Array.isArray(__raw_phones)){instance.phones = __raw_phones as PhoneNumber[];}}{const __raw_fax = obj["fax" ]as string; 
                if (__raw_fax.length === 0) {
                    errors.push({ field: "fax", message: "must not be empty" });
                }
 instance.fax = __raw_fax; }{const __raw_email = obj["email" ]as string; 
                if (__raw_email.length === 0) {
                    errors.push({ field: "email", message: "must not be empty" });
                }
 instance.email = __raw_email; }{const __raw_website = obj["website" ]as string; 
                if (__raw_website.length === 0) {
                    errors.push({ field: "website", message: "must not be empty" });
                }
 instance.website = __raw_website; }{const __raw_taxId = obj["taxId" ]as string; 
                if (__raw_taxId.length === 0) {
                    errors.push({ field: "taxId", message: "must not be empty" });
                }
 instance.taxId = __raw_taxId; }{const __raw_referenceNumber = obj["referenceNumber" ]as number; instance.referenceNumber = __raw_referenceNumber; }{const __raw_postalCodeLookup = obj["postalCodeLookup" ]as string; 
                if (__raw_postalCodeLookup.length === 0) {
                    errors.push({ field: "postalCodeLookup", message: "must not be empty" });
                }
 instance.postalCodeLookup = __raw_postalCodeLookup; }{const __raw_timeZone = obj["timeZone" ]as string; instance.timeZone = __raw_timeZone; }{const __raw_defaultTax = obj["defaultTax" ]as string | TaxRate; instance.defaultTax = __raw_defaultTax; }{const __raw_defaultTaxLocation = obj["defaultTaxLocation" ]as string; 
                if (__raw_defaultTaxLocation.length === 0) {
                    errors.push({ field: "defaultTaxLocation", message: "must not be empty" });
                }
 instance.defaultTaxLocation = __raw_defaultTaxLocation; }{const __raw_defaultAreaCode = obj["defaultAreaCode" ]as number; instance.defaultAreaCode = __raw_defaultAreaCode; }{const __raw_defaultAccountType = obj["defaultAccountType" ]as string; 
                if (__raw_defaultAccountType.length === 0) {
                    errors.push({ field: "defaultAccountType", message: "must not be empty" });
                }
 instance.defaultAccountType = __raw_defaultAccountType; }{const __raw_lookupFormatting = obj["lookupFormatting" ]as string; 
                if (__raw_lookupFormatting.length === 0) {
                    errors.push({ field: "lookupFormatting", message: "must not be empty" });
                }
 instance.lookupFormatting = __raw_lookupFormatting; }{const __raw_accountNameFormat = obj["accountNameFormat" ]as string; 
                if (__raw_accountNameFormat.length === 0) {
                    errors.push({ field: "accountNameFormat", message: "must not be empty" });
                }
 instance.accountNameFormat = __raw_accountNameFormat; }{const __raw_merchantServiceProvider = obj["merchantServiceProvider" ]as string | null; instance.merchantServiceProvider = __raw_merchantServiceProvider; }{const __raw_dateDisplayStyle = obj["dateDisplayStyle" ]as string; 
                if (__raw_dateDisplayStyle.length === 0) {
                    errors.push({ field: "dateDisplayStyle", message: "must not be empty" });
                }
 instance.dateDisplayStyle = __raw_dateDisplayStyle; }{const __raw_hasAutoCommission = obj["hasAutoCommission" ]as boolean; instance.hasAutoCommission = __raw_hasAutoCommission; }{const __raw_hasAutoDaylightSavings = obj["hasAutoDaylightSavings" ]as boolean; instance.hasAutoDaylightSavings = __raw_hasAutoDaylightSavings; }{const __raw_hasAutoFmsTracking = obj["hasAutoFmsTracking" ]as boolean; instance.hasAutoFmsTracking = __raw_hasAutoFmsTracking; }{const __raw_hasNotifications = obj["hasNotifications" ]as boolean; instance.hasNotifications = __raw_hasNotifications; }{const __raw_hasRequiredLeadSource = obj["hasRequiredLeadSource" ]as boolean; instance.hasRequiredLeadSource = __raw_hasRequiredLeadSource; }{const __raw_hasRequiredEmail = obj["hasRequiredEmail" ]as boolean; instance.hasRequiredEmail = __raw_hasRequiredEmail; }{const __raw_hasSortServiceItemsAlphabetically = obj["hasSortServiceItemsAlphabetically" ]as boolean; instance.hasSortServiceItemsAlphabetically = __raw_hasSortServiceItemsAlphabetically; }{const __raw_hasAttachOrderToAppointmentEmails = obj["hasAttachOrderToAppointmentEmails" ]as boolean; instance.hasAttachOrderToAppointmentEmails = __raw_hasAttachOrderToAppointmentEmails; }{const __raw_scheduleInterval = obj["scheduleInterval" ]as number; instance.scheduleInterval = __raw_scheduleInterval; }{const __raw_colorsConfig = obj["colorsConfig" ]as ColorsConfig; {const __result = colorsConfigDeserializeWithContext(__raw_colorsConfig, ctx); ctx.assignOrDefer(instance, "colorsConfig" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Company;}export function companyValidateField<K extends keyof Company>(field: K, value: Company[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "legalName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "legalName", message: "must not be empty" });
                }
 break;}case "fax" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "fax", message: "must not be empty" });
                }
 break;}case "email" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "email", message: "must not be empty" });
                }
 break;}case "website" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "website", message: "must not be empty" });
                }
 break;}case "taxId" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "taxId", message: "must not be empty" });
                }
 break;}case "postalCodeLookup" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "postalCodeLookup", message: "must not be empty" });
                }
 break;}case "defaultTaxLocation" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "defaultTaxLocation", message: "must not be empty" });
                }
 break;}case "defaultAccountType" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "defaultAccountType", message: "must not be empty" });
                }
 break;}case "lookupFormatting" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lookupFormatting", message: "must not be empty" });
                }
 break;}case "accountNameFormat" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountNameFormat", message: "must not be empty" });
                }
 break;}case "dateDisplayStyle" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "dateDisplayStyle", message: "must not be empty" });
                }
 break;}}return errors; }export function companyValidateFields(partial: Partial<Company>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("legalName" in partial && partial.legalName!== undefined){const __val = partial.legalName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "legalName", message: "must not be empty" });
                }
}if("fax" in partial && partial.fax!== undefined){const __val = partial.fax as string; 
                if (__val.length === 0) {
                    errors.push({ field: "fax", message: "must not be empty" });
                }
}if("email" in partial && partial.email!== undefined){const __val = partial.email as string; 
                if (__val.length === 0) {
                    errors.push({ field: "email", message: "must not be empty" });
                }
}if("website" in partial && partial.website!== undefined){const __val = partial.website as string; 
                if (__val.length === 0) {
                    errors.push({ field: "website", message: "must not be empty" });
                }
}if("taxId" in partial && partial.taxId!== undefined){const __val = partial.taxId as string; 
                if (__val.length === 0) {
                    errors.push({ field: "taxId", message: "must not be empty" });
                }
}if("postalCodeLookup" in partial && partial.postalCodeLookup!== undefined){const __val = partial.postalCodeLookup as string; 
                if (__val.length === 0) {
                    errors.push({ field: "postalCodeLookup", message: "must not be empty" });
                }
}if("defaultTaxLocation" in partial && partial.defaultTaxLocation!== undefined){const __val = partial.defaultTaxLocation as string; 
                if (__val.length === 0) {
                    errors.push({ field: "defaultTaxLocation", message: "must not be empty" });
                }
}if("defaultAccountType" in partial && partial.defaultAccountType!== undefined){const __val = partial.defaultAccountType as string; 
                if (__val.length === 0) {
                    errors.push({ field: "defaultAccountType", message: "must not be empty" });
                }
}if("lookupFormatting" in partial && partial.lookupFormatting!== undefined){const __val = partial.lookupFormatting as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lookupFormatting", message: "must not be empty" });
                }
}if("accountNameFormat" in partial && partial.accountNameFormat!== undefined){const __val = partial.accountNameFormat as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountNameFormat", message: "must not be empty" });
                }
}if("dateDisplayStyle" in partial && partial.dateDisplayStyle!== undefined){const __val = partial.dateDisplayStyle as string; 
                if (__val.length === 0) {
                    errors.push({ field: "dateDisplayStyle", message: "must not be empty" });
                }
}return errors; }export function companyHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "legalName" in o && "headquarters" in o && "phones" in o && "fax" in o && "email" in o && "website" in o && "taxId" in o && "referenceNumber" in o && "postalCodeLookup" in o && "timeZone" in o && "defaultTax" in o && "defaultTaxLocation" in o && "defaultAreaCode" in o && "defaultAccountType" in o && "lookupFormatting" in o && "accountNameFormat" in o && "merchantServiceProvider" in o && "dateDisplayStyle" in o && "hasAutoCommission" in o && "hasAutoDaylightSavings" in o && "hasAutoFmsTracking" in o && "hasNotifications" in o && "hasRequiredLeadSource" in o && "hasRequiredEmail" in o && "hasSortServiceItemsAlphabetically" in o && "hasAttachOrderToAppointmentEmails" in o && "scheduleInterval" in o && "colorsConfig" in o;}export function companyIs(obj: unknown): obj is Company {if(!companyHasShape(obj)){return false;}const result = companyDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CompanyErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; legalName: Option<Array<string>>; headquarters: Option<Array<string>>; phones: Option<Array<string>>; fax: Option<Array<string>>; email: Option<Array<string>>; website: Option<Array<string>>; taxId: Option<Array<string>>; referenceNumber: Option<Array<string>>; postalCodeLookup: Option<Array<string>>; timeZone: Option<Array<string>>; defaultTax: Option<Array<string>>; defaultTaxLocation: Option<Array<string>>; defaultAreaCode: Option<Array<string>>; defaultAccountType: Option<Array<string>>; lookupFormatting: Option<Array<string>>; accountNameFormat: Option<Array<string>>; merchantServiceProvider: Option<Array<string>>; dateDisplayStyle: Option<Array<string>>; hasAutoCommission: Option<Array<string>>; hasAutoDaylightSavings: Option<Array<string>>; hasAutoFmsTracking: Option<Array<string>>; hasNotifications: Option<Array<string>>; hasRequiredLeadSource: Option<Array<string>>; hasRequiredEmail: Option<Array<string>>; hasSortServiceItemsAlphabetically: Option<Array<string>>; hasAttachOrderToAppointmentEmails: Option<Array<string>>; scheduleInterval: Option<Array<string>>; colorsConfig: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CompanyTainted = {id: Option<boolean>; legalName: Option<boolean>; headquarters: Option<boolean>; phones: Option<boolean>; fax: Option<boolean>; email: Option<boolean>; website: Option<boolean>; taxId: Option<boolean>; referenceNumber: Option<boolean>; postalCodeLookup: Option<boolean>; timeZone: Option<boolean>; defaultTax: Option<boolean>; defaultTaxLocation: Option<boolean>; defaultAreaCode: Option<boolean>; defaultAccountType: Option<boolean>; lookupFormatting: Option<boolean>; accountNameFormat: Option<boolean>; merchantServiceProvider: Option<boolean>; dateDisplayStyle: Option<boolean>; hasAutoCommission: Option<boolean>; hasAutoDaylightSavings: Option<boolean>; hasAutoFmsTracking: Option<boolean>; hasNotifications: Option<boolean>; hasRequiredLeadSource: Option<boolean>; hasRequiredEmail: Option<boolean>; hasSortServiceItemsAlphabetically: Option<boolean>; hasAttachOrderToAppointmentEmails: Option<boolean>; scheduleInterval: Option<boolean>; colorsConfig: Option<boolean>; }; /** Type-safe field controllers for this form */export interface CompanyFieldControllers {readonly id: FieldController<string>; readonly legalName: FieldController<string>; readonly headquarters: FieldController<string | Site>; readonly phones: ArrayFieldController<PhoneNumber>; readonly fax: FieldController<string>; readonly email: FieldController<string>; readonly website: FieldController<string>; readonly taxId: FieldController<string>; readonly referenceNumber: FieldController<number>; readonly postalCodeLookup: FieldController<string>; readonly timeZone: FieldController<string>; readonly defaultTax: FieldController<string | TaxRate>; readonly defaultTaxLocation: FieldController<string>; readonly defaultAreaCode: FieldController<number>; readonly defaultAccountType: FieldController<string>; readonly lookupFormatting: FieldController<string>; readonly accountNameFormat: FieldController<string>; readonly merchantServiceProvider: FieldController<string | null>; readonly dateDisplayStyle: FieldController<string>; readonly hasAutoCommission: FieldController<boolean>; readonly hasAutoDaylightSavings: FieldController<boolean>; readonly hasAutoFmsTracking: FieldController<boolean>; readonly hasNotifications: FieldController<boolean>; readonly hasRequiredLeadSource: FieldController<boolean>; readonly hasRequiredEmail: FieldController<boolean>; readonly hasSortServiceItemsAlphabetically: FieldController<boolean>; readonly hasAttachOrderToAppointmentEmails: FieldController<boolean>; readonly scheduleInterval: FieldController<number>; readonly colorsConfig: FieldController<ColorsConfig>; }/** Gigaform instance containing reactive state and field controllers */export interface CompanyGigaform {readonly data: Company; readonly errors: CompanyErrors; readonly tainted: CompanyTainted; readonly fields: CompanyFieldControllers; validate(): Result<Company, Array<{field: string; message: string}>>; reset(overrides?: Partial<Company>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function companyCreateForm(overrides?: Partial<Company>): CompanyGigaform {let data = $state({...companyDefaultValue(),...overrides}); let errors = $state<CompanyErrors>({_errors: Option.none(), id: Option.none(), legalName: Option.none(), headquarters: Option.none(), phones: Option.none(), fax: Option.none(), email: Option.none(), website: Option.none(), taxId: Option.none(), referenceNumber: Option.none(), postalCodeLookup: Option.none(), timeZone: Option.none(), defaultTax: Option.none(), defaultTaxLocation: Option.none(), defaultAreaCode: Option.none(), defaultAccountType: Option.none(), lookupFormatting: Option.none(), accountNameFormat: Option.none(), merchantServiceProvider: Option.none(), dateDisplayStyle: Option.none(), hasAutoCommission: Option.none(), hasAutoDaylightSavings: Option.none(), hasAutoFmsTracking: Option.none(), hasNotifications: Option.none(), hasRequiredLeadSource: Option.none(), hasRequiredEmail: Option.none(), hasSortServiceItemsAlphabetically: Option.none(), hasAttachOrderToAppointmentEmails: Option.none(), scheduleInterval: Option.none(), colorsConfig: Option.none(), }); let tainted = $state<CompanyTainted>({id: Option.none(), legalName: Option.none(), headquarters: Option.none(), phones: Option.none(), fax: Option.none(), email: Option.none(), website: Option.none(), taxId: Option.none(), referenceNumber: Option.none(), postalCodeLookup: Option.none(), timeZone: Option.none(), defaultTax: Option.none(), defaultTaxLocation: Option.none(), defaultAreaCode: Option.none(), defaultAccountType: Option.none(), lookupFormatting: Option.none(), accountNameFormat: Option.none(), merchantServiceProvider: Option.none(), dateDisplayStyle: Option.none(), hasAutoCommission: Option.none(), hasAutoDaylightSavings: Option.none(), hasAutoFmsTracking: Option.none(), hasNotifications: Option.none(), hasRequiredLeadSource: Option.none(), hasRequiredEmail: Option.none(), hasSortServiceItemsAlphabetically: Option.none(), hasAttachOrderToAppointmentEmails: Option.none(), scheduleInterval: Option.none(), colorsConfig: Option.none(), }); const fields: CompanyFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},legalName: {path: ["legalName" ]as const, name: "legalName" , constraints: { required: true }, get: ()=>data.legalName, set: (value: string)=>{data.legalName = value;}, transform: (value: string): string =>value,getError: ()=>errors.legalName, setError: (value: Option<Array<string>>)=>{errors.legalName = value;}, getTainted: ()=>tainted.legalName, setTainted: (value: Option<boolean>)=>{tainted.legalName = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("legalName", data.legalName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},headquarters: {path: ["headquarters" ]as const, name: "headquarters" , constraints: { required: true }, get: ()=>data.headquarters, set: (value: string | Site)=>{data.headquarters = value;}, transform: (value: string | Site): string | Site =>value,getError: ()=>errors.headquarters, setError: (value: Option<Array<string>>)=>{errors.headquarters = value;}, getTainted: ()=>tainted.headquarters, setTainted: (value: Option<boolean>)=>{tainted.headquarters = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("headquarters", data.headquarters); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},phones: {path: ["phones" ]as const, name: "phones" , constraints: { required: true }, get: ()=>data.phones, set: (value: PhoneNumber[])=>{data.phones = value;}, transform: (value: PhoneNumber[]): PhoneNumber[] =>value,getError: ()=>errors.phones, setError: (value: Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("phones", data.phones); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["phones" , index]as const, name: `phones.${index}` , constraints: {required: true}, get: ()=>data.phones[index]!, set: (value: PhoneNumber)=>{data.phones[index]= value;}, transform: (value: PhoneNumber): PhoneNumber =>value, getError: ()=>errors.phones, setError: (value: Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>[],}), push: (item: PhoneNumber)=>{data.phones.push(item);}, remove: (index: number)=>{data.phones.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.phones[a]!; data.phones[a]= data.phones[b]!; data.phones[b]= tmp;},},fax: {path: ["fax" ]as const, name: "fax" , constraints: { required: true }, get: ()=>data.fax, set: (value: string)=>{data.fax = value;}, transform: (value: string): string =>value,getError: ()=>errors.fax, setError: (value: Option<Array<string>>)=>{errors.fax = value;}, getTainted: ()=>tainted.fax, setTainted: (value: Option<boolean>)=>{tainted.fax = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("fax", data.fax); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},email: {path: ["email" ]as const, name: "email" , constraints: { required: true }, get: ()=>data.email, set: (value: string)=>{data.email = value;}, transform: (value: string): string =>value,getError: ()=>errors.email, setError: (value: Option<Array<string>>)=>{errors.email = value;}, getTainted: ()=>tainted.email, setTainted: (value: Option<boolean>)=>{tainted.email = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("email", data.email); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},website: {path: ["website" ]as const, name: "website" , constraints: { required: true }, get: ()=>data.website, set: (value: string)=>{data.website = value;}, transform: (value: string): string =>value,getError: ()=>errors.website, setError: (value: Option<Array<string>>)=>{errors.website = value;}, getTainted: ()=>tainted.website, setTainted: (value: Option<boolean>)=>{tainted.website = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("website", data.website); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},taxId: {path: ["taxId" ]as const, name: "taxId" , constraints: { required: true }, get: ()=>data.taxId, set: (value: string)=>{data.taxId = value;}, transform: (value: string): string =>value,getError: ()=>errors.taxId, setError: (value: Option<Array<string>>)=>{errors.taxId = value;}, getTainted: ()=>tainted.taxId, setTainted: (value: Option<boolean>)=>{tainted.taxId = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("taxId", data.taxId); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},referenceNumber: {path: ["referenceNumber" ]as const, name: "referenceNumber" , constraints: { required: true }, get: ()=>data.referenceNumber, set: (value: number)=>{data.referenceNumber = value;}, transform: (value: number): number =>value,getError: ()=>errors.referenceNumber, setError: (value: Option<Array<string>>)=>{errors.referenceNumber = value;}, getTainted: ()=>tainted.referenceNumber, setTainted: (value: Option<boolean>)=>{tainted.referenceNumber = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("referenceNumber", data.referenceNumber); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},postalCodeLookup: {path: ["postalCodeLookup" ]as const, name: "postalCodeLookup" , constraints: { required: true }, get: ()=>data.postalCodeLookup, set: (value: string)=>{data.postalCodeLookup = value;}, transform: (value: string): string =>value,getError: ()=>errors.postalCodeLookup, setError: (value: Option<Array<string>>)=>{errors.postalCodeLookup = value;}, getTainted: ()=>tainted.postalCodeLookup, setTainted: (value: Option<boolean>)=>{tainted.postalCodeLookup = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("postalCodeLookup", data.postalCodeLookup); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},timeZone: {path: ["timeZone" ]as const, name: "timeZone" , constraints: { required: true }, get: ()=>data.timeZone, set: (value: string)=>{data.timeZone = value;}, transform: (value: string): string =>value,getError: ()=>errors.timeZone, setError: (value: Option<Array<string>>)=>{errors.timeZone = value;}, getTainted: ()=>tainted.timeZone, setTainted: (value: Option<boolean>)=>{tainted.timeZone = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("timeZone", data.timeZone); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},defaultTax: {path: ["defaultTax" ]as const, name: "defaultTax" , constraints: { required: true }, get: ()=>data.defaultTax, set: (value: string | TaxRate)=>{data.defaultTax = value;}, transform: (value: string | TaxRate): string | TaxRate =>value,getError: ()=>errors.defaultTax, setError: (value: Option<Array<string>>)=>{errors.defaultTax = value;}, getTainted: ()=>tainted.defaultTax, setTainted: (value: Option<boolean>)=>{tainted.defaultTax = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("defaultTax", data.defaultTax); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},defaultTaxLocation: {path: ["defaultTaxLocation" ]as const, name: "defaultTaxLocation" , constraints: { required: true }, get: ()=>data.defaultTaxLocation, set: (value: string)=>{data.defaultTaxLocation = value;}, transform: (value: string): string =>value,getError: ()=>errors.defaultTaxLocation, setError: (value: Option<Array<string>>)=>{errors.defaultTaxLocation = value;}, getTainted: ()=>tainted.defaultTaxLocation, setTainted: (value: Option<boolean>)=>{tainted.defaultTaxLocation = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("defaultTaxLocation", data.defaultTaxLocation); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},defaultAreaCode: {path: ["defaultAreaCode" ]as const, name: "defaultAreaCode" , constraints: { required: true }, get: ()=>data.defaultAreaCode, set: (value: number)=>{data.defaultAreaCode = value;}, transform: (value: number): number =>value,getError: ()=>errors.defaultAreaCode, setError: (value: Option<Array<string>>)=>{errors.defaultAreaCode = value;}, getTainted: ()=>tainted.defaultAreaCode, setTainted: (value: Option<boolean>)=>{tainted.defaultAreaCode = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("defaultAreaCode", data.defaultAreaCode); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},defaultAccountType: {path: ["defaultAccountType" ]as const, name: "defaultAccountType" , constraints: { required: true }, get: ()=>data.defaultAccountType, set: (value: string)=>{data.defaultAccountType = value;}, transform: (value: string): string =>value,getError: ()=>errors.defaultAccountType, setError: (value: Option<Array<string>>)=>{errors.defaultAccountType = value;}, getTainted: ()=>tainted.defaultAccountType, setTainted: (value: Option<boolean>)=>{tainted.defaultAccountType = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("defaultAccountType", data.defaultAccountType); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},lookupFormatting: {path: ["lookupFormatting" ]as const, name: "lookupFormatting" , constraints: { required: true }, get: ()=>data.lookupFormatting, set: (value: string)=>{data.lookupFormatting = value;}, transform: (value: string): string =>value,getError: ()=>errors.lookupFormatting, setError: (value: Option<Array<string>>)=>{errors.lookupFormatting = value;}, getTainted: ()=>tainted.lookupFormatting, setTainted: (value: Option<boolean>)=>{tainted.lookupFormatting = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("lookupFormatting", data.lookupFormatting); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},accountNameFormat: {path: ["accountNameFormat" ]as const, name: "accountNameFormat" , constraints: { required: true }, get: ()=>data.accountNameFormat, set: (value: string)=>{data.accountNameFormat = value;}, transform: (value: string): string =>value,getError: ()=>errors.accountNameFormat, setError: (value: Option<Array<string>>)=>{errors.accountNameFormat = value;}, getTainted: ()=>tainted.accountNameFormat, setTainted: (value: Option<boolean>)=>{tainted.accountNameFormat = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("accountNameFormat", data.accountNameFormat); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},merchantServiceProvider: {path: ["merchantServiceProvider" ]as const, name: "merchantServiceProvider" , constraints: { required: true }, get: ()=>data.merchantServiceProvider, set: (value: string | null)=>{data.merchantServiceProvider = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.merchantServiceProvider, setError: (value: Option<Array<string>>)=>{errors.merchantServiceProvider = value;}, getTainted: ()=>tainted.merchantServiceProvider, setTainted: (value: Option<boolean>)=>{tainted.merchantServiceProvider = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("merchantServiceProvider", data.merchantServiceProvider); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},dateDisplayStyle: {path: ["dateDisplayStyle" ]as const, name: "dateDisplayStyle" , constraints: { required: true }, get: ()=>data.dateDisplayStyle, set: (value: string)=>{data.dateDisplayStyle = value;}, transform: (value: string): string =>value,getError: ()=>errors.dateDisplayStyle, setError: (value: Option<Array<string>>)=>{errors.dateDisplayStyle = value;}, getTainted: ()=>tainted.dateDisplayStyle, setTainted: (value: Option<boolean>)=>{tainted.dateDisplayStyle = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("dateDisplayStyle", data.dateDisplayStyle); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasAutoCommission: {path: ["hasAutoCommission" ]as const, name: "hasAutoCommission" , constraints: { required: true }, get: ()=>data.hasAutoCommission, set: (value: boolean)=>{data.hasAutoCommission = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasAutoCommission, setError: (value: Option<Array<string>>)=>{errors.hasAutoCommission = value;}, getTainted: ()=>tainted.hasAutoCommission, setTainted: (value: Option<boolean>)=>{tainted.hasAutoCommission = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasAutoCommission", data.hasAutoCommission); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasAutoDaylightSavings: {path: ["hasAutoDaylightSavings" ]as const, name: "hasAutoDaylightSavings" , constraints: { required: true }, get: ()=>data.hasAutoDaylightSavings, set: (value: boolean)=>{data.hasAutoDaylightSavings = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasAutoDaylightSavings, setError: (value: Option<Array<string>>)=>{errors.hasAutoDaylightSavings = value;}, getTainted: ()=>tainted.hasAutoDaylightSavings, setTainted: (value: Option<boolean>)=>{tainted.hasAutoDaylightSavings = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasAutoDaylightSavings", data.hasAutoDaylightSavings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasAutoFmsTracking: {path: ["hasAutoFmsTracking" ]as const, name: "hasAutoFmsTracking" , constraints: { required: true }, get: ()=>data.hasAutoFmsTracking, set: (value: boolean)=>{data.hasAutoFmsTracking = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasAutoFmsTracking, setError: (value: Option<Array<string>>)=>{errors.hasAutoFmsTracking = value;}, getTainted: ()=>tainted.hasAutoFmsTracking, setTainted: (value: Option<boolean>)=>{tainted.hasAutoFmsTracking = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasAutoFmsTracking", data.hasAutoFmsTracking); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasNotifications: {path: ["hasNotifications" ]as const, name: "hasNotifications" , constraints: { required: true }, get: ()=>data.hasNotifications, set: (value: boolean)=>{data.hasNotifications = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasNotifications, setError: (value: Option<Array<string>>)=>{errors.hasNotifications = value;}, getTainted: ()=>tainted.hasNotifications, setTainted: (value: Option<boolean>)=>{tainted.hasNotifications = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasNotifications", data.hasNotifications); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasRequiredLeadSource: {path: ["hasRequiredLeadSource" ]as const, name: "hasRequiredLeadSource" , constraints: { required: true }, get: ()=>data.hasRequiredLeadSource, set: (value: boolean)=>{data.hasRequiredLeadSource = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasRequiredLeadSource, setError: (value: Option<Array<string>>)=>{errors.hasRequiredLeadSource = value;}, getTainted: ()=>tainted.hasRequiredLeadSource, setTainted: (value: Option<boolean>)=>{tainted.hasRequiredLeadSource = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasRequiredLeadSource", data.hasRequiredLeadSource); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasRequiredEmail: {path: ["hasRequiredEmail" ]as const, name: "hasRequiredEmail" , constraints: { required: true }, get: ()=>data.hasRequiredEmail, set: (value: boolean)=>{data.hasRequiredEmail = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasRequiredEmail, setError: (value: Option<Array<string>>)=>{errors.hasRequiredEmail = value;}, getTainted: ()=>tainted.hasRequiredEmail, setTainted: (value: Option<boolean>)=>{tainted.hasRequiredEmail = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasRequiredEmail", data.hasRequiredEmail); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasSortServiceItemsAlphabetically: {path: ["hasSortServiceItemsAlphabetically" ]as const, name: "hasSortServiceItemsAlphabetically" , constraints: { required: true }, get: ()=>data.hasSortServiceItemsAlphabetically, set: (value: boolean)=>{data.hasSortServiceItemsAlphabetically = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasSortServiceItemsAlphabetically, setError: (value: Option<Array<string>>)=>{errors.hasSortServiceItemsAlphabetically = value;}, getTainted: ()=>tainted.hasSortServiceItemsAlphabetically, setTainted: (value: Option<boolean>)=>{tainted.hasSortServiceItemsAlphabetically = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasSortServiceItemsAlphabetically", data.hasSortServiceItemsAlphabetically); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasAttachOrderToAppointmentEmails: {path: ["hasAttachOrderToAppointmentEmails" ]as const, name: "hasAttachOrderToAppointmentEmails" , constraints: { required: true }, get: ()=>data.hasAttachOrderToAppointmentEmails, set: (value: boolean)=>{data.hasAttachOrderToAppointmentEmails = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasAttachOrderToAppointmentEmails, setError: (value: Option<Array<string>>)=>{errors.hasAttachOrderToAppointmentEmails = value;}, getTainted: ()=>tainted.hasAttachOrderToAppointmentEmails, setTainted: (value: Option<boolean>)=>{tainted.hasAttachOrderToAppointmentEmails = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasAttachOrderToAppointmentEmails", data.hasAttachOrderToAppointmentEmails); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},scheduleInterval: {path: ["scheduleInterval" ]as const, name: "scheduleInterval" , constraints: { required: true }, get: ()=>data.scheduleInterval, set: (value: number)=>{data.scheduleInterval = value;}, transform: (value: number): number =>value,getError: ()=>errors.scheduleInterval, setError: (value: Option<Array<string>>)=>{errors.scheduleInterval = value;}, getTainted: ()=>tainted.scheduleInterval, setTainted: (value: Option<boolean>)=>{tainted.scheduleInterval = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("scheduleInterval", data.scheduleInterval); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},colorsConfig: {path: ["colorsConfig" ]as const, name: "colorsConfig" , constraints: { required: true }, get: ()=>data.colorsConfig, set: (value: ColorsConfig)=>{data.colorsConfig = value;}, transform: (value: ColorsConfig): ColorsConfig =>value,getError: ()=>errors.colorsConfig, setError: (value: Option<Array<string>>)=>{errors.colorsConfig = value;}, getTainted: ()=>tainted.colorsConfig, setTainted: (value: Option<boolean>)=>{tainted.colorsConfig = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("colorsConfig", data.colorsConfig); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Company, Array<{field: string; message: string}>>{return companyDeserialize(data);}function reset(newOverrides?: Partial<Company>): void {data = {...companyDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), legalName: Option.none(), headquarters: Option.none(), phones: Option.none(), fax: Option.none(), email: Option.none(), website: Option.none(), taxId: Option.none(), referenceNumber: Option.none(), postalCodeLookup: Option.none(), timeZone: Option.none(), defaultTax: Option.none(), defaultTaxLocation: Option.none(), defaultAreaCode: Option.none(), defaultAccountType: Option.none(), lookupFormatting: Option.none(), accountNameFormat: Option.none(), merchantServiceProvider: Option.none(), dateDisplayStyle: Option.none(), hasAutoCommission: Option.none(), hasAutoDaylightSavings: Option.none(), hasAutoFmsTracking: Option.none(), hasNotifications: Option.none(), hasRequiredLeadSource: Option.none(), hasRequiredEmail: Option.none(), hasSortServiceItemsAlphabetically: Option.none(), hasAttachOrderToAppointmentEmails: Option.none(), scheduleInterval: Option.none(), colorsConfig: Option.none(), }; tainted = {id: Option.none(), legalName: Option.none(), headquarters: Option.none(), phones: Option.none(), fax: Option.none(), email: Option.none(), website: Option.none(), taxId: Option.none(), referenceNumber: Option.none(), postalCodeLookup: Option.none(), timeZone: Option.none(), defaultTax: Option.none(), defaultTaxLocation: Option.none(), defaultAreaCode: Option.none(), defaultAccountType: Option.none(), lookupFormatting: Option.none(), accountNameFormat: Option.none(), merchantServiceProvider: Option.none(), dateDisplayStyle: Option.none(), hasAutoCommission: Option.none(), hasAutoDaylightSavings: Option.none(), hasAutoFmsTracking: Option.none(), hasNotifications: Option.none(), hasRequiredLeadSource: Option.none(), hasRequiredEmail: Option.none(), hasSortServiceItemsAlphabetically: Option.none(), hasAttachOrderToAppointmentEmails: Option.none(), scheduleInterval: Option.none(), colorsConfig: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function companyFromFormData(formData: FormData): Result<Company, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.legalName = formData.get("legalName" )?? "" ;obj.headquarters = formData.get("headquarters" )?? "" ;{const phones Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("phones." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("phones." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("phones." + idx + "." )){const fieldName = key.slice("phones." .length + String(idx).length + 1); item[fieldName]= value;}}phones Items.push(item);}idx ++; if(idx>1000)break;}obj.phones = phones Items;}obj.fax = formData.get("fax" )?? "" ;obj.email = formData.get("email" )?? "" ;obj.website = formData.get("website" )?? "" ;obj.taxId = formData.get("taxId" )?? "" ;{const referenceNumber Str = formData.get("referenceNumber" ); obj.referenceNumber = referenceNumber Str? parseFloat(referenceNumber Str as string): 0; if(obj.referenceNumber!== undefined && isNaN(obj.referenceNumber as number))obj.referenceNumber = 0;}obj.postalCodeLookup = formData.get("postalCodeLookup" )?? "" ;obj.timeZone = formData.get("timeZone" )?? "" ;obj.defaultTax = formData.get("defaultTax" )?? "" ;obj.defaultTaxLocation = formData.get("defaultTaxLocation" )?? "" ;{const defaultAreaCode Str = formData.get("defaultAreaCode" ); obj.defaultAreaCode = defaultAreaCode Str? parseFloat(defaultAreaCode Str as string): 0; if(obj.defaultAreaCode!== undefined && isNaN(obj.defaultAreaCode as number))obj.defaultAreaCode = 0;}obj.defaultAccountType = formData.get("defaultAccountType" )?? "" ;obj.lookupFormatting = formData.get("lookupFormatting" )?? "" ;obj.accountNameFormat = formData.get("accountNameFormat" )?? "" ;obj.merchantServiceProvider = formData.get("merchantServiceProvider" )?? "" ;obj.dateDisplayStyle = formData.get("dateDisplayStyle" )?? "" ;{const hasAutoCommission Val = formData.get("hasAutoCommission" ); obj.hasAutoCommission = hasAutoCommission Val === "true" || hasAutoCommission Val === "on" || hasAutoCommission Val === "1" ;}{const hasAutoDaylightSavings Val = formData.get("hasAutoDaylightSavings" ); obj.hasAutoDaylightSavings = hasAutoDaylightSavings Val === "true" || hasAutoDaylightSavings Val === "on" || hasAutoDaylightSavings Val === "1" ;}{const hasAutoFmsTracking Val = formData.get("hasAutoFmsTracking" ); obj.hasAutoFmsTracking = hasAutoFmsTracking Val === "true" || hasAutoFmsTracking Val === "on" || hasAutoFmsTracking Val === "1" ;}{const hasNotifications Val = formData.get("hasNotifications" ); obj.hasNotifications = hasNotifications Val === "true" || hasNotifications Val === "on" || hasNotifications Val === "1" ;}{const hasRequiredLeadSource Val = formData.get("hasRequiredLeadSource" ); obj.hasRequiredLeadSource = hasRequiredLeadSource Val === "true" || hasRequiredLeadSource Val === "on" || hasRequiredLeadSource Val === "1" ;}{const hasRequiredEmail Val = formData.get("hasRequiredEmail" ); obj.hasRequiredEmail = hasRequiredEmail Val === "true" || hasRequiredEmail Val === "on" || hasRequiredEmail Val === "1" ;}{const hasSortServiceItemsAlphabetically Val = formData.get("hasSortServiceItemsAlphabetically" ); obj.hasSortServiceItemsAlphabetically = hasSortServiceItemsAlphabetically Val === "true" || hasSortServiceItemsAlphabetically Val === "on" || hasSortServiceItemsAlphabetically Val === "1" ;}{const hasAttachOrderToAppointmentEmails Val = formData.get("hasAttachOrderToAppointmentEmails" ); obj.hasAttachOrderToAppointmentEmails = hasAttachOrderToAppointmentEmails Val === "true" || hasAttachOrderToAppointmentEmails Val === "on" || hasAttachOrderToAppointmentEmails Val === "1" ;}{const scheduleInterval Str = formData.get("scheduleInterval" ); obj.scheduleInterval = scheduleInterval Str? parseFloat(scheduleInterval Str as string): 0; if(obj.scheduleInterval!== undefined && isNaN(obj.scheduleInterval as number))obj.scheduleInterval = 0;}{const colorsConfig Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("colorsConfig." )){const fieldName = key.slice("colorsConfig." .length); const parts = fieldName.split("." ); let current = colorsConfig Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.colorsConfig = colorsConfig Obj;}return companyDeserialize(obj);}

export const Company = {
  defaultValue: companyDefaultValue,
  serialize: companySerialize,
  serializeWithContext: companySerializeWithContext,
  deserialize: companyDeserialize,
  deserializeWithContext: companyDeserializeWithContext,
  validateFields: companyValidateFields,
  hasShape: companyHasShape,
  is: companyIs,
  createForm: companyCreateForm,
  fromFormData: companyFromFormData
} as const;


export interface Ordinal {
    north: number;
    northeast: number;
    east: number;
    southeast: number;
    south: number;
    southwest: number;
    west: number;
    northwest: number;
}

export function ordinalDefaultValue(): Ordinal {return {north: 0,
                            northeast: 0,
                            east: 0,
                            southeast: 0,
                            south: 0,
                            southwest: 0,
                            west: 0,
                            northwest: 0, }as Ordinal;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function ordinalSerialize(value: Ordinal): string {const ctx = SerializeContext.create(); return JSON.stringify(ordinalSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function ordinalSerializeWithContext(value: Ordinal, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Ordinal" , __id,}; result["north" ]= value.north; result["northeast" ]= value.northeast; result["east" ]= value.east; result["southeast" ]= value.southeast; result["south" ]= value.south; result["southwest" ]= value.southwest; result["west" ]= value.west; result["northwest" ]= value.northwest; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function ordinalDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Ordinal } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = ordinalDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Ordinal.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function ordinalDeserializeWithContext(value: any, ctx: DeserializeContext): Ordinal | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Ordinal.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("north" in obj)){errors.push({field: "north" , message: "missing required field" });}if(!("northeast" in obj)){errors.push({field: "northeast" , message: "missing required field" });}if(!("east" in obj)){errors.push({field: "east" , message: "missing required field" });}if(!("southeast" in obj)){errors.push({field: "southeast" , message: "missing required field" });}if(!("south" in obj)){errors.push({field: "south" , message: "missing required field" });}if(!("southwest" in obj)){errors.push({field: "southwest" , message: "missing required field" });}if(!("west" in obj)){errors.push({field: "west" , message: "missing required field" });}if(!("northwest" in obj)){errors.push({field: "northwest" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_north = obj["north" ]as number; instance.north = __raw_north; }{const __raw_northeast = obj["northeast" ]as number; instance.northeast = __raw_northeast; }{const __raw_east = obj["east" ]as number; instance.east = __raw_east; }{const __raw_southeast = obj["southeast" ]as number; instance.southeast = __raw_southeast; }{const __raw_south = obj["south" ]as number; instance.south = __raw_south; }{const __raw_southwest = obj["southwest" ]as number; instance.southwest = __raw_southwest; }{const __raw_west = obj["west" ]as number; instance.west = __raw_west; }{const __raw_northwest = obj["northwest" ]as number; instance.northwest = __raw_northwest; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Ordinal;}export function ordinalValidateField<K extends keyof Ordinal>(field: K, value: Ordinal[K]): Array<{field: string; message: string}>{return[]; }export function ordinalValidateFields(partial: Partial<Ordinal>): Array<{field: string; message: string}>{return[]; }export function ordinalHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "north" in o && "northeast" in o && "east" in o && "southeast" in o && "south" in o && "southwest" in o && "west" in o && "northwest" in o;}export function ordinalIs(obj: unknown): obj is Ordinal {if(!ordinalHasShape(obj)){return false;}const result = ordinalDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type OrdinalErrors = {_errors: Option<Array<string>>; north: Option<Array<string>>; northeast: Option<Array<string>>; east: Option<Array<string>>; southeast: Option<Array<string>>; south: Option<Array<string>>; southwest: Option<Array<string>>; west: Option<Array<string>>; northwest: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type OrdinalTainted = {north: Option<boolean>; northeast: Option<boolean>; east: Option<boolean>; southeast: Option<boolean>; south: Option<boolean>; southwest: Option<boolean>; west: Option<boolean>; northwest: Option<boolean>; }; /** Type-safe field controllers for this form */export interface OrdinalFieldControllers {readonly north: FieldController<number>; readonly northeast: FieldController<number>; readonly east: FieldController<number>; readonly southeast: FieldController<number>; readonly south: FieldController<number>; readonly southwest: FieldController<number>; readonly west: FieldController<number>; readonly northwest: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface OrdinalGigaform {readonly data: Ordinal; readonly errors: OrdinalErrors; readonly tainted: OrdinalTainted; readonly fields: OrdinalFieldControllers; validate(): Result<Ordinal, Array<{field: string; message: string}>>; reset(overrides?: Partial<Ordinal>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function ordinalCreateForm(overrides?: Partial<Ordinal>): OrdinalGigaform {let data = $state({...ordinalDefaultValue(),...overrides}); let errors = $state<OrdinalErrors>({_errors: Option.none(), north: Option.none(), northeast: Option.none(), east: Option.none(), southeast: Option.none(), south: Option.none(), southwest: Option.none(), west: Option.none(), northwest: Option.none(), }); let tainted = $state<OrdinalTainted>({north: Option.none(), northeast: Option.none(), east: Option.none(), southeast: Option.none(), south: Option.none(), southwest: Option.none(), west: Option.none(), northwest: Option.none(), }); const fields: OrdinalFieldControllers = {north: {path: ["north" ]as const, name: "north" , constraints: { required: true }, get: ()=>data.north, set: (value: number)=>{data.north = value;}, transform: (value: number): number =>value,getError: ()=>errors.north, setError: (value: Option<Array<string>>)=>{errors.north = value;}, getTainted: ()=>tainted.north, setTainted: (value: Option<boolean>)=>{tainted.north = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("north", data.north); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},northeast: {path: ["northeast" ]as const, name: "northeast" , constraints: { required: true }, get: ()=>data.northeast, set: (value: number)=>{data.northeast = value;}, transform: (value: number): number =>value,getError: ()=>errors.northeast, setError: (value: Option<Array<string>>)=>{errors.northeast = value;}, getTainted: ()=>tainted.northeast, setTainted: (value: Option<boolean>)=>{tainted.northeast = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("northeast", data.northeast); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},east: {path: ["east" ]as const, name: "east" , constraints: { required: true }, get: ()=>data.east, set: (value: number)=>{data.east = value;}, transform: (value: number): number =>value,getError: ()=>errors.east, setError: (value: Option<Array<string>>)=>{errors.east = value;}, getTainted: ()=>tainted.east, setTainted: (value: Option<boolean>)=>{tainted.east = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("east", data.east); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},southeast: {path: ["southeast" ]as const, name: "southeast" , constraints: { required: true }, get: ()=>data.southeast, set: (value: number)=>{data.southeast = value;}, transform: (value: number): number =>value,getError: ()=>errors.southeast, setError: (value: Option<Array<string>>)=>{errors.southeast = value;}, getTainted: ()=>tainted.southeast, setTainted: (value: Option<boolean>)=>{tainted.southeast = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("southeast", data.southeast); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},south: {path: ["south" ]as const, name: "south" , constraints: { required: true }, get: ()=>data.south, set: (value: number)=>{data.south = value;}, transform: (value: number): number =>value,getError: ()=>errors.south, setError: (value: Option<Array<string>>)=>{errors.south = value;}, getTainted: ()=>tainted.south, setTainted: (value: Option<boolean>)=>{tainted.south = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("south", data.south); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},southwest: {path: ["southwest" ]as const, name: "southwest" , constraints: { required: true }, get: ()=>data.southwest, set: (value: number)=>{data.southwest = value;}, transform: (value: number): number =>value,getError: ()=>errors.southwest, setError: (value: Option<Array<string>>)=>{errors.southwest = value;}, getTainted: ()=>tainted.southwest, setTainted: (value: Option<boolean>)=>{tainted.southwest = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("southwest", data.southwest); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},west: {path: ["west" ]as const, name: "west" , constraints: { required: true }, get: ()=>data.west, set: (value: number)=>{data.west = value;}, transform: (value: number): number =>value,getError: ()=>errors.west, setError: (value: Option<Array<string>>)=>{errors.west = value;}, getTainted: ()=>tainted.west, setTainted: (value: Option<boolean>)=>{tainted.west = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("west", data.west); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},northwest: {path: ["northwest" ]as const, name: "northwest" , constraints: { required: true }, get: ()=>data.northwest, set: (value: number)=>{data.northwest = value;}, transform: (value: number): number =>value,getError: ()=>errors.northwest, setError: (value: Option<Array<string>>)=>{errors.northwest = value;}, getTainted: ()=>tainted.northwest, setTainted: (value: Option<boolean>)=>{tainted.northwest = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("northwest", data.northwest); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Ordinal, Array<{field: string; message: string}>>{return ordinalDeserialize(data);}function reset(newOverrides?: Partial<Ordinal>): void {data = {...ordinalDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), north: Option.none(), northeast: Option.none(), east: Option.none(), southeast: Option.none(), south: Option.none(), southwest: Option.none(), west: Option.none(), northwest: Option.none(), }; tainted = {north: Option.none(), northeast: Option.none(), east: Option.none(), southeast: Option.none(), south: Option.none(), southwest: Option.none(), west: Option.none(), northwest: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function ordinalFromFormData(formData: FormData): Result<Ordinal, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const north Str = formData.get("north" ); obj.north = north Str? parseFloat(north Str as string): 0; if(obj.north!== undefined && isNaN(obj.north as number))obj.north = 0;}{const northeast Str = formData.get("northeast" ); obj.northeast = northeast Str? parseFloat(northeast Str as string): 0; if(obj.northeast!== undefined && isNaN(obj.northeast as number))obj.northeast = 0;}{const east Str = formData.get("east" ); obj.east = east Str? parseFloat(east Str as string): 0; if(obj.east!== undefined && isNaN(obj.east as number))obj.east = 0;}{const southeast Str = formData.get("southeast" ); obj.southeast = southeast Str? parseFloat(southeast Str as string): 0; if(obj.southeast!== undefined && isNaN(obj.southeast as number))obj.southeast = 0;}{const south Str = formData.get("south" ); obj.south = south Str? parseFloat(south Str as string): 0; if(obj.south!== undefined && isNaN(obj.south as number))obj.south = 0;}{const southwest Str = formData.get("southwest" ); obj.southwest = southwest Str? parseFloat(southwest Str as string): 0; if(obj.southwest!== undefined && isNaN(obj.southwest as number))obj.southwest = 0;}{const west Str = formData.get("west" ); obj.west = west Str? parseFloat(west Str as string): 0; if(obj.west!== undefined && isNaN(obj.west as number))obj.west = 0;}{const northwest Str = formData.get("northwest" ); obj.northwest = northwest Str? parseFloat(northwest Str as string): 0; if(obj.northwest!== undefined && isNaN(obj.northwest as number))obj.northwest = 0;}return ordinalDeserialize(obj);}

export const Ordinal = {
  defaultValue: ordinalDefaultValue,
  serialize: ordinalSerialize,
  serializeWithContext: ordinalSerializeWithContext,
  deserialize: ordinalDeserialize,
  deserializeWithContext: ordinalDeserializeWithContext,
  validateFields: ordinalValidateFields,
  hasShape: ordinalHasShape,
  is: ordinalIs,
  createForm: ordinalCreateForm,
  fromFormData: ordinalFromFormData
} as const;


export interface Password {
    
    password: string;
}

export function passwordDefaultValue(): Password {return {password: "", }as Password;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function passwordSerialize(value: Password): string {const ctx = SerializeContext.create(); return JSON.stringify(passwordSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function passwordSerializeWithContext(value: Password, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Password" , __id,}; result["password" ]= value.password; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function passwordDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Password } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = passwordDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Password.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function passwordDeserializeWithContext(value: any, ctx: DeserializeContext): Password | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Password.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("password" in obj)){errors.push({field: "password" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_password = obj["password" ]as string; 
                if (__raw_password.length === 0) {
                    errors.push({ field: "password", message: "must not be empty" });
                }
 instance.password = __raw_password; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Password;}export function passwordValidateField<K extends keyof Password>(field: K, value: Password[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "password" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "password", message: "must not be empty" });
                }
 break;}}return errors; }export function passwordValidateFields(partial: Partial<Password>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("password" in partial && partial.password!== undefined){const __val = partial.password as string; 
                if (__val.length === 0) {
                    errors.push({ field: "password", message: "must not be empty" });
                }
}return errors; }export function passwordHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "password" in o;}export function passwordIs(obj: unknown): obj is Password {if(!passwordHasShape(obj)){return false;}const result = passwordDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type PasswordErrors = {_errors: Option<Array<string>>; password: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type PasswordTainted = {password: Option<boolean>; }; /** Type-safe field controllers for this form */export interface PasswordFieldControllers {readonly password: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface PasswordGigaform {readonly data: Password; readonly errors: PasswordErrors; readonly tainted: PasswordTainted; readonly fields: PasswordFieldControllers; validate(): Result<Password, Array<{field: string; message: string}>>; reset(overrides?: Partial<Password>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function passwordCreateForm(overrides?: Partial<Password>): PasswordGigaform {let data = $state({...passwordDefaultValue(),...overrides}); let errors = $state<PasswordErrors>({_errors: Option.none(), password: Option.none(), }); let tainted = $state<PasswordTainted>({password: Option.none(), }); const fields: PasswordFieldControllers = {password: {path: ["password" ]as const, name: "password" , constraints: { required: true }, get: ()=>data.password, set: (value: string)=>{data.password = value;}, transform: (value: string): string =>value,getError: ()=>errors.password, setError: (value: Option<Array<string>>)=>{errors.password = value;}, getTainted: ()=>tainted.password, setTainted: (value: Option<boolean>)=>{tainted.password = value;}, validate: (): Array<string>=>{const fieldErrors = passwordValidateField("password", data.password); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Password, Array<{field: string; message: string}>>{return passwordDeserialize(data);}function reset(newOverrides?: Partial<Password>): void {data = {...passwordDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), password: Option.none(), }; tainted = {password: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function passwordFromFormData(formData: FormData): Result<Password, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.password = formData.get("password" )?? "" ;return passwordDeserialize(obj);}

export const Password = {
  defaultValue: passwordDefaultValue,
  serialize: passwordSerialize,
  serializeWithContext: passwordSerializeWithContext,
  deserialize: passwordDeserialize,
  deserializeWithContext: passwordDeserializeWithContext,
  validateFields: passwordValidateFields,
  hasShape: passwordHasShape,
  is: passwordIs,
  createForm: passwordCreateForm,
  fromFormData: passwordFromFormData
} as const;


export interface Created {
    initialData: string | null;
}

export function createdDefaultValue(): Created {return {initialData: null, }as Created;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function createdSerialize(value: Created): string {const ctx = SerializeContext.create(); return JSON.stringify(createdSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function createdSerializeWithContext(value: Created, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Created" , __id,}; result["initialData" ]= value.initialData; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function createdDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Created } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = createdDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Created.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function createdDeserializeWithContext(value: any, ctx: DeserializeContext): Created | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Created.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("initialData" in obj)){errors.push({field: "initialData" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_initialData = obj["initialData" ]as string | null; instance.initialData = __raw_initialData; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Created;}export function createdValidateField<K extends keyof Created>(field: K, value: Created[K]): Array<{field: string; message: string}>{return[]; }export function createdValidateFields(partial: Partial<Created>): Array<{field: string; message: string}>{return[]; }export function createdHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "initialData" in o;}export function createdIs(obj: unknown): obj is Created {if(!createdHasShape(obj)){return false;}const result = createdDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CreatedErrors = {_errors: Option<Array<string>>; initialData: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CreatedTainted = {initialData: Option<boolean>; }; /** Type-safe field controllers for this form */export interface CreatedFieldControllers {readonly initialData: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface CreatedGigaform {readonly data: Created; readonly errors: CreatedErrors; readonly tainted: CreatedTainted; readonly fields: CreatedFieldControllers; validate(): Result<Created, Array<{field: string; message: string}>>; reset(overrides?: Partial<Created>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createdCreateForm(overrides?: Partial<Created>): CreatedGigaform {let data = $state({...createdDefaultValue(),...overrides}); let errors = $state<CreatedErrors>({_errors: Option.none(), initialData: Option.none(), }); let tainted = $state<CreatedTainted>({initialData: Option.none(), }); const fields: CreatedFieldControllers = {initialData: {path: ["initialData" ]as const, name: "initialData" , constraints: { required: true }, get: ()=>data.initialData, set: (value: string | null)=>{data.initialData = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.initialData, setError: (value: Option<Array<string>>)=>{errors.initialData = value;}, getTainted: ()=>tainted.initialData, setTainted: (value: Option<boolean>)=>{tainted.initialData = value;}, validate: (): Array<string>=>{const fieldErrors = createdValidateField("initialData", data.initialData); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Created, Array<{field: string; message: string}>>{return createdDeserialize(data);}function reset(newOverrides?: Partial<Created>): void {data = {...createdDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), initialData: Option.none(), }; tainted = {initialData: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function createdFromFormData(formData: FormData): Result<Created, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.initialData = formData.get("initialData" )?? "" ;return createdDeserialize(obj);}

export const Created = {
  defaultValue: createdDefaultValue,
  serialize: createdSerialize,
  serializeWithContext: createdSerializeWithContext,
  deserialize: createdDeserialize,
  deserializeWithContext: createdDeserializeWithContext,
  validateFields: createdValidateFields,
  hasShape: createdHasShape,
  is: createdIs,
  createForm: createdCreateForm,
  fromFormData: createdFromFormData
} as const;


export interface Employee {
    id: string;
    imageUrl: string | null;
    
    name: string;
    phones: PhoneNumber[];
    
    role: string;
    
    title: JobTitle;
    email: Email;
    
    address: string;
    
    username: string;
    
    route: string | Route;
    ratePerHour: number;
    active: boolean;
    isTechnician: boolean;
    isSalesRep: boolean;
    description: string | null;
    linkedinUrl: string | null;
    attendance: string[];
    settings: Settings;
}

export function employeeDefaultValue(): Employee {return {id: "",
                            imageUrl: null,
                            name: "",
                            phones: [],
                            role: "",
                            title: "Technician",
                            email: emailDefaultValue(),
                            address: "",
                            username: "",
                            route: "",
                            ratePerHour: 0,
                            active: false,
                            isTechnician: false,
                            isSalesRep: false,
                            description: null,
                            linkedinUrl: null,
                            attendance: [],
                            settings: settingsDefaultValue(), }as Employee;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function employeeSerialize(value: Employee): string {const ctx = SerializeContext.create(); return JSON.stringify(employeeSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function employeeSerializeWithContext(value: Employee, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Employee" , __id,}; result["id" ]= value.id; result["imageUrl" ]= value.imageUrl; result["name" ]= value.name; result["phones" ]= value.phones.map((item)=>phoneNumberSerializeWithContext(item, ctx)); result["role" ]= value.role; result["title" ]= jobTitleSerializeWithContext(value.title, ctx); result["email" ]= emailSerializeWithContext(value.email, ctx); result["address" ]= value.address; result["username" ]= value.username; result["route" ]= value.route; result["ratePerHour" ]= value.ratePerHour; result["active" ]= value.active; result["isTechnician" ]= value.isTechnician; result["isSalesRep" ]= value.isSalesRep; result["description" ]= value.description; result["linkedinUrl" ]= value.linkedinUrl; result["attendance" ]= value.attendance; result["settings" ]= settingsSerializeWithContext(value.settings, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function employeeDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Employee } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = employeeDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Employee.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function employeeDeserializeWithContext(value: any, ctx: DeserializeContext): Employee | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Employee.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("imageUrl" in obj)){errors.push({field: "imageUrl" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("phones" in obj)){errors.push({field: "phones" , message: "missing required field" });}if(!("role" in obj)){errors.push({field: "role" , message: "missing required field" });}if(!("title" in obj)){errors.push({field: "title" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("address" in obj)){errors.push({field: "address" , message: "missing required field" });}if(!("username" in obj)){errors.push({field: "username" , message: "missing required field" });}if(!("route" in obj)){errors.push({field: "route" , message: "missing required field" });}if(!("ratePerHour" in obj)){errors.push({field: "ratePerHour" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(!("isTechnician" in obj)){errors.push({field: "isTechnician" , message: "missing required field" });}if(!("isSalesRep" in obj)){errors.push({field: "isSalesRep" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(!("linkedinUrl" in obj)){errors.push({field: "linkedinUrl" , message: "missing required field" });}if(!("attendance" in obj)){errors.push({field: "attendance" , message: "missing required field" });}if(!("settings" in obj)){errors.push({field: "settings" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_imageUrl = obj["imageUrl" ]as string | null; instance.imageUrl = __raw_imageUrl; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_phones = obj["phones" ]as PhoneNumber[]; if(Array.isArray(__raw_phones)){instance.phones = __raw_phones as PhoneNumber[];}}{const __raw_role = obj["role" ]as string; 
                if (__raw_role.length === 0) {
                    errors.push({ field: "role", message: "must not be empty" });
                }
 instance.role = __raw_role; }{const __raw_title = obj["title" ]as JobTitle; {const __result = jobTitleDeserializeWithContext(__raw_title, ctx); ctx.assignOrDefer(instance, "title" , __result);}}{const __raw_email = obj["email" ]as Email; {const __result = emailDeserializeWithContext(__raw_email, ctx); ctx.assignOrDefer(instance, "email" , __result);}}{const __raw_address = obj["address" ]as string; 
                if (__raw_address.length === 0) {
                    errors.push({ field: "address", message: "must not be empty" });
                }
 instance.address = __raw_address; }{const __raw_username = obj["username" ]as string; 
                if (__raw_username.length === 0) {
                    errors.push({ field: "username", message: "must not be empty" });
                }
 instance.username = __raw_username; }{const __raw_route = obj["route" ]as string | Route; instance.route = __raw_route; }{const __raw_ratePerHour = obj["ratePerHour" ]as number; instance.ratePerHour = __raw_ratePerHour; }{const __raw_active = obj["active" ]as boolean; instance.active = __raw_active; }{const __raw_isTechnician = obj["isTechnician" ]as boolean; instance.isTechnician = __raw_isTechnician; }{const __raw_isSalesRep = obj["isSalesRep" ]as boolean; instance.isSalesRep = __raw_isSalesRep; }{const __raw_description = obj["description" ]as string | null; instance.description = __raw_description; }{const __raw_linkedinUrl = obj["linkedinUrl" ]as string | null; instance.linkedinUrl = __raw_linkedinUrl; }{const __raw_attendance = obj["attendance" ]as string[]; if(Array.isArray(__raw_attendance)){instance.attendance = __raw_attendance as string[];}}{const __raw_settings = obj["settings" ]as Settings; {const __result = settingsDeserializeWithContext(__raw_settings, ctx); ctx.assignOrDefer(instance, "settings" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Employee;}export function employeeValidateField<K extends keyof Employee>(field: K, value: Employee[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "role" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "role", message: "must not be empty" });
                }
 break;}case "address" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "address", message: "must not be empty" });
                }
 break;}case "username" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "username", message: "must not be empty" });
                }
 break;}}return errors; }export function employeeValidateFields(partial: Partial<Employee>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("role" in partial && partial.role!== undefined){const __val = partial.role as string; 
                if (__val.length === 0) {
                    errors.push({ field: "role", message: "must not be empty" });
                }
}if("address" in partial && partial.address!== undefined){const __val = partial.address as string; 
                if (__val.length === 0) {
                    errors.push({ field: "address", message: "must not be empty" });
                }
}if("username" in partial && partial.username!== undefined){const __val = partial.username as string; 
                if (__val.length === 0) {
                    errors.push({ field: "username", message: "must not be empty" });
                }
}return errors; }export function employeeHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "imageUrl" in o && "name" in o && "phones" in o && "role" in o && "title" in o && "email" in o && "address" in o && "username" in o && "route" in o && "ratePerHour" in o && "active" in o && "isTechnician" in o && "isSalesRep" in o && "description" in o && "linkedinUrl" in o && "attendance" in o && "settings" in o;}export function employeeIs(obj: unknown): obj is Employee {if(!employeeHasShape(obj)){return false;}const result = employeeDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type EmployeeErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; imageUrl: Option<Array<string>>; name: Option<Array<string>>; phones: Option<Array<string>>; role: Option<Array<string>>; title: Option<Array<string>>; email: Option<Array<string>>; address: Option<Array<string>>; username: Option<Array<string>>; route: Option<Array<string>>; ratePerHour: Option<Array<string>>; active: Option<Array<string>>; isTechnician: Option<Array<string>>; isSalesRep: Option<Array<string>>; description: Option<Array<string>>; linkedinUrl: Option<Array<string>>; attendance: Option<Array<string>>; settings: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type EmployeeTainted = {id: Option<boolean>; imageUrl: Option<boolean>; name: Option<boolean>; phones: Option<boolean>; role: Option<boolean>; title: Option<boolean>; email: Option<boolean>; address: Option<boolean>; username: Option<boolean>; route: Option<boolean>; ratePerHour: Option<boolean>; active: Option<boolean>; isTechnician: Option<boolean>; isSalesRep: Option<boolean>; description: Option<boolean>; linkedinUrl: Option<boolean>; attendance: Option<boolean>; settings: Option<boolean>; }; /** Type-safe field controllers for this form */export interface EmployeeFieldControllers {readonly id: FieldController<string>; readonly imageUrl: FieldController<string | null>; readonly name: FieldController<string>; readonly phones: ArrayFieldController<PhoneNumber>; readonly role: FieldController<string>; readonly title: FieldController<JobTitle>; readonly email: FieldController<Email>; readonly address: FieldController<string>; readonly username: FieldController<string>; readonly route: FieldController<string | Route>; readonly ratePerHour: FieldController<number>; readonly active: FieldController<boolean>; readonly isTechnician: FieldController<boolean>; readonly isSalesRep: FieldController<boolean>; readonly description: FieldController<string | null>; readonly linkedinUrl: FieldController<string | null>; readonly attendance: ArrayFieldController<string>; readonly settings: FieldController<Settings>; }/** Gigaform instance containing reactive state and field controllers */export interface EmployeeGigaform {readonly data: Employee; readonly errors: EmployeeErrors; readonly tainted: EmployeeTainted; readonly fields: EmployeeFieldControllers; validate(): Result<Employee, Array<{field: string; message: string}>>; reset(overrides?: Partial<Employee>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function employeeCreateForm(overrides?: Partial<Employee>): EmployeeGigaform {let data = $state({...employeeDefaultValue(),...overrides}); let errors = $state<EmployeeErrors>({_errors: Option.none(), id: Option.none(), imageUrl: Option.none(), name: Option.none(), phones: Option.none(), role: Option.none(), title: Option.none(), email: Option.none(), address: Option.none(), username: Option.none(), route: Option.none(), ratePerHour: Option.none(), active: Option.none(), isTechnician: Option.none(), isSalesRep: Option.none(), description: Option.none(), linkedinUrl: Option.none(), attendance: Option.none(), settings: Option.none(), }); let tainted = $state<EmployeeTainted>({id: Option.none(), imageUrl: Option.none(), name: Option.none(), phones: Option.none(), role: Option.none(), title: Option.none(), email: Option.none(), address: Option.none(), username: Option.none(), route: Option.none(), ratePerHour: Option.none(), active: Option.none(), isTechnician: Option.none(), isSalesRep: Option.none(), description: Option.none(), linkedinUrl: Option.none(), attendance: Option.none(), settings: Option.none(), }); const fields: EmployeeFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},imageUrl: {path: ["imageUrl" ]as const, name: "imageUrl" , constraints: { required: true }, get: ()=>data.imageUrl, set: (value: string | null)=>{data.imageUrl = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.imageUrl, setError: (value: Option<Array<string>>)=>{errors.imageUrl = value;}, getTainted: ()=>tainted.imageUrl, setTainted: (value: Option<boolean>)=>{tainted.imageUrl = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("imageUrl", data.imageUrl); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},phones: {path: ["phones" ]as const, name: "phones" , constraints: { required: true }, get: ()=>data.phones, set: (value: PhoneNumber[])=>{data.phones = value;}, transform: (value: PhoneNumber[]): PhoneNumber[] =>value,getError: ()=>errors.phones, setError: (value: Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("phones", data.phones); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["phones" , index]as const, name: `phones.${index}` , constraints: {required: true}, get: ()=>data.phones[index]!, set: (value: PhoneNumber)=>{data.phones[index]= value;}, transform: (value: PhoneNumber): PhoneNumber =>value, getError: ()=>errors.phones, setError: (value: Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>[],}), push: (item: PhoneNumber)=>{data.phones.push(item);}, remove: (index: number)=>{data.phones.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.phones[a]!; data.phones[a]= data.phones[b]!; data.phones[b]= tmp;},},role: {path: ["role" ]as const, name: "role" , constraints: { required: true }, get: ()=>data.role, set: (value: string)=>{data.role = value;}, transform: (value: string): string =>value,getError: ()=>errors.role, setError: (value: Option<Array<string>>)=>{errors.role = value;}, getTainted: ()=>tainted.role, setTainted: (value: Option<boolean>)=>{tainted.role = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("role", data.role); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},title: {path: ["title" ]as const, name: "title" , constraints: { required: true }, get: ()=>data.title, set: (value: JobTitle)=>{data.title = value;}, transform: (value: JobTitle): JobTitle =>value,getError: ()=>errors.title, setError: (value: Option<Array<string>>)=>{errors.title = value;}, getTainted: ()=>tainted.title, setTainted: (value: Option<boolean>)=>{tainted.title = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("title", data.title); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},email: {path: ["email" ]as const, name: "email" , constraints: { required: true }, get: ()=>data.email, set: (value: Email)=>{data.email = value;}, transform: (value: Email): Email =>value,getError: ()=>errors.email, setError: (value: Option<Array<string>>)=>{errors.email = value;}, getTainted: ()=>tainted.email, setTainted: (value: Option<boolean>)=>{tainted.email = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("email", data.email); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},address: {path: ["address" ]as const, name: "address" , constraints: { required: true }, get: ()=>data.address, set: (value: string)=>{data.address = value;}, transform: (value: string): string =>value,getError: ()=>errors.address, setError: (value: Option<Array<string>>)=>{errors.address = value;}, getTainted: ()=>tainted.address, setTainted: (value: Option<boolean>)=>{tainted.address = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("address", data.address); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},username: {path: ["username" ]as const, name: "username" , constraints: { required: true }, get: ()=>data.username, set: (value: string)=>{data.username = value;}, transform: (value: string): string =>value,getError: ()=>errors.username, setError: (value: Option<Array<string>>)=>{errors.username = value;}, getTainted: ()=>tainted.username, setTainted: (value: Option<boolean>)=>{tainted.username = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("username", data.username); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},route: {path: ["route" ]as const, name: "route" , constraints: { required: true }, get: ()=>data.route, set: (value: string | Route)=>{data.route = value;}, transform: (value: string | Route): string | Route =>value,getError: ()=>errors.route, setError: (value: Option<Array<string>>)=>{errors.route = value;}, getTainted: ()=>tainted.route, setTainted: (value: Option<boolean>)=>{tainted.route = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("route", data.route); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},ratePerHour: {path: ["ratePerHour" ]as const, name: "ratePerHour" , constraints: { required: true }, get: ()=>data.ratePerHour, set: (value: number)=>{data.ratePerHour = value;}, transform: (value: number): number =>value,getError: ()=>errors.ratePerHour, setError: (value: Option<Array<string>>)=>{errors.ratePerHour = value;}, getTainted: ()=>tainted.ratePerHour, setTainted: (value: Option<boolean>)=>{tainted.ratePerHour = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("ratePerHour", data.ratePerHour); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},active: {path: ["active" ]as const, name: "active" , constraints: { required: true }, get: ()=>data.active, set: (value: boolean)=>{data.active = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.active, setError: (value: Option<Array<string>>)=>{errors.active = value;}, getTainted: ()=>tainted.active, setTainted: (value: Option<boolean>)=>{tainted.active = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("active", data.active); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},isTechnician: {path: ["isTechnician" ]as const, name: "isTechnician" , constraints: { required: true }, get: ()=>data.isTechnician, set: (value: boolean)=>{data.isTechnician = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.isTechnician, setError: (value: Option<Array<string>>)=>{errors.isTechnician = value;}, getTainted: ()=>tainted.isTechnician, setTainted: (value: Option<boolean>)=>{tainted.isTechnician = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("isTechnician", data.isTechnician); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},isSalesRep: {path: ["isSalesRep" ]as const, name: "isSalesRep" , constraints: { required: true }, get: ()=>data.isSalesRep, set: (value: boolean)=>{data.isSalesRep = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.isSalesRep, setError: (value: Option<Array<string>>)=>{errors.isSalesRep = value;}, getTainted: ()=>tainted.isSalesRep, setTainted: (value: Option<boolean>)=>{tainted.isSalesRep = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("isSalesRep", data.isSalesRep); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},description: {path: ["description" ]as const, name: "description" , constraints: { required: true }, get: ()=>data.description, set: (value: string | null)=>{data.description = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.description, setError: (value: Option<Array<string>>)=>{errors.description = value;}, getTainted: ()=>tainted.description, setTainted: (value: Option<boolean>)=>{tainted.description = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("description", data.description); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},linkedinUrl: {path: ["linkedinUrl" ]as const, name: "linkedinUrl" , constraints: { required: true }, get: ()=>data.linkedinUrl, set: (value: string | null)=>{data.linkedinUrl = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.linkedinUrl, setError: (value: Option<Array<string>>)=>{errors.linkedinUrl = value;}, getTainted: ()=>tainted.linkedinUrl, setTainted: (value: Option<boolean>)=>{tainted.linkedinUrl = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("linkedinUrl", data.linkedinUrl); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},attendance: {path: ["attendance" ]as const, name: "attendance" , constraints: { required: true }, get: ()=>data.attendance, set: (value: string[])=>{data.attendance = value;}, transform: (value: string[]): string[] =>value,getError: ()=>errors.attendance, setError: (value: Option<Array<string>>)=>{errors.attendance = value;}, getTainted: ()=>tainted.attendance, setTainted: (value: Option<boolean>)=>{tainted.attendance = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("attendance", data.attendance); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["attendance" , index]as const, name: `attendance.${index}` , constraints: {required: true}, get: ()=>data.attendance[index]!, set: (value: string)=>{data.attendance[index]= value;}, transform: (value: string): string =>value, getError: ()=>errors.attendance, setError: (value: Option<Array<string>>)=>{errors.attendance = value;}, getTainted: ()=>tainted.attendance, setTainted: (value: Option<boolean>)=>{tainted.attendance = value;}, validate: (): Array<string>=>[],}), push: (item: string)=>{data.attendance.push(item);}, remove: (index: number)=>{data.attendance.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.attendance[a]!; data.attendance[a]= data.attendance[b]!; data.attendance[b]= tmp;},},settings: {path: ["settings" ]as const, name: "settings" , constraints: { required: true }, get: ()=>data.settings, set: (value: Settings)=>{data.settings = value;}, transform: (value: Settings): Settings =>value,getError: ()=>errors.settings, setError: (value: Option<Array<string>>)=>{errors.settings = value;}, getTainted: ()=>tainted.settings, setTainted: (value: Option<boolean>)=>{tainted.settings = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("settings", data.settings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Employee, Array<{field: string; message: string}>>{return employeeDeserialize(data);}function reset(newOverrides?: Partial<Employee>): void {data = {...employeeDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), imageUrl: Option.none(), name: Option.none(), phones: Option.none(), role: Option.none(), title: Option.none(), email: Option.none(), address: Option.none(), username: Option.none(), route: Option.none(), ratePerHour: Option.none(), active: Option.none(), isTechnician: Option.none(), isSalesRep: Option.none(), description: Option.none(), linkedinUrl: Option.none(), attendance: Option.none(), settings: Option.none(), }; tainted = {id: Option.none(), imageUrl: Option.none(), name: Option.none(), phones: Option.none(), role: Option.none(), title: Option.none(), email: Option.none(), address: Option.none(), username: Option.none(), route: Option.none(), ratePerHour: Option.none(), active: Option.none(), isTechnician: Option.none(), isSalesRep: Option.none(), description: Option.none(), linkedinUrl: Option.none(), attendance: Option.none(), settings: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function employeeFromFormData(formData: FormData): Result<Employee, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.imageUrl = formData.get("imageUrl" )?? "" ;obj.name = formData.get("name" )?? "" ;{const phones Items: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("phones." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("phones." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("phones." + idx + "." )){const fieldName = key.slice("phones." .length + String(idx).length + 1); item[fieldName]= value;}}phones Items.push(item);}idx ++; if(idx>1000)break;}obj.phones = phones Items;}obj.role = formData.get("role" )?? "" ;{const title Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("title." )){const fieldName = key.slice("title." .length); const parts = fieldName.split("." ); let current = title Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.title = title Obj;}{const email Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("email." )){const fieldName = key.slice("email." .length); const parts = fieldName.split("." ); let current = email Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.email = email Obj;}obj.address = formData.get("address" )?? "" ;obj.username = formData.get("username" )?? "" ;obj.route = formData.get("route" )?? "" ;{const ratePerHour Str = formData.get("ratePerHour" ); obj.ratePerHour = ratePerHour Str? parseFloat(ratePerHour Str as string): 0; if(obj.ratePerHour!== undefined && isNaN(obj.ratePerHour as number))obj.ratePerHour = 0;}{const active Val = formData.get("active" ); obj.active = active Val === "true" || active Val === "on" || active Val === "1" ;}{const isTechnician Val = formData.get("isTechnician" ); obj.isTechnician = isTechnician Val === "true" || isTechnician Val === "on" || isTechnician Val === "1" ;}{const isSalesRep Val = formData.get("isSalesRep" ); obj.isSalesRep = isSalesRep Val === "true" || isSalesRep Val === "on" || isSalesRep Val === "1" ;}obj.description = formData.get("description" )?? "" ;obj.linkedinUrl = formData.get("linkedinUrl" )?? "" ;obj.attendance = formData.getAll("attendance" )as Array<string>;{const settings Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("settings." )){const fieldName = key.slice("settings." .length); const parts = fieldName.split("." ); let current = settings Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.settings = settings Obj;}return employeeDeserialize(obj);}

export const Employee = {
  defaultValue: employeeDefaultValue,
  serialize: employeeSerialize,
  serializeWithContext: employeeSerializeWithContext,
  deserialize: employeeDeserialize,
  deserializeWithContext: employeeDeserializeWithContext,
  validateFields: employeeValidateFields,
  hasShape: employeeHasShape,
  is: employeeIs,
  createForm: employeeCreateForm,
  fromFormData: employeeFromFormData
} as const;


export interface Commissions {
    
    technician: string;
    
    salesRep: string;
}

export function commissionsDefaultValue(): Commissions {return {technician: "",
                            salesRep: "", }as Commissions;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function commissionsSerialize(value: Commissions): string {const ctx = SerializeContext.create(); return JSON.stringify(commissionsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function commissionsSerializeWithContext(value: Commissions, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Commissions" , __id,}; result["technician" ]= value.technician; result["salesRep" ]= value.salesRep; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function commissionsDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Commissions } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = commissionsDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Commissions.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function commissionsDeserializeWithContext(value: any, ctx: DeserializeContext): Commissions | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Commissions.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("technician" in obj)){errors.push({field: "technician" , message: "missing required field" });}if(!("salesRep" in obj)){errors.push({field: "salesRep" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_technician = obj["technician" ]as string; 
                if (__raw_technician.length === 0) {
                    errors.push({ field: "technician", message: "must not be empty" });
                }
 instance.technician = __raw_technician; }{const __raw_salesRep = obj["salesRep" ]as string; 
                if (__raw_salesRep.length === 0) {
                    errors.push({ field: "salesRep", message: "must not be empty" });
                }
 instance.salesRep = __raw_salesRep; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Commissions;}export function commissionsValidateField<K extends keyof Commissions>(field: K, value: Commissions[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "technician" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "technician", message: "must not be empty" });
                }
 break;}case "salesRep" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "salesRep", message: "must not be empty" });
                }
 break;}}return errors; }export function commissionsValidateFields(partial: Partial<Commissions>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("technician" in partial && partial.technician!== undefined){const __val = partial.technician as string; 
                if (__val.length === 0) {
                    errors.push({ field: "technician", message: "must not be empty" });
                }
}if("salesRep" in partial && partial.salesRep!== undefined){const __val = partial.salesRep as string; 
                if (__val.length === 0) {
                    errors.push({ field: "salesRep", message: "must not be empty" });
                }
}return errors; }export function commissionsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "technician" in o && "salesRep" in o;}export function commissionsIs(obj: unknown): obj is Commissions {if(!commissionsHasShape(obj)){return false;}const result = commissionsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CommissionsErrors = {_errors: Option<Array<string>>; technician: Option<Array<string>>; salesRep: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CommissionsTainted = {technician: Option<boolean>; salesRep: Option<boolean>; }; /** Type-safe field controllers for this form */export interface CommissionsFieldControllers {readonly technician: FieldController<string>; readonly salesRep: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface CommissionsGigaform {readonly data: Commissions; readonly errors: CommissionsErrors; readonly tainted: CommissionsTainted; readonly fields: CommissionsFieldControllers; validate(): Result<Commissions, Array<{field: string; message: string}>>; reset(overrides?: Partial<Commissions>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function commissionsCreateForm(overrides?: Partial<Commissions>): CommissionsGigaform {let data = $state({...commissionsDefaultValue(),...overrides}); let errors = $state<CommissionsErrors>({_errors: Option.none(), technician: Option.none(), salesRep: Option.none(), }); let tainted = $state<CommissionsTainted>({technician: Option.none(), salesRep: Option.none(), }); const fields: CommissionsFieldControllers = {technician: {path: ["technician" ]as const, name: "technician" , constraints: { required: true }, get: ()=>data.technician, set: (value: string)=>{data.technician = value;}, transform: (value: string): string =>value,getError: ()=>errors.technician, setError: (value: Option<Array<string>>)=>{errors.technician = value;}, getTainted: ()=>tainted.technician, setTainted: (value: Option<boolean>)=>{tainted.technician = value;}, validate: (): Array<string>=>{const fieldErrors = commissionsValidateField("technician", data.technician); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},salesRep: {path: ["salesRep" ]as const, name: "salesRep" , constraints: { required: true }, get: ()=>data.salesRep, set: (value: string)=>{data.salesRep = value;}, transform: (value: string): string =>value,getError: ()=>errors.salesRep, setError: (value: Option<Array<string>>)=>{errors.salesRep = value;}, getTainted: ()=>tainted.salesRep, setTainted: (value: Option<boolean>)=>{tainted.salesRep = value;}, validate: (): Array<string>=>{const fieldErrors = commissionsValidateField("salesRep", data.salesRep); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Commissions, Array<{field: string; message: string}>>{return commissionsDeserialize(data);}function reset(newOverrides?: Partial<Commissions>): void {data = {...commissionsDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), technician: Option.none(), salesRep: Option.none(), }; tainted = {technician: Option.none(), salesRep: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function commissionsFromFormData(formData: FormData): Result<Commissions, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.technician = formData.get("technician" )?? "" ;obj.salesRep = formData.get("salesRep" )?? "" ;return commissionsDeserialize(obj);}

export const Commissions = {
  defaultValue: commissionsDefaultValue,
  serialize: commissionsSerialize,
  serializeWithContext: commissionsSerializeWithContext,
  deserialize: commissionsDeserialize,
  deserializeWithContext: commissionsDeserializeWithContext,
  validateFields: commissionsValidateFields,
  hasShape: commissionsHasShape,
  is: commissionsIs,
  createForm: commissionsCreateForm,
  fromFormData: commissionsFromFormData
} as const;


export interface Number {
    
    countryCode: string;
    
    areaCode: string;
    
    localNumber: string;
}

export function numberDefaultValue(): Number {return {countryCode: "",
                            areaCode: "",
                            localNumber: "", }as Number;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function numberSerialize(value: Number): string {const ctx = SerializeContext.create(); return JSON.stringify(numberSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function numberSerializeWithContext(value: Number, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Number" , __id,}; result["countryCode" ]= value.countryCode; result["areaCode" ]= value.areaCode; result["localNumber" ]= value.localNumber; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function numberDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Number } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = numberDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Number.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function numberDeserializeWithContext(value: any, ctx: DeserializeContext): Number | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Number.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("countryCode" in obj)){errors.push({field: "countryCode" , message: "missing required field" });}if(!("areaCode" in obj)){errors.push({field: "areaCode" , message: "missing required field" });}if(!("localNumber" in obj)){errors.push({field: "localNumber" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_countryCode = obj["countryCode" ]as string; 
                if (__raw_countryCode.length === 0) {
                    errors.push({ field: "countryCode", message: "must not be empty" });
                }
 instance.countryCode = __raw_countryCode; }{const __raw_areaCode = obj["areaCode" ]as string; 
                if (__raw_areaCode.length === 0) {
                    errors.push({ field: "areaCode", message: "must not be empty" });
                }
 instance.areaCode = __raw_areaCode; }{const __raw_localNumber = obj["localNumber" ]as string; 
                if (__raw_localNumber.length === 0) {
                    errors.push({ field: "localNumber", message: "must not be empty" });
                }
 instance.localNumber = __raw_localNumber; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Number;}export function numberValidateField<K extends keyof Number>(field: K, value: Number[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "countryCode" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "countryCode", message: "must not be empty" });
                }
 break;}case "areaCode" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "areaCode", message: "must not be empty" });
                }
 break;}case "localNumber" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "localNumber", message: "must not be empty" });
                }
 break;}}return errors; }export function numberValidateFields(partial: Partial<Number>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("countryCode" in partial && partial.countryCode!== undefined){const __val = partial.countryCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "countryCode", message: "must not be empty" });
                }
}if("areaCode" in partial && partial.areaCode!== undefined){const __val = partial.areaCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "areaCode", message: "must not be empty" });
                }
}if("localNumber" in partial && partial.localNumber!== undefined){const __val = partial.localNumber as string; 
                if (__val.length === 0) {
                    errors.push({ field: "localNumber", message: "must not be empty" });
                }
}return errors; }export function numberHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "countryCode" in o && "areaCode" in o && "localNumber" in o;}export function numberIs(obj: unknown): obj is Number {if(!numberHasShape(obj)){return false;}const result = numberDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type NumberErrors = {_errors: Option<Array<string>>; countryCode: Option<Array<string>>; areaCode: Option<Array<string>>; localNumber: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type NumberTainted = {countryCode: Option<boolean>; areaCode: Option<boolean>; localNumber: Option<boolean>; }; /** Type-safe field controllers for this form */export interface NumberFieldControllers {readonly countryCode: FieldController<string>; readonly areaCode: FieldController<string>; readonly localNumber: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface NumberGigaform {readonly data: Number; readonly errors: NumberErrors; readonly tainted: NumberTainted; readonly fields: NumberFieldControllers; validate(): Result<Number, Array<{field: string; message: string}>>; reset(overrides?: Partial<Number>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function numberCreateForm(overrides?: Partial<Number>): NumberGigaform {let data = $state({...numberDefaultValue(),...overrides}); let errors = $state<NumberErrors>({_errors: Option.none(), countryCode: Option.none(), areaCode: Option.none(), localNumber: Option.none(), }); let tainted = $state<NumberTainted>({countryCode: Option.none(), areaCode: Option.none(), localNumber: Option.none(), }); const fields: NumberFieldControllers = {countryCode: {path: ["countryCode" ]as const, name: "countryCode" , constraints: { required: true }, get: ()=>data.countryCode, set: (value: string)=>{data.countryCode = value;}, transform: (value: string): string =>value,getError: ()=>errors.countryCode, setError: (value: Option<Array<string>>)=>{errors.countryCode = value;}, getTainted: ()=>tainted.countryCode, setTainted: (value: Option<boolean>)=>{tainted.countryCode = value;}, validate: (): Array<string>=>{const fieldErrors = numberValidateField("countryCode", data.countryCode); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},areaCode: {path: ["areaCode" ]as const, name: "areaCode" , constraints: { required: true }, get: ()=>data.areaCode, set: (value: string)=>{data.areaCode = value;}, transform: (value: string): string =>value,getError: ()=>errors.areaCode, setError: (value: Option<Array<string>>)=>{errors.areaCode = value;}, getTainted: ()=>tainted.areaCode, setTainted: (value: Option<boolean>)=>{tainted.areaCode = value;}, validate: (): Array<string>=>{const fieldErrors = numberValidateField("areaCode", data.areaCode); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},localNumber: {path: ["localNumber" ]as const, name: "localNumber" , constraints: { required: true }, get: ()=>data.localNumber, set: (value: string)=>{data.localNumber = value;}, transform: (value: string): string =>value,getError: ()=>errors.localNumber, setError: (value: Option<Array<string>>)=>{errors.localNumber = value;}, getTainted: ()=>tainted.localNumber, setTainted: (value: Option<boolean>)=>{tainted.localNumber = value;}, validate: (): Array<string>=>{const fieldErrors = numberValidateField("localNumber", data.localNumber); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Number, Array<{field: string; message: string}>>{return numberDeserialize(data);}function reset(newOverrides?: Partial<Number>): void {data = {...numberDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), countryCode: Option.none(), areaCode: Option.none(), localNumber: Option.none(), }; tainted = {countryCode: Option.none(), areaCode: Option.none(), localNumber: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function numberFromFormData(formData: FormData): Result<Number, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.countryCode = formData.get("countryCode" )?? "" ;obj.areaCode = formData.get("areaCode" )?? "" ;obj.localNumber = formData.get("localNumber" )?? "" ;return numberDeserialize(obj);}

export const Number = {
  defaultValue: numberDefaultValue,
  serialize: numberSerialize,
  serializeWithContext: numberSerializeWithContext,
  deserialize: numberDeserialize,
  deserializeWithContext: numberDeserializeWithContext,
  validateFields: numberValidateFields,
  hasShape: numberHasShape,
  is: numberIs,
  createForm: numberCreateForm,
  fromFormData: numberFromFormData
} as const;


export interface DataPath {
    path: string[];
    formatter: string | null;
}

export function dataPathDefaultValue(): DataPath {return {path: [],
                            formatter: null, }as DataPath;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function dataPathSerialize(value: DataPath): string {const ctx = SerializeContext.create(); return JSON.stringify(dataPathSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function dataPathSerializeWithContext(value: DataPath, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "DataPath" , __id,}; result["path" ]= value.path; result["formatter" ]= value.formatter; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function dataPathDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: DataPath } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = dataPathDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "DataPath.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function dataPathDeserializeWithContext(value: any, ctx: DeserializeContext): DataPath | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "DataPath.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("path" in obj)){errors.push({field: "path" , message: "missing required field" });}if(!("formatter" in obj)){errors.push({field: "formatter" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_path = obj["path" ]as string[]; if(Array.isArray(__raw_path)){instance.path = __raw_path as string[];}}{const __raw_formatter = obj["formatter" ]as string | null; instance.formatter = __raw_formatter; }if(errors.length>0){throw new DeserializeError(errors);}return instance as DataPath;}export function dataPathValidateField<K extends keyof DataPath>(field: K, value: DataPath[K]): Array<{field: string; message: string}>{return[]; }export function dataPathValidateFields(partial: Partial<DataPath>): Array<{field: string; message: string}>{return[]; }export function dataPathHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "path" in o && "formatter" in o;}export function dataPathIs(obj: unknown): obj is DataPath {if(!dataPathHasShape(obj)){return false;}const result = dataPathDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type DataPathErrors = {_errors: Option<Array<string>>; path: Option<Array<string>>; formatter: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type DataPathTainted = {path: Option<boolean>; formatter: Option<boolean>; }; /** Type-safe field controllers for this form */export interface DataPathFieldControllers {readonly path: ArrayFieldController<string>; readonly formatter: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface DataPathGigaform {readonly data: DataPath; readonly errors: DataPathErrors; readonly tainted: DataPathTainted; readonly fields: DataPathFieldControllers; validate(): Result<DataPath, Array<{field: string; message: string}>>; reset(overrides?: Partial<DataPath>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function dataPathCreateForm(overrides?: Partial<DataPath>): DataPathGigaform {let data = $state({...dataPathDefaultValue(),...overrides}); let errors = $state<DataPathErrors>({_errors: Option.none(), path: Option.none(), formatter: Option.none(), }); let tainted = $state<DataPathTainted>({path: Option.none(), formatter: Option.none(), }); const fields: DataPathFieldControllers = {path: {path: ["path" ]as const, name: "path" , constraints: { required: true }, get: ()=>data.path, set: (value: string[])=>{data.path = value;}, transform: (value: string[]): string[] =>value,getError: ()=>errors.path, setError: (value: Option<Array<string>>)=>{errors.path = value;}, getTainted: ()=>tainted.path, setTainted: (value: Option<boolean>)=>{tainted.path = value;}, validate: (): Array<string>=>{const fieldErrors = dataPathValidateField("path", data.path); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["path" , index]as const, name: `path.${index}` , constraints: {required: true}, get: ()=>data.path[index]!, set: (value: string)=>{data.path[index]= value;}, transform: (value: string): string =>value, getError: ()=>errors.path, setError: (value: Option<Array<string>>)=>{errors.path = value;}, getTainted: ()=>tainted.path, setTainted: (value: Option<boolean>)=>{tainted.path = value;}, validate: (): Array<string>=>[],}), push: (item: string)=>{data.path.push(item);}, remove: (index: number)=>{data.path.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.path[a]!; data.path[a]= data.path[b]!; data.path[b]= tmp;},},formatter: {path: ["formatter" ]as const, name: "formatter" , constraints: { required: true }, get: ()=>data.formatter, set: (value: string | null)=>{data.formatter = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.formatter, setError: (value: Option<Array<string>>)=>{errors.formatter = value;}, getTainted: ()=>tainted.formatter, setTainted: (value: Option<boolean>)=>{tainted.formatter = value;}, validate: (): Array<string>=>{const fieldErrors = dataPathValidateField("formatter", data.formatter); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<DataPath, Array<{field: string; message: string}>>{return dataPathDeserialize(data);}function reset(newOverrides?: Partial<DataPath>): void {data = {...dataPathDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), path: Option.none(), formatter: Option.none(), }; tainted = {path: Option.none(), formatter: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function dataPathFromFormData(formData: FormData): Result<DataPath, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.path = formData.getAll("path" )as Array<string>;obj.formatter = formData.get("formatter" )?? "" ;return dataPathDeserialize(obj);}

export const DataPath = {
  defaultValue: dataPathDefaultValue,
  serialize: dataPathSerialize,
  serializeWithContext: dataPathSerializeWithContext,
  deserialize: dataPathDeserialize,
  deserializeWithContext: dataPathDeserializeWithContext,
  validateFields: dataPathValidateFields,
  hasShape: dataPathHasShape,
  is: dataPathIs,
  createForm: dataPathCreateForm,
  fromFormData: dataPathFromFormData
} as const;


export interface Route {
    id: string;
    techs: (string | Employee)[] | null;
    active: boolean;
    
    name: string;
    
    phone: string;
    
    position: string;
    serviceRoute: boolean;
    defaultDurationHours: number;
    tags: string[];
    icon: string | null;
    color: string | null;
}

export function routeDefaultValue(): Route {return {id: "",
                            techs: null,
                            active: false,
                            name: "",
                            phone: "",
                            position: "",
                            serviceRoute: false,
                            defaultDurationHours: 0,
                            tags: [],
                            icon: null,
                            color: null, }as Route;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function routeSerialize(value: Route): string {const ctx = SerializeContext.create(); return JSON.stringify(routeSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function routeSerializeWithContext(value: Route, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Route" , __id,}; result["id" ]= value.id; if(value.techs!== null){result["techs" ]= value.techs; }else {result["techs" ]= null;}result["active" ]= value.active; result["name" ]= value.name; result["phone" ]= value.phone; result["position" ]= value.position; result["serviceRoute" ]= value.serviceRoute; result["defaultDurationHours" ]= value.defaultDurationHours; result["tags" ]= value.tags; result["icon" ]= value.icon; result["color" ]= value.color; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function routeDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Route } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = routeDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Route.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function routeDeserializeWithContext(value: any, ctx: DeserializeContext): Route | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Route.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("techs" in obj)){errors.push({field: "techs" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("phone" in obj)){errors.push({field: "phone" , message: "missing required field" });}if(!("position" in obj)){errors.push({field: "position" , message: "missing required field" });}if(!("serviceRoute" in obj)){errors.push({field: "serviceRoute" , message: "missing required field" });}if(!("defaultDurationHours" in obj)){errors.push({field: "defaultDurationHours" , message: "missing required field" });}if(!("tags" in obj)){errors.push({field: "tags" , message: "missing required field" });}if(!("icon" in obj)){errors.push({field: "icon" , message: "missing required field" });}if(!("color" in obj)){errors.push({field: "color" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_techs = obj["techs" ]as (string | Employee)[] | null; if(__raw_techs === null){instance.techs = null;}else {instance.techs = __raw_techs; }}{const __raw_active = obj["active" ]as boolean; instance.active = __raw_active; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_phone = obj["phone" ]as string; 
                if (__raw_phone.length === 0) {
                    errors.push({ field: "phone", message: "must not be empty" });
                }
 instance.phone = __raw_phone; }{const __raw_position = obj["position" ]as string; 
                if (__raw_position.length === 0) {
                    errors.push({ field: "position", message: "must not be empty" });
                }
 instance.position = __raw_position; }{const __raw_serviceRoute = obj["serviceRoute" ]as boolean; instance.serviceRoute = __raw_serviceRoute; }{const __raw_defaultDurationHours = obj["defaultDurationHours" ]as number; instance.defaultDurationHours = __raw_defaultDurationHours; }{const __raw_tags = obj["tags" ]as string[]; if(Array.isArray(__raw_tags)){instance.tags = __raw_tags as string[];}}{const __raw_icon = obj["icon" ]as string | null; instance.icon = __raw_icon; }{const __raw_color = obj["color" ]as string | null; instance.color = __raw_color; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Route;}export function routeValidateField<K extends keyof Route>(field: K, value: Route[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "phone" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "phone", message: "must not be empty" });
                }
 break;}case "position" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "position", message: "must not be empty" });
                }
 break;}}return errors; }export function routeValidateFields(partial: Partial<Route>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("phone" in partial && partial.phone!== undefined){const __val = partial.phone as string; 
                if (__val.length === 0) {
                    errors.push({ field: "phone", message: "must not be empty" });
                }
}if("position" in partial && partial.position!== undefined){const __val = partial.position as string; 
                if (__val.length === 0) {
                    errors.push({ field: "position", message: "must not be empty" });
                }
}return errors; }export function routeHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "techs" in o && "active" in o && "name" in o && "phone" in o && "position" in o && "serviceRoute" in o && "defaultDurationHours" in o && "tags" in o && "icon" in o && "color" in o;}export function routeIs(obj: unknown): obj is Route {if(!routeHasShape(obj)){return false;}const result = routeDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type RouteErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; techs: Option<Array<string>>; active: Option<Array<string>>; name: Option<Array<string>>; phone: Option<Array<string>>; position: Option<Array<string>>; serviceRoute: Option<Array<string>>; defaultDurationHours: Option<Array<string>>; tags: Option<Array<string>>; icon: Option<Array<string>>; color: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type RouteTainted = {id: Option<boolean>; techs: Option<boolean>; active: Option<boolean>; name: Option<boolean>; phone: Option<boolean>; position: Option<boolean>; serviceRoute: Option<boolean>; defaultDurationHours: Option<boolean>; tags: Option<boolean>; icon: Option<boolean>; color: Option<boolean>; }; /** Type-safe field controllers for this form */export interface RouteFieldControllers {readonly id: FieldController<string>; readonly techs: FieldController<(string | Employee)[] | null>; readonly active: FieldController<boolean>; readonly name: FieldController<string>; readonly phone: FieldController<string>; readonly position: FieldController<string>; readonly serviceRoute: FieldController<boolean>; readonly defaultDurationHours: FieldController<number>; readonly tags: ArrayFieldController<string>; readonly icon: FieldController<string | null>; readonly color: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface RouteGigaform {readonly data: Route; readonly errors: RouteErrors; readonly tainted: RouteTainted; readonly fields: RouteFieldControllers; validate(): Result<Route, Array<{field: string; message: string}>>; reset(overrides?: Partial<Route>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function routeCreateForm(overrides?: Partial<Route>): RouteGigaform {let data = $state({...routeDefaultValue(),...overrides}); let errors = $state<RouteErrors>({_errors: Option.none(), id: Option.none(), techs: Option.none(), active: Option.none(), name: Option.none(), phone: Option.none(), position: Option.none(), serviceRoute: Option.none(), defaultDurationHours: Option.none(), tags: Option.none(), icon: Option.none(), color: Option.none(), }); let tainted = $state<RouteTainted>({id: Option.none(), techs: Option.none(), active: Option.none(), name: Option.none(), phone: Option.none(), position: Option.none(), serviceRoute: Option.none(), defaultDurationHours: Option.none(), tags: Option.none(), icon: Option.none(), color: Option.none(), }); const fields: RouteFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},techs: {path: ["techs" ]as const, name: "techs" , constraints: { required: true }, get: ()=>data.techs, set: (value: (string | Employee)[] | null)=>{data.techs = value;}, transform: (value: (string | Employee)[] | null): (string | Employee)[] | null =>value,getError: ()=>errors.techs, setError: (value: Option<Array<string>>)=>{errors.techs = value;}, getTainted: ()=>tainted.techs, setTainted: (value: Option<boolean>)=>{tainted.techs = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("techs", data.techs); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},active: {path: ["active" ]as const, name: "active" , constraints: { required: true }, get: ()=>data.active, set: (value: boolean)=>{data.active = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.active, setError: (value: Option<Array<string>>)=>{errors.active = value;}, getTainted: ()=>tainted.active, setTainted: (value: Option<boolean>)=>{tainted.active = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("active", data.active); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},phone: {path: ["phone" ]as const, name: "phone" , constraints: { required: true }, get: ()=>data.phone, set: (value: string)=>{data.phone = value;}, transform: (value: string): string =>value,getError: ()=>errors.phone, setError: (value: Option<Array<string>>)=>{errors.phone = value;}, getTainted: ()=>tainted.phone, setTainted: (value: Option<boolean>)=>{tainted.phone = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("phone", data.phone); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},position: {path: ["position" ]as const, name: "position" , constraints: { required: true }, get: ()=>data.position, set: (value: string)=>{data.position = value;}, transform: (value: string): string =>value,getError: ()=>errors.position, setError: (value: Option<Array<string>>)=>{errors.position = value;}, getTainted: ()=>tainted.position, setTainted: (value: Option<boolean>)=>{tainted.position = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("position", data.position); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},serviceRoute: {path: ["serviceRoute" ]as const, name: "serviceRoute" , constraints: { required: true }, get: ()=>data.serviceRoute, set: (value: boolean)=>{data.serviceRoute = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.serviceRoute, setError: (value: Option<Array<string>>)=>{errors.serviceRoute = value;}, getTainted: ()=>tainted.serviceRoute, setTainted: (value: Option<boolean>)=>{tainted.serviceRoute = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("serviceRoute", data.serviceRoute); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},defaultDurationHours: {path: ["defaultDurationHours" ]as const, name: "defaultDurationHours" , constraints: { required: true }, get: ()=>data.defaultDurationHours, set: (value: number)=>{data.defaultDurationHours = value;}, transform: (value: number): number =>value,getError: ()=>errors.defaultDurationHours, setError: (value: Option<Array<string>>)=>{errors.defaultDurationHours = value;}, getTainted: ()=>tainted.defaultDurationHours, setTainted: (value: Option<boolean>)=>{tainted.defaultDurationHours = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("defaultDurationHours", data.defaultDurationHours); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},tags: {path: ["tags" ]as const, name: "tags" , constraints: { required: true }, get: ()=>data.tags, set: (value: string[])=>{data.tags = value;}, transform: (value: string[]): string[] =>value,getError: ()=>errors.tags, setError: (value: Option<Array<string>>)=>{errors.tags = value;}, getTainted: ()=>tainted.tags, setTainted: (value: Option<boolean>)=>{tainted.tags = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("tags", data.tags); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["tags" , index]as const, name: `tags.${index}` , constraints: {required: true}, get: ()=>data.tags[index]!, set: (value: string)=>{data.tags[index]= value;}, transform: (value: string): string =>value, getError: ()=>errors.tags, setError: (value: Option<Array<string>>)=>{errors.tags = value;}, getTainted: ()=>tainted.tags, setTainted: (value: Option<boolean>)=>{tainted.tags = value;}, validate: (): Array<string>=>[],}), push: (item: string)=>{data.tags.push(item);}, remove: (index: number)=>{data.tags.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.tags[a]!; data.tags[a]= data.tags[b]!; data.tags[b]= tmp;},},icon: {path: ["icon" ]as const, name: "icon" , constraints: { required: true }, get: ()=>data.icon, set: (value: string | null)=>{data.icon = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.icon, setError: (value: Option<Array<string>>)=>{errors.icon = value;}, getTainted: ()=>tainted.icon, setTainted: (value: Option<boolean>)=>{tainted.icon = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("icon", data.icon); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},color: {path: ["color" ]as const, name: "color" , constraints: { required: true }, get: ()=>data.color, set: (value: string | null)=>{data.color = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.color, setError: (value: Option<Array<string>>)=>{errors.color = value;}, getTainted: ()=>tainted.color, setTainted: (value: Option<boolean>)=>{tainted.color = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("color", data.color); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Route, Array<{field: string; message: string}>>{return routeDeserialize(data);}function reset(newOverrides?: Partial<Route>): void {data = {...routeDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), techs: Option.none(), active: Option.none(), name: Option.none(), phone: Option.none(), position: Option.none(), serviceRoute: Option.none(), defaultDurationHours: Option.none(), tags: Option.none(), icon: Option.none(), color: Option.none(), }; tainted = {id: Option.none(), techs: Option.none(), active: Option.none(), name: Option.none(), phone: Option.none(), position: Option.none(), serviceRoute: Option.none(), defaultDurationHours: Option.none(), tags: Option.none(), icon: Option.none(), color: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function routeFromFormData(formData: FormData): Result<Route, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.techs = formData.get("techs" )?? "" ;{const active Val = formData.get("active" ); obj.active = active Val === "true" || active Val === "on" || active Val === "1" ;}obj.name = formData.get("name" )?? "" ;obj.phone = formData.get("phone" )?? "" ;obj.position = formData.get("position" )?? "" ;{const serviceRoute Val = formData.get("serviceRoute" ); obj.serviceRoute = serviceRoute Val === "true" || serviceRoute Val === "on" || serviceRoute Val === "1" ;}{const defaultDurationHours Str = formData.get("defaultDurationHours" ); obj.defaultDurationHours = defaultDurationHours Str? parseFloat(defaultDurationHours Str as string): 0; if(obj.defaultDurationHours!== undefined && isNaN(obj.defaultDurationHours as number))obj.defaultDurationHours = 0;}obj.tags = formData.getAll("tags" )as Array<string>;obj.icon = formData.get("icon" )?? "" ;obj.color = formData.get("color" )?? "" ;return routeDeserialize(obj);}

export const Route = {
  defaultValue: routeDefaultValue,
  serialize: routeSerialize,
  serializeWithContext: routeSerializeWithContext,
  deserialize: routeDeserialize,
  deserializeWithContext: routeDeserializeWithContext,
  validateFields: routeValidateFields,
  hasShape: routeHasShape,
  is: routeIs,
  createForm: routeCreateForm,
  fromFormData: routeFromFormData
} as const;


export interface EmailParts {
    
    local: string;
    
    domainName: string;
    
    topLevelDomain: string;
}

export function emailPartsDefaultValue(): EmailParts {return {local: "",
                            domainName: "",
                            topLevelDomain: "", }as EmailParts;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function emailPartsSerialize(value: EmailParts): string {const ctx = SerializeContext.create(); return JSON.stringify(emailPartsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function emailPartsSerializeWithContext(value: EmailParts, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "EmailParts" , __id,}; result["local" ]= value.local; result["domainName" ]= value.domainName; result["topLevelDomain" ]= value.topLevelDomain; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function emailPartsDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: EmailParts } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = emailPartsDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "EmailParts.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function emailPartsDeserializeWithContext(value: any, ctx: DeserializeContext): EmailParts | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "EmailParts.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("local" in obj)){errors.push({field: "local" , message: "missing required field" });}if(!("domainName" in obj)){errors.push({field: "domainName" , message: "missing required field" });}if(!("topLevelDomain" in obj)){errors.push({field: "topLevelDomain" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_local = obj["local" ]as string; 
                if (__raw_local.length === 0) {
                    errors.push({ field: "local", message: "must not be empty" });
                }
 instance.local = __raw_local; }{const __raw_domainName = obj["domainName" ]as string; 
                if (__raw_domainName.length === 0) {
                    errors.push({ field: "domainName", message: "must not be empty" });
                }
 instance.domainName = __raw_domainName; }{const __raw_topLevelDomain = obj["topLevelDomain" ]as string; 
                if (__raw_topLevelDomain.length === 0) {
                    errors.push({ field: "topLevelDomain", message: "must not be empty" });
                }
 instance.topLevelDomain = __raw_topLevelDomain; }if(errors.length>0){throw new DeserializeError(errors);}return instance as EmailParts;}export function emailPartsValidateField<K extends keyof EmailParts>(field: K, value: EmailParts[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "local" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "local", message: "must not be empty" });
                }
 break;}case "domainName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "domainName", message: "must not be empty" });
                }
 break;}case "topLevelDomain" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "topLevelDomain", message: "must not be empty" });
                }
 break;}}return errors; }export function emailPartsValidateFields(partial: Partial<EmailParts>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("local" in partial && partial.local!== undefined){const __val = partial.local as string; 
                if (__val.length === 0) {
                    errors.push({ field: "local", message: "must not be empty" });
                }
}if("domainName" in partial && partial.domainName!== undefined){const __val = partial.domainName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "domainName", message: "must not be empty" });
                }
}if("topLevelDomain" in partial && partial.topLevelDomain!== undefined){const __val = partial.topLevelDomain as string; 
                if (__val.length === 0) {
                    errors.push({ field: "topLevelDomain", message: "must not be empty" });
                }
}return errors; }export function emailPartsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "local" in o && "domainName" in o && "topLevelDomain" in o;}export function emailPartsIs(obj: unknown): obj is EmailParts {if(!emailPartsHasShape(obj)){return false;}const result = emailPartsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type EmailPartsErrors = {_errors: Option<Array<string>>; local: Option<Array<string>>; domainName: Option<Array<string>>; topLevelDomain: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type EmailPartsTainted = {local: Option<boolean>; domainName: Option<boolean>; topLevelDomain: Option<boolean>; }; /** Type-safe field controllers for this form */export interface EmailPartsFieldControllers {readonly local: FieldController<string>; readonly domainName: FieldController<string>; readonly topLevelDomain: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface EmailPartsGigaform {readonly data: EmailParts; readonly errors: EmailPartsErrors; readonly tainted: EmailPartsTainted; readonly fields: EmailPartsFieldControllers; validate(): Result<EmailParts, Array<{field: string; message: string}>>; reset(overrides?: Partial<EmailParts>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function emailPartsCreateForm(overrides?: Partial<EmailParts>): EmailPartsGigaform {let data = $state({...emailPartsDefaultValue(),...overrides}); let errors = $state<EmailPartsErrors>({_errors: Option.none(), local: Option.none(), domainName: Option.none(), topLevelDomain: Option.none(), }); let tainted = $state<EmailPartsTainted>({local: Option.none(), domainName: Option.none(), topLevelDomain: Option.none(), }); const fields: EmailPartsFieldControllers = {local: {path: ["local" ]as const, name: "local" , constraints: { required: true }, get: ()=>data.local, set: (value: string)=>{data.local = value;}, transform: (value: string): string =>value,getError: ()=>errors.local, setError: (value: Option<Array<string>>)=>{errors.local = value;}, getTainted: ()=>tainted.local, setTainted: (value: Option<boolean>)=>{tainted.local = value;}, validate: (): Array<string>=>{const fieldErrors = emailPartsValidateField("local", data.local); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},domainName: {path: ["domainName" ]as const, name: "domainName" , constraints: { required: true }, get: ()=>data.domainName, set: (value: string)=>{data.domainName = value;}, transform: (value: string): string =>value,getError: ()=>errors.domainName, setError: (value: Option<Array<string>>)=>{errors.domainName = value;}, getTainted: ()=>tainted.domainName, setTainted: (value: Option<boolean>)=>{tainted.domainName = value;}, validate: (): Array<string>=>{const fieldErrors = emailPartsValidateField("domainName", data.domainName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},topLevelDomain: {path: ["topLevelDomain" ]as const, name: "topLevelDomain" , constraints: { required: true }, get: ()=>data.topLevelDomain, set: (value: string)=>{data.topLevelDomain = value;}, transform: (value: string): string =>value,getError: ()=>errors.topLevelDomain, setError: (value: Option<Array<string>>)=>{errors.topLevelDomain = value;}, getTainted: ()=>tainted.topLevelDomain, setTainted: (value: Option<boolean>)=>{tainted.topLevelDomain = value;}, validate: (): Array<string>=>{const fieldErrors = emailPartsValidateField("topLevelDomain", data.topLevelDomain); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<EmailParts, Array<{field: string; message: string}>>{return emailPartsDeserialize(data);}function reset(newOverrides?: Partial<EmailParts>): void {data = {...emailPartsDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), local: Option.none(), domainName: Option.none(), topLevelDomain: Option.none(), }; tainted = {local: Option.none(), domainName: Option.none(), topLevelDomain: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function emailPartsFromFormData(formData: FormData): Result<EmailParts, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.local = formData.get("local" )?? "" ;obj.domainName = formData.get("domainName" )?? "" ;obj.topLevelDomain = formData.get("topLevelDomain" )?? "" ;return emailPartsDeserialize(obj);}

export const EmailParts = {
  defaultValue: emailPartsDefaultValue,
  serialize: emailPartsSerialize,
  serializeWithContext: emailPartsSerializeWithContext,
  deserialize: emailPartsDeserialize,
  deserializeWithContext: emailPartsDeserializeWithContext,
  validateFields: emailPartsValidateFields,
  hasShape: emailPartsHasShape,
  is: emailPartsIs,
  createForm: emailPartsCreateForm,
  fromFormData: emailPartsFromFormData
} as const;


export interface Sent {
    recipient: string | null;
    method: string | null;
}

export function sentDefaultValue(): Sent {return {recipient: null,
                            method: null, }as Sent;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function sentSerialize(value: Sent): string {const ctx = SerializeContext.create(); return JSON.stringify(sentSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function sentSerializeWithContext(value: Sent, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Sent" , __id,}; result["recipient" ]= value.recipient; result["method" ]= value.method; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function sentDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Sent } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = sentDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Sent.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function sentDeserializeWithContext(value: any, ctx: DeserializeContext): Sent | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Sent.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("recipient" in obj)){errors.push({field: "recipient" , message: "missing required field" });}if(!("method" in obj)){errors.push({field: "method" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_recipient = obj["recipient" ]as string | null; instance.recipient = __raw_recipient; }{const __raw_method = obj["method" ]as string | null; instance.method = __raw_method; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Sent;}export function sentValidateField<K extends keyof Sent>(field: K, value: Sent[K]): Array<{field: string; message: string}>{return[]; }export function sentValidateFields(partial: Partial<Sent>): Array<{field: string; message: string}>{return[]; }export function sentHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "recipient" in o && "method" in o;}export function sentIs(obj: unknown): obj is Sent {if(!sentHasShape(obj)){return false;}const result = sentDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type SentErrors = {_errors: Option<Array<string>>; recipient: Option<Array<string>>; method: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type SentTainted = {recipient: Option<boolean>; method: Option<boolean>; }; /** Type-safe field controllers for this form */export interface SentFieldControllers {readonly recipient: FieldController<string | null>; readonly method: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface SentGigaform {readonly data: Sent; readonly errors: SentErrors; readonly tainted: SentTainted; readonly fields: SentFieldControllers; validate(): Result<Sent, Array<{field: string; message: string}>>; reset(overrides?: Partial<Sent>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function sentCreateForm(overrides?: Partial<Sent>): SentGigaform {let data = $state({...sentDefaultValue(),...overrides}); let errors = $state<SentErrors>({_errors: Option.none(), recipient: Option.none(), method: Option.none(), }); let tainted = $state<SentTainted>({recipient: Option.none(), method: Option.none(), }); const fields: SentFieldControllers = {recipient: {path: ["recipient" ]as const, name: "recipient" , constraints: { required: true }, get: ()=>data.recipient, set: (value: string | null)=>{data.recipient = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.recipient, setError: (value: Option<Array<string>>)=>{errors.recipient = value;}, getTainted: ()=>tainted.recipient, setTainted: (value: Option<boolean>)=>{tainted.recipient = value;}, validate: (): Array<string>=>{const fieldErrors = sentValidateField("recipient", data.recipient); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},method: {path: ["method" ]as const, name: "method" , constraints: { required: true }, get: ()=>data.method, set: (value: string | null)=>{data.method = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.method, setError: (value: Option<Array<string>>)=>{errors.method = value;}, getTainted: ()=>tainted.method, setTainted: (value: Option<boolean>)=>{tainted.method = value;}, validate: (): Array<string>=>{const fieldErrors = sentValidateField("method", data.method); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Sent, Array<{field: string; message: string}>>{return sentDeserialize(data);}function reset(newOverrides?: Partial<Sent>): void {data = {...sentDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), recipient: Option.none(), method: Option.none(), }; tainted = {recipient: Option.none(), method: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function sentFromFormData(formData: FormData): Result<Sent, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.recipient = formData.get("recipient" )?? "" ;obj.method = formData.get("method" )?? "" ;return sentDeserialize(obj);}

export const Sent = {
  defaultValue: sentDefaultValue,
  serialize: sentSerialize,
  serializeWithContext: sentSerializeWithContext,
  deserialize: sentDeserialize,
  deserializeWithContext: sentDeserializeWithContext,
  validateFields: sentValidateFields,
  hasShape: sentHasShape,
  is: sentIs,
  createForm: sentCreateForm,
  fromFormData: sentFromFormData
} as const;


export interface BilledItem {
    
    
    item: Item;
    
    quantity: number;
    
    taxed: boolean;
    
    upsale: boolean;
}

export function billedItemDefaultValue(): BilledItem {return {item: "",
                            quantity: 0,
                            taxed: false,
                            upsale: false, }as BilledItem;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function billedItemSerialize(value: BilledItem): string {const ctx = SerializeContext.create(); return JSON.stringify(billedItemSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function billedItemSerializeWithContext(value: BilledItem, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "BilledItem" , __id,}; result["item" ]= itemSerializeWithContext(value.item, ctx); result["quantity" ]= value.quantity; result["taxed" ]= value.taxed; result["upsale" ]= value.upsale; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function billedItemDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: BilledItem } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = billedItemDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "BilledItem.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function billedItemDeserializeWithContext(value: any, ctx: DeserializeContext): BilledItem | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "BilledItem.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("item" in obj)){errors.push({field: "item" , message: "missing required field" });}if(!("quantity" in obj)){errors.push({field: "quantity" , message: "missing required field" });}if(!("taxed" in obj)){errors.push({field: "taxed" , message: "missing required field" });}if(!("upsale" in obj)){errors.push({field: "upsale" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_item = obj["item" ]as Item; {const __result = itemDeserializeWithContext(__raw_item, ctx); ctx.assignOrDefer(instance, "item" , __result);}}{const __raw_quantity = obj["quantity" ]as number; instance.quantity = __raw_quantity; }{const __raw_taxed = obj["taxed" ]as boolean; instance.taxed = __raw_taxed; }{const __raw_upsale = obj["upsale" ]as boolean; instance.upsale = __raw_upsale; }if(errors.length>0){throw new DeserializeError(errors);}return instance as BilledItem;}export function billedItemValidateField<K extends keyof BilledItem>(field: K, value: BilledItem[K]): Array<{field: string; message: string}>{return[]; }export function billedItemValidateFields(partial: Partial<BilledItem>): Array<{field: string; message: string}>{return[]; }export function billedItemHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "item" in o && "quantity" in o && "taxed" in o && "upsale" in o;}export function billedItemIs(obj: unknown): obj is BilledItem {if(!billedItemHasShape(obj)){return false;}const result = billedItemDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type BilledItemErrors = {_errors: Option<Array<string>>; item: Option<Array<string>>; quantity: Option<Array<string>>; taxed: Option<Array<string>>; upsale: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type BilledItemTainted = {item: Option<boolean>; quantity: Option<boolean>; taxed: Option<boolean>; upsale: Option<boolean>; }; /** Type-safe field controllers for this form */export interface BilledItemFieldControllers {readonly item: FieldController<Item>; readonly quantity: FieldController<number>; readonly taxed: FieldController<boolean>; readonly upsale: FieldController<boolean>; }/** Gigaform instance containing reactive state and field controllers */export interface BilledItemGigaform {readonly data: BilledItem; readonly errors: BilledItemErrors; readonly tainted: BilledItemTainted; readonly fields: BilledItemFieldControllers; validate(): Result<BilledItem, Array<{field: string; message: string}>>; reset(overrides?: Partial<BilledItem>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function billedItemCreateForm(overrides?: Partial<BilledItem>): BilledItemGigaform {let data = $state({...billedItemDefaultValue(),...overrides}); let errors = $state<BilledItemErrors>({_errors: Option.none(), item: Option.none(), quantity: Option.none(), taxed: Option.none(), upsale: Option.none(), }); let tainted = $state<BilledItemTainted>({item: Option.none(), quantity: Option.none(), taxed: Option.none(), upsale: Option.none(), }); const fields: BilledItemFieldControllers = {item: {path: ["item" ]as const, name: "item" , constraints: { required: true }, label: "Item" , get: ()=>data.item, set: (value: Item)=>{data.item = value;}, transform: (value: Item): Item =>value,getError: ()=>errors.item, setError: (value: Option<Array<string>>)=>{errors.item = value;}, getTainted: ()=>tainted.item, setTainted: (value: Option<boolean>)=>{tainted.item = value;}, validate: (): Array<string>=>{const fieldErrors = billedItemValidateField("item", data.item); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},quantity: {path: ["quantity" ]as const, name: "quantity" , constraints: { required: true }, label: "Quantity" , get: ()=>data.quantity, set: (value: number)=>{data.quantity = value;}, transform: (value: number): number =>value,getError: ()=>errors.quantity, setError: (value: Option<Array<string>>)=>{errors.quantity = value;}, getTainted: ()=>tainted.quantity, setTainted: (value: Option<boolean>)=>{tainted.quantity = value;}, validate: (): Array<string>=>{const fieldErrors = billedItemValidateField("quantity", data.quantity); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},taxed: {path: ["taxed" ]as const, name: "taxed" , constraints: { required: true }, label: "Taxed" , get: ()=>data.taxed, set: (value: boolean)=>{data.taxed = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.taxed, setError: (value: Option<Array<string>>)=>{errors.taxed = value;}, getTainted: ()=>tainted.taxed, setTainted: (value: Option<boolean>)=>{tainted.taxed = value;}, validate: (): Array<string>=>{const fieldErrors = billedItemValidateField("taxed", data.taxed); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},upsale: {path: ["upsale" ]as const, name: "upsale" , constraints: { required: true }, label: "Upsale" , get: ()=>data.upsale, set: (value: boolean)=>{data.upsale = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.upsale, setError: (value: Option<Array<string>>)=>{errors.upsale = value;}, getTainted: ()=>tainted.upsale, setTainted: (value: Option<boolean>)=>{tainted.upsale = value;}, validate: (): Array<string>=>{const fieldErrors = billedItemValidateField("upsale", data.upsale); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<BilledItem, Array<{field: string; message: string}>>{return billedItemDeserialize(data);}function reset(newOverrides?: Partial<BilledItem>): void {data = {...billedItemDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), item: Option.none(), quantity: Option.none(), taxed: Option.none(), upsale: Option.none(), }; tainted = {item: Option.none(), quantity: Option.none(), taxed: Option.none(), upsale: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function billedItemFromFormData(formData: FormData): Result<BilledItem, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const item Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("item." )){const fieldName = key.slice("item." .length); const parts = fieldName.split("." ); let current = item Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.item = item Obj;}{const quantity Str = formData.get("quantity" ); obj.quantity = quantity Str? parseFloat(quantity Str as string): 0; if(obj.quantity!== undefined && isNaN(obj.quantity as number))obj.quantity = 0;}{const taxed Val = formData.get("taxed" ); obj.taxed = taxed Val === "true" || taxed Val === "on" || taxed Val === "1" ;}{const upsale Val = formData.get("upsale" ); obj.upsale = upsale Val === "true" || upsale Val === "on" || upsale Val === "1" ;}return billedItemDeserialize(obj);}

export const BilledItem = {
  defaultValue: billedItemDefaultValue,
  serialize: billedItemSerialize,
  serializeWithContext: billedItemSerializeWithContext,
  deserialize: billedItemDeserialize,
  deserializeWithContext: billedItemDeserializeWithContext,
  validateFields: billedItemValidateFields,
  hasShape: billedItemHasShape,
  is: billedItemIs,
  createForm: billedItemCreateForm,
  fromFormData: billedItemFromFormData
} as const;


export interface Coordinates {
    lat: number;
    lng: number;
}

export function coordinatesDefaultValue(): Coordinates {return {lat: 0,
                            lng: 0, }as Coordinates;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function coordinatesSerialize(value: Coordinates): string {const ctx = SerializeContext.create(); return JSON.stringify(coordinatesSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function coordinatesSerializeWithContext(value: Coordinates, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Coordinates" , __id,}; result["lat" ]= value.lat; result["lng" ]= value.lng; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function coordinatesDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Coordinates } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = coordinatesDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Coordinates.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function coordinatesDeserializeWithContext(value: any, ctx: DeserializeContext): Coordinates | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Coordinates.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("lat" in obj)){errors.push({field: "lat" , message: "missing required field" });}if(!("lng" in obj)){errors.push({field: "lng" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_lat = obj["lat" ]as number; instance.lat = __raw_lat; }{const __raw_lng = obj["lng" ]as number; instance.lng = __raw_lng; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Coordinates;}export function coordinatesValidateField<K extends keyof Coordinates>(field: K, value: Coordinates[K]): Array<{field: string; message: string}>{return[]; }export function coordinatesValidateFields(partial: Partial<Coordinates>): Array<{field: string; message: string}>{return[]; }export function coordinatesHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "lat" in o && "lng" in o;}export function coordinatesIs(obj: unknown): obj is Coordinates {if(!coordinatesHasShape(obj)){return false;}const result = coordinatesDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CoordinatesErrors = {_errors: Option<Array<string>>; lat: Option<Array<string>>; lng: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CoordinatesTainted = {lat: Option<boolean>; lng: Option<boolean>; }; /** Type-safe field controllers for this form */export interface CoordinatesFieldControllers {readonly lat: FieldController<number>; readonly lng: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface CoordinatesGigaform {readonly data: Coordinates; readonly errors: CoordinatesErrors; readonly tainted: CoordinatesTainted; readonly fields: CoordinatesFieldControllers; validate(): Result<Coordinates, Array<{field: string; message: string}>>; reset(overrides?: Partial<Coordinates>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function coordinatesCreateForm(overrides?: Partial<Coordinates>): CoordinatesGigaform {let data = $state({...coordinatesDefaultValue(),...overrides}); let errors = $state<CoordinatesErrors>({_errors: Option.none(), lat: Option.none(), lng: Option.none(), }); let tainted = $state<CoordinatesTainted>({lat: Option.none(), lng: Option.none(), }); const fields: CoordinatesFieldControllers = {lat: {path: ["lat" ]as const, name: "lat" , constraints: { required: true }, get: ()=>data.lat, set: (value: number)=>{data.lat = value;}, transform: (value: number): number =>value,getError: ()=>errors.lat, setError: (value: Option<Array<string>>)=>{errors.lat = value;}, getTainted: ()=>tainted.lat, setTainted: (value: Option<boolean>)=>{tainted.lat = value;}, validate: (): Array<string>=>{const fieldErrors = coordinatesValidateField("lat", data.lat); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},lng: {path: ["lng" ]as const, name: "lng" , constraints: { required: true }, get: ()=>data.lng, set: (value: number)=>{data.lng = value;}, transform: (value: number): number =>value,getError: ()=>errors.lng, setError: (value: Option<Array<string>>)=>{errors.lng = value;}, getTainted: ()=>tainted.lng, setTainted: (value: Option<boolean>)=>{tainted.lng = value;}, validate: (): Array<string>=>{const fieldErrors = coordinatesValidateField("lng", data.lng); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Coordinates, Array<{field: string; message: string}>>{return coordinatesDeserialize(data);}function reset(newOverrides?: Partial<Coordinates>): void {data = {...coordinatesDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), lat: Option.none(), lng: Option.none(), }; tainted = {lat: Option.none(), lng: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function coordinatesFromFormData(formData: FormData): Result<Coordinates, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const lat Str = formData.get("lat" ); obj.lat = lat Str? parseFloat(lat Str as string): 0; if(obj.lat!== undefined && isNaN(obj.lat as number))obj.lat = 0;}{const lng Str = formData.get("lng" ); obj.lng = lng Str? parseFloat(lng Str as string): 0; if(obj.lng!== undefined && isNaN(obj.lng as number))obj.lng = 0;}return coordinatesDeserialize(obj);}

export const Coordinates = {
  defaultValue: coordinatesDefaultValue,
  serialize: coordinatesSerialize,
  serializeWithContext: coordinatesSerializeWithContext,
  deserialize: coordinatesDeserialize,
  deserializeWithContext: coordinatesDeserializeWithContext,
  validateFields: coordinatesValidateFields,
  hasShape: coordinatesHasShape,
  is: coordinatesIs,
  createForm: coordinatesCreateForm,
  fromFormData: coordinatesFromFormData
} as const;


export interface Ordered {
    id: string;
    
    in: string | Account;
    
    out: string | Order;
    date: string;
}

export function orderedDefaultValue(): Ordered {return {id: "",
                            in: "",
                            out: "",
                            date: "", }as Ordered;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function orderedSerialize(value: Ordered): string {const ctx = SerializeContext.create(); return JSON.stringify(orderedSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function orderedSerializeWithContext(value: Ordered, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Ordered" , __id,}; result["id" ]= value.id; result["in" ]= value.in; result["out" ]= value.out; result["date" ]= value.date; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function orderedDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Ordered } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = orderedDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Ordered.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function orderedDeserializeWithContext(value: any, ctx: DeserializeContext): Ordered | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Ordered.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("in" in obj)){errors.push({field: "in" , message: "missing required field" });}if(!("out" in obj)){errors.push({field: "out" , message: "missing required field" });}if(!("date" in obj)){errors.push({field: "date" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_in = obj["in" ]as string | Account; instance.in = __raw_in; }{const __raw_out = obj["out" ]as string | Order; instance.out = __raw_out; }{const __raw_date = obj["date" ]as string; instance.date = __raw_date; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Ordered;}export function orderedValidateField<K extends keyof Ordered>(field: K, value: Ordered[K]): Array<{field: string; message: string}>{return[]; }export function orderedValidateFields(partial: Partial<Ordered>): Array<{field: string; message: string}>{return[]; }export function orderedHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "in" in o && "out" in o && "date" in o;}export function orderedIs(obj: unknown): obj is Ordered {if(!orderedHasShape(obj)){return false;}const result = orderedDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type OrderedErrors = {_errors: Option<Array<string>>; id: Option<Array<string>>; in: Option<Array<string>>; out: Option<Array<string>>; date: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type OrderedTainted = {id: Option<boolean>; in: Option<boolean>; out: Option<boolean>; date: Option<boolean>; }; /** Type-safe field controllers for this form */export interface OrderedFieldControllers {readonly id: FieldController<string>; readonly in: FieldController<string | Account>; readonly out: FieldController<string | Order>; readonly date: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface OrderedGigaform {readonly data: Ordered; readonly errors: OrderedErrors; readonly tainted: OrderedTainted; readonly fields: OrderedFieldControllers; validate(): Result<Ordered, Array<{field: string; message: string}>>; reset(overrides?: Partial<Ordered>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function orderedCreateForm(overrides?: Partial<Ordered>): OrderedGigaform {let data = $state({...orderedDefaultValue(),...overrides}); let errors = $state<OrderedErrors>({_errors: Option.none(), id: Option.none(), in: Option.none(), out: Option.none(), date: Option.none(), }); let tainted = $state<OrderedTainted>({id: Option.none(), in: Option.none(), out: Option.none(), date: Option.none(), }); const fields: OrderedFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = orderedValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},in: {path: ["in" ]as const, name: "in" , constraints: { required: true }, get: ()=>data.in, set: (value: string | Account)=>{data.in = value;}, transform: (value: string | Account): string | Account =>value,getError: ()=>errors.in, setError: (value: Option<Array<string>>)=>{errors.in = value;}, getTainted: ()=>tainted.in, setTainted: (value: Option<boolean>)=>{tainted.in = value;}, validate: (): Array<string>=>{const fieldErrors = orderedValidateField("in", data.in); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},out: {path: ["out" ]as const, name: "out" , constraints: { required: true }, get: ()=>data.out, set: (value: string | Order)=>{data.out = value;}, transform: (value: string | Order): string | Order =>value,getError: ()=>errors.out, setError: (value: Option<Array<string>>)=>{errors.out = value;}, getTainted: ()=>tainted.out, setTainted: (value: Option<boolean>)=>{tainted.out = value;}, validate: (): Array<string>=>{const fieldErrors = orderedValidateField("out", data.out); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},date: {path: ["date" ]as const, name: "date" , constraints: { required: true }, get: ()=>data.date, set: (value: string)=>{data.date = value;}, transform: (value: string): string =>value,getError: ()=>errors.date, setError: (value: Option<Array<string>>)=>{errors.date = value;}, getTainted: ()=>tainted.date, setTainted: (value: Option<boolean>)=>{tainted.date = value;}, validate: (): Array<string>=>{const fieldErrors = orderedValidateField("date", data.date); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Ordered, Array<{field: string; message: string}>>{return orderedDeserialize(data);}function reset(newOverrides?: Partial<Ordered>): void {data = {...orderedDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), id: Option.none(), in: Option.none(), out: Option.none(), date: Option.none(), }; tainted = {id: Option.none(), in: Option.none(), out: Option.none(), date: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function orderedFromFormData(formData: FormData): Result<Ordered, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.in = formData.get("in" )?? "" ;obj.out = formData.get("out" )?? "" ;obj.date = formData.get("date" )?? "" ;return orderedDeserialize(obj);}

export const Ordered = {
  defaultValue: orderedDefaultValue,
  serialize: orderedSerialize,
  serializeWithContext: orderedSerializeWithContext,
  deserialize: orderedDeserialize,
  deserializeWithContext: orderedDeserializeWithContext,
  validateFields: orderedValidateFields,
  hasShape: orderedHasShape,
  is: orderedIs,
  createForm: orderedCreateForm,
  fromFormData: orderedFromFormData
} as const;


export interface Email {
    
    canEmail: boolean;
    
    
    emailString: string;
}

export function emailDefaultValue(): Email {return {canEmail: false,
                            emailString: "", }as Email;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function emailSerialize(value: Email): string {const ctx = SerializeContext.create(); return JSON.stringify(emailSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function emailSerializeWithContext(value: Email, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Email" , __id,}; result["canEmail" ]= value.canEmail; result["emailString" ]= value.emailString; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function emailDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Email } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = emailDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Email.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function emailDeserializeWithContext(value: any, ctx: DeserializeContext): Email | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Email.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("canEmail" in obj)){errors.push({field: "canEmail" , message: "missing required field" });}if(!("emailString" in obj)){errors.push({field: "emailString" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_canEmail = obj["canEmail" ]as boolean; instance.canEmail = __raw_canEmail; }{const __raw_emailString = obj["emailString" ]as string; 
                if (__raw_emailString.length === 0) {
                    errors.push({ field: "emailString", message: "must not be empty" });
                }

                if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__raw_emailString)) {
                    errors.push({ field: "emailString", message: "must be a valid email" });
                }
 instance.emailString = __raw_emailString; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Email;}export function emailValidateField<K extends keyof Email>(field: K, value: Email[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "emailString" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "emailString", message: "must not be empty" });
                }

                if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__val)) {
                    errors.push({ field: "emailString", message: "must be a valid email" });
                }
 break;}}return errors; }export function emailValidateFields(partial: Partial<Email>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("emailString" in partial && partial.emailString!== undefined){const __val = partial.emailString as string; 
                if (__val.length === 0) {
                    errors.push({ field: "emailString", message: "must not be empty" });
                }

                if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__val)) {
                    errors.push({ field: "emailString", message: "must be a valid email" });
                }
}return errors; }export function emailHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "canEmail" in o && "emailString" in o;}export function emailIs(obj: unknown): obj is Email {if(!emailHasShape(obj)){return false;}const result = emailDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type EmailErrors = {_errors: Option<Array<string>>; canEmail: Option<Array<string>>; emailString: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type EmailTainted = {canEmail: Option<boolean>; emailString: Option<boolean>; }; /** Type-safe field controllers for this form */export interface EmailFieldControllers {readonly canEmail: FieldController<boolean>; readonly emailString: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface EmailGigaform {readonly data: Email; readonly errors: EmailErrors; readonly tainted: EmailTainted; readonly fields: EmailFieldControllers; validate(): Result<Email, Array<{field: string; message: string}>>; reset(overrides?: Partial<Email>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function emailCreateForm(overrides?: Partial<Email>): EmailGigaform {let data = $state({...emailDefaultValue(),...overrides}); let errors = $state<EmailErrors>({_errors: Option.none(), canEmail: Option.none(), emailString: Option.none(), }); let tainted = $state<EmailTainted>({canEmail: Option.none(), emailString: Option.none(), }); const fields: EmailFieldControllers = {canEmail: {path: ["canEmail" ]as const, name: "canEmail" , constraints: { required: true }, label: "Can Email" , get: ()=>data.canEmail, set: (value: boolean)=>{data.canEmail = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.canEmail, setError: (value: Option<Array<string>>)=>{errors.canEmail = value;}, getTainted: ()=>tainted.canEmail, setTainted: (value: Option<boolean>)=>{tainted.canEmail = value;}, validate: (): Array<string>=>{const fieldErrors = emailValidateField("canEmail", data.canEmail); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},emailString: {path: ["emailString" ]as const, name: "emailString" , constraints: { required: true, type: "email" }, label: "Email" , get: ()=>data.emailString, set: (value: string)=>{data.emailString = value;}, transform: (value: string): string =>value,getError: ()=>errors.emailString, setError: (value: Option<Array<string>>)=>{errors.emailString = value;}, getTainted: ()=>tainted.emailString, setTainted: (value: Option<boolean>)=>{tainted.emailString = value;}, validate: (): Array<string>=>{const fieldErrors = emailValidateField("emailString", data.emailString); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Email, Array<{field: string; message: string}>>{return emailDeserialize(data);}function reset(newOverrides?: Partial<Email>): void {data = {...emailDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), canEmail: Option.none(), emailString: Option.none(), }; tainted = {canEmail: Option.none(), emailString: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function emailFromFormData(formData: FormData): Result<Email, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const canEmail Val = formData.get("canEmail" ); obj.canEmail = canEmail Val === "true" || canEmail Val === "on" || canEmail Val === "1" ;}obj.emailString = formData.get("emailString" )?? "" ;return emailDeserialize(obj);}

export const Email = {
  defaultValue: emailDefaultValue,
  serialize: emailSerialize,
  serializeWithContext: emailSerializeWithContext,
  deserialize: emailDeserialize,
  deserializeWithContext: emailDeserializeWithContext,
  validateFields: emailValidateFields,
  hasShape: emailHasShape,
  is: emailIs,
  createForm: emailCreateForm,
  fromFormData: emailFromFormData
} as const;


export interface RecurrenceRule {
    interval: Interval;
    recurrenceBegins: string;
    recurrenceEnds: RecurrenceEnd | null;
    cancelledInstances: string[] | null;
    additionalInstances: string[] | null;
}

export function recurrenceRuleDefaultValue(): RecurrenceRule {return {interval: intervalDefaultValue(),
                            recurrenceBegins: "",
                            recurrenceEnds: null,
                            cancelledInstances: null,
                            additionalInstances: null, }as RecurrenceRule;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function recurrenceRuleSerialize(value: RecurrenceRule): string {const ctx = SerializeContext.create(); return JSON.stringify(recurrenceRuleSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function recurrenceRuleSerializeWithContext(value: RecurrenceRule, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "RecurrenceRule" , __id,}; result["interval" ]= intervalSerializeWithContext(value.interval, ctx); result["recurrenceBegins" ]= value.recurrenceBegins; if(value.recurrenceEnds!== null){result["recurrenceEnds" ]= recurrenceEndSerializeWithContext(value.recurrenceEnds, ctx); }else {result["recurrenceEnds" ]= null;}if(value.cancelledInstances!== null){result["cancelledInstances" ]= value.cancelledInstances; }else {result["cancelledInstances" ]= null;}if(value.additionalInstances!== null){result["additionalInstances" ]= value.additionalInstances; }else {result["additionalInstances" ]= null;}return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function recurrenceRuleDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: RecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = recurrenceRuleDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "RecurrenceRule.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function recurrenceRuleDeserializeWithContext(value: any, ctx: DeserializeContext): RecurrenceRule | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "RecurrenceRule.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("interval" in obj)){errors.push({field: "interval" , message: "missing required field" });}if(!("recurrenceBegins" in obj)){errors.push({field: "recurrenceBegins" , message: "missing required field" });}if(!("recurrenceEnds" in obj)){errors.push({field: "recurrenceEnds" , message: "missing required field" });}if(!("cancelledInstances" in obj)){errors.push({field: "cancelledInstances" , message: "missing required field" });}if(!("additionalInstances" in obj)){errors.push({field: "additionalInstances" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_interval = obj["interval" ]as Interval; {const __result = intervalDeserializeWithContext(__raw_interval, ctx); ctx.assignOrDefer(instance, "interval" , __result);}}{const __raw_recurrenceBegins = obj["recurrenceBegins" ]as string; instance.recurrenceBegins = __raw_recurrenceBegins; }{const __raw_recurrenceEnds = obj["recurrenceEnds" ]as RecurrenceEnd | null; if(__raw_recurrenceEnds === null){instance.recurrenceEnds = null;}else {const __result = recurrenceEndDeserializeWithContext(__raw_recurrenceEnds, ctx); ctx.assignOrDefer(instance, "recurrenceEnds" , __result); }}{const __raw_cancelledInstances = obj["cancelledInstances" ]as string[] | null; if(__raw_cancelledInstances === null){instance.cancelledInstances = null;}else {instance.cancelledInstances = __raw_cancelledInstances; }}{const __raw_additionalInstances = obj["additionalInstances" ]as string[] | null; if(__raw_additionalInstances === null){instance.additionalInstances = null;}else {instance.additionalInstances = __raw_additionalInstances; }}if(errors.length>0){throw new DeserializeError(errors);}return instance as RecurrenceRule;}export function recurrenceRuleValidateField<K extends keyof RecurrenceRule>(field: K, value: RecurrenceRule[K]): Array<{field: string; message: string}>{return[]; }export function recurrenceRuleValidateFields(partial: Partial<RecurrenceRule>): Array<{field: string; message: string}>{return[]; }export function recurrenceRuleHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "interval" in o && "recurrenceBegins" in o && "recurrenceEnds" in o && "cancelledInstances" in o && "additionalInstances" in o;}export function recurrenceRuleIs(obj: unknown): obj is RecurrenceRule {if(!recurrenceRuleHasShape(obj)){return false;}const result = recurrenceRuleDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type RecurrenceRuleErrors = {_errors: Option<Array<string>>; interval: Option<Array<string>>; recurrenceBegins: Option<Array<string>>; recurrenceEnds: Option<Array<string>>; cancelledInstances: Option<Array<string>>; additionalInstances: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type RecurrenceRuleTainted = {interval: Option<boolean>; recurrenceBegins: Option<boolean>; recurrenceEnds: Option<boolean>; cancelledInstances: Option<boolean>; additionalInstances: Option<boolean>; }; /** Type-safe field controllers for this form */export interface RecurrenceRuleFieldControllers {readonly interval: FieldController<Interval>; readonly recurrenceBegins: FieldController<string>; readonly recurrenceEnds: FieldController<RecurrenceEnd | null>; readonly cancelledInstances: FieldController<string[] | null>; readonly additionalInstances: FieldController<string[] | null>; }/** Gigaform instance containing reactive state and field controllers */export interface RecurrenceRuleGigaform {readonly data: RecurrenceRule; readonly errors: RecurrenceRuleErrors; readonly tainted: RecurrenceRuleTainted; readonly fields: RecurrenceRuleFieldControllers; validate(): Result<RecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<RecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function recurrenceRuleCreateForm(overrides?: Partial<RecurrenceRule>): RecurrenceRuleGigaform {let data = $state({...recurrenceRuleDefaultValue(),...overrides}); let errors = $state<RecurrenceRuleErrors>({_errors: Option.none(), interval: Option.none(), recurrenceBegins: Option.none(), recurrenceEnds: Option.none(), cancelledInstances: Option.none(), additionalInstances: Option.none(), }); let tainted = $state<RecurrenceRuleTainted>({interval: Option.none(), recurrenceBegins: Option.none(), recurrenceEnds: Option.none(), cancelledInstances: Option.none(), additionalInstances: Option.none(), }); const fields: RecurrenceRuleFieldControllers = {interval: {path: ["interval" ]as const, name: "interval" , constraints: { required: true }, get: ()=>data.interval, set: (value: Interval)=>{data.interval = value;}, transform: (value: Interval): Interval =>value,getError: ()=>errors.interval, setError: (value: Option<Array<string>>)=>{errors.interval = value;}, getTainted: ()=>tainted.interval, setTainted: (value: Option<boolean>)=>{tainted.interval = value;}, validate: (): Array<string>=>{const fieldErrors = recurrenceRuleValidateField("interval", data.interval); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},recurrenceBegins: {path: ["recurrenceBegins" ]as const, name: "recurrenceBegins" , constraints: { required: true }, get: ()=>data.recurrenceBegins, set: (value: string)=>{data.recurrenceBegins = value;}, transform: (value: string): string =>value,getError: ()=>errors.recurrenceBegins, setError: (value: Option<Array<string>>)=>{errors.recurrenceBegins = value;}, getTainted: ()=>tainted.recurrenceBegins, setTainted: (value: Option<boolean>)=>{tainted.recurrenceBegins = value;}, validate: (): Array<string>=>{const fieldErrors = recurrenceRuleValidateField("recurrenceBegins", data.recurrenceBegins); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},recurrenceEnds: {path: ["recurrenceEnds" ]as const, name: "recurrenceEnds" , constraints: { required: true }, get: ()=>data.recurrenceEnds, set: (value: RecurrenceEnd | null)=>{data.recurrenceEnds = value;}, transform: (value: RecurrenceEnd | null): RecurrenceEnd | null =>value,getError: ()=>errors.recurrenceEnds, setError: (value: Option<Array<string>>)=>{errors.recurrenceEnds = value;}, getTainted: ()=>tainted.recurrenceEnds, setTainted: (value: Option<boolean>)=>{tainted.recurrenceEnds = value;}, validate: (): Array<string>=>{const fieldErrors = recurrenceRuleValidateField("recurrenceEnds", data.recurrenceEnds); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},cancelledInstances: {path: ["cancelledInstances" ]as const, name: "cancelledInstances" , constraints: { required: true }, get: ()=>data.cancelledInstances, set: (value: string[] | null)=>{data.cancelledInstances = value;}, transform: (value: string[] | null): string[] | null =>value,getError: ()=>errors.cancelledInstances, setError: (value: Option<Array<string>>)=>{errors.cancelledInstances = value;}, getTainted: ()=>tainted.cancelledInstances, setTainted: (value: Option<boolean>)=>{tainted.cancelledInstances = value;}, validate: (): Array<string>=>{const fieldErrors = recurrenceRuleValidateField("cancelledInstances", data.cancelledInstances); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},additionalInstances: {path: ["additionalInstances" ]as const, name: "additionalInstances" , constraints: { required: true }, get: ()=>data.additionalInstances, set: (value: string[] | null)=>{data.additionalInstances = value;}, transform: (value: string[] | null): string[] | null =>value,getError: ()=>errors.additionalInstances, setError: (value: Option<Array<string>>)=>{errors.additionalInstances = value;}, getTainted: ()=>tainted.additionalInstances, setTainted: (value: Option<boolean>)=>{tainted.additionalInstances = value;}, validate: (): Array<string>=>{const fieldErrors = recurrenceRuleValidateField("additionalInstances", data.additionalInstances); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<RecurrenceRule, Array<{field: string; message: string}>>{return recurrenceRuleDeserialize(data);}function reset(newOverrides?: Partial<RecurrenceRule>): void {data = {...recurrenceRuleDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), interval: Option.none(), recurrenceBegins: Option.none(), recurrenceEnds: Option.none(), cancelledInstances: Option.none(), additionalInstances: Option.none(), }; tainted = {interval: Option.none(), recurrenceBegins: Option.none(), recurrenceEnds: Option.none(), cancelledInstances: Option.none(), additionalInstances: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function recurrenceRuleFromFormData(formData: FormData): Result<RecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const interval Obj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("interval." )){const fieldName = key.slice("interval." .length); const parts = fieldName.split("." ); let current = interval Obj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.interval = interval Obj;}obj.recurrenceBegins = formData.get("recurrenceBegins" )?? "" ;obj.recurrenceEnds = formData.get("recurrenceEnds" )?? "" ;obj.cancelledInstances = formData.get("cancelledInstances" )?? "" ;obj.additionalInstances = formData.get("additionalInstances" )?? "" ;return recurrenceRuleDeserialize(obj);}

export const RecurrenceRule = {
  defaultValue: recurrenceRuleDefaultValue,
  serialize: recurrenceRuleSerialize,
  serializeWithContext: recurrenceRuleSerializeWithContext,
  deserialize: recurrenceRuleDeserialize,
  deserializeWithContext: recurrenceRuleDeserializeWithContext,
  validateFields: recurrenceRuleValidateFields,
  hasShape: recurrenceRuleHasShape,
  is: recurrenceRuleIs,
  createForm: recurrenceRuleCreateForm,
  fromFormData: recurrenceRuleFromFormData
} as const;


export interface LastName {
    
    name: string;
}

export function lastNameDefaultValue(): LastName {return {name: "", }as LastName;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function lastNameSerialize(value: LastName): string {const ctx = SerializeContext.create(); return JSON.stringify(lastNameSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function lastNameSerializeWithContext(value: LastName, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "LastName" , __id,}; result["name" ]= value.name; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function lastNameDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: LastName } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = lastNameDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "LastName.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function lastNameDeserializeWithContext(value: any, ctx: DeserializeContext): LastName | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "LastName.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }if(errors.length>0){throw new DeserializeError(errors);}return instance as LastName;}export function lastNameValidateField<K extends keyof LastName>(field: K, value: LastName[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}}return errors; }export function lastNameValidateFields(partial: Partial<LastName>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}return errors; }export function lastNameHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "name" in o;}export function lastNameIs(obj: unknown): obj is LastName {if(!lastNameHasShape(obj)){return false;}const result = lastNameDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type LastNameErrors = {_errors: Option<Array<string>>; name: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type LastNameTainted = {name: Option<boolean>; }; /** Type-safe field controllers for this form */export interface LastNameFieldControllers {readonly name: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface LastNameGigaform {readonly data: LastName; readonly errors: LastNameErrors; readonly tainted: LastNameTainted; readonly fields: LastNameFieldControllers; validate(): Result<LastName, Array<{field: string; message: string}>>; reset(overrides?: Partial<LastName>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function lastNameCreateForm(overrides?: Partial<LastName>): LastNameGigaform {let data = $state({...lastNameDefaultValue(),...overrides}); let errors = $state<LastNameErrors>({_errors: Option.none(), name: Option.none(), }); let tainted = $state<LastNameTainted>({name: Option.none(), }); const fields: LastNameFieldControllers = {name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = lastNameValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<LastName, Array<{field: string; message: string}>>{return lastNameDeserialize(data);}function reset(newOverrides?: Partial<LastName>): void {data = {...lastNameDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), name: Option.none(), }; tainted = {name: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function lastNameFromFormData(formData: FormData): Result<LastName, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.name = formData.get("name" )?? "" ;return lastNameDeserialize(obj);}

export const LastName = {
  defaultValue: lastNameDefaultValue,
  serialize: lastNameSerialize,
  serializeWithContext: lastNameSerializeWithContext,
  deserialize: lastNameDeserialize,
  deserializeWithContext: lastNameDeserializeWithContext,
  validateFields: lastNameValidateFields,
  hasShape: lastNameHasShape,
  is: lastNameIs,
  createForm: lastNameCreateForm,
  fromFormData: lastNameFromFormData
} as const;


export interface Cardinal {
    north: number;
    east: number;
    south: number;
    west: number;
}

export function cardinalDefaultValue(): Cardinal {return {north: 0,
                            east: 0,
                            south: 0,
                            west: 0, }as Cardinal;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function cardinalSerialize(value: Cardinal): string {const ctx = SerializeContext.create(); return JSON.stringify(cardinalSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function cardinalSerializeWithContext(value: Cardinal, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Cardinal" , __id,}; result["north" ]= value.north; result["east" ]= value.east; result["south" ]= value.south; result["west" ]= value.west; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function cardinalDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Cardinal } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = cardinalDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Cardinal.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function cardinalDeserializeWithContext(value: any, ctx: DeserializeContext): Cardinal | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Cardinal.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("north" in obj)){errors.push({field: "north" , message: "missing required field" });}if(!("east" in obj)){errors.push({field: "east" , message: "missing required field" });}if(!("south" in obj)){errors.push({field: "south" , message: "missing required field" });}if(!("west" in obj)){errors.push({field: "west" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_north = obj["north" ]as number; instance.north = __raw_north; }{const __raw_east = obj["east" ]as number; instance.east = __raw_east; }{const __raw_south = obj["south" ]as number; instance.south = __raw_south; }{const __raw_west = obj["west" ]as number; instance.west = __raw_west; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Cardinal;}export function cardinalValidateField<K extends keyof Cardinal>(field: K, value: Cardinal[K]): Array<{field: string; message: string}>{return[]; }export function cardinalValidateFields(partial: Partial<Cardinal>): Array<{field: string; message: string}>{return[]; }export function cardinalHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "north" in o && "east" in o && "south" in o && "west" in o;}export function cardinalIs(obj: unknown): obj is Cardinal {if(!cardinalHasShape(obj)){return false;}const result = cardinalDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CardinalErrors = {_errors: Option<Array<string>>; north: Option<Array<string>>; east: Option<Array<string>>; south: Option<Array<string>>; west: Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CardinalTainted = {north: Option<boolean>; east: Option<boolean>; south: Option<boolean>; west: Option<boolean>; }; /** Type-safe field controllers for this form */export interface CardinalFieldControllers {readonly north: FieldController<number>; readonly east: FieldController<number>; readonly south: FieldController<number>; readonly west: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface CardinalGigaform {readonly data: Cardinal; readonly errors: CardinalErrors; readonly tainted: CardinalTainted; readonly fields: CardinalFieldControllers; validate(): Result<Cardinal, Array<{field: string; message: string}>>; reset(overrides?: Partial<Cardinal>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function cardinalCreateForm(overrides?: Partial<Cardinal>): CardinalGigaform {let data = $state({...cardinalDefaultValue(),...overrides}); let errors = $state<CardinalErrors>({_errors: Option.none(), north: Option.none(), east: Option.none(), south: Option.none(), west: Option.none(), }); let tainted = $state<CardinalTainted>({north: Option.none(), east: Option.none(), south: Option.none(), west: Option.none(), }); const fields: CardinalFieldControllers = {north: {path: ["north" ]as const, name: "north" , constraints: { required: true }, get: ()=>data.north, set: (value: number)=>{data.north = value;}, transform: (value: number): number =>value,getError: ()=>errors.north, setError: (value: Option<Array<string>>)=>{errors.north = value;}, getTainted: ()=>tainted.north, setTainted: (value: Option<boolean>)=>{tainted.north = value;}, validate: (): Array<string>=>{const fieldErrors = cardinalValidateField("north", data.north); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},east: {path: ["east" ]as const, name: "east" , constraints: { required: true }, get: ()=>data.east, set: (value: number)=>{data.east = value;}, transform: (value: number): number =>value,getError: ()=>errors.east, setError: (value: Option<Array<string>>)=>{errors.east = value;}, getTainted: ()=>tainted.east, setTainted: (value: Option<boolean>)=>{tainted.east = value;}, validate: (): Array<string>=>{const fieldErrors = cardinalValidateField("east", data.east); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},south: {path: ["south" ]as const, name: "south" , constraints: { required: true }, get: ()=>data.south, set: (value: number)=>{data.south = value;}, transform: (value: number): number =>value,getError: ()=>errors.south, setError: (value: Option<Array<string>>)=>{errors.south = value;}, getTainted: ()=>tainted.south, setTainted: (value: Option<boolean>)=>{tainted.south = value;}, validate: (): Array<string>=>{const fieldErrors = cardinalValidateField("south", data.south); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},west: {path: ["west" ]as const, name: "west" , constraints: { required: true }, get: ()=>data.west, set: (value: number)=>{data.west = value;}, transform: (value: number): number =>value,getError: ()=>errors.west, setError: (value: Option<Array<string>>)=>{errors.west = value;}, getTainted: ()=>tainted.west, setTainted: (value: Option<boolean>)=>{tainted.west = value;}, validate: (): Array<string>=>{const fieldErrors = cardinalValidateField("west", data.west); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Result<Cardinal, Array<{field: string; message: string}>>{return cardinalDeserialize(data);}function reset(newOverrides?: Partial<Cardinal>): void {data = {...cardinalDefaultValue(),...newOverrides}; errors = {_errors: Option.none(), north: Option.none(), east: Option.none(), south: Option.none(), west: Option.none(), }; tainted = {north: Option.none(), east: Option.none(), south: Option.none(), west: Option.none(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function cardinalFromFormData(formData: FormData): Result<Cardinal, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const north Str = formData.get("north" ); obj.north = north Str? parseFloat(north Str as string): 0; if(obj.north!== undefined && isNaN(obj.north as number))obj.north = 0;}{const east Str = formData.get("east" ); obj.east = east Str? parseFloat(east Str as string): 0; if(obj.east!== undefined && isNaN(obj.east as number))obj.east = 0;}{const south Str = formData.get("south" ); obj.south = south Str? parseFloat(south Str as string): 0; if(obj.south!== undefined && isNaN(obj.south as number))obj.south = 0;}{const west Str = formData.get("west" ); obj.west = west Str? parseFloat(west Str as string): 0; if(obj.west!== undefined && isNaN(obj.west as number))obj.west = 0;}return cardinalDeserialize(obj);}

export const Cardinal = {
  defaultValue: cardinalDefaultValue,
  serialize: cardinalSerialize,
  serializeWithContext: cardinalSerializeWithContext,
  deserialize: cardinalDeserialize,
  deserializeWithContext: cardinalDeserializeWithContext,
  validateFields: cardinalValidateFields,
  hasShape: cardinalHasShape,
  is: cardinalIs,
  createForm: cardinalCreateForm,
  fromFormData: cardinalFromFormData
} as const;


export type Interval =
    | /** @default */ DailyRecurrenceRule
    | WeeklyRecurrenceRule
    | MonthlyRecurrenceRule
    | YearlyRecurrenceRule;

export function intervalDefaultValue(): Interval {return dailyRecurrenceRuleDefaultValue();}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function intervalSerialize(value: Interval): string {const ctx = SerializeContext.create(); return JSON.stringify(intervalSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function intervalSerializeWithContext(value: Interval, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function intervalDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Interval } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = intervalDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Interval.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function intervalDeserializeWithContext(value: any, ctx: DeserializeContext): Interval | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Interval | PendingRef;}if(typeof value!== "object" || value === null){throw new DeserializeError([{field: "_root" , message: "Interval.deserializeWithContext: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new DeserializeError([{field: "_root" , message: "Interval.deserializeWithContext: missing __type field for union dispatch" }]);}if(__typeName === "DailyRecurrenceRule" ){return dailyRecurrenceRuleDeserializeWithContext(value, ctx)as Interval;}if(__typeName === "WeeklyRecurrenceRule" ){return weeklyRecurrenceRuleDeserializeWithContext(value, ctx)as Interval;}if(__typeName === "MonthlyRecurrenceRule" ){return monthlyRecurrenceRuleDeserializeWithContext(value, ctx)as Interval;}if(__typeName === "YearlyRecurrenceRule" ){return yearlyRecurrenceRuleDeserializeWithContext(value, ctx)as Interval;}throw new DeserializeError([{field: "_root" , message: "Interval.deserializeWithContext: unknown type \"" + __typeName + "\". Expected one of: DailyRecurrenceRule, WeeklyRecurrenceRule, MonthlyRecurrenceRule, YearlyRecurrenceRule" }]); }export function intervalIs(value: unknown): value is Interval {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "DailyRecurrenceRule" || __typeName === "WeeklyRecurrenceRule" || __typeName === "MonthlyRecurrenceRule" || __typeName === "YearlyRecurrenceRule" ; }

/** Per-variant error types */export type IntervalDailyRecurrenceRule Errors = {_errors: Option<Array<string>>; }; export type IntervalWeeklyRecurrenceRule Errors = {_errors: Option<Array<string>>; }; export type IntervalMonthlyRecurrenceRule Errors = {_errors: Option<Array<string>>; }; export type IntervalYearlyRecurrenceRule Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type IntervalDailyRecurrenceRule Tainted = {}; export type IntervalWeeklyRecurrenceRule Tainted = {}; export type IntervalMonthlyRecurrenceRule Tainted = {}; export type IntervalYearlyRecurrenceRule Tainted = {}; /** Union error type */export type IntervalErrors = ({ _type: "DailyRecurrenceRule" } & IntervalDailyRecurrenceRuleErrors) | ({ _type: "WeeklyRecurrenceRule" } & IntervalWeeklyRecurrenceRuleErrors) | ({ _type: "MonthlyRecurrenceRule" } & IntervalMonthlyRecurrenceRuleErrors) | ({ _type: "YearlyRecurrenceRule" } & IntervalYearlyRecurrenceRuleErrors); /** Union tainted type */export type IntervalTainted = ({ _type: "DailyRecurrenceRule" } & IntervalDailyRecurrenceRuleTainted) | ({ _type: "WeeklyRecurrenceRule" } & IntervalWeeklyRecurrenceRuleTainted) | ({ _type: "MonthlyRecurrenceRule" } & IntervalMonthlyRecurrenceRuleTainted) | ({ _type: "YearlyRecurrenceRule" } & IntervalYearlyRecurrenceRuleTainted); /** Per-variant field controller types */export interface IntervalDailyRecurrenceRule FieldControllers {}export interface IntervalWeeklyRecurrenceRule FieldControllers {}export interface IntervalMonthlyRecurrenceRule FieldControllers {}export interface IntervalYearlyRecurrenceRule FieldControllers {}/** Union Gigaform interface with variant switching */export interface IntervalGigaform {readonly currentVariant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule"; readonly data: Interval; readonly errors: IntervalErrors; readonly tainted: IntervalTainted; readonly variants: IntervalVariantFields; switchVariant(variant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule"): void; validate(): Result<Interval, Array<{field: string; message: string}>>; reset(overrides?: Partial<Interval>): void;}/** Variant fields container */export interface IntervalVariantFields {readonly DailyRecurrenceRule: {readonly fields: IntervalDailyRecurrenceRule FieldControllers}; readonly WeeklyRecurrenceRule: {readonly fields: IntervalWeeklyRecurrenceRule FieldControllers}; readonly MonthlyRecurrenceRule: {readonly fields: IntervalMonthlyRecurrenceRule FieldControllers}; readonly YearlyRecurrenceRule: {readonly fields: IntervalYearlyRecurrenceRule FieldControllers}; }/** Gets default value for a specific variant */function intervalGetDefaultForVariant(variant: string): Interval {switch(variant){case "DailyRecurrenceRule" : return dailyRecurrenceRuleDefaultValue() as Interval; case "WeeklyRecurrenceRule" : return weeklyRecurrenceRuleDefaultValue() as Interval; case "MonthlyRecurrenceRule" : return monthlyRecurrenceRuleDefaultValue() as Interval; case "YearlyRecurrenceRule" : return yearlyRecurrenceRuleDefaultValue() as Interval; default: return dailyRecurrenceRuleDefaultValue() as Interval;}}/** Creates a new discriminated union Gigaform with variant switching */export function intervalCreateForm(initial?: Interval): IntervalGigaform {const initialVariant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule" = "DailyRecurrenceRule"; let currentVariant = $state<"DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule">(initialVariant); let data = $state<Interval>(initial?? intervalGetDefaultForVariant(initialVariant)); let errors = $state<IntervalErrors>({}as IntervalErrors); let tainted = $state<IntervalTainted>({}as IntervalTainted); const variants: IntervalVariantFields = {DailyRecurrenceRule: {fields: {}as IntervalDailyRecurrenceRule FieldControllers}, WeeklyRecurrenceRule: {fields: {}as IntervalWeeklyRecurrenceRule FieldControllers}, MonthlyRecurrenceRule: {fields: {}as IntervalMonthlyRecurrenceRule FieldControllers}, YearlyRecurrenceRule: {fields: {}as IntervalYearlyRecurrenceRule FieldControllers}, }; function switchVariant(variant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule"): void {currentVariant = variant; data = intervalGetDefaultForVariant(variant); errors = {}as IntervalErrors; tainted = {}as IntervalTainted;}function validate(): Result<Interval, Array<{field: string; message: string}>>{return intervalDeserialize(data);}function reset(overrides?: Partial<Interval>): void {data = overrides ? overrides as typeof data : intervalGetDefaultForVariant(currentVariant); errors = {}as IntervalErrors; tainted = {}as IntervalTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function intervalFromFormData(formData: FormData): Result<Interval, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "DailyRecurrenceRule" ){}else if(discriminant === "WeeklyRecurrenceRule" ){}else if(discriminant === "MonthlyRecurrenceRule" ){}else if(discriminant === "YearlyRecurrenceRule" ){}return intervalDeserialize(obj);}

export const Interval = {
  defaultValue: intervalDefaultValue,
  serialize: intervalSerialize,
  serializeWithContext: intervalSerializeWithContext,
  deserialize: intervalDeserialize,
  deserializeWithContext: intervalDeserializeWithContext,
  is: intervalIs,
  createForm: intervalCreateForm,
  fromFormData: intervalFromFormData
} as const;


export type Page =
    | /** @default */ 'SalesHomeDashboard'
    | 'SalesHomeProducts'
    | 'SalesHomeServices'
    | 'SalesHomePackages'
    | 'SalesHomeTaxRates'
    | 'SalesLeadsOverview'
    | 'SalesLeadsActivities'
    | 'SalesLeadsCampaigns'
    | 'SalesLeadsDripCampaigns'
    | 'SalesLeadsOpportunities'
    | 'SalesLeadsPromotions'
    | 'SalesAccountsOverview'
    | 'SalesAccountsActivities'
    | 'SalesAccountsBilling'
    | 'SalesAccountsContracts'
    | 'SalesOrdersOverview'
    | 'SalesOrdersActivities'
    | 'SalesOrdersPayments'
    | 'SalesOrdersCommissions'
    | 'SalesSchedulingSchedule'
    | 'SalesSchedulingAppointments'
    | 'SalesSchedulingRecurring'
    | 'SalesSchedulingRoutes'
    | 'SalesSchedulingReminders'
    | 'UserHome';

export function pageDefaultValue(): Page {return 'SalesHomeDashboard';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function pageSerialize(value: Page): string {const ctx = SerializeContext.create(); return JSON.stringify(pageSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function pageSerializeWithContext(value: Page, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function pageDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Page } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = pageDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Page.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function pageDeserializeWithContext(value: any, ctx: DeserializeContext): Page | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Page | PendingRef;}const allowedValues = ['SalesHomeDashboard', 'SalesHomeProducts', 'SalesHomeServices', 'SalesHomePackages', 'SalesHomeTaxRates', 'SalesLeadsOverview', 'SalesLeadsActivities', 'SalesLeadsCampaigns', 'SalesLeadsDripCampaigns', 'SalesLeadsOpportunities', 'SalesLeadsPromotions', 'SalesAccountsOverview', 'SalesAccountsActivities', 'SalesAccountsBilling', 'SalesAccountsContracts', 'SalesOrdersOverview', 'SalesOrdersActivities', 'SalesOrdersPayments', 'SalesOrdersCommissions', 'SalesSchedulingSchedule', 'SalesSchedulingAppointments', 'SalesSchedulingRecurring', 'SalesSchedulingRoutes', 'SalesSchedulingReminders', 'UserHome', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for Page: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Page; }export function pageIs(value: unknown): value is Page {const allowedValues = ['SalesHomeDashboard', 'SalesHomeProducts', 'SalesHomeServices', 'SalesHomePackages', 'SalesHomeTaxRates', 'SalesLeadsOverview', 'SalesLeadsActivities', 'SalesLeadsCampaigns', 'SalesLeadsDripCampaigns', 'SalesLeadsOpportunities', 'SalesLeadsPromotions', 'SalesAccountsOverview', 'SalesAccountsActivities', 'SalesAccountsBilling', 'SalesAccountsContracts', 'SalesOrdersOverview', 'SalesOrdersActivities', 'SalesOrdersPayments', 'SalesOrdersCommissions', 'SalesSchedulingSchedule', 'SalesSchedulingAppointments', 'SalesSchedulingRecurring', 'SalesSchedulingRoutes', 'SalesSchedulingReminders', 'UserHome', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type PageSalesHomeDashboard Errors = {_errors: Option<Array<string>>; }; export type PageSalesHomeProducts Errors = {_errors: Option<Array<string>>; }; export type PageSalesHomeServices Errors = {_errors: Option<Array<string>>; }; export type PageSalesHomePackages Errors = {_errors: Option<Array<string>>; }; export type PageSalesHomeTaxRates Errors = {_errors: Option<Array<string>>; }; export type PageSalesLeadsOverview Errors = {_errors: Option<Array<string>>; }; export type PageSalesLeadsActivities Errors = {_errors: Option<Array<string>>; }; export type PageSalesLeadsCampaigns Errors = {_errors: Option<Array<string>>; }; export type PageSalesLeadsDripCampaigns Errors = {_errors: Option<Array<string>>; }; export type PageSalesLeadsOpportunities Errors = {_errors: Option<Array<string>>; }; export type PageSalesLeadsPromotions Errors = {_errors: Option<Array<string>>; }; export type PageSalesAccountsOverview Errors = {_errors: Option<Array<string>>; }; export type PageSalesAccountsActivities Errors = {_errors: Option<Array<string>>; }; export type PageSalesAccountsBilling Errors = {_errors: Option<Array<string>>; }; export type PageSalesAccountsContracts Errors = {_errors: Option<Array<string>>; }; export type PageSalesOrdersOverview Errors = {_errors: Option<Array<string>>; }; export type PageSalesOrdersActivities Errors = {_errors: Option<Array<string>>; }; export type PageSalesOrdersPayments Errors = {_errors: Option<Array<string>>; }; export type PageSalesOrdersCommissions Errors = {_errors: Option<Array<string>>; }; export type PageSalesSchedulingSchedule Errors = {_errors: Option<Array<string>>; }; export type PageSalesSchedulingAppointments Errors = {_errors: Option<Array<string>>; }; export type PageSalesSchedulingRecurring Errors = {_errors: Option<Array<string>>; }; export type PageSalesSchedulingRoutes Errors = {_errors: Option<Array<string>>; }; export type PageSalesSchedulingReminders Errors = {_errors: Option<Array<string>>; }; export type PageUserHome Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type PageSalesHomeDashboard Tainted = {}; export type PageSalesHomeProducts Tainted = {}; export type PageSalesHomeServices Tainted = {}; export type PageSalesHomePackages Tainted = {}; export type PageSalesHomeTaxRates Tainted = {}; export type PageSalesLeadsOverview Tainted = {}; export type PageSalesLeadsActivities Tainted = {}; export type PageSalesLeadsCampaigns Tainted = {}; export type PageSalesLeadsDripCampaigns Tainted = {}; export type PageSalesLeadsOpportunities Tainted = {}; export type PageSalesLeadsPromotions Tainted = {}; export type PageSalesAccountsOverview Tainted = {}; export type PageSalesAccountsActivities Tainted = {}; export type PageSalesAccountsBilling Tainted = {}; export type PageSalesAccountsContracts Tainted = {}; export type PageSalesOrdersOverview Tainted = {}; export type PageSalesOrdersActivities Tainted = {}; export type PageSalesOrdersPayments Tainted = {}; export type PageSalesOrdersCommissions Tainted = {}; export type PageSalesSchedulingSchedule Tainted = {}; export type PageSalesSchedulingAppointments Tainted = {}; export type PageSalesSchedulingRecurring Tainted = {}; export type PageSalesSchedulingRoutes Tainted = {}; export type PageSalesSchedulingReminders Tainted = {}; export type PageUserHome Tainted = {}; /** Union error type */export type PageErrors = ({ _value: "SalesHomeDashboard" } & PageSalesHomeDashboardErrors) | ({ _value: "SalesHomeProducts" } & PageSalesHomeProductsErrors) | ({ _value: "SalesHomeServices" } & PageSalesHomeServicesErrors) | ({ _value: "SalesHomePackages" } & PageSalesHomePackagesErrors) | ({ _value: "SalesHomeTaxRates" } & PageSalesHomeTaxRatesErrors) | ({ _value: "SalesLeadsOverview" } & PageSalesLeadsOverviewErrors) | ({ _value: "SalesLeadsActivities" } & PageSalesLeadsActivitiesErrors) | ({ _value: "SalesLeadsCampaigns" } & PageSalesLeadsCampaignsErrors) | ({ _value: "SalesLeadsDripCampaigns" } & PageSalesLeadsDripCampaignsErrors) | ({ _value: "SalesLeadsOpportunities" } & PageSalesLeadsOpportunitiesErrors) | ({ _value: "SalesLeadsPromotions" } & PageSalesLeadsPromotionsErrors) | ({ _value: "SalesAccountsOverview" } & PageSalesAccountsOverviewErrors) | ({ _value: "SalesAccountsActivities" } & PageSalesAccountsActivitiesErrors) | ({ _value: "SalesAccountsBilling" } & PageSalesAccountsBillingErrors) | ({ _value: "SalesAccountsContracts" } & PageSalesAccountsContractsErrors) | ({ _value: "SalesOrdersOverview" } & PageSalesOrdersOverviewErrors) | ({ _value: "SalesOrdersActivities" } & PageSalesOrdersActivitiesErrors) | ({ _value: "SalesOrdersPayments" } & PageSalesOrdersPaymentsErrors) | ({ _value: "SalesOrdersCommissions" } & PageSalesOrdersCommissionsErrors) | ({ _value: "SalesSchedulingSchedule" } & PageSalesSchedulingScheduleErrors) | ({ _value: "SalesSchedulingAppointments" } & PageSalesSchedulingAppointmentsErrors) | ({ _value: "SalesSchedulingRecurring" } & PageSalesSchedulingRecurringErrors) | ({ _value: "SalesSchedulingRoutes" } & PageSalesSchedulingRoutesErrors) | ({ _value: "SalesSchedulingReminders" } & PageSalesSchedulingRemindersErrors) | ({ _value: "UserHome" } & PageUserHomeErrors); /** Union tainted type */export type PageTainted = ({ _value: "SalesHomeDashboard" } & PageSalesHomeDashboardTainted) | ({ _value: "SalesHomeProducts" } & PageSalesHomeProductsTainted) | ({ _value: "SalesHomeServices" } & PageSalesHomeServicesTainted) | ({ _value: "SalesHomePackages" } & PageSalesHomePackagesTainted) | ({ _value: "SalesHomeTaxRates" } & PageSalesHomeTaxRatesTainted) | ({ _value: "SalesLeadsOverview" } & PageSalesLeadsOverviewTainted) | ({ _value: "SalesLeadsActivities" } & PageSalesLeadsActivitiesTainted) | ({ _value: "SalesLeadsCampaigns" } & PageSalesLeadsCampaignsTainted) | ({ _value: "SalesLeadsDripCampaigns" } & PageSalesLeadsDripCampaignsTainted) | ({ _value: "SalesLeadsOpportunities" } & PageSalesLeadsOpportunitiesTainted) | ({ _value: "SalesLeadsPromotions" } & PageSalesLeadsPromotionsTainted) | ({ _value: "SalesAccountsOverview" } & PageSalesAccountsOverviewTainted) | ({ _value: "SalesAccountsActivities" } & PageSalesAccountsActivitiesTainted) | ({ _value: "SalesAccountsBilling" } & PageSalesAccountsBillingTainted) | ({ _value: "SalesAccountsContracts" } & PageSalesAccountsContractsTainted) | ({ _value: "SalesOrdersOverview" } & PageSalesOrdersOverviewTainted) | ({ _value: "SalesOrdersActivities" } & PageSalesOrdersActivitiesTainted) | ({ _value: "SalesOrdersPayments" } & PageSalesOrdersPaymentsTainted) | ({ _value: "SalesOrdersCommissions" } & PageSalesOrdersCommissionsTainted) | ({ _value: "SalesSchedulingSchedule" } & PageSalesSchedulingScheduleTainted) | ({ _value: "SalesSchedulingAppointments" } & PageSalesSchedulingAppointmentsTainted) | ({ _value: "SalesSchedulingRecurring" } & PageSalesSchedulingRecurringTainted) | ({ _value: "SalesSchedulingRoutes" } & PageSalesSchedulingRoutesTainted) | ({ _value: "SalesSchedulingReminders" } & PageSalesSchedulingRemindersTainted) | ({ _value: "UserHome" } & PageUserHomeTainted); /** Per-variant field controller types */export interface PageSalesHomeDashboard FieldControllers {}export interface PageSalesHomeProducts FieldControllers {}export interface PageSalesHomeServices FieldControllers {}export interface PageSalesHomePackages FieldControllers {}export interface PageSalesHomeTaxRates FieldControllers {}export interface PageSalesLeadsOverview FieldControllers {}export interface PageSalesLeadsActivities FieldControllers {}export interface PageSalesLeadsCampaigns FieldControllers {}export interface PageSalesLeadsDripCampaigns FieldControllers {}export interface PageSalesLeadsOpportunities FieldControllers {}export interface PageSalesLeadsPromotions FieldControllers {}export interface PageSalesAccountsOverview FieldControllers {}export interface PageSalesAccountsActivities FieldControllers {}export interface PageSalesAccountsBilling FieldControllers {}export interface PageSalesAccountsContracts FieldControllers {}export interface PageSalesOrdersOverview FieldControllers {}export interface PageSalesOrdersActivities FieldControllers {}export interface PageSalesOrdersPayments FieldControllers {}export interface PageSalesOrdersCommissions FieldControllers {}export interface PageSalesSchedulingSchedule FieldControllers {}export interface PageSalesSchedulingAppointments FieldControllers {}export interface PageSalesSchedulingRecurring FieldControllers {}export interface PageSalesSchedulingRoutes FieldControllers {}export interface PageSalesSchedulingReminders FieldControllers {}export interface PageUserHome FieldControllers {}/** Union Gigaform interface with variant switching */export interface PageGigaform {readonly currentVariant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome"; readonly data: Page; readonly errors: PageErrors; readonly tainted: PageTainted; readonly variants: PageVariantFields; switchVariant(variant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome"): void; validate(): Result<Page, Array<{field: string; message: string}>>; reset(overrides?: Partial<Page>): void;}/** Variant fields container */export interface PageVariantFields {readonly SalesHomeDashboard: {readonly fields: PageSalesHomeDashboard FieldControllers}; readonly SalesHomeProducts: {readonly fields: PageSalesHomeProducts FieldControllers}; readonly SalesHomeServices: {readonly fields: PageSalesHomeServices FieldControllers}; readonly SalesHomePackages: {readonly fields: PageSalesHomePackages FieldControllers}; readonly SalesHomeTaxRates: {readonly fields: PageSalesHomeTaxRates FieldControllers}; readonly SalesLeadsOverview: {readonly fields: PageSalesLeadsOverview FieldControllers}; readonly SalesLeadsActivities: {readonly fields: PageSalesLeadsActivities FieldControllers}; readonly SalesLeadsCampaigns: {readonly fields: PageSalesLeadsCampaigns FieldControllers}; readonly SalesLeadsDripCampaigns: {readonly fields: PageSalesLeadsDripCampaigns FieldControllers}; readonly SalesLeadsOpportunities: {readonly fields: PageSalesLeadsOpportunities FieldControllers}; readonly SalesLeadsPromotions: {readonly fields: PageSalesLeadsPromotions FieldControllers}; readonly SalesAccountsOverview: {readonly fields: PageSalesAccountsOverview FieldControllers}; readonly SalesAccountsActivities: {readonly fields: PageSalesAccountsActivities FieldControllers}; readonly SalesAccountsBilling: {readonly fields: PageSalesAccountsBilling FieldControllers}; readonly SalesAccountsContracts: {readonly fields: PageSalesAccountsContracts FieldControllers}; readonly SalesOrdersOverview: {readonly fields: PageSalesOrdersOverview FieldControllers}; readonly SalesOrdersActivities: {readonly fields: PageSalesOrdersActivities FieldControllers}; readonly SalesOrdersPayments: {readonly fields: PageSalesOrdersPayments FieldControllers}; readonly SalesOrdersCommissions: {readonly fields: PageSalesOrdersCommissions FieldControllers}; readonly SalesSchedulingSchedule: {readonly fields: PageSalesSchedulingSchedule FieldControllers}; readonly SalesSchedulingAppointments: {readonly fields: PageSalesSchedulingAppointments FieldControllers}; readonly SalesSchedulingRecurring: {readonly fields: PageSalesSchedulingRecurring FieldControllers}; readonly SalesSchedulingRoutes: {readonly fields: PageSalesSchedulingRoutes FieldControllers}; readonly SalesSchedulingReminders: {readonly fields: PageSalesSchedulingReminders FieldControllers}; readonly UserHome: {readonly fields: PageUserHome FieldControllers}; }/** Gets default value for a specific variant */function pageGetDefaultForVariant(variant: string): Page {switch(variant){case "SalesHomeDashboard" : return "SalesHomeDashboard" as Page; case "SalesHomeProducts" : return "SalesHomeProducts" as Page; case "SalesHomeServices" : return "SalesHomeServices" as Page; case "SalesHomePackages" : return "SalesHomePackages" as Page; case "SalesHomeTaxRates" : return "SalesHomeTaxRates" as Page; case "SalesLeadsOverview" : return "SalesLeadsOverview" as Page; case "SalesLeadsActivities" : return "SalesLeadsActivities" as Page; case "SalesLeadsCampaigns" : return "SalesLeadsCampaigns" as Page; case "SalesLeadsDripCampaigns" : return "SalesLeadsDripCampaigns" as Page; case "SalesLeadsOpportunities" : return "SalesLeadsOpportunities" as Page; case "SalesLeadsPromotions" : return "SalesLeadsPromotions" as Page; case "SalesAccountsOverview" : return "SalesAccountsOverview" as Page; case "SalesAccountsActivities" : return "SalesAccountsActivities" as Page; case "SalesAccountsBilling" : return "SalesAccountsBilling" as Page; case "SalesAccountsContracts" : return "SalesAccountsContracts" as Page; case "SalesOrdersOverview" : return "SalesOrdersOverview" as Page; case "SalesOrdersActivities" : return "SalesOrdersActivities" as Page; case "SalesOrdersPayments" : return "SalesOrdersPayments" as Page; case "SalesOrdersCommissions" : return "SalesOrdersCommissions" as Page; case "SalesSchedulingSchedule" : return "SalesSchedulingSchedule" as Page; case "SalesSchedulingAppointments" : return "SalesSchedulingAppointments" as Page; case "SalesSchedulingRecurring" : return "SalesSchedulingRecurring" as Page; case "SalesSchedulingRoutes" : return "SalesSchedulingRoutes" as Page; case "SalesSchedulingReminders" : return "SalesSchedulingReminders" as Page; case "UserHome" : return "UserHome" as Page; default: return "SalesHomeDashboard" as Page;}}/** Creates a new discriminated union Gigaform with variant switching */export function pageCreateForm(initial?: Page): PageGigaform {const initialVariant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome" = (initial as "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome") ?? "SalesHomeDashboard"; let currentVariant = $state<"SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome">(initialVariant); let data = $state<Page>(initial?? pageGetDefaultForVariant(initialVariant)); let errors = $state<PageErrors>({}as PageErrors); let tainted = $state<PageTainted>({}as PageTainted); const variants: PageVariantFields = {SalesHomeDashboard: {fields: {}as PageSalesHomeDashboard FieldControllers}, SalesHomeProducts: {fields: {}as PageSalesHomeProducts FieldControllers}, SalesHomeServices: {fields: {}as PageSalesHomeServices FieldControllers}, SalesHomePackages: {fields: {}as PageSalesHomePackages FieldControllers}, SalesHomeTaxRates: {fields: {}as PageSalesHomeTaxRates FieldControllers}, SalesLeadsOverview: {fields: {}as PageSalesLeadsOverview FieldControllers}, SalesLeadsActivities: {fields: {}as PageSalesLeadsActivities FieldControllers}, SalesLeadsCampaigns: {fields: {}as PageSalesLeadsCampaigns FieldControllers}, SalesLeadsDripCampaigns: {fields: {}as PageSalesLeadsDripCampaigns FieldControllers}, SalesLeadsOpportunities: {fields: {}as PageSalesLeadsOpportunities FieldControllers}, SalesLeadsPromotions: {fields: {}as PageSalesLeadsPromotions FieldControllers}, SalesAccountsOverview: {fields: {}as PageSalesAccountsOverview FieldControllers}, SalesAccountsActivities: {fields: {}as PageSalesAccountsActivities FieldControllers}, SalesAccountsBilling: {fields: {}as PageSalesAccountsBilling FieldControllers}, SalesAccountsContracts: {fields: {}as PageSalesAccountsContracts FieldControllers}, SalesOrdersOverview: {fields: {}as PageSalesOrdersOverview FieldControllers}, SalesOrdersActivities: {fields: {}as PageSalesOrdersActivities FieldControllers}, SalesOrdersPayments: {fields: {}as PageSalesOrdersPayments FieldControllers}, SalesOrdersCommissions: {fields: {}as PageSalesOrdersCommissions FieldControllers}, SalesSchedulingSchedule: {fields: {}as PageSalesSchedulingSchedule FieldControllers}, SalesSchedulingAppointments: {fields: {}as PageSalesSchedulingAppointments FieldControllers}, SalesSchedulingRecurring: {fields: {}as PageSalesSchedulingRecurring FieldControllers}, SalesSchedulingRoutes: {fields: {}as PageSalesSchedulingRoutes FieldControllers}, SalesSchedulingReminders: {fields: {}as PageSalesSchedulingReminders FieldControllers}, UserHome: {fields: {}as PageUserHome FieldControllers}, }; function switchVariant(variant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome"): void {currentVariant = variant; data = pageGetDefaultForVariant(variant); errors = {}as PageErrors; tainted = {}as PageTainted;}function validate(): Result<Page, Array<{field: string; message: string}>>{return pageDeserialize(data);}function reset(overrides?: Partial<Page>): void {data = overrides ? overrides as typeof data : pageGetDefaultForVariant(currentVariant); errors = {}as PageErrors; tainted = {}as PageTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function pageFromFormData(formData: FormData): Result<Page, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "SalesHomeDashboard" ){}else if(discriminant === "SalesHomeProducts" ){}else if(discriminant === "SalesHomeServices" ){}else if(discriminant === "SalesHomePackages" ){}else if(discriminant === "SalesHomeTaxRates" ){}else if(discriminant === "SalesLeadsOverview" ){}else if(discriminant === "SalesLeadsActivities" ){}else if(discriminant === "SalesLeadsCampaigns" ){}else if(discriminant === "SalesLeadsDripCampaigns" ){}else if(discriminant === "SalesLeadsOpportunities" ){}else if(discriminant === "SalesLeadsPromotions" ){}else if(discriminant === "SalesAccountsOverview" ){}else if(discriminant === "SalesAccountsActivities" ){}else if(discriminant === "SalesAccountsBilling" ){}else if(discriminant === "SalesAccountsContracts" ){}else if(discriminant === "SalesOrdersOverview" ){}else if(discriminant === "SalesOrdersActivities" ){}else if(discriminant === "SalesOrdersPayments" ){}else if(discriminant === "SalesOrdersCommissions" ){}else if(discriminant === "SalesSchedulingSchedule" ){}else if(discriminant === "SalesSchedulingAppointments" ){}else if(discriminant === "SalesSchedulingRecurring" ){}else if(discriminant === "SalesSchedulingRoutes" ){}else if(discriminant === "SalesSchedulingReminders" ){}else if(discriminant === "UserHome" ){}return pageDeserialize(obj);}

export const Page = {
  defaultValue: pageDefaultValue,
  serialize: pageSerialize,
  serializeWithContext: pageSerializeWithContext,
  deserialize: pageDeserialize,
  deserializeWithContext: pageDeserializeWithContext,
  is: pageIs,
  createForm: pageCreateForm,
  fromFormData: pageFromFormData
} as const;


export type UserRole =
    | /** @default */ 'Administrator'
    | 'SalesRepresentative'
    | 'Technician'
    | 'HumanResources'
    | 'InformationTechnology';

export function userRoleDefaultValue(): UserRole {return 'Administrator';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function userRoleSerialize(value: UserRole): string {const ctx = SerializeContext.create(); return JSON.stringify(userRoleSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function userRoleSerializeWithContext(value: UserRole, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function userRoleDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: UserRole } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = userRoleDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "UserRole.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function userRoleDeserializeWithContext(value: any, ctx: DeserializeContext): UserRole | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as UserRole | PendingRef;}const allowedValues = ['Administrator', 'SalesRepresentative', 'Technician', 'HumanResources', 'InformationTechnology', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for UserRole: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as UserRole; }export function userRoleIs(value: unknown): value is UserRole {const allowedValues = ['Administrator', 'SalesRepresentative', 'Technician', 'HumanResources', 'InformationTechnology', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type UserRoleAdministrator Errors = {_errors: Option<Array<string>>; }; export type UserRoleSalesRepresentative Errors = {_errors: Option<Array<string>>; }; export type UserRoleTechnician Errors = {_errors: Option<Array<string>>; }; export type UserRoleHumanResources Errors = {_errors: Option<Array<string>>; }; export type UserRoleInformationTechnology Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type UserRoleAdministrator Tainted = {}; export type UserRoleSalesRepresentative Tainted = {}; export type UserRoleTechnician Tainted = {}; export type UserRoleHumanResources Tainted = {}; export type UserRoleInformationTechnology Tainted = {}; /** Union error type */export type UserRoleErrors = ({ _value: "Administrator" } & UserRoleAdministratorErrors) | ({ _value: "SalesRepresentative" } & UserRoleSalesRepresentativeErrors) | ({ _value: "Technician" } & UserRoleTechnicianErrors) | ({ _value: "HumanResources" } & UserRoleHumanResourcesErrors) | ({ _value: "InformationTechnology" } & UserRoleInformationTechnologyErrors); /** Union tainted type */export type UserRoleTainted = ({ _value: "Administrator" } & UserRoleAdministratorTainted) | ({ _value: "SalesRepresentative" } & UserRoleSalesRepresentativeTainted) | ({ _value: "Technician" } & UserRoleTechnicianTainted) | ({ _value: "HumanResources" } & UserRoleHumanResourcesTainted) | ({ _value: "InformationTechnology" } & UserRoleInformationTechnologyTainted); /** Per-variant field controller types */export interface UserRoleAdministrator FieldControllers {}export interface UserRoleSalesRepresentative FieldControllers {}export interface UserRoleTechnician FieldControllers {}export interface UserRoleHumanResources FieldControllers {}export interface UserRoleInformationTechnology FieldControllers {}/** Union Gigaform interface with variant switching */export interface UserRoleGigaform {readonly currentVariant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology"; readonly data: UserRole; readonly errors: UserRoleErrors; readonly tainted: UserRoleTainted; readonly variants: UserRoleVariantFields; switchVariant(variant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology"): void; validate(): Result<UserRole, Array<{field: string; message: string}>>; reset(overrides?: Partial<UserRole>): void;}/** Variant fields container */export interface UserRoleVariantFields {readonly Administrator: {readonly fields: UserRoleAdministrator FieldControllers}; readonly SalesRepresentative: {readonly fields: UserRoleSalesRepresentative FieldControllers}; readonly Technician: {readonly fields: UserRoleTechnician FieldControllers}; readonly HumanResources: {readonly fields: UserRoleHumanResources FieldControllers}; readonly InformationTechnology: {readonly fields: UserRoleInformationTechnology FieldControllers}; }/** Gets default value for a specific variant */function userRoleGetDefaultForVariant(variant: string): UserRole {switch(variant){case "Administrator" : return "Administrator" as UserRole; case "SalesRepresentative" : return "SalesRepresentative" as UserRole; case "Technician" : return "Technician" as UserRole; case "HumanResources" : return "HumanResources" as UserRole; case "InformationTechnology" : return "InformationTechnology" as UserRole; default: return "Administrator" as UserRole;}}/** Creates a new discriminated union Gigaform with variant switching */export function userRoleCreateForm(initial?: UserRole): UserRoleGigaform {const initialVariant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology" = (initial as "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology") ?? "Administrator"; let currentVariant = $state<"Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology">(initialVariant); let data = $state<UserRole>(initial?? userRoleGetDefaultForVariant(initialVariant)); let errors = $state<UserRoleErrors>({}as UserRoleErrors); let tainted = $state<UserRoleTainted>({}as UserRoleTainted); const variants: UserRoleVariantFields = {Administrator: {fields: {}as UserRoleAdministrator FieldControllers}, SalesRepresentative: {fields: {}as UserRoleSalesRepresentative FieldControllers}, Technician: {fields: {}as UserRoleTechnician FieldControllers}, HumanResources: {fields: {}as UserRoleHumanResources FieldControllers}, InformationTechnology: {fields: {}as UserRoleInformationTechnology FieldControllers}, }; function switchVariant(variant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology"): void {currentVariant = variant; data = userRoleGetDefaultForVariant(variant); errors = {}as UserRoleErrors; tainted = {}as UserRoleTainted;}function validate(): Result<UserRole, Array<{field: string; message: string}>>{return userRoleDeserialize(data);}function reset(overrides?: Partial<UserRole>): void {data = overrides ? overrides as typeof data : userRoleGetDefaultForVariant(currentVariant); errors = {}as UserRoleErrors; tainted = {}as UserRoleTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function userRoleFromFormData(formData: FormData): Result<UserRole, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Administrator" ){}else if(discriminant === "SalesRepresentative" ){}else if(discriminant === "Technician" ){}else if(discriminant === "HumanResources" ){}else if(discriminant === "InformationTechnology" ){}return userRoleDeserialize(obj);}

export const UserRole = {
  defaultValue: userRoleDefaultValue,
  serialize: userRoleSerialize,
  serializeWithContext: userRoleSerializeWithContext,
  deserialize: userRoleDeserialize,
  deserializeWithContext: userRoleDeserializeWithContext,
  is: userRoleIs,
  createForm: userRoleCreateForm,
  fromFormData: userRoleFromFormData
} as const;


export type Target =
    | /** @default */ Account
    | User
    | Employee
    | Appointment
    | Lead
    | TaxRate
    | Site
    | Route
    | Company
    | Product
    | Service
    | Order
    | Payment
    | Package
    | Promotion
    | Represents
    | Ordered;

export function targetDefaultValue(): Target {return accountDefaultValue();}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function targetSerialize(value: Target): string {const ctx = SerializeContext.create(); return JSON.stringify(targetSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function targetSerializeWithContext(value: Target, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function targetDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Target } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = targetDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Target.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function targetDeserializeWithContext(value: any, ctx: DeserializeContext): Target | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Target | PendingRef;}if(typeof value!== "object" || value === null){throw new DeserializeError([{field: "_root" , message: "Target.deserializeWithContext: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new DeserializeError([{field: "_root" , message: "Target.deserializeWithContext: missing __type field for union dispatch" }]);}if(__typeName === "Account" ){return accountDeserializeWithContext(value, ctx)as Target;}if(__typeName === "User" ){return userDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Employee" ){return employeeDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Appointment" ){return appointmentDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Lead" ){return leadDeserializeWithContext(value, ctx)as Target;}if(__typeName === "TaxRate" ){return taxRateDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Site" ){return siteDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Route" ){return routeDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Company" ){return companyDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Product" ){return productDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Service" ){return serviceDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Order" ){return orderDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Payment" ){return paymentDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Package" ){return packageDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Promotion" ){return promotionDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Represents" ){return representsDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Ordered" ){return orderedDeserializeWithContext(value, ctx)as Target;}throw new DeserializeError([{field: "_root" , message: "Target.deserializeWithContext: unknown type \"" + __typeName + "\". Expected one of: Account, User, Employee, Appointment, Lead, TaxRate, Site, Route, Company, Product, Service, Order, Payment, Package, Promotion, Represents, Ordered" }]); }export function targetIs(value: unknown): value is Target {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "Account" || __typeName === "User" || __typeName === "Employee" || __typeName === "Appointment" || __typeName === "Lead" || __typeName === "TaxRate" || __typeName === "Site" || __typeName === "Route" || __typeName === "Company" || __typeName === "Product" || __typeName === "Service" || __typeName === "Order" || __typeName === "Payment" || __typeName === "Package" || __typeName === "Promotion" || __typeName === "Represents" || __typeName === "Ordered" ; }

/** Per-variant error types */export type TargetAccount Errors = {_errors: Option<Array<string>>; }; export type TargetUser Errors = {_errors: Option<Array<string>>; }; export type TargetEmployee Errors = {_errors: Option<Array<string>>; }; export type TargetAppointment Errors = {_errors: Option<Array<string>>; }; export type TargetLead Errors = {_errors: Option<Array<string>>; }; export type TargetTaxRate Errors = {_errors: Option<Array<string>>; }; export type TargetSite Errors = {_errors: Option<Array<string>>; }; export type TargetRoute Errors = {_errors: Option<Array<string>>; }; export type TargetCompany Errors = {_errors: Option<Array<string>>; }; export type TargetProduct Errors = {_errors: Option<Array<string>>; }; export type TargetService Errors = {_errors: Option<Array<string>>; }; export type TargetOrder Errors = {_errors: Option<Array<string>>; }; export type TargetPayment Errors = {_errors: Option<Array<string>>; }; export type TargetPackage Errors = {_errors: Option<Array<string>>; }; export type TargetPromotion Errors = {_errors: Option<Array<string>>; }; export type TargetRepresents Errors = {_errors: Option<Array<string>>; }; export type TargetOrdered Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type TargetAccount Tainted = {}; export type TargetUser Tainted = {}; export type TargetEmployee Tainted = {}; export type TargetAppointment Tainted = {}; export type TargetLead Tainted = {}; export type TargetTaxRate Tainted = {}; export type TargetSite Tainted = {}; export type TargetRoute Tainted = {}; export type TargetCompany Tainted = {}; export type TargetProduct Tainted = {}; export type TargetService Tainted = {}; export type TargetOrder Tainted = {}; export type TargetPayment Tainted = {}; export type TargetPackage Tainted = {}; export type TargetPromotion Tainted = {}; export type TargetRepresents Tainted = {}; export type TargetOrdered Tainted = {}; /** Union error type */export type TargetErrors = ({ _type: "Account" } & TargetAccountErrors) | ({ _type: "User" } & TargetUserErrors) | ({ _type: "Employee" } & TargetEmployeeErrors) | ({ _type: "Appointment" } & TargetAppointmentErrors) | ({ _type: "Lead" } & TargetLeadErrors) | ({ _type: "TaxRate" } & TargetTaxRateErrors) | ({ _type: "Site" } & TargetSiteErrors) | ({ _type: "Route" } & TargetRouteErrors) | ({ _type: "Company" } & TargetCompanyErrors) | ({ _type: "Product" } & TargetProductErrors) | ({ _type: "Service" } & TargetServiceErrors) | ({ _type: "Order" } & TargetOrderErrors) | ({ _type: "Payment" } & TargetPaymentErrors) | ({ _type: "Package" } & TargetPackageErrors) | ({ _type: "Promotion" } & TargetPromotionErrors) | ({ _type: "Represents" } & TargetRepresentsErrors) | ({ _type: "Ordered" } & TargetOrderedErrors); /** Union tainted type */export type TargetTainted = ({ _type: "Account" } & TargetAccountTainted) | ({ _type: "User" } & TargetUserTainted) | ({ _type: "Employee" } & TargetEmployeeTainted) | ({ _type: "Appointment" } & TargetAppointmentTainted) | ({ _type: "Lead" } & TargetLeadTainted) | ({ _type: "TaxRate" } & TargetTaxRateTainted) | ({ _type: "Site" } & TargetSiteTainted) | ({ _type: "Route" } & TargetRouteTainted) | ({ _type: "Company" } & TargetCompanyTainted) | ({ _type: "Product" } & TargetProductTainted) | ({ _type: "Service" } & TargetServiceTainted) | ({ _type: "Order" } & TargetOrderTainted) | ({ _type: "Payment" } & TargetPaymentTainted) | ({ _type: "Package" } & TargetPackageTainted) | ({ _type: "Promotion" } & TargetPromotionTainted) | ({ _type: "Represents" } & TargetRepresentsTainted) | ({ _type: "Ordered" } & TargetOrderedTainted); /** Per-variant field controller types */export interface TargetAccount FieldControllers {}export interface TargetUser FieldControllers {}export interface TargetEmployee FieldControllers {}export interface TargetAppointment FieldControllers {}export interface TargetLead FieldControllers {}export interface TargetTaxRate FieldControllers {}export interface TargetSite FieldControllers {}export interface TargetRoute FieldControllers {}export interface TargetCompany FieldControllers {}export interface TargetProduct FieldControllers {}export interface TargetService FieldControllers {}export interface TargetOrder FieldControllers {}export interface TargetPayment FieldControllers {}export interface TargetPackage FieldControllers {}export interface TargetPromotion FieldControllers {}export interface TargetRepresents FieldControllers {}export interface TargetOrdered FieldControllers {}/** Union Gigaform interface with variant switching */export interface TargetGigaform {readonly currentVariant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"; readonly data: Target; readonly errors: TargetErrors; readonly tainted: TargetTainted; readonly variants: TargetVariantFields; switchVariant(variant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void; validate(): Result<Target, Array<{field: string; message: string}>>; reset(overrides?: Partial<Target>): void;}/** Variant fields container */export interface TargetVariantFields {readonly Account: {readonly fields: TargetAccount FieldControllers}; readonly User: {readonly fields: TargetUser FieldControllers}; readonly Employee: {readonly fields: TargetEmployee FieldControllers}; readonly Appointment: {readonly fields: TargetAppointment FieldControllers}; readonly Lead: {readonly fields: TargetLead FieldControllers}; readonly TaxRate: {readonly fields: TargetTaxRate FieldControllers}; readonly Site: {readonly fields: TargetSite FieldControllers}; readonly Route: {readonly fields: TargetRoute FieldControllers}; readonly Company: {readonly fields: TargetCompany FieldControllers}; readonly Product: {readonly fields: TargetProduct FieldControllers}; readonly Service: {readonly fields: TargetService FieldControllers}; readonly Order: {readonly fields: TargetOrder FieldControllers}; readonly Payment: {readonly fields: TargetPayment FieldControllers}; readonly Package: {readonly fields: TargetPackage FieldControllers}; readonly Promotion: {readonly fields: TargetPromotion FieldControllers}; readonly Represents: {readonly fields: TargetRepresents FieldControllers}; readonly Ordered: {readonly fields: TargetOrdered FieldControllers}; }/** Gets default value for a specific variant */function targetGetDefaultForVariant(variant: string): Target {switch(variant){case "Account" : return accountDefaultValue() as Target; case "User" : return userDefaultValue() as Target; case "Employee" : return employeeDefaultValue() as Target; case "Appointment" : return appointmentDefaultValue() as Target; case "Lead" : return leadDefaultValue() as Target; case "TaxRate" : return taxRateDefaultValue() as Target; case "Site" : return siteDefaultValue() as Target; case "Route" : return routeDefaultValue() as Target; case "Company" : return companyDefaultValue() as Target; case "Product" : return productDefaultValue() as Target; case "Service" : return serviceDefaultValue() as Target; case "Order" : return orderDefaultValue() as Target; case "Payment" : return paymentDefaultValue() as Target; case "Package" : return packageDefaultValue() as Target; case "Promotion" : return promotionDefaultValue() as Target; case "Represents" : return representsDefaultValue() as Target; case "Ordered" : return orderedDefaultValue() as Target; default: return accountDefaultValue() as Target;}}/** Creates a new discriminated union Gigaform with variant switching */export function targetCreateForm(initial?: Target): TargetGigaform {const initialVariant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" = "Account"; let currentVariant = $state<"Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered">(initialVariant); let data = $state<Target>(initial?? targetGetDefaultForVariant(initialVariant)); let errors = $state<TargetErrors>({}as TargetErrors); let tainted = $state<TargetTainted>({}as TargetTainted); const variants: TargetVariantFields = {Account: {fields: {}as TargetAccount FieldControllers}, User: {fields: {}as TargetUser FieldControllers}, Employee: {fields: {}as TargetEmployee FieldControllers}, Appointment: {fields: {}as TargetAppointment FieldControllers}, Lead: {fields: {}as TargetLead FieldControllers}, TaxRate: {fields: {}as TargetTaxRate FieldControllers}, Site: {fields: {}as TargetSite FieldControllers}, Route: {fields: {}as TargetRoute FieldControllers}, Company: {fields: {}as TargetCompany FieldControllers}, Product: {fields: {}as TargetProduct FieldControllers}, Service: {fields: {}as TargetService FieldControllers}, Order: {fields: {}as TargetOrder FieldControllers}, Payment: {fields: {}as TargetPayment FieldControllers}, Package: {fields: {}as TargetPackage FieldControllers}, Promotion: {fields: {}as TargetPromotion FieldControllers}, Represents: {fields: {}as TargetRepresents FieldControllers}, Ordered: {fields: {}as TargetOrdered FieldControllers}, }; function switchVariant(variant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void {currentVariant = variant; data = targetGetDefaultForVariant(variant); errors = {}as TargetErrors; tainted = {}as TargetTainted;}function validate(): Result<Target, Array<{field: string; message: string}>>{return targetDeserialize(data);}function reset(overrides?: Partial<Target>): void {data = overrides ? overrides as typeof data : targetGetDefaultForVariant(currentVariant); errors = {}as TargetErrors; tainted = {}as TargetTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function targetFromFormData(formData: FormData): Result<Target, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "Account" ){}else if(discriminant === "User" ){}else if(discriminant === "Employee" ){}else if(discriminant === "Appointment" ){}else if(discriminant === "Lead" ){}else if(discriminant === "TaxRate" ){}else if(discriminant === "Site" ){}else if(discriminant === "Route" ){}else if(discriminant === "Company" ){}else if(discriminant === "Product" ){}else if(discriminant === "Service" ){}else if(discriminant === "Order" ){}else if(discriminant === "Payment" ){}else if(discriminant === "Package" ){}else if(discriminant === "Promotion" ){}else if(discriminant === "Represents" ){}else if(discriminant === "Ordered" ){}return targetDeserialize(obj);}

export const Target = {
  defaultValue: targetDefaultValue,
  serialize: targetSerialize,
  serializeWithContext: targetSerializeWithContext,
  deserialize: targetDeserialize,
  deserializeWithContext: targetDeserializeWithContext,
  is: targetIs,
  createForm: targetCreateForm,
  fromFormData: targetFromFormData
} as const;


export type RecurrenceEnd = /** @default(0) */ number | string;

export function recurrenceEndDefaultValue(): RecurrenceEnd {return 0;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function recurrenceEndSerialize(value: RecurrenceEnd): string {const ctx = SerializeContext.create(); return JSON.stringify(recurrenceEndSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function recurrenceEndSerializeWithContext(value: RecurrenceEnd, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function recurrenceEndDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: RecurrenceEnd } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = recurrenceEndDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "RecurrenceEnd.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function recurrenceEndDeserializeWithContext(value: any, ctx: DeserializeContext): RecurrenceEnd | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as RecurrenceEnd | PendingRef;}if(typeof value === "number" ){return value as RecurrenceEnd;}if(typeof value === "string" ){return value as RecurrenceEnd;}throw new DeserializeError([{field: "_root" , message: "RecurrenceEnd.deserializeWithContext: expected number, string, got " + typeof value}]); }export function recurrenceEndIs(value: unknown): value is RecurrenceEnd {return typeof value === "number" || typeof value === "string" ; }

/** Per-variant error types */export type RecurrenceEndNumber Errors = {_errors: Option<Array<string>>; }; export type RecurrenceEndString Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type RecurrenceEndNumber Tainted = {}; export type RecurrenceEndString Tainted = {}; /** Union error type */export type RecurrenceEndErrors = ({ _type: "number" } & RecurrenceEndNumberErrors) | ({ _type: "string" } & RecurrenceEndStringErrors); /** Union tainted type */export type RecurrenceEndTainted = ({ _type: "number" } & RecurrenceEndNumberTainted) | ({ _type: "string" } & RecurrenceEndStringTainted); /** Per-variant field controller types */export interface RecurrenceEndNumber FieldControllers {}export interface RecurrenceEndString FieldControllers {}/** Union Gigaform interface with variant switching */export interface RecurrenceEndGigaform {readonly currentVariant: "number" | "string"; readonly data: RecurrenceEnd; readonly errors: RecurrenceEndErrors; readonly tainted: RecurrenceEndTainted; readonly variants: RecurrenceEndVariantFields; switchVariant(variant: "number" | "string"): void; validate(): Result<RecurrenceEnd, Array<{field: string; message: string}>>; reset(overrides?: Partial<RecurrenceEnd>): void;}/** Variant fields container */export interface RecurrenceEndVariantFields {readonly number: {readonly fields: RecurrenceEndNumber FieldControllers}; readonly string: {readonly fields: RecurrenceEndString FieldControllers}; }/** Gets default value for a specific variant */function recurrenceEndGetDefaultForVariant(variant: string): RecurrenceEnd {switch(variant){case "number" : return 0 as RecurrenceEnd; case "string" : return "" as RecurrenceEnd; default: return 0 as RecurrenceEnd;}}/** Creates a new discriminated union Gigaform with variant switching */export function recurrenceEndCreateForm(initial?: RecurrenceEnd): RecurrenceEndGigaform {const initialVariant: "number" | "string" = "number"; let currentVariant = $state<"number" | "string">(initialVariant); let data = $state<RecurrenceEnd>(initial?? recurrenceEndGetDefaultForVariant(initialVariant)); let errors = $state<RecurrenceEndErrors>({}as RecurrenceEndErrors); let tainted = $state<RecurrenceEndTainted>({}as RecurrenceEndTainted); const variants: RecurrenceEndVariantFields = {number: {fields: {}as RecurrenceEndNumber FieldControllers}, string: {fields: {}as RecurrenceEndString FieldControllers}, }; function switchVariant(variant: "number" | "string"): void {currentVariant = variant; data = recurrenceEndGetDefaultForVariant(variant); errors = {}as RecurrenceEndErrors; tainted = {}as RecurrenceEndTainted;}function validate(): Result<RecurrenceEnd, Array<{field: string; message: string}>>{return recurrenceEndDeserialize(data);}function reset(overrides?: Partial<RecurrenceEnd>): void {data = overrides ? overrides as typeof data : recurrenceEndGetDefaultForVariant(currentVariant); errors = {}as RecurrenceEndErrors; tainted = {}as RecurrenceEndTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function recurrenceEndFromFormData(formData: FormData): Result<RecurrenceEnd, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "number" | "string" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "number" ){}else if(discriminant === "string" ){}return recurrenceEndDeserialize(obj);}

export const RecurrenceEnd = {
  defaultValue: recurrenceEndDefaultValue,
  serialize: recurrenceEndSerialize,
  serializeWithContext: recurrenceEndSerializeWithContext,
  deserialize: recurrenceEndDeserialize,
  deserializeWithContext: recurrenceEndDeserializeWithContext,
  is: recurrenceEndIs,
  createForm: recurrenceEndCreateForm,
  fromFormData: recurrenceEndFromFormData
} as const;


export type OverviewDisplay = /** @default */ 'Card' | 'Table';

export function overviewDisplayDefaultValue(): OverviewDisplay {return 'Card';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function overviewDisplaySerialize(value: OverviewDisplay): string {const ctx = SerializeContext.create(); return JSON.stringify(overviewDisplaySerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function overviewDisplaySerializeWithContext(value: OverviewDisplay, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function overviewDisplayDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: OverviewDisplay } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = overviewDisplayDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "OverviewDisplay.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function overviewDisplayDeserializeWithContext(value: any, ctx: DeserializeContext): OverviewDisplay | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as OverviewDisplay | PendingRef;}const allowedValues = ['Card', 'Table', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for OverviewDisplay: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as OverviewDisplay; }export function overviewDisplayIs(value: unknown): value is OverviewDisplay {const allowedValues = ['Card', 'Table', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type OverviewDisplayCard Errors = {_errors: Option<Array<string>>; }; export type OverviewDisplayTable Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type OverviewDisplayCard Tainted = {}; export type OverviewDisplayTable Tainted = {}; /** Union error type */export type OverviewDisplayErrors = ({ _value: "Card" } & OverviewDisplayCardErrors) | ({ _value: "Table" } & OverviewDisplayTableErrors); /** Union tainted type */export type OverviewDisplayTainted = ({ _value: "Card" } & OverviewDisplayCardTainted) | ({ _value: "Table" } & OverviewDisplayTableTainted); /** Per-variant field controller types */export interface OverviewDisplayCard FieldControllers {}export interface OverviewDisplayTable FieldControllers {}/** Union Gigaform interface with variant switching */export interface OverviewDisplayGigaform {readonly currentVariant: "Card" | "Table"; readonly data: OverviewDisplay; readonly errors: OverviewDisplayErrors; readonly tainted: OverviewDisplayTainted; readonly variants: OverviewDisplayVariantFields; switchVariant(variant: "Card" | "Table"): void; validate(): Result<OverviewDisplay, Array<{field: string; message: string}>>; reset(overrides?: Partial<OverviewDisplay>): void;}/** Variant fields container */export interface OverviewDisplayVariantFields {readonly Card: {readonly fields: OverviewDisplayCard FieldControllers}; readonly Table: {readonly fields: OverviewDisplayTable FieldControllers}; }/** Gets default value for a specific variant */function overviewDisplayGetDefaultForVariant(variant: string): OverviewDisplay {switch(variant){case "Card" : return "Card" as OverviewDisplay; case "Table" : return "Table" as OverviewDisplay; default: return "Card" as OverviewDisplay;}}/** Creates a new discriminated union Gigaform with variant switching */export function overviewDisplayCreateForm(initial?: OverviewDisplay): OverviewDisplayGigaform {const initialVariant: "Card" | "Table" = (initial as "Card" | "Table") ?? "Card"; let currentVariant = $state<"Card" | "Table">(initialVariant); let data = $state<OverviewDisplay>(initial?? overviewDisplayGetDefaultForVariant(initialVariant)); let errors = $state<OverviewDisplayErrors>({}as OverviewDisplayErrors); let tainted = $state<OverviewDisplayTainted>({}as OverviewDisplayTainted); const variants: OverviewDisplayVariantFields = {Card: {fields: {}as OverviewDisplayCard FieldControllers}, Table: {fields: {}as OverviewDisplayTable FieldControllers}, }; function switchVariant(variant: "Card" | "Table"): void {currentVariant = variant; data = overviewDisplayGetDefaultForVariant(variant); errors = {}as OverviewDisplayErrors; tainted = {}as OverviewDisplayTainted;}function validate(): Result<OverviewDisplay, Array<{field: string; message: string}>>{return overviewDisplayDeserialize(data);}function reset(overrides?: Partial<OverviewDisplay>): void {data = overrides ? overrides as typeof data : overviewDisplayGetDefaultForVariant(currentVariant); errors = {}as OverviewDisplayErrors; tainted = {}as OverviewDisplayTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function overviewDisplayFromFormData(formData: FormData): Result<OverviewDisplay, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Card" | "Table" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Card" ){}else if(discriminant === "Table" ){}return overviewDisplayDeserialize(obj);}

export const OverviewDisplay = {
  defaultValue: overviewDisplayDefaultValue,
  serialize: overviewDisplaySerialize,
  serializeWithContext: overviewDisplaySerializeWithContext,
  deserialize: overviewDisplayDeserialize,
  deserializeWithContext: overviewDisplayDeserializeWithContext,
  is: overviewDisplayIs,
  createForm: overviewDisplayCreateForm,
  fromFormData: overviewDisplayFromFormData
} as const;


export type IntervalUnit = /** @default */ 'Day' | 'Week' | 'Month' | 'Year';

export function intervalUnitDefaultValue(): IntervalUnit {return 'Day';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function intervalUnitSerialize(value: IntervalUnit): string {const ctx = SerializeContext.create(); return JSON.stringify(intervalUnitSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function intervalUnitSerializeWithContext(value: IntervalUnit, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function intervalUnitDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: IntervalUnit } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = intervalUnitDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "IntervalUnit.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function intervalUnitDeserializeWithContext(value: any, ctx: DeserializeContext): IntervalUnit | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as IntervalUnit | PendingRef;}const allowedValues = ['Day', 'Week', 'Month', 'Year', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for IntervalUnit: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as IntervalUnit; }export function intervalUnitIs(value: unknown): value is IntervalUnit {const allowedValues = ['Day', 'Week', 'Month', 'Year', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type IntervalUnitDay Errors = {_errors: Option<Array<string>>; }; export type IntervalUnitWeek Errors = {_errors: Option<Array<string>>; }; export type IntervalUnitMonth Errors = {_errors: Option<Array<string>>; }; export type IntervalUnitYear Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type IntervalUnitDay Tainted = {}; export type IntervalUnitWeek Tainted = {}; export type IntervalUnitMonth Tainted = {}; export type IntervalUnitYear Tainted = {}; /** Union error type */export type IntervalUnitErrors = ({ _value: "Day" } & IntervalUnitDayErrors) | ({ _value: "Week" } & IntervalUnitWeekErrors) | ({ _value: "Month" } & IntervalUnitMonthErrors) | ({ _value: "Year" } & IntervalUnitYearErrors); /** Union tainted type */export type IntervalUnitTainted = ({ _value: "Day" } & IntervalUnitDayTainted) | ({ _value: "Week" } & IntervalUnitWeekTainted) | ({ _value: "Month" } & IntervalUnitMonthTainted) | ({ _value: "Year" } & IntervalUnitYearTainted); /** Per-variant field controller types */export interface IntervalUnitDay FieldControllers {}export interface IntervalUnitWeek FieldControllers {}export interface IntervalUnitMonth FieldControllers {}export interface IntervalUnitYear FieldControllers {}/** Union Gigaform interface with variant switching */export interface IntervalUnitGigaform {readonly currentVariant: "Day" | "Week" | "Month" | "Year"; readonly data: IntervalUnit; readonly errors: IntervalUnitErrors; readonly tainted: IntervalUnitTainted; readonly variants: IntervalUnitVariantFields; switchVariant(variant: "Day" | "Week" | "Month" | "Year"): void; validate(): Result<IntervalUnit, Array<{field: string; message: string}>>; reset(overrides?: Partial<IntervalUnit>): void;}/** Variant fields container */export interface IntervalUnitVariantFields {readonly Day: {readonly fields: IntervalUnitDay FieldControllers}; readonly Week: {readonly fields: IntervalUnitWeek FieldControllers}; readonly Month: {readonly fields: IntervalUnitMonth FieldControllers}; readonly Year: {readonly fields: IntervalUnitYear FieldControllers}; }/** Gets default value for a specific variant */function intervalUnitGetDefaultForVariant(variant: string): IntervalUnit {switch(variant){case "Day" : return "Day" as IntervalUnit; case "Week" : return "Week" as IntervalUnit; case "Month" : return "Month" as IntervalUnit; case "Year" : return "Year" as IntervalUnit; default: return "Day" as IntervalUnit;}}/** Creates a new discriminated union Gigaform with variant switching */export function intervalUnitCreateForm(initial?: IntervalUnit): IntervalUnitGigaform {const initialVariant: "Day" | "Week" | "Month" | "Year" = (initial as "Day" | "Week" | "Month" | "Year") ?? "Day"; let currentVariant = $state<"Day" | "Week" | "Month" | "Year">(initialVariant); let data = $state<IntervalUnit>(initial?? intervalUnitGetDefaultForVariant(initialVariant)); let errors = $state<IntervalUnitErrors>({}as IntervalUnitErrors); let tainted = $state<IntervalUnitTainted>({}as IntervalUnitTainted); const variants: IntervalUnitVariantFields = {Day: {fields: {}as IntervalUnitDay FieldControllers}, Week: {fields: {}as IntervalUnitWeek FieldControllers}, Month: {fields: {}as IntervalUnitMonth FieldControllers}, Year: {fields: {}as IntervalUnitYear FieldControllers}, }; function switchVariant(variant: "Day" | "Week" | "Month" | "Year"): void {currentVariant = variant; data = intervalUnitGetDefaultForVariant(variant); errors = {}as IntervalUnitErrors; tainted = {}as IntervalUnitTainted;}function validate(): Result<IntervalUnit, Array<{field: string; message: string}>>{return intervalUnitDeserialize(data);}function reset(overrides?: Partial<IntervalUnit>): void {data = overrides ? overrides as typeof data : intervalUnitGetDefaultForVariant(currentVariant); errors = {}as IntervalUnitErrors; tainted = {}as IntervalUnitTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function intervalUnitFromFormData(formData: FormData): Result<IntervalUnit, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Day" | "Week" | "Month" | "Year" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Day" ){}else if(discriminant === "Week" ){}else if(discriminant === "Month" ){}else if(discriminant === "Year" ){}return intervalUnitDeserialize(obj);}

export const IntervalUnit = {
  defaultValue: intervalUnitDefaultValue,
  serialize: intervalUnitSerialize,
  serializeWithContext: intervalUnitSerializeWithContext,
  deserialize: intervalUnitDeserialize,
  deserializeWithContext: intervalUnitDeserializeWithContext,
  is: intervalUnitIs,
  createForm: intervalUnitCreateForm,
  fromFormData: intervalUnitFromFormData
} as const;


export type Sector = /** @default */ 'Residential' | 'Commercial';

export function sectorDefaultValue(): Sector {return 'Residential';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function sectorSerialize(value: Sector): string {const ctx = SerializeContext.create(); return JSON.stringify(sectorSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function sectorSerializeWithContext(value: Sector, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function sectorDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Sector } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = sectorDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Sector.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function sectorDeserializeWithContext(value: any, ctx: DeserializeContext): Sector | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Sector | PendingRef;}const allowedValues = ['Residential', 'Commercial', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for Sector: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Sector; }export function sectorIs(value: unknown): value is Sector {const allowedValues = ['Residential', 'Commercial', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type SectorResidential Errors = {_errors: Option<Array<string>>; }; export type SectorCommercial Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type SectorResidential Tainted = {}; export type SectorCommercial Tainted = {}; /** Union error type */export type SectorErrors = ({ _value: "Residential" } & SectorResidentialErrors) | ({ _value: "Commercial" } & SectorCommercialErrors); /** Union tainted type */export type SectorTainted = ({ _value: "Residential" } & SectorResidentialTainted) | ({ _value: "Commercial" } & SectorCommercialTainted); /** Per-variant field controller types */export interface SectorResidential FieldControllers {}export interface SectorCommercial FieldControllers {}/** Union Gigaform interface with variant switching */export interface SectorGigaform {readonly currentVariant: "Residential" | "Commercial"; readonly data: Sector; readonly errors: SectorErrors; readonly tainted: SectorTainted; readonly variants: SectorVariantFields; switchVariant(variant: "Residential" | "Commercial"): void; validate(): Result<Sector, Array<{field: string; message: string}>>; reset(overrides?: Partial<Sector>): void;}/** Variant fields container */export interface SectorVariantFields {readonly Residential: {readonly fields: SectorResidential FieldControllers}; readonly Commercial: {readonly fields: SectorCommercial FieldControllers}; }/** Gets default value for a specific variant */function sectorGetDefaultForVariant(variant: string): Sector {switch(variant){case "Residential" : return "Residential" as Sector; case "Commercial" : return "Commercial" as Sector; default: return "Residential" as Sector;}}/** Creates a new discriminated union Gigaform with variant switching */export function sectorCreateForm(initial?: Sector): SectorGigaform {const initialVariant: "Residential" | "Commercial" = (initial as "Residential" | "Commercial") ?? "Residential"; let currentVariant = $state<"Residential" | "Commercial">(initialVariant); let data = $state<Sector>(initial?? sectorGetDefaultForVariant(initialVariant)); let errors = $state<SectorErrors>({}as SectorErrors); let tainted = $state<SectorTainted>({}as SectorTainted); const variants: SectorVariantFields = {Residential: {fields: {}as SectorResidential FieldControllers}, Commercial: {fields: {}as SectorCommercial FieldControllers}, }; function switchVariant(variant: "Residential" | "Commercial"): void {currentVariant = variant; data = sectorGetDefaultForVariant(variant); errors = {}as SectorErrors; tainted = {}as SectorTainted;}function validate(): Result<Sector, Array<{field: string; message: string}>>{return sectorDeserialize(data);}function reset(overrides?: Partial<Sector>): void {data = overrides ? overrides as typeof data : sectorGetDefaultForVariant(currentVariant); errors = {}as SectorErrors; tainted = {}as SectorTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function sectorFromFormData(formData: FormData): Result<Sector, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Residential" | "Commercial" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Residential" ){}else if(discriminant === "Commercial" ){}return sectorDeserialize(obj);}

export const Sector = {
  defaultValue: sectorDefaultValue,
  serialize: sectorSerialize,
  serializeWithContext: sectorSerializeWithContext,
  deserialize: sectorDeserialize,
  deserializeWithContext: sectorDeserializeWithContext,
  is: sectorIs,
  createForm: sectorCreateForm,
  fromFormData: sectorFromFormData
} as const;


export type Weekday =
    | /** @default */ 'Monday'
    | 'Tuesday'
    | 'Wednesday'
    | 'Thursday'
    | 'Friday'
    | 'Saturday'
    | 'Sunday';

export function weekdayDefaultValue(): Weekday {return 'Monday';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function weekdaySerialize(value: Weekday): string {const ctx = SerializeContext.create(); return JSON.stringify(weekdaySerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function weekdaySerializeWithContext(value: Weekday, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function weekdayDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Weekday } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = weekdayDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Weekday.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function weekdayDeserializeWithContext(value: any, ctx: DeserializeContext): Weekday | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Weekday | PendingRef;}const allowedValues = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for Weekday: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Weekday; }export function weekdayIs(value: unknown): value is Weekday {const allowedValues = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type WeekdayMonday Errors = {_errors: Option<Array<string>>; }; export type WeekdayTuesday Errors = {_errors: Option<Array<string>>; }; export type WeekdayWednesday Errors = {_errors: Option<Array<string>>; }; export type WeekdayThursday Errors = {_errors: Option<Array<string>>; }; export type WeekdayFriday Errors = {_errors: Option<Array<string>>; }; export type WeekdaySaturday Errors = {_errors: Option<Array<string>>; }; export type WeekdaySunday Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type WeekdayMonday Tainted = {}; export type WeekdayTuesday Tainted = {}; export type WeekdayWednesday Tainted = {}; export type WeekdayThursday Tainted = {}; export type WeekdayFriday Tainted = {}; export type WeekdaySaturday Tainted = {}; export type WeekdaySunday Tainted = {}; /** Union error type */export type WeekdayErrors = ({ _value: "Monday" } & WeekdayMondayErrors) | ({ _value: "Tuesday" } & WeekdayTuesdayErrors) | ({ _value: "Wednesday" } & WeekdayWednesdayErrors) | ({ _value: "Thursday" } & WeekdayThursdayErrors) | ({ _value: "Friday" } & WeekdayFridayErrors) | ({ _value: "Saturday" } & WeekdaySaturdayErrors) | ({ _value: "Sunday" } & WeekdaySundayErrors); /** Union tainted type */export type WeekdayTainted = ({ _value: "Monday" } & WeekdayMondayTainted) | ({ _value: "Tuesday" } & WeekdayTuesdayTainted) | ({ _value: "Wednesday" } & WeekdayWednesdayTainted) | ({ _value: "Thursday" } & WeekdayThursdayTainted) | ({ _value: "Friday" } & WeekdayFridayTainted) | ({ _value: "Saturday" } & WeekdaySaturdayTainted) | ({ _value: "Sunday" } & WeekdaySundayTainted); /** Per-variant field controller types */export interface WeekdayMonday FieldControllers {}export interface WeekdayTuesday FieldControllers {}export interface WeekdayWednesday FieldControllers {}export interface WeekdayThursday FieldControllers {}export interface WeekdayFriday FieldControllers {}export interface WeekdaySaturday FieldControllers {}export interface WeekdaySunday FieldControllers {}/** Union Gigaform interface with variant switching */export interface WeekdayGigaform {readonly currentVariant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"; readonly data: Weekday; readonly errors: WeekdayErrors; readonly tainted: WeekdayTainted; readonly variants: WeekdayVariantFields; switchVariant(variant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"): void; validate(): Result<Weekday, Array<{field: string; message: string}>>; reset(overrides?: Partial<Weekday>): void;}/** Variant fields container */export interface WeekdayVariantFields {readonly Monday: {readonly fields: WeekdayMonday FieldControllers}; readonly Tuesday: {readonly fields: WeekdayTuesday FieldControllers}; readonly Wednesday: {readonly fields: WeekdayWednesday FieldControllers}; readonly Thursday: {readonly fields: WeekdayThursday FieldControllers}; readonly Friday: {readonly fields: WeekdayFriday FieldControllers}; readonly Saturday: {readonly fields: WeekdaySaturday FieldControllers}; readonly Sunday: {readonly fields: WeekdaySunday FieldControllers}; }/** Gets default value for a specific variant */function weekdayGetDefaultForVariant(variant: string): Weekday {switch(variant){case "Monday" : return "Monday" as Weekday; case "Tuesday" : return "Tuesday" as Weekday; case "Wednesday" : return "Wednesday" as Weekday; case "Thursday" : return "Thursday" as Weekday; case "Friday" : return "Friday" as Weekday; case "Saturday" : return "Saturday" as Weekday; case "Sunday" : return "Sunday" as Weekday; default: return "Monday" as Weekday;}}/** Creates a new discriminated union Gigaform with variant switching */export function weekdayCreateForm(initial?: Weekday): WeekdayGigaform {const initialVariant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday" = (initial as "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday") ?? "Monday"; let currentVariant = $state<"Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday">(initialVariant); let data = $state<Weekday>(initial?? weekdayGetDefaultForVariant(initialVariant)); let errors = $state<WeekdayErrors>({}as WeekdayErrors); let tainted = $state<WeekdayTainted>({}as WeekdayTainted); const variants: WeekdayVariantFields = {Monday: {fields: {}as WeekdayMonday FieldControllers}, Tuesday: {fields: {}as WeekdayTuesday FieldControllers}, Wednesday: {fields: {}as WeekdayWednesday FieldControllers}, Thursday: {fields: {}as WeekdayThursday FieldControllers}, Friday: {fields: {}as WeekdayFriday FieldControllers}, Saturday: {fields: {}as WeekdaySaturday FieldControllers}, Sunday: {fields: {}as WeekdaySunday FieldControllers}, }; function switchVariant(variant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"): void {currentVariant = variant; data = weekdayGetDefaultForVariant(variant); errors = {}as WeekdayErrors; tainted = {}as WeekdayTainted;}function validate(): Result<Weekday, Array<{field: string; message: string}>>{return weekdayDeserialize(data);}function reset(overrides?: Partial<Weekday>): void {data = overrides ? overrides as typeof data : weekdayGetDefaultForVariant(currentVariant); errors = {}as WeekdayErrors; tainted = {}as WeekdayTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function weekdayFromFormData(formData: FormData): Result<Weekday, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Monday" ){}else if(discriminant === "Tuesday" ){}else if(discriminant === "Wednesday" ){}else if(discriminant === "Thursday" ){}else if(discriminant === "Friday" ){}else if(discriminant === "Saturday" ){}else if(discriminant === "Sunday" ){}return weekdayDeserialize(obj);}

export const Weekday = {
  defaultValue: weekdayDefaultValue,
  serialize: weekdaySerialize,
  serializeWithContext: weekdaySerializeWithContext,
  deserialize: weekdayDeserialize,
  deserializeWithContext: weekdayDeserializeWithContext,
  is: weekdayIs,
  createForm: weekdayCreateForm,
  fromFormData: weekdayFromFormData
} as const;


export type Status = /** @default */ 'Scheduled' | 'OnDeck' | 'Waiting';

export function statusDefaultValue(): Status {return 'Scheduled';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function statusSerialize(value: Status): string {const ctx = SerializeContext.create(); return JSON.stringify(statusSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function statusSerializeWithContext(value: Status, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function statusDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Status } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = statusDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Status.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function statusDeserializeWithContext(value: any, ctx: DeserializeContext): Status | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Status | PendingRef;}const allowedValues = ['Scheduled', 'OnDeck', 'Waiting', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for Status: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Status; }export function statusIs(value: unknown): value is Status {const allowedValues = ['Scheduled', 'OnDeck', 'Waiting', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type StatusScheduled Errors = {_errors: Option<Array<string>>; }; export type StatusOnDeck Errors = {_errors: Option<Array<string>>; }; export type StatusWaiting Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type StatusScheduled Tainted = {}; export type StatusOnDeck Tainted = {}; export type StatusWaiting Tainted = {}; /** Union error type */export type StatusErrors = ({ _value: "Scheduled" } & StatusScheduledErrors) | ({ _value: "OnDeck" } & StatusOnDeckErrors) | ({ _value: "Waiting" } & StatusWaitingErrors); /** Union tainted type */export type StatusTainted = ({ _value: "Scheduled" } & StatusScheduledTainted) | ({ _value: "OnDeck" } & StatusOnDeckTainted) | ({ _value: "Waiting" } & StatusWaitingTainted); /** Per-variant field controller types */export interface StatusScheduled FieldControllers {}export interface StatusOnDeck FieldControllers {}export interface StatusWaiting FieldControllers {}/** Union Gigaform interface with variant switching */export interface StatusGigaform {readonly currentVariant: "Scheduled" | "OnDeck" | "Waiting"; readonly data: Status; readonly errors: StatusErrors; readonly tainted: StatusTainted; readonly variants: StatusVariantFields; switchVariant(variant: "Scheduled" | "OnDeck" | "Waiting"): void; validate(): Result<Status, Array<{field: string; message: string}>>; reset(overrides?: Partial<Status>): void;}/** Variant fields container */export interface StatusVariantFields {readonly Scheduled: {readonly fields: StatusScheduled FieldControllers}; readonly OnDeck: {readonly fields: StatusOnDeck FieldControllers}; readonly Waiting: {readonly fields: StatusWaiting FieldControllers}; }/** Gets default value for a specific variant */function statusGetDefaultForVariant(variant: string): Status {switch(variant){case "Scheduled" : return "Scheduled" as Status; case "OnDeck" : return "OnDeck" as Status; case "Waiting" : return "Waiting" as Status; default: return "Scheduled" as Status;}}/** Creates a new discriminated union Gigaform with variant switching */export function statusCreateForm(initial?: Status): StatusGigaform {const initialVariant: "Scheduled" | "OnDeck" | "Waiting" = (initial as "Scheduled" | "OnDeck" | "Waiting") ?? "Scheduled"; let currentVariant = $state<"Scheduled" | "OnDeck" | "Waiting">(initialVariant); let data = $state<Status>(initial?? statusGetDefaultForVariant(initialVariant)); let errors = $state<StatusErrors>({}as StatusErrors); let tainted = $state<StatusTainted>({}as StatusTainted); const variants: StatusVariantFields = {Scheduled: {fields: {}as StatusScheduled FieldControllers}, OnDeck: {fields: {}as StatusOnDeck FieldControllers}, Waiting: {fields: {}as StatusWaiting FieldControllers}, }; function switchVariant(variant: "Scheduled" | "OnDeck" | "Waiting"): void {currentVariant = variant; data = statusGetDefaultForVariant(variant); errors = {}as StatusErrors; tainted = {}as StatusTainted;}function validate(): Result<Status, Array<{field: string; message: string}>>{return statusDeserialize(data);}function reset(overrides?: Partial<Status>): void {data = overrides ? overrides as typeof data : statusGetDefaultForVariant(currentVariant); errors = {}as StatusErrors; tainted = {}as StatusTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function statusFromFormData(formData: FormData): Result<Status, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Scheduled" | "OnDeck" | "Waiting" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Scheduled" ){}else if(discriminant === "OnDeck" ){}else if(discriminant === "Waiting" ){}return statusDeserialize(obj);}

export const Status = {
  defaultValue: statusDefaultValue,
  serialize: statusSerialize,
  serializeWithContext: statusSerializeWithContext,
  deserialize: statusDeserialize,
  deserializeWithContext: statusDeserializeWithContext,
  is: statusIs,
  createForm: statusCreateForm,
  fromFormData: statusFromFormData
} as const;


export type NextStep = /** @default */ 'InitialContact' | 'Qualified' | 'Estimate' | 'Negotiation';

export function nextStepDefaultValue(): NextStep {return 'InitialContact';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function nextStepSerialize(value: NextStep): string {const ctx = SerializeContext.create(); return JSON.stringify(nextStepSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function nextStepSerializeWithContext(value: NextStep, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function nextStepDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: NextStep } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = nextStepDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "NextStep.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function nextStepDeserializeWithContext(value: any, ctx: DeserializeContext): NextStep | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as NextStep | PendingRef;}const allowedValues = ['InitialContact', 'Qualified', 'Estimate', 'Negotiation', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for NextStep: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as NextStep; }export function nextStepIs(value: unknown): value is NextStep {const allowedValues = ['InitialContact', 'Qualified', 'Estimate', 'Negotiation', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type NextStepInitialContact Errors = {_errors: Option<Array<string>>; }; export type NextStepQualified Errors = {_errors: Option<Array<string>>; }; export type NextStepEstimate Errors = {_errors: Option<Array<string>>; }; export type NextStepNegotiation Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type NextStepInitialContact Tainted = {}; export type NextStepQualified Tainted = {}; export type NextStepEstimate Tainted = {}; export type NextStepNegotiation Tainted = {}; /** Union error type */export type NextStepErrors = ({ _value: "InitialContact" } & NextStepInitialContactErrors) | ({ _value: "Qualified" } & NextStepQualifiedErrors) | ({ _value: "Estimate" } & NextStepEstimateErrors) | ({ _value: "Negotiation" } & NextStepNegotiationErrors); /** Union tainted type */export type NextStepTainted = ({ _value: "InitialContact" } & NextStepInitialContactTainted) | ({ _value: "Qualified" } & NextStepQualifiedTainted) | ({ _value: "Estimate" } & NextStepEstimateTainted) | ({ _value: "Negotiation" } & NextStepNegotiationTainted); /** Per-variant field controller types */export interface NextStepInitialContact FieldControllers {}export interface NextStepQualified FieldControllers {}export interface NextStepEstimate FieldControllers {}export interface NextStepNegotiation FieldControllers {}/** Union Gigaform interface with variant switching */export interface NextStepGigaform {readonly currentVariant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation"; readonly data: NextStep; readonly errors: NextStepErrors; readonly tainted: NextStepTainted; readonly variants: NextStepVariantFields; switchVariant(variant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void; validate(): Result<NextStep, Array<{field: string; message: string}>>; reset(overrides?: Partial<NextStep>): void;}/** Variant fields container */export interface NextStepVariantFields {readonly InitialContact: {readonly fields: NextStepInitialContact FieldControllers}; readonly Qualified: {readonly fields: NextStepQualified FieldControllers}; readonly Estimate: {readonly fields: NextStepEstimate FieldControllers}; readonly Negotiation: {readonly fields: NextStepNegotiation FieldControllers}; }/** Gets default value for a specific variant */function nextStepGetDefaultForVariant(variant: string): NextStep {switch(variant){case "InitialContact" : return "InitialContact" as NextStep; case "Qualified" : return "Qualified" as NextStep; case "Estimate" : return "Estimate" as NextStep; case "Negotiation" : return "Negotiation" as NextStep; default: return "InitialContact" as NextStep;}}/** Creates a new discriminated union Gigaform with variant switching */export function nextStepCreateForm(initial?: NextStep): NextStepGigaform {const initialVariant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation" = (initial as "InitialContact" | "Qualified" | "Estimate" | "Negotiation") ?? "InitialContact"; let currentVariant = $state<"InitialContact" | "Qualified" | "Estimate" | "Negotiation">(initialVariant); let data = $state<NextStep>(initial?? nextStepGetDefaultForVariant(initialVariant)); let errors = $state<NextStepErrors>({}as NextStepErrors); let tainted = $state<NextStepTainted>({}as NextStepTainted); const variants: NextStepVariantFields = {InitialContact: {fields: {}as NextStepInitialContact FieldControllers}, Qualified: {fields: {}as NextStepQualified FieldControllers}, Estimate: {fields: {}as NextStepEstimate FieldControllers}, Negotiation: {fields: {}as NextStepNegotiation FieldControllers}, }; function switchVariant(variant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void {currentVariant = variant; data = nextStepGetDefaultForVariant(variant); errors = {}as NextStepErrors; tainted = {}as NextStepTainted;}function validate(): Result<NextStep, Array<{field: string; message: string}>>{return nextStepDeserialize(data);}function reset(overrides?: Partial<NextStep>): void {data = overrides ? overrides as typeof data : nextStepGetDefaultForVariant(currentVariant); errors = {}as NextStepErrors; tainted = {}as NextStepTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function nextStepFromFormData(formData: FormData): Result<NextStep, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "InitialContact" | "Qualified" | "Estimate" | "Negotiation" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "InitialContact" ){}else if(discriminant === "Qualified" ){}else if(discriminant === "Estimate" ){}else if(discriminant === "Negotiation" ){}return nextStepDeserialize(obj);}

export const NextStep = {
  defaultValue: nextStepDefaultValue,
  serialize: nextStepSerialize,
  serializeWithContext: nextStepSerializeWithContext,
  deserialize: nextStepDeserialize,
  deserializeWithContext: nextStepDeserializeWithContext,
  is: nextStepIs,
  createForm: nextStepCreateForm,
  fromFormData: nextStepFromFormData
} as const;


export type LeadStage =
    | /** @default */ 'Open'
    | 'InitialContact'
    | 'Qualified'
    | 'Estimate'
    | 'Negotiation';

export function leadStageDefaultValue(): LeadStage {return 'Open';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function leadStageSerialize(value: LeadStage): string {const ctx = SerializeContext.create(); return JSON.stringify(leadStageSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function leadStageSerializeWithContext(value: LeadStage, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function leadStageDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: LeadStage } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = leadStageDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "LeadStage.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function leadStageDeserializeWithContext(value: any, ctx: DeserializeContext): LeadStage | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as LeadStage | PendingRef;}const allowedValues = ['Open', 'InitialContact', 'Qualified', 'Estimate', 'Negotiation', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for LeadStage: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as LeadStage; }export function leadStageIs(value: unknown): value is LeadStage {const allowedValues = ['Open', 'InitialContact', 'Qualified', 'Estimate', 'Negotiation', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type LeadStageOpen Errors = {_errors: Option<Array<string>>; }; export type LeadStageInitialContact Errors = {_errors: Option<Array<string>>; }; export type LeadStageQualified Errors = {_errors: Option<Array<string>>; }; export type LeadStageEstimate Errors = {_errors: Option<Array<string>>; }; export type LeadStageNegotiation Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type LeadStageOpen Tainted = {}; export type LeadStageInitialContact Tainted = {}; export type LeadStageQualified Tainted = {}; export type LeadStageEstimate Tainted = {}; export type LeadStageNegotiation Tainted = {}; /** Union error type */export type LeadStageErrors = ({ _value: "Open" } & LeadStageOpenErrors) | ({ _value: "InitialContact" } & LeadStageInitialContactErrors) | ({ _value: "Qualified" } & LeadStageQualifiedErrors) | ({ _value: "Estimate" } & LeadStageEstimateErrors) | ({ _value: "Negotiation" } & LeadStageNegotiationErrors); /** Union tainted type */export type LeadStageTainted = ({ _value: "Open" } & LeadStageOpenTainted) | ({ _value: "InitialContact" } & LeadStageInitialContactTainted) | ({ _value: "Qualified" } & LeadStageQualifiedTainted) | ({ _value: "Estimate" } & LeadStageEstimateTainted) | ({ _value: "Negotiation" } & LeadStageNegotiationTainted); /** Per-variant field controller types */export interface LeadStageOpen FieldControllers {}export interface LeadStageInitialContact FieldControllers {}export interface LeadStageQualified FieldControllers {}export interface LeadStageEstimate FieldControllers {}export interface LeadStageNegotiation FieldControllers {}/** Union Gigaform interface with variant switching */export interface LeadStageGigaform {readonly currentVariant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation"; readonly data: LeadStage; readonly errors: LeadStageErrors; readonly tainted: LeadStageTainted; readonly variants: LeadStageVariantFields; switchVariant(variant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void; validate(): Result<LeadStage, Array<{field: string; message: string}>>; reset(overrides?: Partial<LeadStage>): void;}/** Variant fields container */export interface LeadStageVariantFields {readonly Open: {readonly fields: LeadStageOpen FieldControllers}; readonly InitialContact: {readonly fields: LeadStageInitialContact FieldControllers}; readonly Qualified: {readonly fields: LeadStageQualified FieldControllers}; readonly Estimate: {readonly fields: LeadStageEstimate FieldControllers}; readonly Negotiation: {readonly fields: LeadStageNegotiation FieldControllers}; }/** Gets default value for a specific variant */function leadStageGetDefaultForVariant(variant: string): LeadStage {switch(variant){case "Open" : return "Open" as LeadStage; case "InitialContact" : return "InitialContact" as LeadStage; case "Qualified" : return "Qualified" as LeadStage; case "Estimate" : return "Estimate" as LeadStage; case "Negotiation" : return "Negotiation" as LeadStage; default: return "Open" as LeadStage;}}/** Creates a new discriminated union Gigaform with variant switching */export function leadStageCreateForm(initial?: LeadStage): LeadStageGigaform {const initialVariant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation" = (initial as "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation") ?? "Open"; let currentVariant = $state<"Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation">(initialVariant); let data = $state<LeadStage>(initial?? leadStageGetDefaultForVariant(initialVariant)); let errors = $state<LeadStageErrors>({}as LeadStageErrors); let tainted = $state<LeadStageTainted>({}as LeadStageTainted); const variants: LeadStageVariantFields = {Open: {fields: {}as LeadStageOpen FieldControllers}, InitialContact: {fields: {}as LeadStageInitialContact FieldControllers}, Qualified: {fields: {}as LeadStageQualified FieldControllers}, Estimate: {fields: {}as LeadStageEstimate FieldControllers}, Negotiation: {fields: {}as LeadStageNegotiation FieldControllers}, }; function switchVariant(variant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void {currentVariant = variant; data = leadStageGetDefaultForVariant(variant); errors = {}as LeadStageErrors; tainted = {}as LeadStageTainted;}function validate(): Result<LeadStage, Array<{field: string; message: string}>>{return leadStageDeserialize(data);}function reset(overrides?: Partial<LeadStage>): void {data = overrides ? overrides as typeof data : leadStageGetDefaultForVariant(currentVariant); errors = {}as LeadStageErrors; tainted = {}as LeadStageTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function leadStageFromFormData(formData: FormData): Result<LeadStage, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Open" ){}else if(discriminant === "InitialContact" ){}else if(discriminant === "Qualified" ){}else if(discriminant === "Estimate" ){}else if(discriminant === "Negotiation" ){}return leadStageDeserialize(obj);}

export const LeadStage = {
  defaultValue: leadStageDefaultValue,
  serialize: leadStageSerialize,
  serializeWithContext: leadStageSerializeWithContext,
  deserialize: leadStageDeserialize,
  deserializeWithContext: leadStageDeserializeWithContext,
  is: leadStageIs,
  createForm: leadStageCreateForm,
  fromFormData: leadStageFromFormData
} as const;


export type AccountName = /** @default */ CompanyName | PersonName;

export function accountNameDefaultValue(): AccountName {return companyNameDefaultValue();}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function accountNameSerialize(value: AccountName): string {const ctx = SerializeContext.create(); return JSON.stringify(accountNameSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function accountNameSerializeWithContext(value: AccountName, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function accountNameDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: AccountName } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = accountNameDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "AccountName.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function accountNameDeserializeWithContext(value: any, ctx: DeserializeContext): AccountName | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as AccountName | PendingRef;}if(typeof value!== "object" || value === null){throw new DeserializeError([{field: "_root" , message: "AccountName.deserializeWithContext: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new DeserializeError([{field: "_root" , message: "AccountName.deserializeWithContext: missing __type field for union dispatch" }]);}if(__typeName === "CompanyName" ){return companyNameDeserializeWithContext(value, ctx)as AccountName;}if(__typeName === "PersonName" ){return personNameDeserializeWithContext(value, ctx)as AccountName;}throw new DeserializeError([{field: "_root" , message: "AccountName.deserializeWithContext: unknown type \"" + __typeName + "\". Expected one of: CompanyName, PersonName" }]); }export function accountNameIs(value: unknown): value is AccountName {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "CompanyName" || __typeName === "PersonName" ; }

/** Per-variant error types */export type AccountNameCompanyName Errors = {_errors: Option<Array<string>>; }; export type AccountNamePersonName Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type AccountNameCompanyName Tainted = {}; export type AccountNamePersonName Tainted = {}; /** Union error type */export type AccountNameErrors = ({ _type: "CompanyName" } & AccountNameCompanyNameErrors) | ({ _type: "PersonName" } & AccountNamePersonNameErrors); /** Union tainted type */export type AccountNameTainted = ({ _type: "CompanyName" } & AccountNameCompanyNameTainted) | ({ _type: "PersonName" } & AccountNamePersonNameTainted); /** Per-variant field controller types */export interface AccountNameCompanyName FieldControllers {}export interface AccountNamePersonName FieldControllers {}/** Union Gigaform interface with variant switching */export interface AccountNameGigaform {readonly currentVariant: "CompanyName" | "PersonName"; readonly data: AccountName; readonly errors: AccountNameErrors; readonly tainted: AccountNameTainted; readonly variants: AccountNameVariantFields; switchVariant(variant: "CompanyName" | "PersonName"): void; validate(): Result<AccountName, Array<{field: string; message: string}>>; reset(overrides?: Partial<AccountName>): void;}/** Variant fields container */export interface AccountNameVariantFields {readonly CompanyName: {readonly fields: AccountNameCompanyName FieldControllers}; readonly PersonName: {readonly fields: AccountNamePersonName FieldControllers}; }/** Gets default value for a specific variant */function accountNameGetDefaultForVariant(variant: string): AccountName {switch(variant){case "CompanyName" : return companyNameDefaultValue() as AccountName; case "PersonName" : return personNameDefaultValue() as AccountName; default: return companyNameDefaultValue() as AccountName;}}/** Creates a new discriminated union Gigaform with variant switching */export function accountNameCreateForm(initial?: AccountName): AccountNameGigaform {const initialVariant: "CompanyName" | "PersonName" = "CompanyName"; let currentVariant = $state<"CompanyName" | "PersonName">(initialVariant); let data = $state<AccountName>(initial?? accountNameGetDefaultForVariant(initialVariant)); let errors = $state<AccountNameErrors>({}as AccountNameErrors); let tainted = $state<AccountNameTainted>({}as AccountNameTainted); const variants: AccountNameVariantFields = {CompanyName: {fields: {}as AccountNameCompanyName FieldControllers}, PersonName: {fields: {}as AccountNamePersonName FieldControllers}, }; function switchVariant(variant: "CompanyName" | "PersonName"): void {currentVariant = variant; data = accountNameGetDefaultForVariant(variant); errors = {}as AccountNameErrors; tainted = {}as AccountNameTainted;}function validate(): Result<AccountName, Array<{field: string; message: string}>>{return accountNameDeserialize(data);}function reset(overrides?: Partial<AccountName>): void {data = overrides ? overrides as typeof data : accountNameGetDefaultForVariant(currentVariant); errors = {}as AccountNameErrors; tainted = {}as AccountNameTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function accountNameFromFormData(formData: FormData): Result<AccountName, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "CompanyName" | "PersonName" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "CompanyName" ){}else if(discriminant === "PersonName" ){}return accountNameDeserialize(obj);}

export const AccountName = {
  defaultValue: accountNameDefaultValue,
  serialize: accountNameSerialize,
  serializeWithContext: accountNameSerializeWithContext,
  deserialize: accountNameDeserialize,
  deserializeWithContext: accountNameDeserializeWithContext,
  is: accountNameIs,
  createForm: accountNameCreateForm,
  fromFormData: accountNameFromFormData
} as const;


export type Priority = /** @default */ 'Medium' | 'High' | 'Low';

export function priorityDefaultValue(): Priority {return 'Medium';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function prioritySerialize(value: Priority): string {const ctx = SerializeContext.create(); return JSON.stringify(prioritySerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function prioritySerializeWithContext(value: Priority, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function priorityDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Priority } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = priorityDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Priority.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function priorityDeserializeWithContext(value: any, ctx: DeserializeContext): Priority | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Priority | PendingRef;}const allowedValues = ['Medium', 'High', 'Low', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for Priority: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Priority; }export function priorityIs(value: unknown): value is Priority {const allowedValues = ['Medium', 'High', 'Low', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type PriorityMedium Errors = {_errors: Option<Array<string>>; }; export type PriorityHigh Errors = {_errors: Option<Array<string>>; }; export type PriorityLow Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type PriorityMedium Tainted = {}; export type PriorityHigh Tainted = {}; export type PriorityLow Tainted = {}; /** Union error type */export type PriorityErrors = ({ _value: "Medium" } & PriorityMediumErrors) | ({ _value: "High" } & PriorityHighErrors) | ({ _value: "Low" } & PriorityLowErrors); /** Union tainted type */export type PriorityTainted = ({ _value: "Medium" } & PriorityMediumTainted) | ({ _value: "High" } & PriorityHighTainted) | ({ _value: "Low" } & PriorityLowTainted); /** Per-variant field controller types */export interface PriorityMedium FieldControllers {}export interface PriorityHigh FieldControllers {}export interface PriorityLow FieldControllers {}/** Union Gigaform interface with variant switching */export interface PriorityGigaform {readonly currentVariant: "Medium" | "High" | "Low"; readonly data: Priority; readonly errors: PriorityErrors; readonly tainted: PriorityTainted; readonly variants: PriorityVariantFields; switchVariant(variant: "Medium" | "High" | "Low"): void; validate(): Result<Priority, Array<{field: string; message: string}>>; reset(overrides?: Partial<Priority>): void;}/** Variant fields container */export interface PriorityVariantFields {readonly Medium: {readonly fields: PriorityMedium FieldControllers}; readonly High: {readonly fields: PriorityHigh FieldControllers}; readonly Low: {readonly fields: PriorityLow FieldControllers}; }/** Gets default value for a specific variant */function priorityGetDefaultForVariant(variant: string): Priority {switch(variant){case "Medium" : return "Medium" as Priority; case "High" : return "High" as Priority; case "Low" : return "Low" as Priority; default: return "Medium" as Priority;}}/** Creates a new discriminated union Gigaform with variant switching */export function priorityCreateForm(initial?: Priority): PriorityGigaform {const initialVariant: "Medium" | "High" | "Low" = (initial as "Medium" | "High" | "Low") ?? "Medium"; let currentVariant = $state<"Medium" | "High" | "Low">(initialVariant); let data = $state<Priority>(initial?? priorityGetDefaultForVariant(initialVariant)); let errors = $state<PriorityErrors>({}as PriorityErrors); let tainted = $state<PriorityTainted>({}as PriorityTainted); const variants: PriorityVariantFields = {Medium: {fields: {}as PriorityMedium FieldControllers}, High: {fields: {}as PriorityHigh FieldControllers}, Low: {fields: {}as PriorityLow FieldControllers}, }; function switchVariant(variant: "Medium" | "High" | "Low"): void {currentVariant = variant; data = priorityGetDefaultForVariant(variant); errors = {}as PriorityErrors; tainted = {}as PriorityTainted;}function validate(): Result<Priority, Array<{field: string; message: string}>>{return priorityDeserialize(data);}function reset(overrides?: Partial<Priority>): void {data = overrides ? overrides as typeof data : priorityGetDefaultForVariant(currentVariant); errors = {}as PriorityErrors; tainted = {}as PriorityTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function priorityFromFormData(formData: FormData): Result<Priority, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Medium" | "High" | "Low" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Medium" ){}else if(discriminant === "High" ){}else if(discriminant === "Low" ){}return priorityDeserialize(obj);}

export const Priority = {
  defaultValue: priorityDefaultValue,
  serialize: prioritySerialize,
  serializeWithContext: prioritySerializeWithContext,
  deserialize: priorityDeserialize,
  deserializeWithContext: priorityDeserializeWithContext,
  is: priorityIs,
  createForm: priorityCreateForm,
  fromFormData: priorityFromFormData
} as const;


export type Applications =
    | /** @default */ 'Sales'
    | 'Accounting'
    | 'Errand'
    | 'HumanResources'
    | 'Logistics'
    | 'Marketing'
    | 'Website';

export function applicationsDefaultValue(): Applications {return 'Sales';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function applicationsSerialize(value: Applications): string {const ctx = SerializeContext.create(); return JSON.stringify(applicationsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function applicationsSerializeWithContext(value: Applications, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function applicationsDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Applications } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = applicationsDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Applications.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function applicationsDeserializeWithContext(value: any, ctx: DeserializeContext): Applications | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Applications | PendingRef;}const allowedValues = ['Sales', 'Accounting', 'Errand', 'HumanResources', 'Logistics', 'Marketing', 'Website', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for Applications: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Applications; }export function applicationsIs(value: unknown): value is Applications {const allowedValues = ['Sales', 'Accounting', 'Errand', 'HumanResources', 'Logistics', 'Marketing', 'Website', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type ApplicationsSales Errors = {_errors: Option<Array<string>>; }; export type ApplicationsAccounting Errors = {_errors: Option<Array<string>>; }; export type ApplicationsErrand Errors = {_errors: Option<Array<string>>; }; export type ApplicationsHumanResources Errors = {_errors: Option<Array<string>>; }; export type ApplicationsLogistics Errors = {_errors: Option<Array<string>>; }; export type ApplicationsMarketing Errors = {_errors: Option<Array<string>>; }; export type ApplicationsWebsite Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type ApplicationsSales Tainted = {}; export type ApplicationsAccounting Tainted = {}; export type ApplicationsErrand Tainted = {}; export type ApplicationsHumanResources Tainted = {}; export type ApplicationsLogistics Tainted = {}; export type ApplicationsMarketing Tainted = {}; export type ApplicationsWebsite Tainted = {}; /** Union error type */export type ApplicationsErrors = ({ _value: "Sales" } & ApplicationsSalesErrors) | ({ _value: "Accounting" } & ApplicationsAccountingErrors) | ({ _value: "Errand" } & ApplicationsErrandErrors) | ({ _value: "HumanResources" } & ApplicationsHumanResourcesErrors) | ({ _value: "Logistics" } & ApplicationsLogisticsErrors) | ({ _value: "Marketing" } & ApplicationsMarketingErrors) | ({ _value: "Website" } & ApplicationsWebsiteErrors); /** Union tainted type */export type ApplicationsTainted = ({ _value: "Sales" } & ApplicationsSalesTainted) | ({ _value: "Accounting" } & ApplicationsAccountingTainted) | ({ _value: "Errand" } & ApplicationsErrandTainted) | ({ _value: "HumanResources" } & ApplicationsHumanResourcesTainted) | ({ _value: "Logistics" } & ApplicationsLogisticsTainted) | ({ _value: "Marketing" } & ApplicationsMarketingTainted) | ({ _value: "Website" } & ApplicationsWebsiteTainted); /** Per-variant field controller types */export interface ApplicationsSales FieldControllers {}export interface ApplicationsAccounting FieldControllers {}export interface ApplicationsErrand FieldControllers {}export interface ApplicationsHumanResources FieldControllers {}export interface ApplicationsLogistics FieldControllers {}export interface ApplicationsMarketing FieldControllers {}export interface ApplicationsWebsite FieldControllers {}/** Union Gigaform interface with variant switching */export interface ApplicationsGigaform {readonly currentVariant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website"; readonly data: Applications; readonly errors: ApplicationsErrors; readonly tainted: ApplicationsTainted; readonly variants: ApplicationsVariantFields; switchVariant(variant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website"): void; validate(): Result<Applications, Array<{field: string; message: string}>>; reset(overrides?: Partial<Applications>): void;}/** Variant fields container */export interface ApplicationsVariantFields {readonly Sales: {readonly fields: ApplicationsSales FieldControllers}; readonly Accounting: {readonly fields: ApplicationsAccounting FieldControllers}; readonly Errand: {readonly fields: ApplicationsErrand FieldControllers}; readonly HumanResources: {readonly fields: ApplicationsHumanResources FieldControllers}; readonly Logistics: {readonly fields: ApplicationsLogistics FieldControllers}; readonly Marketing: {readonly fields: ApplicationsMarketing FieldControllers}; readonly Website: {readonly fields: ApplicationsWebsite FieldControllers}; }/** Gets default value for a specific variant */function applicationsGetDefaultForVariant(variant: string): Applications {switch(variant){case "Sales" : return "Sales" as Applications; case "Accounting" : return "Accounting" as Applications; case "Errand" : return "Errand" as Applications; case "HumanResources" : return "HumanResources" as Applications; case "Logistics" : return "Logistics" as Applications; case "Marketing" : return "Marketing" as Applications; case "Website" : return "Website" as Applications; default: return "Sales" as Applications;}}/** Creates a new discriminated union Gigaform with variant switching */export function applicationsCreateForm(initial?: Applications): ApplicationsGigaform {const initialVariant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website" = (initial as "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website") ?? "Sales"; let currentVariant = $state<"Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website">(initialVariant); let data = $state<Applications>(initial?? applicationsGetDefaultForVariant(initialVariant)); let errors = $state<ApplicationsErrors>({}as ApplicationsErrors); let tainted = $state<ApplicationsTainted>({}as ApplicationsTainted); const variants: ApplicationsVariantFields = {Sales: {fields: {}as ApplicationsSales FieldControllers}, Accounting: {fields: {}as ApplicationsAccounting FieldControllers}, Errand: {fields: {}as ApplicationsErrand FieldControllers}, HumanResources: {fields: {}as ApplicationsHumanResources FieldControllers}, Logistics: {fields: {}as ApplicationsLogistics FieldControllers}, Marketing: {fields: {}as ApplicationsMarketing FieldControllers}, Website: {fields: {}as ApplicationsWebsite FieldControllers}, }; function switchVariant(variant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website"): void {currentVariant = variant; data = applicationsGetDefaultForVariant(variant); errors = {}as ApplicationsErrors; tainted = {}as ApplicationsTainted;}function validate(): Result<Applications, Array<{field: string; message: string}>>{return applicationsDeserialize(data);}function reset(overrides?: Partial<Applications>): void {data = overrides ? overrides as typeof data : applicationsGetDefaultForVariant(currentVariant); errors = {}as ApplicationsErrors; tainted = {}as ApplicationsTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function applicationsFromFormData(formData: FormData): Result<Applications, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Sales" ){}else if(discriminant === "Accounting" ){}else if(discriminant === "Errand" ){}else if(discriminant === "HumanResources" ){}else if(discriminant === "Logistics" ){}else if(discriminant === "Marketing" ){}else if(discriminant === "Website" ){}return applicationsDeserialize(obj);}

export const Applications = {
  defaultValue: applicationsDefaultValue,
  serialize: applicationsSerialize,
  serializeWithContext: applicationsSerializeWithContext,
  deserialize: applicationsDeserialize,
  deserializeWithContext: applicationsDeserializeWithContext,
  is: applicationsIs,
  createForm: applicationsCreateForm,
  fromFormData: applicationsFromFormData
} as const;


export type JobTitle =
    | /** @default */ 'Technician'
    | 'SalesRepresentative'
    | 'HumanResources'
    | 'InformationTechnology';

export function jobTitleDefaultValue(): JobTitle {return 'Technician';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function jobTitleSerialize(value: JobTitle): string {const ctx = SerializeContext.create(); return JSON.stringify(jobTitleSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function jobTitleSerializeWithContext(value: JobTitle, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function jobTitleDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: JobTitle } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = jobTitleDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "JobTitle.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function jobTitleDeserializeWithContext(value: any, ctx: DeserializeContext): JobTitle | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as JobTitle | PendingRef;}const allowedValues = ['Technician', 'SalesRepresentative', 'HumanResources', 'InformationTechnology', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for JobTitle: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as JobTitle; }export function jobTitleIs(value: unknown): value is JobTitle {const allowedValues = ['Technician', 'SalesRepresentative', 'HumanResources', 'InformationTechnology', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type JobTitleTechnician Errors = {_errors: Option<Array<string>>; }; export type JobTitleSalesRepresentative Errors = {_errors: Option<Array<string>>; }; export type JobTitleHumanResources Errors = {_errors: Option<Array<string>>; }; export type JobTitleInformationTechnology Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type JobTitleTechnician Tainted = {}; export type JobTitleSalesRepresentative Tainted = {}; export type JobTitleHumanResources Tainted = {}; export type JobTitleInformationTechnology Tainted = {}; /** Union error type */export type JobTitleErrors = ({ _value: "Technician" } & JobTitleTechnicianErrors) | ({ _value: "SalesRepresentative" } & JobTitleSalesRepresentativeErrors) | ({ _value: "HumanResources" } & JobTitleHumanResourcesErrors) | ({ _value: "InformationTechnology" } & JobTitleInformationTechnologyErrors); /** Union tainted type */export type JobTitleTainted = ({ _value: "Technician" } & JobTitleTechnicianTainted) | ({ _value: "SalesRepresentative" } & JobTitleSalesRepresentativeTainted) | ({ _value: "HumanResources" } & JobTitleHumanResourcesTainted) | ({ _value: "InformationTechnology" } & JobTitleInformationTechnologyTainted); /** Per-variant field controller types */export interface JobTitleTechnician FieldControllers {}export interface JobTitleSalesRepresentative FieldControllers {}export interface JobTitleHumanResources FieldControllers {}export interface JobTitleInformationTechnology FieldControllers {}/** Union Gigaform interface with variant switching */export interface JobTitleGigaform {readonly currentVariant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology"; readonly data: JobTitle; readonly errors: JobTitleErrors; readonly tainted: JobTitleTainted; readonly variants: JobTitleVariantFields; switchVariant(variant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology"): void; validate(): Result<JobTitle, Array<{field: string; message: string}>>; reset(overrides?: Partial<JobTitle>): void;}/** Variant fields container */export interface JobTitleVariantFields {readonly Technician: {readonly fields: JobTitleTechnician FieldControllers}; readonly SalesRepresentative: {readonly fields: JobTitleSalesRepresentative FieldControllers}; readonly HumanResources: {readonly fields: JobTitleHumanResources FieldControllers}; readonly InformationTechnology: {readonly fields: JobTitleInformationTechnology FieldControllers}; }/** Gets default value for a specific variant */function jobTitleGetDefaultForVariant(variant: string): JobTitle {switch(variant){case "Technician" : return "Technician" as JobTitle; case "SalesRepresentative" : return "SalesRepresentative" as JobTitle; case "HumanResources" : return "HumanResources" as JobTitle; case "InformationTechnology" : return "InformationTechnology" as JobTitle; default: return "Technician" as JobTitle;}}/** Creates a new discriminated union Gigaform with variant switching */export function jobTitleCreateForm(initial?: JobTitle): JobTitleGigaform {const initialVariant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology" = (initial as "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology") ?? "Technician"; let currentVariant = $state<"Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology">(initialVariant); let data = $state<JobTitle>(initial?? jobTitleGetDefaultForVariant(initialVariant)); let errors = $state<JobTitleErrors>({}as JobTitleErrors); let tainted = $state<JobTitleTainted>({}as JobTitleTainted); const variants: JobTitleVariantFields = {Technician: {fields: {}as JobTitleTechnician FieldControllers}, SalesRepresentative: {fields: {}as JobTitleSalesRepresentative FieldControllers}, HumanResources: {fields: {}as JobTitleHumanResources FieldControllers}, InformationTechnology: {fields: {}as JobTitleInformationTechnology FieldControllers}, }; function switchVariant(variant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology"): void {currentVariant = variant; data = jobTitleGetDefaultForVariant(variant); errors = {}as JobTitleErrors; tainted = {}as JobTitleTainted;}function validate(): Result<JobTitle, Array<{field: string; message: string}>>{return jobTitleDeserialize(data);}function reset(overrides?: Partial<JobTitle>): void {data = overrides ? overrides as typeof data : jobTitleGetDefaultForVariant(currentVariant); errors = {}as JobTitleErrors; tainted = {}as JobTitleTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function jobTitleFromFormData(formData: FormData): Result<JobTitle, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Technician" ){}else if(discriminant === "SalesRepresentative" ){}else if(discriminant === "HumanResources" ){}else if(discriminant === "InformationTechnology" ){}return jobTitleDeserialize(obj);}

export const JobTitle = {
  defaultValue: jobTitleDefaultValue,
  serialize: jobTitleSerialize,
  serializeWithContext: jobTitleSerializeWithContext,
  deserialize: jobTitleDeserialize,
  deserializeWithContext: jobTitleDeserializeWithContext,
  is: jobTitleIs,
  createForm: jobTitleCreateForm,
  fromFormData: jobTitleFromFormData
} as const;


export type ColorsConfig = Cardinal | Ordinal | Custom | /** @default */ Gradient;

export function colorsConfigDefaultValue(): ColorsConfig {return gradientDefaultValue();}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function colorsConfigSerialize(value: ColorsConfig): string {const ctx = SerializeContext.create(); return JSON.stringify(colorsConfigSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function colorsConfigSerializeWithContext(value: ColorsConfig, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function colorsConfigDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: ColorsConfig } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = colorsConfigDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "ColorsConfig.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function colorsConfigDeserializeWithContext(value: any, ctx: DeserializeContext): ColorsConfig | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as ColorsConfig | PendingRef;}if(typeof value!== "object" || value === null){throw new DeserializeError([{field: "_root" , message: "ColorsConfig.deserializeWithContext: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new DeserializeError([{field: "_root" , message: "ColorsConfig.deserializeWithContext: missing __type field for union dispatch" }]);}if(__typeName === "Cardinal" ){return cardinalDeserializeWithContext(value, ctx)as ColorsConfig;}if(__typeName === "Ordinal" ){return ordinalDeserializeWithContext(value, ctx)as ColorsConfig;}if(__typeName === "Custom" ){return customDeserializeWithContext(value, ctx)as ColorsConfig;}if(__typeName === "Gradient" ){return gradientDeserializeWithContext(value, ctx)as ColorsConfig;}throw new DeserializeError([{field: "_root" , message: "ColorsConfig.deserializeWithContext: unknown type \"" + __typeName + "\". Expected one of: Cardinal, Ordinal, Custom, Gradient" }]); }export function colorsConfigIs(value: unknown): value is ColorsConfig {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "Cardinal" || __typeName === "Ordinal" || __typeName === "Custom" || __typeName === "Gradient" ; }

/** Per-variant error types */export type ColorsConfigCardinal Errors = {_errors: Option<Array<string>>; }; export type ColorsConfigOrdinal Errors = {_errors: Option<Array<string>>; }; export type ColorsConfigCustom Errors = {_errors: Option<Array<string>>; }; export type ColorsConfigGradient Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type ColorsConfigCardinal Tainted = {}; export type ColorsConfigOrdinal Tainted = {}; export type ColorsConfigCustom Tainted = {}; export type ColorsConfigGradient Tainted = {}; /** Union error type */export type ColorsConfigErrors = ({ _type: "Cardinal" } & ColorsConfigCardinalErrors) | ({ _type: "Ordinal" } & ColorsConfigOrdinalErrors) | ({ _type: "Custom" } & ColorsConfigCustomErrors) | ({ _type: "Gradient" } & ColorsConfigGradientErrors); /** Union tainted type */export type ColorsConfigTainted = ({ _type: "Cardinal" } & ColorsConfigCardinalTainted) | ({ _type: "Ordinal" } & ColorsConfigOrdinalTainted) | ({ _type: "Custom" } & ColorsConfigCustomTainted) | ({ _type: "Gradient" } & ColorsConfigGradientTainted); /** Per-variant field controller types */export interface ColorsConfigCardinal FieldControllers {}export interface ColorsConfigOrdinal FieldControllers {}export interface ColorsConfigCustom FieldControllers {}export interface ColorsConfigGradient FieldControllers {}/** Union Gigaform interface with variant switching */export interface ColorsConfigGigaform {readonly currentVariant: "Cardinal" | "Ordinal" | "Custom" | "Gradient"; readonly data: ColorsConfig; readonly errors: ColorsConfigErrors; readonly tainted: ColorsConfigTainted; readonly variants: ColorsConfigVariantFields; switchVariant(variant: "Cardinal" | "Ordinal" | "Custom" | "Gradient"): void; validate(): Result<ColorsConfig, Array<{field: string; message: string}>>; reset(overrides?: Partial<ColorsConfig>): void;}/** Variant fields container */export interface ColorsConfigVariantFields {readonly Cardinal: {readonly fields: ColorsConfigCardinal FieldControllers}; readonly Ordinal: {readonly fields: ColorsConfigOrdinal FieldControllers}; readonly Custom: {readonly fields: ColorsConfigCustom FieldControllers}; readonly Gradient: {readonly fields: ColorsConfigGradient FieldControllers}; }/** Gets default value for a specific variant */function colorsConfigGetDefaultForVariant(variant: string): ColorsConfig {switch(variant){case "Cardinal" : return cardinalDefaultValue() as ColorsConfig; case "Ordinal" : return ordinalDefaultValue() as ColorsConfig; case "Custom" : return customDefaultValue() as ColorsConfig; case "Gradient" : return gradientDefaultValue() as ColorsConfig; default: return cardinalDefaultValue() as ColorsConfig;}}/** Creates a new discriminated union Gigaform with variant switching */export function colorsConfigCreateForm(initial?: ColorsConfig): ColorsConfigGigaform {const initialVariant: "Cardinal" | "Ordinal" | "Custom" | "Gradient" = "Cardinal"; let currentVariant = $state<"Cardinal" | "Ordinal" | "Custom" | "Gradient">(initialVariant); let data = $state<ColorsConfig>(initial?? colorsConfigGetDefaultForVariant(initialVariant)); let errors = $state<ColorsConfigErrors>({}as ColorsConfigErrors); let tainted = $state<ColorsConfigTainted>({}as ColorsConfigTainted); const variants: ColorsConfigVariantFields = {Cardinal: {fields: {}as ColorsConfigCardinal FieldControllers}, Ordinal: {fields: {}as ColorsConfigOrdinal FieldControllers}, Custom: {fields: {}as ColorsConfigCustom FieldControllers}, Gradient: {fields: {}as ColorsConfigGradient FieldControllers}, }; function switchVariant(variant: "Cardinal" | "Ordinal" | "Custom" | "Gradient"): void {currentVariant = variant; data = colorsConfigGetDefaultForVariant(variant); errors = {}as ColorsConfigErrors; tainted = {}as ColorsConfigTainted;}function validate(): Result<ColorsConfig, Array<{field: string; message: string}>>{return colorsConfigDeserialize(data);}function reset(overrides?: Partial<ColorsConfig>): void {data = overrides ? overrides as typeof data : colorsConfigGetDefaultForVariant(currentVariant); errors = {}as ColorsConfigErrors; tainted = {}as ColorsConfigTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function colorsConfigFromFormData(formData: FormData): Result<ColorsConfig, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "Cardinal" | "Ordinal" | "Custom" | "Gradient" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "Cardinal" ){}else if(discriminant === "Ordinal" ){}else if(discriminant === "Custom" ){}else if(discriminant === "Gradient" ){}return colorsConfigDeserialize(obj);}

export const ColorsConfig = {
  defaultValue: colorsConfigDefaultValue,
  serialize: colorsConfigSerialize,
  serializeWithContext: colorsConfigSerializeWithContext,
  deserialize: colorsConfigDeserialize,
  deserializeWithContext: colorsConfigDeserializeWithContext,
  is: colorsConfigIs,
  createForm: colorsConfigCreateForm,
  fromFormData: colorsConfigFromFormData
} as const;


export type WeekOfMonth = /** @default */ 'First' | 'Second' | 'Third' | 'Fourth' | 'Last';

export function weekOfMonthDefaultValue(): WeekOfMonth {return 'First';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function weekOfMonthSerialize(value: WeekOfMonth): string {const ctx = SerializeContext.create(); return JSON.stringify(weekOfMonthSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function weekOfMonthSerializeWithContext(value: WeekOfMonth, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function weekOfMonthDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: WeekOfMonth } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = weekOfMonthDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "WeekOfMonth.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function weekOfMonthDeserializeWithContext(value: any, ctx: DeserializeContext): WeekOfMonth | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as WeekOfMonth | PendingRef;}const allowedValues = ['First', 'Second', 'Third', 'Fourth', 'Last', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for WeekOfMonth: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as WeekOfMonth; }export function weekOfMonthIs(value: unknown): value is WeekOfMonth {const allowedValues = ['First', 'Second', 'Third', 'Fourth', 'Last', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type WeekOfMonthFirst Errors = {_errors: Option<Array<string>>; }; export type WeekOfMonthSecond Errors = {_errors: Option<Array<string>>; }; export type WeekOfMonthThird Errors = {_errors: Option<Array<string>>; }; export type WeekOfMonthFourth Errors = {_errors: Option<Array<string>>; }; export type WeekOfMonthLast Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type WeekOfMonthFirst Tainted = {}; export type WeekOfMonthSecond Tainted = {}; export type WeekOfMonthThird Tainted = {}; export type WeekOfMonthFourth Tainted = {}; export type WeekOfMonthLast Tainted = {}; /** Union error type */export type WeekOfMonthErrors = ({ _value: "First" } & WeekOfMonthFirstErrors) | ({ _value: "Second" } & WeekOfMonthSecondErrors) | ({ _value: "Third" } & WeekOfMonthThirdErrors) | ({ _value: "Fourth" } & WeekOfMonthFourthErrors) | ({ _value: "Last" } & WeekOfMonthLastErrors); /** Union tainted type */export type WeekOfMonthTainted = ({ _value: "First" } & WeekOfMonthFirstTainted) | ({ _value: "Second" } & WeekOfMonthSecondTainted) | ({ _value: "Third" } & WeekOfMonthThirdTainted) | ({ _value: "Fourth" } & WeekOfMonthFourthTainted) | ({ _value: "Last" } & WeekOfMonthLastTainted); /** Per-variant field controller types */export interface WeekOfMonthFirst FieldControllers {}export interface WeekOfMonthSecond FieldControllers {}export interface WeekOfMonthThird FieldControllers {}export interface WeekOfMonthFourth FieldControllers {}export interface WeekOfMonthLast FieldControllers {}/** Union Gigaform interface with variant switching */export interface WeekOfMonthGigaform {readonly currentVariant: "First" | "Second" | "Third" | "Fourth" | "Last"; readonly data: WeekOfMonth; readonly errors: WeekOfMonthErrors; readonly tainted: WeekOfMonthTainted; readonly variants: WeekOfMonthVariantFields; switchVariant(variant: "First" | "Second" | "Third" | "Fourth" | "Last"): void; validate(): Result<WeekOfMonth, Array<{field: string; message: string}>>; reset(overrides?: Partial<WeekOfMonth>): void;}/** Variant fields container */export interface WeekOfMonthVariantFields {readonly First: {readonly fields: WeekOfMonthFirst FieldControllers}; readonly Second: {readonly fields: WeekOfMonthSecond FieldControllers}; readonly Third: {readonly fields: WeekOfMonthThird FieldControllers}; readonly Fourth: {readonly fields: WeekOfMonthFourth FieldControllers}; readonly Last: {readonly fields: WeekOfMonthLast FieldControllers}; }/** Gets default value for a specific variant */function weekOfMonthGetDefaultForVariant(variant: string): WeekOfMonth {switch(variant){case "First" : return "First" as WeekOfMonth; case "Second" : return "Second" as WeekOfMonth; case "Third" : return "Third" as WeekOfMonth; case "Fourth" : return "Fourth" as WeekOfMonth; case "Last" : return "Last" as WeekOfMonth; default: return "First" as WeekOfMonth;}}/** Creates a new discriminated union Gigaform with variant switching */export function weekOfMonthCreateForm(initial?: WeekOfMonth): WeekOfMonthGigaform {const initialVariant: "First" | "Second" | "Third" | "Fourth" | "Last" = (initial as "First" | "Second" | "Third" | "Fourth" | "Last") ?? "First"; let currentVariant = $state<"First" | "Second" | "Third" | "Fourth" | "Last">(initialVariant); let data = $state<WeekOfMonth>(initial?? weekOfMonthGetDefaultForVariant(initialVariant)); let errors = $state<WeekOfMonthErrors>({}as WeekOfMonthErrors); let tainted = $state<WeekOfMonthTainted>({}as WeekOfMonthTainted); const variants: WeekOfMonthVariantFields = {First: {fields: {}as WeekOfMonthFirst FieldControllers}, Second: {fields: {}as WeekOfMonthSecond FieldControllers}, Third: {fields: {}as WeekOfMonthThird FieldControllers}, Fourth: {fields: {}as WeekOfMonthFourth FieldControllers}, Last: {fields: {}as WeekOfMonthLast FieldControllers}, }; function switchVariant(variant: "First" | "Second" | "Third" | "Fourth" | "Last"): void {currentVariant = variant; data = weekOfMonthGetDefaultForVariant(variant); errors = {}as WeekOfMonthErrors; tainted = {}as WeekOfMonthTainted;}function validate(): Result<WeekOfMonth, Array<{field: string; message: string}>>{return weekOfMonthDeserialize(data);}function reset(overrides?: Partial<WeekOfMonth>): void {data = overrides ? overrides as typeof data : weekOfMonthGetDefaultForVariant(currentVariant); errors = {}as WeekOfMonthErrors; tainted = {}as WeekOfMonthTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function weekOfMonthFromFormData(formData: FormData): Result<WeekOfMonth, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "First" | "Second" | "Third" | "Fourth" | "Last" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "First" ){}else if(discriminant === "Second" ){}else if(discriminant === "Third" ){}else if(discriminant === "Fourth" ){}else if(discriminant === "Last" ){}return weekOfMonthDeserialize(obj);}

export const WeekOfMonth = {
  defaultValue: weekOfMonthDefaultValue,
  serialize: weekOfMonthSerialize,
  serializeWithContext: weekOfMonthSerializeWithContext,
  deserialize: weekOfMonthDeserialize,
  deserializeWithContext: weekOfMonthDeserializeWithContext,
  is: weekOfMonthIs,
  createForm: weekOfMonthCreateForm,
  fromFormData: weekOfMonthFromFormData
} as const;


export type ActivityType = /** @default */ Created | Edited | Sent | Viewed | Commented | Paid;

export function activityTypeDefaultValue(): ActivityType {return createdDefaultValue();}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function activityTypeSerialize(value: ActivityType): string {const ctx = SerializeContext.create(); return JSON.stringify(activityTypeSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function activityTypeSerializeWithContext(value: ActivityType, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function activityTypeDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: ActivityType } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = activityTypeDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "ActivityType.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function activityTypeDeserializeWithContext(value: any, ctx: DeserializeContext): ActivityType | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as ActivityType | PendingRef;}if(typeof value!== "object" || value === null){throw new DeserializeError([{field: "_root" , message: "ActivityType.deserializeWithContext: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new DeserializeError([{field: "_root" , message: "ActivityType.deserializeWithContext: missing __type field for union dispatch" }]);}if(__typeName === "Created" ){return createdDeserializeWithContext(value, ctx)as ActivityType;}if(__typeName === "Edited" ){return editedDeserializeWithContext(value, ctx)as ActivityType;}if(__typeName === "Sent" ){return sentDeserializeWithContext(value, ctx)as ActivityType;}if(__typeName === "Viewed" ){return viewedDeserializeWithContext(value, ctx)as ActivityType;}if(__typeName === "Commented" ){return commentedDeserializeWithContext(value, ctx)as ActivityType;}if(__typeName === "Paid" ){return paidDeserializeWithContext(value, ctx)as ActivityType;}throw new DeserializeError([{field: "_root" , message: "ActivityType.deserializeWithContext: unknown type \"" + __typeName + "\". Expected one of: Created, Edited, Sent, Viewed, Commented, Paid" }]); }export function activityTypeIs(value: unknown): value is ActivityType {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "Created" || __typeName === "Edited" || __typeName === "Sent" || __typeName === "Viewed" || __typeName === "Commented" || __typeName === "Paid" ; }

/** Per-variant error types */export type ActivityTypeCreated Errors = {_errors: Option<Array<string>>; }; export type ActivityTypeEdited Errors = {_errors: Option<Array<string>>; }; export type ActivityTypeSent Errors = {_errors: Option<Array<string>>; }; export type ActivityTypeViewed Errors = {_errors: Option<Array<string>>; }; export type ActivityTypeCommented Errors = {_errors: Option<Array<string>>; }; export type ActivityTypePaid Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type ActivityTypeCreated Tainted = {}; export type ActivityTypeEdited Tainted = {}; export type ActivityTypeSent Tainted = {}; export type ActivityTypeViewed Tainted = {}; export type ActivityTypeCommented Tainted = {}; export type ActivityTypePaid Tainted = {}; /** Union error type */export type ActivityTypeErrors = ({ _type: "Created" } & ActivityTypeCreatedErrors) | ({ _type: "Edited" } & ActivityTypeEditedErrors) | ({ _type: "Sent" } & ActivityTypeSentErrors) | ({ _type: "Viewed" } & ActivityTypeViewedErrors) | ({ _type: "Commented" } & ActivityTypeCommentedErrors) | ({ _type: "Paid" } & ActivityTypePaidErrors); /** Union tainted type */export type ActivityTypeTainted = ({ _type: "Created" } & ActivityTypeCreatedTainted) | ({ _type: "Edited" } & ActivityTypeEditedTainted) | ({ _type: "Sent" } & ActivityTypeSentTainted) | ({ _type: "Viewed" } & ActivityTypeViewedTainted) | ({ _type: "Commented" } & ActivityTypeCommentedTainted) | ({ _type: "Paid" } & ActivityTypePaidTainted); /** Per-variant field controller types */export interface ActivityTypeCreated FieldControllers {}export interface ActivityTypeEdited FieldControllers {}export interface ActivityTypeSent FieldControllers {}export interface ActivityTypeViewed FieldControllers {}export interface ActivityTypeCommented FieldControllers {}export interface ActivityTypePaid FieldControllers {}/** Union Gigaform interface with variant switching */export interface ActivityTypeGigaform {readonly currentVariant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid"; readonly data: ActivityType; readonly errors: ActivityTypeErrors; readonly tainted: ActivityTypeTainted; readonly variants: ActivityTypeVariantFields; switchVariant(variant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid"): void; validate(): Result<ActivityType, Array<{field: string; message: string}>>; reset(overrides?: Partial<ActivityType>): void;}/** Variant fields container */export interface ActivityTypeVariantFields {readonly Created: {readonly fields: ActivityTypeCreated FieldControllers}; readonly Edited: {readonly fields: ActivityTypeEdited FieldControllers}; readonly Sent: {readonly fields: ActivityTypeSent FieldControllers}; readonly Viewed: {readonly fields: ActivityTypeViewed FieldControllers}; readonly Commented: {readonly fields: ActivityTypeCommented FieldControllers}; readonly Paid: {readonly fields: ActivityTypePaid FieldControllers}; }/** Gets default value for a specific variant */function activityTypeGetDefaultForVariant(variant: string): ActivityType {switch(variant){case "Created" : return createdDefaultValue() as ActivityType; case "Edited" : return editedDefaultValue() as ActivityType; case "Sent" : return sentDefaultValue() as ActivityType; case "Viewed" : return viewedDefaultValue() as ActivityType; case "Commented" : return commentedDefaultValue() as ActivityType; case "Paid" : return paidDefaultValue() as ActivityType; default: return createdDefaultValue() as ActivityType;}}/** Creates a new discriminated union Gigaform with variant switching */export function activityTypeCreateForm(initial?: ActivityType): ActivityTypeGigaform {const initialVariant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid" = "Created"; let currentVariant = $state<"Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid">(initialVariant); let data = $state<ActivityType>(initial?? activityTypeGetDefaultForVariant(initialVariant)); let errors = $state<ActivityTypeErrors>({}as ActivityTypeErrors); let tainted = $state<ActivityTypeTainted>({}as ActivityTypeTainted); const variants: ActivityTypeVariantFields = {Created: {fields: {}as ActivityTypeCreated FieldControllers}, Edited: {fields: {}as ActivityTypeEdited FieldControllers}, Sent: {fields: {}as ActivityTypeSent FieldControllers}, Viewed: {fields: {}as ActivityTypeViewed FieldControllers}, Commented: {fields: {}as ActivityTypeCommented FieldControllers}, Paid: {fields: {}as ActivityTypePaid FieldControllers}, }; function switchVariant(variant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid"): void {currentVariant = variant; data = activityTypeGetDefaultForVariant(variant); errors = {}as ActivityTypeErrors; tainted = {}as ActivityTypeTainted;}function validate(): Result<ActivityType, Array<{field: string; message: string}>>{return activityTypeDeserialize(data);}function reset(overrides?: Partial<ActivityType>): void {data = overrides ? overrides as typeof data : activityTypeGetDefaultForVariant(currentVariant); errors = {}as ActivityTypeErrors; tainted = {}as ActivityTypeTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function activityTypeFromFormData(formData: FormData): Result<ActivityType, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "Created" ){}else if(discriminant === "Edited" ){}else if(discriminant === "Sent" ){}else if(discriminant === "Viewed" ){}else if(discriminant === "Commented" ){}else if(discriminant === "Paid" ){}return activityTypeDeserialize(obj);}

export const ActivityType = {
  defaultValue: activityTypeDefaultValue,
  serialize: activityTypeSerialize,
  serializeWithContext: activityTypeSerializeWithContext,
  deserialize: activityTypeDeserialize,
  deserializeWithContext: activityTypeDeserializeWithContext,
  is: activityTypeIs,
  createForm: activityTypeCreateForm,
  fromFormData: activityTypeFromFormData
} as const;


export type RowHeight = 'ExtraSmall' | 'Small' | /** @default */ 'Medium' | 'Large';

export function rowHeightDefaultValue(): RowHeight {return 'Medium';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function rowHeightSerialize(value: RowHeight): string {const ctx = SerializeContext.create(); return JSON.stringify(rowHeightSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function rowHeightSerializeWithContext(value: RowHeight, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function rowHeightDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: RowHeight } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = rowHeightDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "RowHeight.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function rowHeightDeserializeWithContext(value: any, ctx: DeserializeContext): RowHeight | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as RowHeight | PendingRef;}const allowedValues = ['ExtraSmall', 'Small', 'Medium', 'Large', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for RowHeight: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as RowHeight; }export function rowHeightIs(value: unknown): value is RowHeight {const allowedValues = ['ExtraSmall', 'Small', 'Medium', 'Large', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type RowHeightExtraSmall Errors = {_errors: Option<Array<string>>; }; export type RowHeightSmall Errors = {_errors: Option<Array<string>>; }; export type RowHeightMedium Errors = {_errors: Option<Array<string>>; }; export type RowHeightLarge Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type RowHeightExtraSmall Tainted = {}; export type RowHeightSmall Tainted = {}; export type RowHeightMedium Tainted = {}; export type RowHeightLarge Tainted = {}; /** Union error type */export type RowHeightErrors = ({ _value: "ExtraSmall" } & RowHeightExtraSmallErrors) | ({ _value: "Small" } & RowHeightSmallErrors) | ({ _value: "Medium" } & RowHeightMediumErrors) | ({ _value: "Large" } & RowHeightLargeErrors); /** Union tainted type */export type RowHeightTainted = ({ _value: "ExtraSmall" } & RowHeightExtraSmallTainted) | ({ _value: "Small" } & RowHeightSmallTainted) | ({ _value: "Medium" } & RowHeightMediumTainted) | ({ _value: "Large" } & RowHeightLargeTainted); /** Per-variant field controller types */export interface RowHeightExtraSmall FieldControllers {}export interface RowHeightSmall FieldControllers {}export interface RowHeightMedium FieldControllers {}export interface RowHeightLarge FieldControllers {}/** Union Gigaform interface with variant switching */export interface RowHeightGigaform {readonly currentVariant: "ExtraSmall" | "Small" | "Medium" | "Large"; readonly data: RowHeight; readonly errors: RowHeightErrors; readonly tainted: RowHeightTainted; readonly variants: RowHeightVariantFields; switchVariant(variant: "ExtraSmall" | "Small" | "Medium" | "Large"): void; validate(): Result<RowHeight, Array<{field: string; message: string}>>; reset(overrides?: Partial<RowHeight>): void;}/** Variant fields container */export interface RowHeightVariantFields {readonly ExtraSmall: {readonly fields: RowHeightExtraSmall FieldControllers}; readonly Small: {readonly fields: RowHeightSmall FieldControllers}; readonly Medium: {readonly fields: RowHeightMedium FieldControllers}; readonly Large: {readonly fields: RowHeightLarge FieldControllers}; }/** Gets default value for a specific variant */function rowHeightGetDefaultForVariant(variant: string): RowHeight {switch(variant){case "ExtraSmall" : return "ExtraSmall" as RowHeight; case "Small" : return "Small" as RowHeight; case "Medium" : return "Medium" as RowHeight; case "Large" : return "Large" as RowHeight; default: return "ExtraSmall" as RowHeight;}}/** Creates a new discriminated union Gigaform with variant switching */export function rowHeightCreateForm(initial?: RowHeight): RowHeightGigaform {const initialVariant: "ExtraSmall" | "Small" | "Medium" | "Large" = (initial as "ExtraSmall" | "Small" | "Medium" | "Large") ?? "ExtraSmall"; let currentVariant = $state<"ExtraSmall" | "Small" | "Medium" | "Large">(initialVariant); let data = $state<RowHeight>(initial?? rowHeightGetDefaultForVariant(initialVariant)); let errors = $state<RowHeightErrors>({}as RowHeightErrors); let tainted = $state<RowHeightTainted>({}as RowHeightTainted); const variants: RowHeightVariantFields = {ExtraSmall: {fields: {}as RowHeightExtraSmall FieldControllers}, Small: {fields: {}as RowHeightSmall FieldControllers}, Medium: {fields: {}as RowHeightMedium FieldControllers}, Large: {fields: {}as RowHeightLarge FieldControllers}, }; function switchVariant(variant: "ExtraSmall" | "Small" | "Medium" | "Large"): void {currentVariant = variant; data = rowHeightGetDefaultForVariant(variant); errors = {}as RowHeightErrors; tainted = {}as RowHeightTainted;}function validate(): Result<RowHeight, Array<{field: string; message: string}>>{return rowHeightDeserialize(data);}function reset(overrides?: Partial<RowHeight>): void {data = overrides ? overrides as typeof data : rowHeightGetDefaultForVariant(currentVariant); errors = {}as RowHeightErrors; tainted = {}as RowHeightTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function rowHeightFromFormData(formData: FormData): Result<RowHeight, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "ExtraSmall" | "Small" | "Medium" | "Large" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "ExtraSmall" ){}else if(discriminant === "Small" ){}else if(discriminant === "Medium" ){}else if(discriminant === "Large" ){}return rowHeightDeserialize(obj);}

export const RowHeight = {
  defaultValue: rowHeightDefaultValue,
  serialize: rowHeightSerialize,
  serializeWithContext: rowHeightSerializeWithContext,
  deserialize: rowHeightDeserialize,
  deserializeWithContext: rowHeightDeserializeWithContext,
  is: rowHeightIs,
  createForm: rowHeightCreateForm,
  fromFormData: rowHeightFromFormData
} as const;


export type OrderStage = /** @default */ 'Estimate' | 'Active' | 'Invoice';

export function orderStageDefaultValue(): OrderStage {return 'Estimate';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function orderStageSerialize(value: OrderStage): string {const ctx = SerializeContext.create(); return JSON.stringify(orderStageSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function orderStageSerializeWithContext(value: OrderStage, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function orderStageDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: OrderStage } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = orderStageDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "OrderStage.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function orderStageDeserializeWithContext(value: any, ctx: DeserializeContext): OrderStage | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as OrderStage | PendingRef;}const allowedValues = ['Estimate', 'Active', 'Invoice', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for OrderStage: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as OrderStage; }export function orderStageIs(value: unknown): value is OrderStage {const allowedValues = ['Estimate', 'Active', 'Invoice', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type OrderStageEstimate Errors = {_errors: Option<Array<string>>; }; export type OrderStageActive Errors = {_errors: Option<Array<string>>; }; export type OrderStageInvoice Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type OrderStageEstimate Tainted = {}; export type OrderStageActive Tainted = {}; export type OrderStageInvoice Tainted = {}; /** Union error type */export type OrderStageErrors = ({ _value: "Estimate" } & OrderStageEstimateErrors) | ({ _value: "Active" } & OrderStageActiveErrors) | ({ _value: "Invoice" } & OrderStageInvoiceErrors); /** Union tainted type */export type OrderStageTainted = ({ _value: "Estimate" } & OrderStageEstimateTainted) | ({ _value: "Active" } & OrderStageActiveTainted) | ({ _value: "Invoice" } & OrderStageInvoiceTainted); /** Per-variant field controller types */export interface OrderStageEstimate FieldControllers {}export interface OrderStageActive FieldControllers {}export interface OrderStageInvoice FieldControllers {}/** Union Gigaform interface with variant switching */export interface OrderStageGigaform {readonly currentVariant: "Estimate" | "Active" | "Invoice"; readonly data: OrderStage; readonly errors: OrderStageErrors; readonly tainted: OrderStageTainted; readonly variants: OrderStageVariantFields; switchVariant(variant: "Estimate" | "Active" | "Invoice"): void; validate(): Result<OrderStage, Array<{field: string; message: string}>>; reset(overrides?: Partial<OrderStage>): void;}/** Variant fields container */export interface OrderStageVariantFields {readonly Estimate: {readonly fields: OrderStageEstimate FieldControllers}; readonly Active: {readonly fields: OrderStageActive FieldControllers}; readonly Invoice: {readonly fields: OrderStageInvoice FieldControllers}; }/** Gets default value for a specific variant */function orderStageGetDefaultForVariant(variant: string): OrderStage {switch(variant){case "Estimate" : return "Estimate" as OrderStage; case "Active" : return "Active" as OrderStage; case "Invoice" : return "Invoice" as OrderStage; default: return "Estimate" as OrderStage;}}/** Creates a new discriminated union Gigaform with variant switching */export function orderStageCreateForm(initial?: OrderStage): OrderStageGigaform {const initialVariant: "Estimate" | "Active" | "Invoice" = (initial as "Estimate" | "Active" | "Invoice") ?? "Estimate"; let currentVariant = $state<"Estimate" | "Active" | "Invoice">(initialVariant); let data = $state<OrderStage>(initial?? orderStageGetDefaultForVariant(initialVariant)); let errors = $state<OrderStageErrors>({}as OrderStageErrors); let tainted = $state<OrderStageTainted>({}as OrderStageTainted); const variants: OrderStageVariantFields = {Estimate: {fields: {}as OrderStageEstimate FieldControllers}, Active: {fields: {}as OrderStageActive FieldControllers}, Invoice: {fields: {}as OrderStageInvoice FieldControllers}, }; function switchVariant(variant: "Estimate" | "Active" | "Invoice"): void {currentVariant = variant; data = orderStageGetDefaultForVariant(variant); errors = {}as OrderStageErrors; tainted = {}as OrderStageTainted;}function validate(): Result<OrderStage, Array<{field: string; message: string}>>{return orderStageDeserialize(data);}function reset(overrides?: Partial<OrderStage>): void {data = overrides ? overrides as typeof data : orderStageGetDefaultForVariant(currentVariant); errors = {}as OrderStageErrors; tainted = {}as OrderStageTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function orderStageFromFormData(formData: FormData): Result<OrderStage, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Estimate" | "Active" | "Invoice" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Estimate" ){}else if(discriminant === "Active" ){}else if(discriminant === "Invoice" ){}return orderStageDeserialize(obj);}

export const OrderStage = {
  defaultValue: orderStageDefaultValue,
  serialize: orderStageSerialize,
  serializeWithContext: orderStageSerializeWithContext,
  deserialize: orderStageDeserialize,
  deserializeWithContext: orderStageDeserializeWithContext,
  is: orderStageIs,
  createForm: orderStageCreateForm,
  fromFormData: orderStageFromFormData
} as const;


export type Table =
    | /** @default */ 'Account'
    | 'Did'
    | 'Appointment'
    | 'Lead'
    | 'TaxRate'
    | 'Site'
    | 'Employee'
    | 'Route'
    | 'Company'
    | 'Product'
    | 'Service'
    | 'User'
    | 'Order'
    | 'Payment'
    | 'Package'
    | 'Promotion'
    | 'Represents'
    | 'Ordered';

export function tableDefaultValue(): Table {return 'Account';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function tableSerialize(value: Table): string {const ctx = SerializeContext.create(); return JSON.stringify(tableSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function tableSerializeWithContext(value: Table, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function tableDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Table } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = tableDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Table.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function tableDeserializeWithContext(value: any, ctx: DeserializeContext): Table | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Table | PendingRef;}const allowedValues = ['Account', 'Did', 'Appointment', 'Lead', 'TaxRate', 'Site', 'Employee', 'Route', 'Company', 'Product', 'Service', 'User', 'Order', 'Payment', 'Package', 'Promotion', 'Represents', 'Ordered', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for Table: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Table; }export function tableIs(value: unknown): value is Table {const allowedValues = ['Account', 'Did', 'Appointment', 'Lead', 'TaxRate', 'Site', 'Employee', 'Route', 'Company', 'Product', 'Service', 'User', 'Order', 'Payment', 'Package', 'Promotion', 'Represents', 'Ordered', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type TableAccount Errors = {_errors: Option<Array<string>>; }; export type TableDid Errors = {_errors: Option<Array<string>>; }; export type TableAppointment Errors = {_errors: Option<Array<string>>; }; export type TableLead Errors = {_errors: Option<Array<string>>; }; export type TableTaxRate Errors = {_errors: Option<Array<string>>; }; export type TableSite Errors = {_errors: Option<Array<string>>; }; export type TableEmployee Errors = {_errors: Option<Array<string>>; }; export type TableRoute Errors = {_errors: Option<Array<string>>; }; export type TableCompany Errors = {_errors: Option<Array<string>>; }; export type TableProduct Errors = {_errors: Option<Array<string>>; }; export type TableService Errors = {_errors: Option<Array<string>>; }; export type TableUser Errors = {_errors: Option<Array<string>>; }; export type TableOrder Errors = {_errors: Option<Array<string>>; }; export type TablePayment Errors = {_errors: Option<Array<string>>; }; export type TablePackage Errors = {_errors: Option<Array<string>>; }; export type TablePromotion Errors = {_errors: Option<Array<string>>; }; export type TableRepresents Errors = {_errors: Option<Array<string>>; }; export type TableOrdered Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type TableAccount Tainted = {}; export type TableDid Tainted = {}; export type TableAppointment Tainted = {}; export type TableLead Tainted = {}; export type TableTaxRate Tainted = {}; export type TableSite Tainted = {}; export type TableEmployee Tainted = {}; export type TableRoute Tainted = {}; export type TableCompany Tainted = {}; export type TableProduct Tainted = {}; export type TableService Tainted = {}; export type TableUser Tainted = {}; export type TableOrder Tainted = {}; export type TablePayment Tainted = {}; export type TablePackage Tainted = {}; export type TablePromotion Tainted = {}; export type TableRepresents Tainted = {}; export type TableOrdered Tainted = {}; /** Union error type */export type TableErrors = ({ _value: "Account" } & TableAccountErrors) | ({ _value: "Did" } & TableDidErrors) | ({ _value: "Appointment" } & TableAppointmentErrors) | ({ _value: "Lead" } & TableLeadErrors) | ({ _value: "TaxRate" } & TableTaxRateErrors) | ({ _value: "Site" } & TableSiteErrors) | ({ _value: "Employee" } & TableEmployeeErrors) | ({ _value: "Route" } & TableRouteErrors) | ({ _value: "Company" } & TableCompanyErrors) | ({ _value: "Product" } & TableProductErrors) | ({ _value: "Service" } & TableServiceErrors) | ({ _value: "User" } & TableUserErrors) | ({ _value: "Order" } & TableOrderErrors) | ({ _value: "Payment" } & TablePaymentErrors) | ({ _value: "Package" } & TablePackageErrors) | ({ _value: "Promotion" } & TablePromotionErrors) | ({ _value: "Represents" } & TableRepresentsErrors) | ({ _value: "Ordered" } & TableOrderedErrors); /** Union tainted type */export type TableTainted = ({ _value: "Account" } & TableAccountTainted) | ({ _value: "Did" } & TableDidTainted) | ({ _value: "Appointment" } & TableAppointmentTainted) | ({ _value: "Lead" } & TableLeadTainted) | ({ _value: "TaxRate" } & TableTaxRateTainted) | ({ _value: "Site" } & TableSiteTainted) | ({ _value: "Employee" } & TableEmployeeTainted) | ({ _value: "Route" } & TableRouteTainted) | ({ _value: "Company" } & TableCompanyTainted) | ({ _value: "Product" } & TableProductTainted) | ({ _value: "Service" } & TableServiceTainted) | ({ _value: "User" } & TableUserTainted) | ({ _value: "Order" } & TableOrderTainted) | ({ _value: "Payment" } & TablePaymentTainted) | ({ _value: "Package" } & TablePackageTainted) | ({ _value: "Promotion" } & TablePromotionTainted) | ({ _value: "Represents" } & TableRepresentsTainted) | ({ _value: "Ordered" } & TableOrderedTainted); /** Per-variant field controller types */export interface TableAccount FieldControllers {}export interface TableDid FieldControllers {}export interface TableAppointment FieldControllers {}export interface TableLead FieldControllers {}export interface TableTaxRate FieldControllers {}export interface TableSite FieldControllers {}export interface TableEmployee FieldControllers {}export interface TableRoute FieldControllers {}export interface TableCompany FieldControllers {}export interface TableProduct FieldControllers {}export interface TableService FieldControllers {}export interface TableUser FieldControllers {}export interface TableOrder FieldControllers {}export interface TablePayment FieldControllers {}export interface TablePackage FieldControllers {}export interface TablePromotion FieldControllers {}export interface TableRepresents FieldControllers {}export interface TableOrdered FieldControllers {}/** Union Gigaform interface with variant switching */export interface TableGigaform {readonly currentVariant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"; readonly data: Table; readonly errors: TableErrors; readonly tainted: TableTainted; readonly variants: TableVariantFields; switchVariant(variant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void; validate(): Result<Table, Array<{field: string; message: string}>>; reset(overrides?: Partial<Table>): void;}/** Variant fields container */export interface TableVariantFields {readonly Account: {readonly fields: TableAccount FieldControllers}; readonly Did: {readonly fields: TableDid FieldControllers}; readonly Appointment: {readonly fields: TableAppointment FieldControllers}; readonly Lead: {readonly fields: TableLead FieldControllers}; readonly TaxRate: {readonly fields: TableTaxRate FieldControllers}; readonly Site: {readonly fields: TableSite FieldControllers}; readonly Employee: {readonly fields: TableEmployee FieldControllers}; readonly Route: {readonly fields: TableRoute FieldControllers}; readonly Company: {readonly fields: TableCompany FieldControllers}; readonly Product: {readonly fields: TableProduct FieldControllers}; readonly Service: {readonly fields: TableService FieldControllers}; readonly User: {readonly fields: TableUser FieldControllers}; readonly Order: {readonly fields: TableOrder FieldControllers}; readonly Payment: {readonly fields: TablePayment FieldControllers}; readonly Package: {readonly fields: TablePackage FieldControllers}; readonly Promotion: {readonly fields: TablePromotion FieldControllers}; readonly Represents: {readonly fields: TableRepresents FieldControllers}; readonly Ordered: {readonly fields: TableOrdered FieldControllers}; }/** Gets default value for a specific variant */function tableGetDefaultForVariant(variant: string): Table {switch(variant){case "Account" : return "Account" as Table; case "Did" : return "Did" as Table; case "Appointment" : return "Appointment" as Table; case "Lead" : return "Lead" as Table; case "TaxRate" : return "TaxRate" as Table; case "Site" : return "Site" as Table; case "Employee" : return "Employee" as Table; case "Route" : return "Route" as Table; case "Company" : return "Company" as Table; case "Product" : return "Product" as Table; case "Service" : return "Service" as Table; case "User" : return "User" as Table; case "Order" : return "Order" as Table; case "Payment" : return "Payment" as Table; case "Package" : return "Package" as Table; case "Promotion" : return "Promotion" as Table; case "Represents" : return "Represents" as Table; case "Ordered" : return "Ordered" as Table; default: return "Account" as Table;}}/** Creates a new discriminated union Gigaform with variant switching */export function tableCreateForm(initial?: Table): TableGigaform {const initialVariant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" = (initial as "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered") ?? "Account"; let currentVariant = $state<"Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered">(initialVariant); let data = $state<Table>(initial?? tableGetDefaultForVariant(initialVariant)); let errors = $state<TableErrors>({}as TableErrors); let tainted = $state<TableTainted>({}as TableTainted); const variants: TableVariantFields = {Account: {fields: {}as TableAccount FieldControllers}, Did: {fields: {}as TableDid FieldControllers}, Appointment: {fields: {}as TableAppointment FieldControllers}, Lead: {fields: {}as TableLead FieldControllers}, TaxRate: {fields: {}as TableTaxRate FieldControllers}, Site: {fields: {}as TableSite FieldControllers}, Employee: {fields: {}as TableEmployee FieldControllers}, Route: {fields: {}as TableRoute FieldControllers}, Company: {fields: {}as TableCompany FieldControllers}, Product: {fields: {}as TableProduct FieldControllers}, Service: {fields: {}as TableService FieldControllers}, User: {fields: {}as TableUser FieldControllers}, Order: {fields: {}as TableOrder FieldControllers}, Payment: {fields: {}as TablePayment FieldControllers}, Package: {fields: {}as TablePackage FieldControllers}, Promotion: {fields: {}as TablePromotion FieldControllers}, Represents: {fields: {}as TableRepresents FieldControllers}, Ordered: {fields: {}as TableOrdered FieldControllers}, }; function switchVariant(variant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void {currentVariant = variant; data = tableGetDefaultForVariant(variant); errors = {}as TableErrors; tainted = {}as TableTainted;}function validate(): Result<Table, Array<{field: string; message: string}>>{return tableDeserialize(data);}function reset(overrides?: Partial<Table>): void {data = overrides ? overrides as typeof data : tableGetDefaultForVariant(currentVariant); errors = {}as TableErrors; tainted = {}as TableTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function tableFromFormData(formData: FormData): Result<Table, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Account" ){}else if(discriminant === "Did" ){}else if(discriminant === "Appointment" ){}else if(discriminant === "Lead" ){}else if(discriminant === "TaxRate" ){}else if(discriminant === "Site" ){}else if(discriminant === "Employee" ){}else if(discriminant === "Route" ){}else if(discriminant === "Company" ){}else if(discriminant === "Product" ){}else if(discriminant === "Service" ){}else if(discriminant === "User" ){}else if(discriminant === "Order" ){}else if(discriminant === "Payment" ){}else if(discriminant === "Package" ){}else if(discriminant === "Promotion" ){}else if(discriminant === "Represents" ){}else if(discriminant === "Ordered" ){}return tableDeserialize(obj);}

export const Table = {
  defaultValue: tableDefaultValue,
  serialize: tableSerialize,
  serializeWithContext: tableSerializeWithContext,
  deserialize: tableDeserialize,
  deserializeWithContext: tableDeserializeWithContext,
  is: tableIs,
  createForm: tableCreateForm,
  fromFormData: tableFromFormData
} as const;


export type Item = RecordLink<Product> | /** @default */ RecordLink<Service>;

export function itemDefaultValue(): Item {return recordLinkDefaultValue<Service>();}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function itemSerialize(value: Item): string {const ctx = SerializeContext.create(); return JSON.stringify(itemSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function itemSerializeWithContext(value: Item, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function itemDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Item } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = itemDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Item.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function itemDeserializeWithContext(value: any, ctx: DeserializeContext): Item | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Item | PendingRef;}if(typeof value!== "object" || value === null){throw new DeserializeError([{field: "_root" , message: "Item.deserializeWithContext: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new DeserializeError([{field: "_root" , message: "Item.deserializeWithContext: missing __type field for union dispatch" }]);}if(__typeName === "RecordLink<Product>" ){return recordLinkDeserializeWithContext(value, ctx)as Item;}if(__typeName === "RecordLink<Service>" ){return recordLinkDeserializeWithContext(value, ctx)as Item;}throw new DeserializeError([{field: "_root" , message: "Item.deserializeWithContext: unknown type \"" + __typeName + "\". Expected one of: RecordLink<Product>, RecordLink<Service>" }]); }export function itemIs(value: unknown): value is Item {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "RecordLink<Product>" || __typeName === "RecordLink<Service>" ; }

/** Per-variant error types */export type ItemRecordLinkProduct Errors = {_errors: Option<Array<string>>; }; export type ItemRecordLinkService Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type ItemRecordLinkProduct Tainted = {}; export type ItemRecordLinkService Tainted = {}; /** Union error type */export type ItemErrors = ({ _type: "RecordLink<Product>" } & ItemRecordLinkProductErrors) | ({ _type: "RecordLink<Service>" } & ItemRecordLinkServiceErrors); /** Union tainted type */export type ItemTainted = ({ _type: "RecordLink<Product>" } & ItemRecordLinkProductTainted) | ({ _type: "RecordLink<Service>" } & ItemRecordLinkServiceTainted); /** Per-variant field controller types */export interface ItemRecordLinkProduct FieldControllers {}export interface ItemRecordLinkService FieldControllers {}/** Union Gigaform interface with variant switching */export interface ItemGigaform {readonly currentVariant: "RecordLink<Product>" | "RecordLink<Service>"; readonly data: Item; readonly errors: ItemErrors; readonly tainted: ItemTainted; readonly variants: ItemVariantFields; switchVariant(variant: "RecordLink<Product>" | "RecordLink<Service>"): void; validate(): Result<Item, Array<{field: string; message: string}>>; reset(overrides?: Partial<Item>): void;}/** Variant fields container */export interface ItemVariantFields {readonly "RecordLink<Product>": {readonly fields: ItemRecordLinkProduct FieldControllers}; readonly "RecordLink<Service>": {readonly fields: ItemRecordLinkService FieldControllers}; }/** Gets default value for a specific variant */function itemGetDefaultForVariant(variant: string): Item {switch(variant){case "RecordLink<Product>" : return recordLinkDefaultValue<Product>() as Item; case "RecordLink<Service>" : return recordLinkDefaultValue<Service>() as Item; default: return recordLinkDefaultValue<Product>() as Item;}}/** Creates a new discriminated union Gigaform with variant switching */export function itemCreateForm(initial?: Item): ItemGigaform {const initialVariant: "RecordLink<Product>" | "RecordLink<Service>" = "RecordLink<Product>"; let currentVariant = $state<"RecordLink<Product>" | "RecordLink<Service>">(initialVariant); let data = $state<Item>(initial?? itemGetDefaultForVariant(initialVariant)); let errors = $state<ItemErrors>({}as ItemErrors); let tainted = $state<ItemTainted>({}as ItemTainted); const variants: ItemVariantFields = {"RecordLink<Product>": {fields: {}as ItemRecordLinkProduct FieldControllers}, "RecordLink<Service>": {fields: {}as ItemRecordLinkService FieldControllers}, }; function switchVariant(variant: "RecordLink<Product>" | "RecordLink<Service>"): void {currentVariant = variant; data = itemGetDefaultForVariant(variant); errors = {}as ItemErrors; tainted = {}as ItemTainted;}function validate(): Result<Item, Array<{field: string; message: string}>>{return itemDeserialize(data);}function reset(overrides?: Partial<Item>): void {data = overrides ? overrides as typeof data : itemGetDefaultForVariant(currentVariant); errors = {}as ItemErrors; tainted = {}as ItemTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function itemFromFormData(formData: FormData): Result<Item, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "RecordLink<Product>" | "RecordLink<Service>" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "RecordLink<Product>" ){}else if(discriminant === "RecordLink<Service>" ){}return itemDeserialize(obj);}

export const Item = {
  defaultValue: itemDefaultValue,
  serialize: itemSerialize,
  serializeWithContext: itemSerializeWithContext,
  deserialize: itemDeserialize,
  deserializeWithContext: itemDeserializeWithContext,
  is: itemIs,
  createForm: itemCreateForm,
  fromFormData: itemFromFormData
} as const;


export type RecordLink<T> = /** @default */ string | T;

export function recordLinkDefaultValue<T>(): RecordLink<T> {return "";}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function recordLinkSerialize<T>(value: RecordLink<T>): string {const ctx = SerializeContext.create(); return JSON.stringify(recordLinkSerializeWithContext<T>(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function recordLinkSerializeWithContext<T>(value: RecordLink<T>, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function recordLinkDeserialize<T>(input: unknown, opts?: DeserializeOptions): { success: true; value: RecordLink<T> } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = recordLinkDeserializeWithContext<T>(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "RecordLink.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function recordLinkDeserializeWithContext<T>(value: any, ctx: DeserializeContext): RecordLink<T> | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as RecordLink<T> | PendingRef;}if(typeof value === "string" ){return value as RecordLink<T>;}return value as RecordLink<T>; throw new DeserializeError([{field: "_root" , message: "RecordLink.deserializeWithContext: value does not match any union member" }]); }export function recordLinkIs<T>(value: unknown): value is RecordLink<T> {if(typeof value === "string" )return true; return true; }


export type Actor = /** @default */ User | Employee | Account;

export function actorDefaultValue(): Actor {return userDefaultValue();}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function actorSerialize(value: Actor): string {const ctx = SerializeContext.create(); return JSON.stringify(actorSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function actorSerializeWithContext(value: Actor, ctx: SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function actorDeserialize(input: unknown, opts?: DeserializeOptions): { success: true; value: Actor } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = DeserializeContext.create(); const resultOrRef = actorDeserializeWithContext(data, ctx); if(PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Actor.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function actorDeserializeWithContext(value: any, ctx: DeserializeContext): Actor | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Actor | PendingRef;}if(typeof value!== "object" || value === null){throw new DeserializeError([{field: "_root" , message: "Actor.deserializeWithContext: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new DeserializeError([{field: "_root" , message: "Actor.deserializeWithContext: missing __type field for union dispatch" }]);}if(__typeName === "User" ){return userDeserializeWithContext(value, ctx)as Actor;}if(__typeName === "Employee" ){return employeeDeserializeWithContext(value, ctx)as Actor;}if(__typeName === "Account" ){return accountDeserializeWithContext(value, ctx)as Actor;}throw new DeserializeError([{field: "_root" , message: "Actor.deserializeWithContext: unknown type \"" + __typeName + "\". Expected one of: User, Employee, Account" }]); }export function actorIs(value: unknown): value is Actor {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "User" || __typeName === "Employee" || __typeName === "Account" ; }

/** Per-variant error types */export type ActorUser Errors = {_errors: Option<Array<string>>; }; export type ActorEmployee Errors = {_errors: Option<Array<string>>; }; export type ActorAccount Errors = {_errors: Option<Array<string>>; }; /** Per-variant tainted types */export type ActorUser Tainted = {}; export type ActorEmployee Tainted = {}; export type ActorAccount Tainted = {}; /** Union error type */export type ActorErrors = ({ _type: "User" } & ActorUserErrors) | ({ _type: "Employee" } & ActorEmployeeErrors) | ({ _type: "Account" } & ActorAccountErrors); /** Union tainted type */export type ActorTainted = ({ _type: "User" } & ActorUserTainted) | ({ _type: "Employee" } & ActorEmployeeTainted) | ({ _type: "Account" } & ActorAccountTainted); /** Per-variant field controller types */export interface ActorUser FieldControllers {}export interface ActorEmployee FieldControllers {}export interface ActorAccount FieldControllers {}/** Union Gigaform interface with variant switching */export interface ActorGigaform {readonly currentVariant: "User" | "Employee" | "Account"; readonly data: Actor; readonly errors: ActorErrors; readonly tainted: ActorTainted; readonly variants: ActorVariantFields; switchVariant(variant: "User" | "Employee" | "Account"): void; validate(): Result<Actor, Array<{field: string; message: string}>>; reset(overrides?: Partial<Actor>): void;}/** Variant fields container */export interface ActorVariantFields {readonly User: {readonly fields: ActorUser FieldControllers}; readonly Employee: {readonly fields: ActorEmployee FieldControllers}; readonly Account: {readonly fields: ActorAccount FieldControllers}; }/** Gets default value for a specific variant */function actorGetDefaultForVariant(variant: string): Actor {switch(variant){case "User" : return userDefaultValue() as Actor; case "Employee" : return employeeDefaultValue() as Actor; case "Account" : return accountDefaultValue() as Actor; default: return userDefaultValue() as Actor;}}/** Creates a new discriminated union Gigaform with variant switching */export function actorCreateForm(initial?: Actor): ActorGigaform {const initialVariant: "User" | "Employee" | "Account" = "User"; let currentVariant = $state<"User" | "Employee" | "Account">(initialVariant); let data = $state<Actor>(initial?? actorGetDefaultForVariant(initialVariant)); let errors = $state<ActorErrors>({}as ActorErrors); let tainted = $state<ActorTainted>({}as ActorTainted); const variants: ActorVariantFields = {User: {fields: {}as ActorUser FieldControllers}, Employee: {fields: {}as ActorEmployee FieldControllers}, Account: {fields: {}as ActorAccount FieldControllers}, }; function switchVariant(variant: "User" | "Employee" | "Account"): void {currentVariant = variant; data = actorGetDefaultForVariant(variant); errors = {}as ActorErrors; tainted = {}as ActorTainted;}function validate(): Result<Actor, Array<{field: string; message: string}>>{return actorDeserialize(data);}function reset(overrides?: Partial<Actor>): void {data = overrides ? overrides as typeof data : actorGetDefaultForVariant(currentVariant); errors = {}as ActorErrors; tainted = {}as ActorTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function actorFromFormData(formData: FormData): Result<Actor, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "User" | "Employee" | "Account" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "User" ){}else if(discriminant === "Employee" ){}else if(discriminant === "Account" ){}return actorDeserialize(obj);}

export const Actor = {
  defaultValue: actorDefaultValue,
  serialize: actorSerialize,
  serializeWithContext: actorSerializeWithContext,
  deserialize: actorDeserialize,
  deserializeWithContext: actorDeserializeWithContext,
  is: actorIs,
  createForm: actorCreateForm,
  fromFormData: actorFromFormData
} as const;