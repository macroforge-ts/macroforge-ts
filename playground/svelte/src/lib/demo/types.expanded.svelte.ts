import { SerializeContext } from "macroforge/serde";
import { Result } from "macroforge/utils";
import { DeserializeContext } from "macroforge/serde";
import { DeserializeError } from "macroforge/serde";
import type { DeserializeOptions } from "macroforge/serde";
import { PendingRef } from "macroforge/serde";
import { Option } from "macroforge/utils";
import type { FieldController } from "@playground/macro/gigaform";
import type { ArrayFieldController } from "@playground/macro/gigaform";
/** import macro {Gigaform} from "@playground/macro"; */

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface User {
  id: string;
  email: string | null;
  /** @serde({ validate: ["nonEmpty"] }) */
  firstName: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  lastName: string;
  password: string | null;
  metadata: Metadata | null;
  settings: Settings;
  /** @default("Administrator") */
  role: UserRole;
  emailVerified: boolean;
  verificationToken: string | null;
  verificationExpires: string | null;
  passwordResetToken: string | null;
  passwordResetExpires: string | null;
  permissions: AppPermissions;
}

export function defaultValueUser(): User {
  return {
    id: "",
    email: null,
    firstName: "",
    lastName: "",
    password: null,
    metadata: null,
    settings: Settings.defaultValue(),
    role: "Administrator",
    emailVerified: false,
    verificationToken: null,
    verificationExpires: null,
    passwordResetToken: null,
    passwordResetExpires: null,
    permissions: AppPermissions.defaultValue(),
  } as User;
}

export function toStringifiedJSONUser(value: User): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeUser(value, ctx));
}
export function toObjectUser(value: User): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeUser(value, ctx);
}
export function __serializeUser(
  value: User,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "User", __id };
  result["id"] = value.id;
  if (value.email !== null) {
    result["email"] =
      typeof (value.email as any)?.__serialize === "function"
        ? (value.email as any).__serialize(ctx)
        : value.email;
  } else {
    result["email"] = null;
  }
  result["firstName"] = value.firstName;
  result["lastName"] = value.lastName;
  if (value.password !== null) {
    result["password"] =
      typeof (value.password as any)?.__serialize === "function"
        ? (value.password as any).__serialize(ctx)
        : value.password;
  } else {
    result["password"] = null;
  }
  if (value.metadata !== null) {
    result["metadata"] =
      typeof (value.metadata as any)?.__serialize === "function"
        ? (value.metadata as any).__serialize(ctx)
        : value.metadata;
  } else {
    result["metadata"] = null;
  }
  result["settings"] =
    typeof (value.settings as any)?.__serialize === "function"
      ? (value.settings as any).__serialize(ctx)
      : value.settings;
  result["role"] =
    typeof (value.role as any)?.__serialize === "function"
      ? (value.role as any).__serialize(ctx)
      : value.role;
  result["emailVerified"] = value.emailVerified;
  if (value.verificationToken !== null) {
    result["verificationToken"] =
      typeof (value.verificationToken as any)?.__serialize === "function"
        ? (value.verificationToken as any).__serialize(ctx)
        : value.verificationToken;
  } else {
    result["verificationToken"] = null;
  }
  if (value.verificationExpires !== null) {
    result["verificationExpires"] =
      typeof (value.verificationExpires as any)?.__serialize === "function"
        ? (value.verificationExpires as any).__serialize(ctx)
        : value.verificationExpires;
  } else {
    result["verificationExpires"] = null;
  }
  if (value.passwordResetToken !== null) {
    result["passwordResetToken"] =
      typeof (value.passwordResetToken as any)?.__serialize === "function"
        ? (value.passwordResetToken as any).__serialize(ctx)
        : value.passwordResetToken;
  } else {
    result["passwordResetToken"] = null;
  }
  if (value.passwordResetExpires !== null) {
    result["passwordResetExpires"] =
      typeof (value.passwordResetExpires as any)?.__serialize === "function"
        ? (value.passwordResetExpires as any).__serialize(ctx)
        : value.passwordResetExpires;
  } else {
    result["passwordResetExpires"] = null;
  }
  result["permissions"] =
    typeof (value.permissions as any)?.__serialize === "function"
      ? (value.permissions as any).__serialize(ctx)
      : value.permissions;
  return result;
}

export function fromStringifiedJSONUser(
  json: string,
  opts?: DeserializeOptions,
): Result<User, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectUser(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectUser(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<User, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeUser(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "User.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeUser(
  value: any,
  ctx: DeserializeContext,
): User | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "User.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("email" in obj)) {
    errors.push({ field: "email", message: "missing required field" });
  }
  if (!("firstName" in obj)) {
    errors.push({ field: "firstName", message: "missing required field" });
  }
  if (!("lastName" in obj)) {
    errors.push({ field: "lastName", message: "missing required field" });
  }
  if (!("password" in obj)) {
    errors.push({ field: "password", message: "missing required field" });
  }
  if (!("metadata" in obj)) {
    errors.push({ field: "metadata", message: "missing required field" });
  }
  if (!("settings" in obj)) {
    errors.push({ field: "settings", message: "missing required field" });
  }
  if (!("role" in obj)) {
    errors.push({ field: "role", message: "missing required field" });
  }
  if (!("emailVerified" in obj)) {
    errors.push({ field: "emailVerified", message: "missing required field" });
  }
  if (!("verificationToken" in obj)) {
    errors.push({
      field: "verificationToken",
      message: "missing required field",
    });
  }
  if (!("verificationExpires" in obj)) {
    errors.push({
      field: "verificationExpires",
      message: "missing required field",
    });
  }
  if (!("passwordResetToken" in obj)) {
    errors.push({
      field: "passwordResetToken",
      message: "missing required field",
    });
  }
  if (!("passwordResetExpires" in obj)) {
    errors.push({
      field: "passwordResetExpires",
      message: "missing required field",
    });
  }
  if (!("permissions" in obj)) {
    errors.push({ field: "permissions", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_email = obj["email"] as string | null;
    if (__raw_email === null) {
      instance.email = null;
    } else if (typeof (__raw_email as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_email as any).__ref);
      ctx.assignOrDefer(instance, "email", __result);
    } else {
      instance.email = __raw_email;
    }
  }
  {
    const __raw_firstName = obj["firstName"] as string;
    if (__raw_firstName.length === 0) {
      errors.push({ field: "firstName", message: "must not be empty" });
    }
    instance.firstName = __raw_firstName;
  }
  {
    const __raw_lastName = obj["lastName"] as string;
    if (__raw_lastName.length === 0) {
      errors.push({ field: "lastName", message: "must not be empty" });
    }
    instance.lastName = __raw_lastName;
  }
  {
    const __raw_password = obj["password"] as string | null;
    if (__raw_password === null) {
      instance.password = null;
    } else if (typeof (__raw_password as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_password as any).__ref);
      ctx.assignOrDefer(instance, "password", __result);
    } else {
      instance.password = __raw_password;
    }
  }
  {
    const __raw_metadata = obj["metadata"] as Metadata | null;
    if (__raw_metadata === null) {
      instance.metadata = null;
    } else if (typeof (__raw_metadata as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_metadata as any).__ref);
      ctx.assignOrDefer(instance, "metadata", __result);
    } else {
      instance.metadata = __raw_metadata;
    }
  }
  {
    const __raw_settings = obj["settings"] as Settings;
    if (typeof (Settings as any)?.__deserialize === "function") {
      const __result = (Settings as any).__deserialize(__raw_settings, ctx);
      ctx.assignOrDefer(instance, "settings", __result);
    } else {
      instance.settings = __raw_settings;
    }
  }
  {
    const __raw_role = obj["role"] as UserRole;
    if (typeof (UserRole as any)?.__deserialize === "function") {
      const __result = (UserRole as any).__deserialize(__raw_role, ctx);
      ctx.assignOrDefer(instance, "role", __result);
    } else {
      instance.role = __raw_role;
    }
  }
  {
    const __raw_emailVerified = obj["emailVerified"] as boolean;
    instance.emailVerified = __raw_emailVerified;
  }
  {
    const __raw_verificationToken = obj["verificationToken"] as string | null;
    if (__raw_verificationToken === null) {
      instance.verificationToken = null;
    } else if (typeof (__raw_verificationToken as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_verificationToken as any).__ref);
      ctx.assignOrDefer(instance, "verificationToken", __result);
    } else {
      instance.verificationToken = __raw_verificationToken;
    }
  }
  {
    const __raw_verificationExpires = obj["verificationExpires"] as
      | string
      | null;
    if (__raw_verificationExpires === null) {
      instance.verificationExpires = null;
    } else if (
      typeof (__raw_verificationExpires as any)?.__ref !== "undefined"
    ) {
      const __result = ctx.getOrDefer((__raw_verificationExpires as any).__ref);
      ctx.assignOrDefer(instance, "verificationExpires", __result);
    } else {
      instance.verificationExpires = __raw_verificationExpires;
    }
  }
  {
    const __raw_passwordResetToken = obj["passwordResetToken"] as string | null;
    if (__raw_passwordResetToken === null) {
      instance.passwordResetToken = null;
    } else if (
      typeof (__raw_passwordResetToken as any)?.__ref !== "undefined"
    ) {
      const __result = ctx.getOrDefer((__raw_passwordResetToken as any).__ref);
      ctx.assignOrDefer(instance, "passwordResetToken", __result);
    } else {
      instance.passwordResetToken = __raw_passwordResetToken;
    }
  }
  {
    const __raw_passwordResetExpires = obj["passwordResetExpires"] as
      | string
      | null;
    if (__raw_passwordResetExpires === null) {
      instance.passwordResetExpires = null;
    } else if (
      typeof (__raw_passwordResetExpires as any)?.__ref !== "undefined"
    ) {
      const __result = ctx.getOrDefer(
        (__raw_passwordResetExpires as any).__ref,
      );
      ctx.assignOrDefer(instance, "passwordResetExpires", __result);
    } else {
      instance.passwordResetExpires = __raw_passwordResetExpires;
    }
  }
  {
    const __raw_permissions = obj["permissions"] as AppPermissions;
    if (typeof (AppPermissions as any)?.__deserialize === "function") {
      const __result = (AppPermissions as any).__deserialize(
        __raw_permissions,
        ctx,
      );
      ctx.assignOrDefer(instance, "permissions", __result);
    } else {
      instance.permissions = __raw_permissions;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as User;
}
export function validateFieldUser<K extends keyof User>(
  field: K,
  value: User[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "firstName": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "firstName", message: "must not be empty" });
      }
      break;
    }
    case "lastName": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "lastName", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsUser(
  partial: Partial<User>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("firstName" in partial && partial.firstName !== undefined) {
    const __val = partial.firstName as string;
    if (__val.length === 0) {
      errors.push({ field: "firstName", message: "must not be empty" });
    }
  }
  if ("lastName" in partial && partial.lastName !== undefined) {
    const __val = partial.lastName as string;
    if (__val.length === 0) {
      errors.push({ field: "lastName", message: "must not be empty" });
    }
  }
  return errors;
}
export function isUser(obj: unknown): obj is User {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "id" in o &&
    "email" in o &&
    "firstName" in o &&
    "lastName" in o &&
    "password" in o &&
    "metadata" in o &&
    "settings" in o &&
    "role" in o &&
    "emailVerified" in o &&
    "verificationToken" in o &&
    "verificationExpires" in o &&
    "passwordResetToken" in o &&
    "passwordResetExpires" in o &&
    "permissions" in o
  );
}

export namespace User {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    email: Option<Array<string>>;
    firstName: Option<Array<string>>;
    lastName: Option<Array<string>>;
    password: Option<Array<string>>;
    metadata: Option<Array<string>>;
    settings: Option<Array<string>>;
    role: Option<Array<string>>;
    emailVerified: Option<Array<string>>;
    verificationToken: Option<Array<string>>;
    verificationExpires: Option<Array<string>>;
    passwordResetToken: Option<Array<string>>;
    passwordResetExpires: Option<Array<string>>;
    permissions: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      email: Option<boolean>;
      firstName: Option<boolean>;
      lastName: Option<boolean>;
      password: Option<boolean>;
      metadata: Option<boolean>;
      settings: Option<boolean>;
      role: Option<boolean>;
      emailVerified: Option<boolean>;
      verificationToken: Option<boolean>;
      verificationExpires: Option<boolean>;
      passwordResetToken: Option<boolean>;
      passwordResetExpires: Option<boolean>;
      permissions: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly email: FieldController<string | null>;
    readonly firstName: FieldController<string>;
    readonly lastName: FieldController<string>;
    readonly password: FieldController<string | null>;
    readonly metadata: FieldController<Metadata | null>;
    readonly settings: FieldController<Settings>;
    readonly role: FieldController<UserRole>;
    readonly emailVerified: FieldController<boolean>;
    readonly verificationToken: FieldController<string | null>;
    readonly verificationExpires: FieldController<string | null>;
    readonly passwordResetToken: FieldController<string | null>;
    readonly passwordResetExpires: FieldController<string | null>;
    readonly permissions: FieldController<AppPermissions>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: User;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<User, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<User>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<User>,
  ): Gigaform {
    let data = $state({ ...User.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      email: Option.none(),
      firstName: Option.none(),
      lastName: Option.none(),
      password: Option.none(),
      metadata: Option.none(),
      settings: Option.none(),
      role: Option.none(),
      emailVerified: Option.none(),
      verificationToken: Option.none(),
      verificationExpires: Option.none(),
      passwordResetToken: Option.none(),
      passwordResetExpires: Option.none(),
      permissions: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      email: Option.none(),
      firstName: Option.none(),
      lastName: Option.none(),
      password: Option.none(),
      metadata: Option.none(),
      settings: Option.none(),
      role: Option.none(),
      emailVerified: Option.none(),
      verificationToken: Option.none(),
      verificationExpires: Option.none(),
      passwordResetToken: Option.none(),
      passwordResetExpires: Option.none(),
      permissions: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      email: {
        path: ["email"] as const,
        name: "email",
        constraints: { required: true },

        get: () => data.email,
        set: (value: string | null) => {
          data.email = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.email,
        setError: (value: Option<Array<string>>) => {
          errors.email = value;
        },
        getTainted: () => tainted.email,
        setTainted: (value: Option<boolean>) => {
          tainted.email = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("email", data.email);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      firstName: {
        path: ["firstName"] as const,
        name: "firstName",
        constraints: { required: true },

        get: () => data.firstName,
        set: (value: string) => {
          data.firstName = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.firstName,
        setError: (value: Option<Array<string>>) => {
          errors.firstName = value;
        },
        getTainted: () => tainted.firstName,
        setTainted: (value: Option<boolean>) => {
          tainted.firstName = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("firstName", data.firstName);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      lastName: {
        path: ["lastName"] as const,
        name: "lastName",
        constraints: { required: true },

        get: () => data.lastName,
        set: (value: string) => {
          data.lastName = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.lastName,
        setError: (value: Option<Array<string>>) => {
          errors.lastName = value;
        },
        getTainted: () => tainted.lastName,
        setTainted: (value: Option<boolean>) => {
          tainted.lastName = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("lastName", data.lastName);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      password: {
        path: ["password"] as const,
        name: "password",
        constraints: { required: true },

        get: () => data.password,
        set: (value: string | null) => {
          data.password = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.password,
        setError: (value: Option<Array<string>>) => {
          errors.password = value;
        },
        getTainted: () => tainted.password,
        setTainted: (value: Option<boolean>) => {
          tainted.password = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("password", data.password);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      metadata: {
        path: ["metadata"] as const,
        name: "metadata",
        constraints: { required: true },

        get: () => data.metadata,
        set: (value: Metadata | null) => {
          data.metadata = value;
        },
        transform: (value: Metadata | null): Metadata | null => value,
        getError: () => errors.metadata,
        setError: (value: Option<Array<string>>) => {
          errors.metadata = value;
        },
        getTainted: () => tainted.metadata,
        setTainted: (value: Option<boolean>) => {
          tainted.metadata = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("metadata", data.metadata);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      settings: {
        path: ["settings"] as const,
        name: "settings",
        constraints: { required: true },

        get: () => data.settings,
        set: (value: Settings) => {
          data.settings = value;
        },
        transform: (value: Settings): Settings => value,
        getError: () => errors.settings,
        setError: (value: Option<Array<string>>) => {
          errors.settings = value;
        },
        getTainted: () => tainted.settings,
        setTainted: (value: Option<boolean>) => {
          tainted.settings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("settings", data.settings);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      role: {
        path: ["role"] as const,
        name: "role",
        constraints: { required: true },

        get: () => data.role,
        set: (value: UserRole) => {
          data.role = value;
        },
        transform: (value: UserRole): UserRole => value,
        getError: () => errors.role,
        setError: (value: Option<Array<string>>) => {
          errors.role = value;
        },
        getTainted: () => tainted.role,
        setTainted: (value: Option<boolean>) => {
          tainted.role = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("role", data.role);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      emailVerified: {
        path: ["emailVerified"] as const,
        name: "emailVerified",
        constraints: { required: true },

        get: () => data.emailVerified,
        set: (value: boolean) => {
          data.emailVerified = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.emailVerified,
        setError: (value: Option<Array<string>>) => {
          errors.emailVerified = value;
        },
        getTainted: () => tainted.emailVerified,
        setTainted: (value: Option<boolean>) => {
          tainted.emailVerified = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField(
            "emailVerified",
            data.emailVerified,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      verificationToken: {
        path: ["verificationToken"] as const,
        name: "verificationToken",
        constraints: { required: true },

        get: () => data.verificationToken,
        set: (value: string | null) => {
          data.verificationToken = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.verificationToken,
        setError: (value: Option<Array<string>>) => {
          errors.verificationToken = value;
        },
        getTainted: () => tainted.verificationToken,
        setTainted: (value: Option<boolean>) => {
          tainted.verificationToken = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField(
            "verificationToken",
            data.verificationToken,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      verificationExpires: {
        path: ["verificationExpires"] as const,
        name: "verificationExpires",
        constraints: { required: true },

        get: () => data.verificationExpires,
        set: (value: string | null) => {
          data.verificationExpires = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.verificationExpires,
        setError: (value: Option<Array<string>>) => {
          errors.verificationExpires = value;
        },
        getTainted: () => tainted.verificationExpires,
        setTainted: (value: Option<boolean>) => {
          tainted.verificationExpires = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField(
            "verificationExpires",
            data.verificationExpires,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      passwordResetToken: {
        path: ["passwordResetToken"] as const,
        name: "passwordResetToken",
        constraints: { required: true },

        get: () => data.passwordResetToken,
        set: (value: string | null) => {
          data.passwordResetToken = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.passwordResetToken,
        setError: (value: Option<Array<string>>) => {
          errors.passwordResetToken = value;
        },
        getTainted: () => tainted.passwordResetToken,
        setTainted: (value: Option<boolean>) => {
          tainted.passwordResetToken = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField(
            "passwordResetToken",
            data.passwordResetToken,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      passwordResetExpires: {
        path: ["passwordResetExpires"] as const,
        name: "passwordResetExpires",
        constraints: { required: true },

        get: () => data.passwordResetExpires,
        set: (value: string | null) => {
          data.passwordResetExpires = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.passwordResetExpires,
        setError: (value: Option<Array<string>>) => {
          errors.passwordResetExpires = value;
        },
        getTainted: () => tainted.passwordResetExpires,
        setTainted: (value: Option<boolean>) => {
          tainted.passwordResetExpires = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField(
            "passwordResetExpires",
            data.passwordResetExpires,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      permissions: {
        path: ["permissions"] as const,
        name: "permissions",
        constraints: { required: true },

        get: () => data.permissions,
        set: (value: AppPermissions) => {
          data.permissions = value;
        },
        transform: (value: AppPermissions): AppPermissions => value,
        getError: () => errors.permissions,
        setError: (value: Option<Array<string>>) => {
          errors.permissions = value;
        },
        getTainted: () => tainted.permissions,
        setTainted: (value: Option<boolean>) => {
          tainted.permissions = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField(
            "permissions",
            data.permissions,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      User,
      Array<{ field: string; message: string }>
    > {
      return User.fromObject(data);
    }
    function reset(newOverrides?: Partial<User>): void {
      data = { ...User.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        email: Option.none(),
        firstName: Option.none(),
        lastName: Option.none(),
        password: Option.none(),
        metadata: Option.none(),
        settings: Option.none(),
        role: Option.none(),
        emailVerified: Option.none(),
        verificationToken: Option.none(),
        verificationExpires: Option.none(),
        passwordResetToken: Option.none(),
        passwordResetExpires: Option.none(),
        permissions: Option.none(),
      };
      tainted = {
        id: Option.none(),
        email: Option.none(),
        firstName: Option.none(),
        lastName: Option.none(),
        password: Option.none(),
        metadata: Option.none(),
        settings: Option.none(),
        role: Option.none(),
        emailVerified: Option.none(),
        verificationToken: Option.none(),
        verificationExpires: Option.none(),
        passwordResetToken: Option.none(),
        passwordResetExpires: Option.none(),
        permissions: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<User, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.email = formData.get("email") ?? "";
    obj.firstName = formData.get("firstName") ?? "";
    obj.lastName = formData.get("lastName") ?? "";
    obj.password = formData.get("password") ?? "";
    obj.metadata = formData.get("metadata") ?? "";
    {
      // Collect nested object fields with prefix "settings."
      const settingsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("settings.")) {
          const fieldName = key.slice("settings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = settingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.settings = settingsObj;
    }
    {
      // Collect nested object fields with prefix "role."
      const roleObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("role.")) {
          const fieldName = key.slice("role.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = roleObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.role = roleObj;
    }
    {
      const emailVerifiedVal = formData.get("emailVerified");
      obj.emailVerified =
        emailVerifiedVal === "true" ||
        emailVerifiedVal === "on" ||
        emailVerifiedVal === "1";
    }
    obj.verificationToken = formData.get("verificationToken") ?? "";
    obj.verificationExpires = formData.get("verificationExpires") ?? "";
    obj.passwordResetToken = formData.get("passwordResetToken") ?? "";
    obj.passwordResetExpires = formData.get("passwordResetExpires") ?? "";
    {
      // Collect nested object fields with prefix "permissions."
      const permissionsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("permissions.")) {
          const fieldName = key.slice("permissions.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = permissionsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.permissions = permissionsObj;
    }
    return User.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Service {
  /** @hiddenController({}) */
  id: string;
  /** @textController({ label: "Name" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  name: string;
  /** @textController({ label: "Quick Code" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  quickCode: string;
  /** @comboboxController({ label: "Group", allowCustom: true }) */
  group: string | null;
  /** @comboboxController({ label: "Subgroup", allowCustom: true }) */
  subgroup: string | null;
  /** @comboboxController({ label: "Unit", allowCustom: true }) */
  unit: string | null;
  /** @switchController({ label: "Active" }) */
  active: boolean;
  /** @switchController({ label: "Commission" }) */
  commission: boolean;
  /** @switchController({ label: "Favorite" }) */
  favorite: boolean;
  /** @textController({ label: "Average Time" }) */
  averageTime: string | null;
  defaults: ServiceDefaults;
}

export function defaultValueService(): Service {
  return {
    id: "",
    name: "",
    quickCode: "",
    group: null,
    subgroup: null,
    unit: null,
    active: false,
    commission: false,
    favorite: false,
    averageTime: null,
    defaults: ServiceDefaults.defaultValue(),
  } as Service;
}

export function toStringifiedJSONService(value: Service): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeService(value, ctx));
}
export function toObjectService(value: Service): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeService(value, ctx);
}
export function __serializeService(
  value: Service,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Service", __id };
  result["id"] = value.id;
  result["name"] = value.name;
  result["quickCode"] = value.quickCode;
  if (value.group !== null) {
    result["group"] =
      typeof (value.group as any)?.__serialize === "function"
        ? (value.group as any).__serialize(ctx)
        : value.group;
  } else {
    result["group"] = null;
  }
  if (value.subgroup !== null) {
    result["subgroup"] =
      typeof (value.subgroup as any)?.__serialize === "function"
        ? (value.subgroup as any).__serialize(ctx)
        : value.subgroup;
  } else {
    result["subgroup"] = null;
  }
  if (value.unit !== null) {
    result["unit"] =
      typeof (value.unit as any)?.__serialize === "function"
        ? (value.unit as any).__serialize(ctx)
        : value.unit;
  } else {
    result["unit"] = null;
  }
  result["active"] = value.active;
  result["commission"] = value.commission;
  result["favorite"] = value.favorite;
  if (value.averageTime !== null) {
    result["averageTime"] =
      typeof (value.averageTime as any)?.__serialize === "function"
        ? (value.averageTime as any).__serialize(ctx)
        : value.averageTime;
  } else {
    result["averageTime"] = null;
  }
  result["defaults"] =
    typeof (value.defaults as any)?.__serialize === "function"
      ? (value.defaults as any).__serialize(ctx)
      : value.defaults;
  return result;
}

export function fromStringifiedJSONService(
  json: string,
  opts?: DeserializeOptions,
): Result<Service, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectService(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectService(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Service, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeService(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Service.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeService(
  value: any,
  ctx: DeserializeContext,
): Service | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Service.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("name" in obj)) {
    errors.push({ field: "name", message: "missing required field" });
  }
  if (!("quickCode" in obj)) {
    errors.push({ field: "quickCode", message: "missing required field" });
  }
  if (!("group" in obj)) {
    errors.push({ field: "group", message: "missing required field" });
  }
  if (!("subgroup" in obj)) {
    errors.push({ field: "subgroup", message: "missing required field" });
  }
  if (!("unit" in obj)) {
    errors.push({ field: "unit", message: "missing required field" });
  }
  if (!("active" in obj)) {
    errors.push({ field: "active", message: "missing required field" });
  }
  if (!("commission" in obj)) {
    errors.push({ field: "commission", message: "missing required field" });
  }
  if (!("favorite" in obj)) {
    errors.push({ field: "favorite", message: "missing required field" });
  }
  if (!("averageTime" in obj)) {
    errors.push({ field: "averageTime", message: "missing required field" });
  }
  if (!("defaults" in obj)) {
    errors.push({ field: "defaults", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_name = obj["name"] as string;
    if (__raw_name.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
    instance.name = __raw_name;
  }
  {
    const __raw_quickCode = obj["quickCode"] as string;
    if (__raw_quickCode.length === 0) {
      errors.push({ field: "quickCode", message: "must not be empty" });
    }
    instance.quickCode = __raw_quickCode;
  }
  {
    const __raw_group = obj["group"] as string | null;
    if (__raw_group === null) {
      instance.group = null;
    } else if (typeof (__raw_group as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_group as any).__ref);
      ctx.assignOrDefer(instance, "group", __result);
    } else {
      instance.group = __raw_group;
    }
  }
  {
    const __raw_subgroup = obj["subgroup"] as string | null;
    if (__raw_subgroup === null) {
      instance.subgroup = null;
    } else if (typeof (__raw_subgroup as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_subgroup as any).__ref);
      ctx.assignOrDefer(instance, "subgroup", __result);
    } else {
      instance.subgroup = __raw_subgroup;
    }
  }
  {
    const __raw_unit = obj["unit"] as string | null;
    if (__raw_unit === null) {
      instance.unit = null;
    } else if (typeof (__raw_unit as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_unit as any).__ref);
      ctx.assignOrDefer(instance, "unit", __result);
    } else {
      instance.unit = __raw_unit;
    }
  }
  {
    const __raw_active = obj["active"] as boolean;
    instance.active = __raw_active;
  }
  {
    const __raw_commission = obj["commission"] as boolean;
    instance.commission = __raw_commission;
  }
  {
    const __raw_favorite = obj["favorite"] as boolean;
    instance.favorite = __raw_favorite;
  }
  {
    const __raw_averageTime = obj["averageTime"] as string | null;
    if (__raw_averageTime === null) {
      instance.averageTime = null;
    } else if (typeof (__raw_averageTime as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_averageTime as any).__ref);
      ctx.assignOrDefer(instance, "averageTime", __result);
    } else {
      instance.averageTime = __raw_averageTime;
    }
  }
  {
    const __raw_defaults = obj["defaults"] as ServiceDefaults;
    if (typeof (ServiceDefaults as any)?.__deserialize === "function") {
      const __result = (ServiceDefaults as any).__deserialize(
        __raw_defaults,
        ctx,
      );
      ctx.assignOrDefer(instance, "defaults", __result);
    } else {
      instance.defaults = __raw_defaults;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Service;
}
export function validateFieldService<K extends keyof Service>(
  field: K,
  value: Service[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "name": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
      break;
    }
    case "quickCode": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "quickCode", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsService(
  partial: Partial<Service>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("name" in partial && partial.name !== undefined) {
    const __val = partial.name as string;
    if (__val.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
  }
  if ("quickCode" in partial && partial.quickCode !== undefined) {
    const __val = partial.quickCode as string;
    if (__val.length === 0) {
      errors.push({ field: "quickCode", message: "must not be empty" });
    }
  }
  return errors;
}
export function isService(obj: unknown): obj is Service {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "id" in o &&
    "name" in o &&
    "quickCode" in o &&
    "group" in o &&
    "subgroup" in o &&
    "unit" in o &&
    "active" in o &&
    "commission" in o &&
    "favorite" in o &&
    "averageTime" in o &&
    "defaults" in o
  );
}

export namespace Service {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    name: Option<Array<string>>;
    quickCode: Option<Array<string>>;
    group: Option<Array<string>>;
    subgroup: Option<Array<string>>;
    unit: Option<Array<string>>;
    active: Option<Array<string>>;
    commission: Option<Array<string>>;
    favorite: Option<Array<string>>;
    averageTime: Option<Array<string>>;
    defaults: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      name: Option<boolean>;
      quickCode: Option<boolean>;
      group: Option<boolean>;
      subgroup: Option<boolean>;
      unit: Option<boolean>;
      active: Option<boolean>;
      commission: Option<boolean>;
      favorite: Option<boolean>;
      averageTime: Option<boolean>;
      defaults: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly name: FieldController<string>;
    readonly quickCode: FieldController<string>;
    readonly group: FieldController<string | null>;
    readonly subgroup: FieldController<string | null>;
    readonly unit: FieldController<string | null>;
    readonly active: FieldController<boolean>;
    readonly commission: FieldController<boolean>;
    readonly favorite: FieldController<boolean>;
    readonly averageTime: FieldController<string | null>;
    readonly defaults: FieldController<ServiceDefaults>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Service;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Service, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Service>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Service>,
  ): Gigaform {
    let data = $state({ ...Service.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      name: Option.none(),
      quickCode: Option.none(),
      group: Option.none(),
      subgroup: Option.none(),
      unit: Option.none(),
      active: Option.none(),
      commission: Option.none(),
      favorite: Option.none(),
      averageTime: Option.none(),
      defaults: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      name: Option.none(),
      quickCode: Option.none(),
      group: Option.none(),
      subgroup: Option.none(),
      unit: Option.none(),
      active: Option.none(),
      commission: Option.none(),
      favorite: Option.none(),
      averageTime: Option.none(),
      defaults: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Service.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },
        label: "Name",
        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Service.validateField("name", data.name);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      quickCode: {
        path: ["quickCode"] as const,
        name: "quickCode",
        constraints: { required: true },
        label: "Quick Code",
        get: () => data.quickCode,
        set: (value: string) => {
          data.quickCode = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.quickCode,
        setError: (value: Option<Array<string>>) => {
          errors.quickCode = value;
        },
        getTainted: () => tainted.quickCode,
        setTainted: (value: Option<boolean>) => {
          tainted.quickCode = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Service.validateField(
            "quickCode",
            data.quickCode,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      group: {
        path: ["group"] as const,
        name: "group",
        constraints: { required: true },
        label: "Group",
        get: () => data.group,
        set: (value: string | null) => {
          data.group = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.group,
        setError: (value: Option<Array<string>>) => {
          errors.group = value;
        },
        getTainted: () => tainted.group,
        setTainted: (value: Option<boolean>) => {
          tainted.group = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Service.validateField("group", data.group);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      subgroup: {
        path: ["subgroup"] as const,
        name: "subgroup",
        constraints: { required: true },
        label: "Subgroup",
        get: () => data.subgroup,
        set: (value: string | null) => {
          data.subgroup = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.subgroup,
        setError: (value: Option<Array<string>>) => {
          errors.subgroup = value;
        },
        getTainted: () => tainted.subgroup,
        setTainted: (value: Option<boolean>) => {
          tainted.subgroup = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Service.validateField("subgroup", data.subgroup);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      unit: {
        path: ["unit"] as const,
        name: "unit",
        constraints: { required: true },
        label: "Unit",
        get: () => data.unit,
        set: (value: string | null) => {
          data.unit = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.unit,
        setError: (value: Option<Array<string>>) => {
          errors.unit = value;
        },
        getTainted: () => tainted.unit,
        setTainted: (value: Option<boolean>) => {
          tainted.unit = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Service.validateField("unit", data.unit);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      active: {
        path: ["active"] as const,
        name: "active",
        constraints: { required: true },
        label: "Active",
        get: () => data.active,
        set: (value: boolean) => {
          data.active = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.active,
        setError: (value: Option<Array<string>>) => {
          errors.active = value;
        },
        getTainted: () => tainted.active,
        setTainted: (value: Option<boolean>) => {
          tainted.active = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Service.validateField("active", data.active);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      commission: {
        path: ["commission"] as const,
        name: "commission",
        constraints: { required: true },
        label: "Commission",
        get: () => data.commission,
        set: (value: boolean) => {
          data.commission = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.commission,
        setError: (value: Option<Array<string>>) => {
          errors.commission = value;
        },
        getTainted: () => tainted.commission,
        setTainted: (value: Option<boolean>) => {
          tainted.commission = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Service.validateField(
            "commission",
            data.commission,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      favorite: {
        path: ["favorite"] as const,
        name: "favorite",
        constraints: { required: true },
        label: "Favorite",
        get: () => data.favorite,
        set: (value: boolean) => {
          data.favorite = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.favorite,
        setError: (value: Option<Array<string>>) => {
          errors.favorite = value;
        },
        getTainted: () => tainted.favorite,
        setTainted: (value: Option<boolean>) => {
          tainted.favorite = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Service.validateField("favorite", data.favorite);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      averageTime: {
        path: ["averageTime"] as const,
        name: "averageTime",
        constraints: { required: true },
        label: "Average Time",
        get: () => data.averageTime,
        set: (value: string | null) => {
          data.averageTime = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.averageTime,
        setError: (value: Option<Array<string>>) => {
          errors.averageTime = value;
        },
        getTainted: () => tainted.averageTime,
        setTainted: (value: Option<boolean>) => {
          tainted.averageTime = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Service.validateField(
            "averageTime",
            data.averageTime,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      defaults: {
        path: ["defaults"] as const,
        name: "defaults",
        constraints: { required: true },

        get: () => data.defaults,
        set: (value: ServiceDefaults) => {
          data.defaults = value;
        },
        transform: (value: ServiceDefaults): ServiceDefaults => value,
        getError: () => errors.defaults,
        setError: (value: Option<Array<string>>) => {
          errors.defaults = value;
        },
        getTainted: () => tainted.defaults,
        setTainted: (value: Option<boolean>) => {
          tainted.defaults = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Service.validateField("defaults", data.defaults);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Service,
      Array<{ field: string; message: string }>
    > {
      return Service.fromObject(data);
    }
    function reset(newOverrides?: Partial<Service>): void {
      data = { ...Service.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        name: Option.none(),
        quickCode: Option.none(),
        group: Option.none(),
        subgroup: Option.none(),
        unit: Option.none(),
        active: Option.none(),
        commission: Option.none(),
        favorite: Option.none(),
        averageTime: Option.none(),
        defaults: Option.none(),
      };
      tainted = {
        id: Option.none(),
        name: Option.none(),
        quickCode: Option.none(),
        group: Option.none(),
        subgroup: Option.none(),
        unit: Option.none(),
        active: Option.none(),
        commission: Option.none(),
        favorite: Option.none(),
        averageTime: Option.none(),
        defaults: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Service, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.name = formData.get("name") ?? "";
    obj.quickCode = formData.get("quickCode") ?? "";
    obj.group = formData.get("group") ?? "";
    obj.subgroup = formData.get("subgroup") ?? "";
    obj.unit = formData.get("unit") ?? "";
    {
      const activeVal = formData.get("active");
      obj.active =
        activeVal === "true" || activeVal === "on" || activeVal === "1";
    }
    {
      const commissionVal = formData.get("commission");
      obj.commission =
        commissionVal === "true" ||
        commissionVal === "on" ||
        commissionVal === "1";
    }
    {
      const favoriteVal = formData.get("favorite");
      obj.favorite =
        favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1";
    }
    obj.averageTime = formData.get("averageTime") ?? "";
    {
      // Collect nested object fields with prefix "defaults."
      const defaultsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("defaults.")) {
          const fieldName = key.slice("defaults.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = defaultsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.defaults = defaultsObj;
    }
    return Service.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface ServiceDefaults {
  /** @numberController({ label: "Price", min: 0, step: 0.01 }) */
  price: number;
  /** @textAreaController({ label: "Description" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  description: string;
}

export function defaultValueServiceDefaults(): ServiceDefaults {
  return { price: 0, description: "" } as ServiceDefaults;
}

export function toStringifiedJSONServiceDefaults(
  value: ServiceDefaults,
): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeServiceDefaults(value, ctx));
}
export function toObjectServiceDefaults(
  value: ServiceDefaults,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeServiceDefaults(value, ctx);
}
export function __serializeServiceDefaults(
  value: ServiceDefaults,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "ServiceDefaults", __id };
  result["price"] = value.price;
  result["description"] = value.description;
  return result;
}

export function fromStringifiedJSONServiceDefaults(
  json: string,
  opts?: DeserializeOptions,
): Result<ServiceDefaults, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectServiceDefaults(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectServiceDefaults(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<ServiceDefaults, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeServiceDefaults(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "ServiceDefaults.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeServiceDefaults(
  value: any,
  ctx: DeserializeContext,
): ServiceDefaults | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "ServiceDefaults.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("price" in obj)) {
    errors.push({ field: "price", message: "missing required field" });
  }
  if (!("description" in obj)) {
    errors.push({ field: "description", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_price = obj["price"] as number;
    instance.price = __raw_price;
  }
  {
    const __raw_description = obj["description"] as string;
    if (__raw_description.length === 0) {
      errors.push({ field: "description", message: "must not be empty" });
    }
    instance.description = __raw_description;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as ServiceDefaults;
}
export function validateFieldServiceDefaults<K extends keyof ServiceDefaults>(
  field: K,
  value: ServiceDefaults[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "description": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "description", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsServiceDefaults(
  partial: Partial<ServiceDefaults>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("description" in partial && partial.description !== undefined) {
    const __val = partial.description as string;
    if (__val.length === 0) {
      errors.push({ field: "description", message: "must not be empty" });
    }
  }
  return errors;
}
export function isServiceDefaults(obj: unknown): obj is ServiceDefaults {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "price" in o && "description" in o;
}

export namespace ServiceDefaults {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    price: Option<Array<string>>;
    description: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { price: Option<boolean>; description: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly price: FieldController<number>;
    readonly description: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: ServiceDefaults;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      ServiceDefaults,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<ServiceDefaults>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<ServiceDefaults>,
  ): Gigaform {
    let data = $state({ ...ServiceDefaults.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      price: Option.none(),
      description: Option.none(),
    });
    let tainted = $state<Tainted>({
      price: Option.none(),
      description: Option.none(),
    });
    const fields: FieldControllers = {
      price: {
        path: ["price"] as const,
        name: "price",
        constraints: { required: true },
        label: "Price",
        get: () => data.price,
        set: (value: number) => {
          data.price = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.price,
        setError: (value: Option<Array<string>>) => {
          errors.price = value;
        },
        getTainted: () => tainted.price,
        setTainted: (value: Option<boolean>) => {
          tainted.price = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = ServiceDefaults.validateField(
            "price",
            data.price,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      description: {
        path: ["description"] as const,
        name: "description",
        constraints: { required: true },
        label: "Description",
        get: () => data.description,
        set: (value: string) => {
          data.description = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.description,
        setError: (value: Option<Array<string>>) => {
          errors.description = value;
        },
        getTainted: () => tainted.description,
        setTainted: (value: Option<boolean>) => {
          tainted.description = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = ServiceDefaults.validateField(
            "description",
            data.description,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      ServiceDefaults,
      Array<{ field: string; message: string }>
    > {
      return ServiceDefaults.fromObject(data);
    }
    function reset(newOverrides?: Partial<ServiceDefaults>): void {
      data = { ...ServiceDefaults.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        price: Option.none(),
        description: Option.none(),
      };
      tainted = { price: Option.none(), description: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<ServiceDefaults, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const priceStr = formData.get("price");
      obj.price = priceStr ? parseFloat(priceStr as string) : 0;
      if (obj.price !== undefined && isNaN(obj.price as number)) obj.price = 0;
    }
    obj.description = formData.get("description") ?? "";
    return ServiceDefaults.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Did {
  /** @default("") */
  in: string | Actor;
  /** @default("") */
  out: string | Target;
  id: string;
  activityType: ActivityType;
  createdAt: string;
  metadata: string | null;
}

export function defaultValueDid(): Did {
  return {
    in: "",
    out: "",
    id: "",
    activityType: ActivityType.defaultValue(),
    createdAt: "",
    metadata: null,
  } as Did;
}

export function toStringifiedJSONDid(value: Did): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeDid(value, ctx));
}
export function toObjectDid(value: Did): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeDid(value, ctx);
}
export function __serializeDid(
  value: Did,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Did", __id };
  result["in"] = value.in;
  result["out"] = value.out;
  result["id"] = value.id;
  result["activityType"] =
    typeof (value.activityType as any)?.__serialize === "function"
      ? (value.activityType as any).__serialize(ctx)
      : value.activityType;
  result["createdAt"] = value.createdAt;
  if (value.metadata !== null) {
    result["metadata"] =
      typeof (value.metadata as any)?.__serialize === "function"
        ? (value.metadata as any).__serialize(ctx)
        : value.metadata;
  } else {
    result["metadata"] = null;
  }
  return result;
}

export function fromStringifiedJSONDid(
  json: string,
  opts?: DeserializeOptions,
): Result<Did, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectDid(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectDid(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Did, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeDid(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Did.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeDid(
  value: any,
  ctx: DeserializeContext,
): Did | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Did.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("in" in obj)) {
    errors.push({ field: "in", message: "missing required field" });
  }
  if (!("out" in obj)) {
    errors.push({ field: "out", message: "missing required field" });
  }
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("activityType" in obj)) {
    errors.push({ field: "activityType", message: "missing required field" });
  }
  if (!("createdAt" in obj)) {
    errors.push({ field: "createdAt", message: "missing required field" });
  }
  if (!("metadata" in obj)) {
    errors.push({ field: "metadata", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_in = obj["in"] as string | Actor;
    instance.in = __raw_in;
  }
  {
    const __raw_out = obj["out"] as string | Target;
    instance.out = __raw_out;
  }
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_activityType = obj["activityType"] as ActivityType;
    if (typeof (ActivityType as any)?.__deserialize === "function") {
      const __result = (ActivityType as any).__deserialize(
        __raw_activityType,
        ctx,
      );
      ctx.assignOrDefer(instance, "activityType", __result);
    } else {
      instance.activityType = __raw_activityType;
    }
  }
  {
    const __raw_createdAt = obj["createdAt"] as string;
    instance.createdAt = __raw_createdAt;
  }
  {
    const __raw_metadata = obj["metadata"] as string | null;
    if (__raw_metadata === null) {
      instance.metadata = null;
    } else if (typeof (__raw_metadata as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_metadata as any).__ref);
      ctx.assignOrDefer(instance, "metadata", __result);
    } else {
      instance.metadata = __raw_metadata;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Did;
}
export function validateFieldDid<K extends keyof Did>(
  field: K,
  value: Did[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsDid(
  partial: Partial<Did>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isDid(obj: unknown): obj is Did {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "in" in o &&
    "out" in o &&
    "id" in o &&
    "activityType" in o &&
    "createdAt" in o &&
    "metadata" in o
  );
}

export namespace Did {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    in: Option<Array<string>>;
    out: Option<Array<string>>;
    id: Option<Array<string>>;
    activityType: Option<Array<string>>;
    createdAt: Option<Array<string>>;
    metadata: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      in: Option<boolean>;
      out: Option<boolean>;
      id: Option<boolean>;
      activityType: Option<boolean>;
      createdAt: Option<boolean>;
      metadata: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly in: FieldController<string | Actor>;
    readonly out: FieldController<string | Target>;
    readonly id: FieldController<string>;
    readonly activityType: FieldController<ActivityType>;
    readonly createdAt: FieldController<string>;
    readonly metadata: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Did;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Did, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Did>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Did>,
  ): Gigaform {
    let data = $state({ ...Did.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      in: Option.none(),
      out: Option.none(),
      id: Option.none(),
      activityType: Option.none(),
      createdAt: Option.none(),
      metadata: Option.none(),
    });
    let tainted = $state<Tainted>({
      in: Option.none(),
      out: Option.none(),
      id: Option.none(),
      activityType: Option.none(),
      createdAt: Option.none(),
      metadata: Option.none(),
    });
    const fields: FieldControllers = {
      in: {
        path: ["in"] as const,
        name: "in",
        constraints: { required: true },

        get: () => data.in,
        set: (value: string | Actor) => {
          data.in = value;
        },
        transform: (value: string | Actor): string | Actor => value,
        getError: () => errors.in,
        setError: (value: Option<Array<string>>) => {
          errors.in = value;
        },
        getTainted: () => tainted.in,
        setTainted: (value: Option<boolean>) => {
          tainted.in = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Did.validateField("in", data.in);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      out: {
        path: ["out"] as const,
        name: "out",
        constraints: { required: true },

        get: () => data.out,
        set: (value: string | Target) => {
          data.out = value;
        },
        transform: (value: string | Target): string | Target => value,
        getError: () => errors.out,
        setError: (value: Option<Array<string>>) => {
          errors.out = value;
        },
        getTainted: () => tainted.out,
        setTainted: (value: Option<boolean>) => {
          tainted.out = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Did.validateField("out", data.out);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Did.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      activityType: {
        path: ["activityType"] as const,
        name: "activityType",
        constraints: { required: true },

        get: () => data.activityType,
        set: (value: ActivityType) => {
          data.activityType = value;
        },
        transform: (value: ActivityType): ActivityType => value,
        getError: () => errors.activityType,
        setError: (value: Option<Array<string>>) => {
          errors.activityType = value;
        },
        getTainted: () => tainted.activityType,
        setTainted: (value: Option<boolean>) => {
          tainted.activityType = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Did.validateField(
            "activityType",
            data.activityType,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      createdAt: {
        path: ["createdAt"] as const,
        name: "createdAt",
        constraints: { required: true },

        get: () => data.createdAt,
        set: (value: string) => {
          data.createdAt = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.createdAt,
        setError: (value: Option<Array<string>>) => {
          errors.createdAt = value;
        },
        getTainted: () => tainted.createdAt,
        setTainted: (value: Option<boolean>) => {
          tainted.createdAt = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Did.validateField("createdAt", data.createdAt);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      metadata: {
        path: ["metadata"] as const,
        name: "metadata",
        constraints: { required: true },

        get: () => data.metadata,
        set: (value: string | null) => {
          data.metadata = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.metadata,
        setError: (value: Option<Array<string>>) => {
          errors.metadata = value;
        },
        getTainted: () => tainted.metadata,
        setTainted: (value: Option<boolean>) => {
          tainted.metadata = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Did.validateField("metadata", data.metadata);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Did,
      Array<{ field: string; message: string }>
    > {
      return Did.fromObject(data);
    }
    function reset(newOverrides?: Partial<Did>): void {
      data = { ...Did.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        in: Option.none(),
        out: Option.none(),
        id: Option.none(),
        activityType: Option.none(),
        createdAt: Option.none(),
        metadata: Option.none(),
      };
      tainted = {
        in: Option.none(),
        out: Option.none(),
        id: Option.none(),
        activityType: Option.none(),
        createdAt: Option.none(),
        metadata: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Did, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.in = formData.get("in") ?? "";
    obj.out = formData.get("out") ?? "";
    obj.id = formData.get("id") ?? "";
    {
      // Collect nested object fields with prefix "activityType."
      const activityTypeObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("activityType.")) {
          const fieldName = key.slice("activityType.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = activityTypeObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.activityType = activityTypeObj;
    }
    obj.createdAt = formData.get("createdAt") ?? "";
    obj.metadata = formData.get("metadata") ?? "";
    return Did.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface PersonName {
  /** @textController({ label: "First Name" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  firstName: string;
  /** @textController({ label: "Last Name" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  lastName: string;
}

export function defaultValuePersonName(): PersonName {
  return { firstName: "", lastName: "" } as PersonName;
}

export function toStringifiedJSONPersonName(value: PersonName): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializePersonName(value, ctx));
}
export function toObjectPersonName(value: PersonName): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializePersonName(value, ctx);
}
export function __serializePersonName(
  value: PersonName,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "PersonName", __id };
  result["firstName"] = value.firstName;
  result["lastName"] = value.lastName;
  return result;
}

export function fromStringifiedJSONPersonName(
  json: string,
  opts?: DeserializeOptions,
): Result<PersonName, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectPersonName(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectPersonName(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<PersonName, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializePersonName(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "PersonName.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializePersonName(
  value: any,
  ctx: DeserializeContext,
): PersonName | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "PersonName.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("firstName" in obj)) {
    errors.push({ field: "firstName", message: "missing required field" });
  }
  if (!("lastName" in obj)) {
    errors.push({ field: "lastName", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_firstName = obj["firstName"] as string;
    if (__raw_firstName.length === 0) {
      errors.push({ field: "firstName", message: "must not be empty" });
    }
    instance.firstName = __raw_firstName;
  }
  {
    const __raw_lastName = obj["lastName"] as string;
    if (__raw_lastName.length === 0) {
      errors.push({ field: "lastName", message: "must not be empty" });
    }
    instance.lastName = __raw_lastName;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as PersonName;
}
export function validateFieldPersonName<K extends keyof PersonName>(
  field: K,
  value: PersonName[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "firstName": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "firstName", message: "must not be empty" });
      }
      break;
    }
    case "lastName": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "lastName", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsPersonName(
  partial: Partial<PersonName>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("firstName" in partial && partial.firstName !== undefined) {
    const __val = partial.firstName as string;
    if (__val.length === 0) {
      errors.push({ field: "firstName", message: "must not be empty" });
    }
  }
  if ("lastName" in partial && partial.lastName !== undefined) {
    const __val = partial.lastName as string;
    if (__val.length === 0) {
      errors.push({ field: "lastName", message: "must not be empty" });
    }
  }
  return errors;
}
export function isPersonName(obj: unknown): obj is PersonName {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "firstName" in o && "lastName" in o;
}

export namespace PersonName {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    firstName: Option<Array<string>>;
    lastName: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { firstName: Option<boolean>; lastName: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly firstName: FieldController<string>;
    readonly lastName: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: PersonName;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<PersonName, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<PersonName>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<PersonName>,
  ): Gigaform {
    let data = $state({ ...PersonName.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      firstName: Option.none(),
      lastName: Option.none(),
    });
    let tainted = $state<Tainted>({
      firstName: Option.none(),
      lastName: Option.none(),
    });
    const fields: FieldControllers = {
      firstName: {
        path: ["firstName"] as const,
        name: "firstName",
        constraints: { required: true },
        label: "First Name",
        get: () => data.firstName,
        set: (value: string) => {
          data.firstName = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.firstName,
        setError: (value: Option<Array<string>>) => {
          errors.firstName = value;
        },
        getTainted: () => tainted.firstName,
        setTainted: (value: Option<boolean>) => {
          tainted.firstName = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = PersonName.validateField(
            "firstName",
            data.firstName,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      lastName: {
        path: ["lastName"] as const,
        name: "lastName",
        constraints: { required: true },
        label: "Last Name",
        get: () => data.lastName,
        set: (value: string) => {
          data.lastName = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.lastName,
        setError: (value: Option<Array<string>>) => {
          errors.lastName = value;
        },
        getTainted: () => tainted.lastName,
        setTainted: (value: Option<boolean>) => {
          tainted.lastName = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = PersonName.validateField(
            "lastName",
            data.lastName,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      PersonName,
      Array<{ field: string; message: string }>
    > {
      return PersonName.fromObject(data);
    }
    function reset(newOverrides?: Partial<PersonName>): void {
      data = { ...PersonName.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        firstName: Option.none(),
        lastName: Option.none(),
      };
      tainted = { firstName: Option.none(), lastName: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<PersonName, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.firstName = formData.get("firstName") ?? "";
    obj.lastName = formData.get("lastName") ?? "";
    return PersonName.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Promotion {
  id: string;
  date: string;
}

export function defaultValuePromotion(): Promotion {
  return { id: "", date: "" } as Promotion;
}

export function toStringifiedJSONPromotion(value: Promotion): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializePromotion(value, ctx));
}
export function toObjectPromotion(value: Promotion): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializePromotion(value, ctx);
}
export function __serializePromotion(
  value: Promotion,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Promotion", __id };
  result["id"] = value.id;
  result["date"] = value.date;
  return result;
}

export function fromStringifiedJSONPromotion(
  json: string,
  opts?: DeserializeOptions,
): Result<Promotion, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectPromotion(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectPromotion(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Promotion, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializePromotion(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Promotion.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializePromotion(
  value: any,
  ctx: DeserializeContext,
): Promotion | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "Promotion.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("date" in obj)) {
    errors.push({ field: "date", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_date = obj["date"] as string;
    instance.date = __raw_date;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Promotion;
}
export function validateFieldPromotion<K extends keyof Promotion>(
  field: K,
  value: Promotion[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsPromotion(
  partial: Partial<Promotion>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isPromotion(obj: unknown): obj is Promotion {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "id" in o && "date" in o;
}

export namespace Promotion {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    date: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { id: Option<boolean>; date: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly date: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Promotion;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Promotion, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Promotion>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Promotion>,
  ): Gigaform {
    let data = $state({ ...Promotion.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      date: Option.none(),
    });
    let tainted = $state<Tainted>({ id: Option.none(), date: Option.none() });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Promotion.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      date: {
        path: ["date"] as const,
        name: "date",
        constraints: { required: true },

        get: () => data.date,
        set: (value: string) => {
          data.date = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.date,
        setError: (value: Option<Array<string>>) => {
          errors.date = value;
        },
        getTainted: () => tainted.date,
        setTainted: (value: Option<boolean>) => {
          tainted.date = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Promotion.validateField("date", data.date);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Promotion,
      Array<{ field: string; message: string }>
    > {
      return Promotion.fromObject(data);
    }
    function reset(newOverrides?: Partial<Promotion>): void {
      data = { ...Promotion.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        date: Option.none(),
      };
      tainted = { id: Option.none(), date: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Promotion, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.date = formData.get("date") ?? "";
    return Promotion.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Site {
  id: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  addressLine1: string;
  addressLine2: string | null;
  sublocalityLevel1: string | null;
  /** @serde({ validate: ["nonEmpty"] }) */
  locality: string;
  administrativeAreaLevel3: string | null;
  administrativeAreaLevel2: string | null;
  /** @serde({ validate: ["nonEmpty"] }) */
  administrativeAreaLevel1: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  country: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  postalCode: string;
  postalCodeSuffix: string | null;
  coordinates: Coordinates;
}

export function defaultValueSite(): Site {
  return {
    id: "",
    addressLine1: "",
    addressLine2: null,
    sublocalityLevel1: null,
    locality: "",
    administrativeAreaLevel3: null,
    administrativeAreaLevel2: null,
    administrativeAreaLevel1: "",
    country: "",
    postalCode: "",
    postalCodeSuffix: null,
    coordinates: Coordinates.defaultValue(),
  } as Site;
}

export function toStringifiedJSONSite(value: Site): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeSite(value, ctx));
}
export function toObjectSite(value: Site): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeSite(value, ctx);
}
export function __serializeSite(
  value: Site,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Site", __id };
  result["id"] = value.id;
  result["addressLine1"] = value.addressLine1;
  if (value.addressLine2 !== null) {
    result["addressLine2"] =
      typeof (value.addressLine2 as any)?.__serialize === "function"
        ? (value.addressLine2 as any).__serialize(ctx)
        : value.addressLine2;
  } else {
    result["addressLine2"] = null;
  }
  if (value.sublocalityLevel1 !== null) {
    result["sublocalityLevel1"] =
      typeof (value.sublocalityLevel1 as any)?.__serialize === "function"
        ? (value.sublocalityLevel1 as any).__serialize(ctx)
        : value.sublocalityLevel1;
  } else {
    result["sublocalityLevel1"] = null;
  }
  result["locality"] = value.locality;
  if (value.administrativeAreaLevel3 !== null) {
    result["administrativeAreaLevel3"] =
      typeof (value.administrativeAreaLevel3 as any)?.__serialize === "function"
        ? (value.administrativeAreaLevel3 as any).__serialize(ctx)
        : value.administrativeAreaLevel3;
  } else {
    result["administrativeAreaLevel3"] = null;
  }
  if (value.administrativeAreaLevel2 !== null) {
    result["administrativeAreaLevel2"] =
      typeof (value.administrativeAreaLevel2 as any)?.__serialize === "function"
        ? (value.administrativeAreaLevel2 as any).__serialize(ctx)
        : value.administrativeAreaLevel2;
  } else {
    result["administrativeAreaLevel2"] = null;
  }
  result["administrativeAreaLevel1"] = value.administrativeAreaLevel1;
  result["country"] = value.country;
  result["postalCode"] = value.postalCode;
  if (value.postalCodeSuffix !== null) {
    result["postalCodeSuffix"] =
      typeof (value.postalCodeSuffix as any)?.__serialize === "function"
        ? (value.postalCodeSuffix as any).__serialize(ctx)
        : value.postalCodeSuffix;
  } else {
    result["postalCodeSuffix"] = null;
  }
  result["coordinates"] =
    typeof (value.coordinates as any)?.__serialize === "function"
      ? (value.coordinates as any).__serialize(ctx)
      : value.coordinates;
  return result;
}

export function fromStringifiedJSONSite(
  json: string,
  opts?: DeserializeOptions,
): Result<Site, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectSite(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectSite(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Site, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeSite(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Site.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeSite(
  value: any,
  ctx: DeserializeContext,
): Site | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Site.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("addressLine1" in obj)) {
    errors.push({ field: "addressLine1", message: "missing required field" });
  }
  if (!("addressLine2" in obj)) {
    errors.push({ field: "addressLine2", message: "missing required field" });
  }
  if (!("sublocalityLevel1" in obj)) {
    errors.push({
      field: "sublocalityLevel1",
      message: "missing required field",
    });
  }
  if (!("locality" in obj)) {
    errors.push({ field: "locality", message: "missing required field" });
  }
  if (!("administrativeAreaLevel3" in obj)) {
    errors.push({
      field: "administrativeAreaLevel3",
      message: "missing required field",
    });
  }
  if (!("administrativeAreaLevel2" in obj)) {
    errors.push({
      field: "administrativeAreaLevel2",
      message: "missing required field",
    });
  }
  if (!("administrativeAreaLevel1" in obj)) {
    errors.push({
      field: "administrativeAreaLevel1",
      message: "missing required field",
    });
  }
  if (!("country" in obj)) {
    errors.push({ field: "country", message: "missing required field" });
  }
  if (!("postalCode" in obj)) {
    errors.push({ field: "postalCode", message: "missing required field" });
  }
  if (!("postalCodeSuffix" in obj)) {
    errors.push({
      field: "postalCodeSuffix",
      message: "missing required field",
    });
  }
  if (!("coordinates" in obj)) {
    errors.push({ field: "coordinates", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_addressLine1 = obj["addressLine1"] as string;
    if (__raw_addressLine1.length === 0) {
      errors.push({ field: "addressLine1", message: "must not be empty" });
    }
    instance.addressLine1 = __raw_addressLine1;
  }
  {
    const __raw_addressLine2 = obj["addressLine2"] as string | null;
    if (__raw_addressLine2 === null) {
      instance.addressLine2 = null;
    } else if (typeof (__raw_addressLine2 as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_addressLine2 as any).__ref);
      ctx.assignOrDefer(instance, "addressLine2", __result);
    } else {
      instance.addressLine2 = __raw_addressLine2;
    }
  }
  {
    const __raw_sublocalityLevel1 = obj["sublocalityLevel1"] as string | null;
    if (__raw_sublocalityLevel1 === null) {
      instance.sublocalityLevel1 = null;
    } else if (typeof (__raw_sublocalityLevel1 as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_sublocalityLevel1 as any).__ref);
      ctx.assignOrDefer(instance, "sublocalityLevel1", __result);
    } else {
      instance.sublocalityLevel1 = __raw_sublocalityLevel1;
    }
  }
  {
    const __raw_locality = obj["locality"] as string;
    if (__raw_locality.length === 0) {
      errors.push({ field: "locality", message: "must not be empty" });
    }
    instance.locality = __raw_locality;
  }
  {
    const __raw_administrativeAreaLevel3 = obj["administrativeAreaLevel3"] as
      | string
      | null;
    if (__raw_administrativeAreaLevel3 === null) {
      instance.administrativeAreaLevel3 = null;
    } else if (
      typeof (__raw_administrativeAreaLevel3 as any)?.__ref !== "undefined"
    ) {
      const __result = ctx.getOrDefer(
        (__raw_administrativeAreaLevel3 as any).__ref,
      );
      ctx.assignOrDefer(instance, "administrativeAreaLevel3", __result);
    } else {
      instance.administrativeAreaLevel3 = __raw_administrativeAreaLevel3;
    }
  }
  {
    const __raw_administrativeAreaLevel2 = obj["administrativeAreaLevel2"] as
      | string
      | null;
    if (__raw_administrativeAreaLevel2 === null) {
      instance.administrativeAreaLevel2 = null;
    } else if (
      typeof (__raw_administrativeAreaLevel2 as any)?.__ref !== "undefined"
    ) {
      const __result = ctx.getOrDefer(
        (__raw_administrativeAreaLevel2 as any).__ref,
      );
      ctx.assignOrDefer(instance, "administrativeAreaLevel2", __result);
    } else {
      instance.administrativeAreaLevel2 = __raw_administrativeAreaLevel2;
    }
  }
  {
    const __raw_administrativeAreaLevel1 = obj[
      "administrativeAreaLevel1"
    ] as string;
    if (__raw_administrativeAreaLevel1.length === 0) {
      errors.push({
        field: "administrativeAreaLevel1",
        message: "must not be empty",
      });
    }
    instance.administrativeAreaLevel1 = __raw_administrativeAreaLevel1;
  }
  {
    const __raw_country = obj["country"] as string;
    if (__raw_country.length === 0) {
      errors.push({ field: "country", message: "must not be empty" });
    }
    instance.country = __raw_country;
  }
  {
    const __raw_postalCode = obj["postalCode"] as string;
    if (__raw_postalCode.length === 0) {
      errors.push({ field: "postalCode", message: "must not be empty" });
    }
    instance.postalCode = __raw_postalCode;
  }
  {
    const __raw_postalCodeSuffix = obj["postalCodeSuffix"] as string | null;
    if (__raw_postalCodeSuffix === null) {
      instance.postalCodeSuffix = null;
    } else if (typeof (__raw_postalCodeSuffix as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_postalCodeSuffix as any).__ref);
      ctx.assignOrDefer(instance, "postalCodeSuffix", __result);
    } else {
      instance.postalCodeSuffix = __raw_postalCodeSuffix;
    }
  }
  {
    const __raw_coordinates = obj["coordinates"] as Coordinates;
    if (typeof (Coordinates as any)?.__deserialize === "function") {
      const __result = (Coordinates as any).__deserialize(
        __raw_coordinates,
        ctx,
      );
      ctx.assignOrDefer(instance, "coordinates", __result);
    } else {
      instance.coordinates = __raw_coordinates;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Site;
}
export function validateFieldSite<K extends keyof Site>(
  field: K,
  value: Site[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "addressLine1": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "addressLine1", message: "must not be empty" });
      }
      break;
    }
    case "locality": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "locality", message: "must not be empty" });
      }
      break;
    }
    case "administrativeAreaLevel1": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({
          field: "administrativeAreaLevel1",
          message: "must not be empty",
        });
      }
      break;
    }
    case "country": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "country", message: "must not be empty" });
      }
      break;
    }
    case "postalCode": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "postalCode", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsSite(
  partial: Partial<Site>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("addressLine1" in partial && partial.addressLine1 !== undefined) {
    const __val = partial.addressLine1 as string;
    if (__val.length === 0) {
      errors.push({ field: "addressLine1", message: "must not be empty" });
    }
  }
  if ("locality" in partial && partial.locality !== undefined) {
    const __val = partial.locality as string;
    if (__val.length === 0) {
      errors.push({ field: "locality", message: "must not be empty" });
    }
  }
  if (
    "administrativeAreaLevel1" in partial &&
    partial.administrativeAreaLevel1 !== undefined
  ) {
    const __val = partial.administrativeAreaLevel1 as string;
    if (__val.length === 0) {
      errors.push({
        field: "administrativeAreaLevel1",
        message: "must not be empty",
      });
    }
  }
  if ("country" in partial && partial.country !== undefined) {
    const __val = partial.country as string;
    if (__val.length === 0) {
      errors.push({ field: "country", message: "must not be empty" });
    }
  }
  if ("postalCode" in partial && partial.postalCode !== undefined) {
    const __val = partial.postalCode as string;
    if (__val.length === 0) {
      errors.push({ field: "postalCode", message: "must not be empty" });
    }
  }
  return errors;
}
export function isSite(obj: unknown): obj is Site {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "id" in o &&
    "addressLine1" in o &&
    "addressLine2" in o &&
    "sublocalityLevel1" in o &&
    "locality" in o &&
    "administrativeAreaLevel3" in o &&
    "administrativeAreaLevel2" in o &&
    "administrativeAreaLevel1" in o &&
    "country" in o &&
    "postalCode" in o &&
    "postalCodeSuffix" in o &&
    "coordinates" in o
  );
}

export namespace Site {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    addressLine1: Option<Array<string>>;
    addressLine2: Option<Array<string>>;
    sublocalityLevel1: Option<Array<string>>;
    locality: Option<Array<string>>;
    administrativeAreaLevel3: Option<Array<string>>;
    administrativeAreaLevel2: Option<Array<string>>;
    administrativeAreaLevel1: Option<Array<string>>;
    country: Option<Array<string>>;
    postalCode: Option<Array<string>>;
    postalCodeSuffix: Option<Array<string>>;
    coordinates: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      addressLine1: Option<boolean>;
      addressLine2: Option<boolean>;
      sublocalityLevel1: Option<boolean>;
      locality: Option<boolean>;
      administrativeAreaLevel3: Option<boolean>;
      administrativeAreaLevel2: Option<boolean>;
      administrativeAreaLevel1: Option<boolean>;
      country: Option<boolean>;
      postalCode: Option<boolean>;
      postalCodeSuffix: Option<boolean>;
      coordinates: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly addressLine1: FieldController<string>;
    readonly addressLine2: FieldController<string | null>;
    readonly sublocalityLevel1: FieldController<string | null>;
    readonly locality: FieldController<string>;
    readonly administrativeAreaLevel3: FieldController<string | null>;
    readonly administrativeAreaLevel2: FieldController<string | null>;
    readonly administrativeAreaLevel1: FieldController<string>;
    readonly country: FieldController<string>;
    readonly postalCode: FieldController<string>;
    readonly postalCodeSuffix: FieldController<string | null>;
    readonly coordinates: FieldController<Coordinates>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Site;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Site, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Site>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Site>,
  ): Gigaform {
    let data = $state({ ...Site.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      addressLine1: Option.none(),
      addressLine2: Option.none(),
      sublocalityLevel1: Option.none(),
      locality: Option.none(),
      administrativeAreaLevel3: Option.none(),
      administrativeAreaLevel2: Option.none(),
      administrativeAreaLevel1: Option.none(),
      country: Option.none(),
      postalCode: Option.none(),
      postalCodeSuffix: Option.none(),
      coordinates: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      addressLine1: Option.none(),
      addressLine2: Option.none(),
      sublocalityLevel1: Option.none(),
      locality: Option.none(),
      administrativeAreaLevel3: Option.none(),
      administrativeAreaLevel2: Option.none(),
      administrativeAreaLevel1: Option.none(),
      country: Option.none(),
      postalCode: Option.none(),
      postalCodeSuffix: Option.none(),
      coordinates: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Site.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      addressLine1: {
        path: ["addressLine1"] as const,
        name: "addressLine1",
        constraints: { required: true },

        get: () => data.addressLine1,
        set: (value: string) => {
          data.addressLine1 = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.addressLine1,
        setError: (value: Option<Array<string>>) => {
          errors.addressLine1 = value;
        },
        getTainted: () => tainted.addressLine1,
        setTainted: (value: Option<boolean>) => {
          tainted.addressLine1 = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Site.validateField(
            "addressLine1",
            data.addressLine1,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      addressLine2: {
        path: ["addressLine2"] as const,
        name: "addressLine2",
        constraints: { required: true },

        get: () => data.addressLine2,
        set: (value: string | null) => {
          data.addressLine2 = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.addressLine2,
        setError: (value: Option<Array<string>>) => {
          errors.addressLine2 = value;
        },
        getTainted: () => tainted.addressLine2,
        setTainted: (value: Option<boolean>) => {
          tainted.addressLine2 = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Site.validateField(
            "addressLine2",
            data.addressLine2,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      sublocalityLevel1: {
        path: ["sublocalityLevel1"] as const,
        name: "sublocalityLevel1",
        constraints: { required: true },

        get: () => data.sublocalityLevel1,
        set: (value: string | null) => {
          data.sublocalityLevel1 = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.sublocalityLevel1,
        setError: (value: Option<Array<string>>) => {
          errors.sublocalityLevel1 = value;
        },
        getTainted: () => tainted.sublocalityLevel1,
        setTainted: (value: Option<boolean>) => {
          tainted.sublocalityLevel1 = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Site.validateField(
            "sublocalityLevel1",
            data.sublocalityLevel1,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      locality: {
        path: ["locality"] as const,
        name: "locality",
        constraints: { required: true },

        get: () => data.locality,
        set: (value: string) => {
          data.locality = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.locality,
        setError: (value: Option<Array<string>>) => {
          errors.locality = value;
        },
        getTainted: () => tainted.locality,
        setTainted: (value: Option<boolean>) => {
          tainted.locality = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Site.validateField("locality", data.locality);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      administrativeAreaLevel3: {
        path: ["administrativeAreaLevel3"] as const,
        name: "administrativeAreaLevel3",
        constraints: { required: true },

        get: () => data.administrativeAreaLevel3,
        set: (value: string | null) => {
          data.administrativeAreaLevel3 = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.administrativeAreaLevel3,
        setError: (value: Option<Array<string>>) => {
          errors.administrativeAreaLevel3 = value;
        },
        getTainted: () => tainted.administrativeAreaLevel3,
        setTainted: (value: Option<boolean>) => {
          tainted.administrativeAreaLevel3 = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Site.validateField(
            "administrativeAreaLevel3",
            data.administrativeAreaLevel3,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      administrativeAreaLevel2: {
        path: ["administrativeAreaLevel2"] as const,
        name: "administrativeAreaLevel2",
        constraints: { required: true },

        get: () => data.administrativeAreaLevel2,
        set: (value: string | null) => {
          data.administrativeAreaLevel2 = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.administrativeAreaLevel2,
        setError: (value: Option<Array<string>>) => {
          errors.administrativeAreaLevel2 = value;
        },
        getTainted: () => tainted.administrativeAreaLevel2,
        setTainted: (value: Option<boolean>) => {
          tainted.administrativeAreaLevel2 = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Site.validateField(
            "administrativeAreaLevel2",
            data.administrativeAreaLevel2,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      administrativeAreaLevel1: {
        path: ["administrativeAreaLevel1"] as const,
        name: "administrativeAreaLevel1",
        constraints: { required: true },

        get: () => data.administrativeAreaLevel1,
        set: (value: string) => {
          data.administrativeAreaLevel1 = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.administrativeAreaLevel1,
        setError: (value: Option<Array<string>>) => {
          errors.administrativeAreaLevel1 = value;
        },
        getTainted: () => tainted.administrativeAreaLevel1,
        setTainted: (value: Option<boolean>) => {
          tainted.administrativeAreaLevel1 = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Site.validateField(
            "administrativeAreaLevel1",
            data.administrativeAreaLevel1,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      country: {
        path: ["country"] as const,
        name: "country",
        constraints: { required: true },

        get: () => data.country,
        set: (value: string) => {
          data.country = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.country,
        setError: (value: Option<Array<string>>) => {
          errors.country = value;
        },
        getTainted: () => tainted.country,
        setTainted: (value: Option<boolean>) => {
          tainted.country = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Site.validateField("country", data.country);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      postalCode: {
        path: ["postalCode"] as const,
        name: "postalCode",
        constraints: { required: true },

        get: () => data.postalCode,
        set: (value: string) => {
          data.postalCode = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.postalCode,
        setError: (value: Option<Array<string>>) => {
          errors.postalCode = value;
        },
        getTainted: () => tainted.postalCode,
        setTainted: (value: Option<boolean>) => {
          tainted.postalCode = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Site.validateField("postalCode", data.postalCode);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      postalCodeSuffix: {
        path: ["postalCodeSuffix"] as const,
        name: "postalCodeSuffix",
        constraints: { required: true },

        get: () => data.postalCodeSuffix,
        set: (value: string | null) => {
          data.postalCodeSuffix = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.postalCodeSuffix,
        setError: (value: Option<Array<string>>) => {
          errors.postalCodeSuffix = value;
        },
        getTainted: () => tainted.postalCodeSuffix,
        setTainted: (value: Option<boolean>) => {
          tainted.postalCodeSuffix = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Site.validateField(
            "postalCodeSuffix",
            data.postalCodeSuffix,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      coordinates: {
        path: ["coordinates"] as const,
        name: "coordinates",
        constraints: { required: true },

        get: () => data.coordinates,
        set: (value: Coordinates) => {
          data.coordinates = value;
        },
        transform: (value: Coordinates): Coordinates => value,
        getError: () => errors.coordinates,
        setError: (value: Option<Array<string>>) => {
          errors.coordinates = value;
        },
        getTainted: () => tainted.coordinates,
        setTainted: (value: Option<boolean>) => {
          tainted.coordinates = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Site.validateField(
            "coordinates",
            data.coordinates,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Site,
      Array<{ field: string; message: string }>
    > {
      return Site.fromObject(data);
    }
    function reset(newOverrides?: Partial<Site>): void {
      data = { ...Site.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        addressLine1: Option.none(),
        addressLine2: Option.none(),
        sublocalityLevel1: Option.none(),
        locality: Option.none(),
        administrativeAreaLevel3: Option.none(),
        administrativeAreaLevel2: Option.none(),
        administrativeAreaLevel1: Option.none(),
        country: Option.none(),
        postalCode: Option.none(),
        postalCodeSuffix: Option.none(),
        coordinates: Option.none(),
      };
      tainted = {
        id: Option.none(),
        addressLine1: Option.none(),
        addressLine2: Option.none(),
        sublocalityLevel1: Option.none(),
        locality: Option.none(),
        administrativeAreaLevel3: Option.none(),
        administrativeAreaLevel2: Option.none(),
        administrativeAreaLevel1: Option.none(),
        country: Option.none(),
        postalCode: Option.none(),
        postalCodeSuffix: Option.none(),
        coordinates: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Site, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.addressLine1 = formData.get("addressLine1") ?? "";
    obj.addressLine2 = formData.get("addressLine2") ?? "";
    obj.sublocalityLevel1 = formData.get("sublocalityLevel1") ?? "";
    obj.locality = formData.get("locality") ?? "";
    obj.administrativeAreaLevel3 =
      formData.get("administrativeAreaLevel3") ?? "";
    obj.administrativeAreaLevel2 =
      formData.get("administrativeAreaLevel2") ?? "";
    obj.administrativeAreaLevel1 =
      formData.get("administrativeAreaLevel1") ?? "";
    obj.country = formData.get("country") ?? "";
    obj.postalCode = formData.get("postalCode") ?? "";
    obj.postalCodeSuffix = formData.get("postalCodeSuffix") ?? "";
    {
      // Collect nested object fields with prefix "coordinates."
      const coordinatesObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("coordinates.")) {
          const fieldName = key.slice("coordinates.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = coordinatesObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.coordinates = coordinatesObj;
    }
    return Site.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Metadata {
  createdAt: string;
  lastLogin: string | null;
  isActive: boolean;
  roles: string[];
}

export function defaultValueMetadata(): Metadata {
  return {
    createdAt: "",
    lastLogin: null,
    isActive: false,
    roles: [],
  } as Metadata;
}

export function toStringifiedJSONMetadata(value: Metadata): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeMetadata(value, ctx));
}
export function toObjectMetadata(value: Metadata): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeMetadata(value, ctx);
}
export function __serializeMetadata(
  value: Metadata,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Metadata", __id };
  result["createdAt"] = value.createdAt;
  if (value.lastLogin !== null) {
    result["lastLogin"] =
      typeof (value.lastLogin as any)?.__serialize === "function"
        ? (value.lastLogin as any).__serialize(ctx)
        : value.lastLogin;
  } else {
    result["lastLogin"] = null;
  }
  result["isActive"] = value.isActive;
  result["roles"] = value.roles.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  return result;
}

export function fromStringifiedJSONMetadata(
  json: string,
  opts?: DeserializeOptions,
): Result<Metadata, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectMetadata(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectMetadata(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Metadata, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeMetadata(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Metadata.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeMetadata(
  value: any,
  ctx: DeserializeContext,
): Metadata | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Metadata.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("createdAt" in obj)) {
    errors.push({ field: "createdAt", message: "missing required field" });
  }
  if (!("lastLogin" in obj)) {
    errors.push({ field: "lastLogin", message: "missing required field" });
  }
  if (!("isActive" in obj)) {
    errors.push({ field: "isActive", message: "missing required field" });
  }
  if (!("roles" in obj)) {
    errors.push({ field: "roles", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_createdAt = obj["createdAt"] as string;
    instance.createdAt = __raw_createdAt;
  }
  {
    const __raw_lastLogin = obj["lastLogin"] as string | null;
    if (__raw_lastLogin === null) {
      instance.lastLogin = null;
    } else if (typeof (__raw_lastLogin as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_lastLogin as any).__ref);
      ctx.assignOrDefer(instance, "lastLogin", __result);
    } else {
      instance.lastLogin = __raw_lastLogin;
    }
  }
  {
    const __raw_isActive = obj["isActive"] as boolean;
    instance.isActive = __raw_isActive;
  }
  {
    const __raw_roles = obj["roles"] as string[];
    if (Array.isArray(__raw_roles)) {
      instance.roles = __raw_roles as string[];
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Metadata;
}
export function validateFieldMetadata<K extends keyof Metadata>(
  field: K,
  value: Metadata[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsMetadata(
  partial: Partial<Metadata>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isMetadata(obj: unknown): obj is Metadata {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "createdAt" in o && "lastLogin" in o && "isActive" in o && "roles" in o
  );
}

export namespace Metadata {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    createdAt: Option<Array<string>>;
    lastLogin: Option<Array<string>>;
    isActive: Option<Array<string>>;
    roles: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      createdAt: Option<boolean>;
      lastLogin: Option<boolean>;
      isActive: Option<boolean>;
      roles: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly createdAt: FieldController<string>;
    readonly lastLogin: FieldController<string | null>;
    readonly isActive: FieldController<boolean>;
    readonly roles: ArrayFieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Metadata;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Metadata, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Metadata>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Metadata>,
  ): Gigaform {
    let data = $state({ ...Metadata.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      createdAt: Option.none(),
      lastLogin: Option.none(),
      isActive: Option.none(),
      roles: Option.none(),
    });
    let tainted = $state<Tainted>({
      createdAt: Option.none(),
      lastLogin: Option.none(),
      isActive: Option.none(),
      roles: Option.none(),
    });
    const fields: FieldControllers = {
      createdAt: {
        path: ["createdAt"] as const,
        name: "createdAt",
        constraints: { required: true },

        get: () => data.createdAt,
        set: (value: string) => {
          data.createdAt = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.createdAt,
        setError: (value: Option<Array<string>>) => {
          errors.createdAt = value;
        },
        getTainted: () => tainted.createdAt,
        setTainted: (value: Option<boolean>) => {
          tainted.createdAt = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Metadata.validateField(
            "createdAt",
            data.createdAt,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      lastLogin: {
        path: ["lastLogin"] as const,
        name: "lastLogin",
        constraints: { required: true },

        get: () => data.lastLogin,
        set: (value: string | null) => {
          data.lastLogin = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.lastLogin,
        setError: (value: Option<Array<string>>) => {
          errors.lastLogin = value;
        },
        getTainted: () => tainted.lastLogin,
        setTainted: (value: Option<boolean>) => {
          tainted.lastLogin = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Metadata.validateField(
            "lastLogin",
            data.lastLogin,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      isActive: {
        path: ["isActive"] as const,
        name: "isActive",
        constraints: { required: true },

        get: () => data.isActive,
        set: (value: boolean) => {
          data.isActive = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.isActive,
        setError: (value: Option<Array<string>>) => {
          errors.isActive = value;
        },
        getTainted: () => tainted.isActive,
        setTainted: (value: Option<boolean>) => {
          tainted.isActive = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Metadata.validateField("isActive", data.isActive);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      roles: {
        path: ["roles"] as const,
        name: "roles",
        constraints: { required: true },

        get: () => data.roles,
        set: (value: string[]) => {
          data.roles = value;
        },
        transform: (value: string[]): string[] => value,
        getError: () => errors.roles,
        setError: (value: Option<Array<string>>) => {
          errors.roles = value;
        },
        getTainted: () => tainted.roles,
        setTainted: (value: Option<boolean>) => {
          tainted.roles = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Metadata.validateField("roles", data.roles);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["roles", index] as const,
          name: `roles.${index}`,
          constraints: { required: true },
          get: () => data.roles[index]!,
          set: (value: string) => {
            data.roles[index] = value;
          },
          transform: (value: string): string => value,
          getError: () => errors.roles,
          setError: (value: Option<Array<string>>) => {
            errors.roles = value;
          },
          getTainted: () => tainted.roles,
          setTainted: (value: Option<boolean>) => {
            tainted.roles = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.roles.push(item);
        },
        remove: (index: number) => {
          data.roles.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.roles[a]!;
          data.roles[a] = data.roles[b]!;
          data.roles[b] = tmp;
        },
      },
    };
    function validate(): Result<
      Metadata,
      Array<{ field: string; message: string }>
    > {
      return Metadata.fromObject(data);
    }
    function reset(newOverrides?: Partial<Metadata>): void {
      data = { ...Metadata.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        createdAt: Option.none(),
        lastLogin: Option.none(),
        isActive: Option.none(),
        roles: Option.none(),
      };
      tainted = {
        createdAt: Option.none(),
        lastLogin: Option.none(),
        isActive: Option.none(),
        roles: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Metadata, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.createdAt = formData.get("createdAt") ?? "";
    obj.lastLogin = formData.get("lastLogin") ?? "";
    {
      const isActiveVal = formData.get("isActive");
      obj.isActive =
        isActiveVal === "true" || isActiveVal === "on" || isActiveVal === "1";
    }
    obj.roles = formData.getAll("roles") as Array<string>;
    return Metadata.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface ColumnConfig {
  /** @serde({ validate: ["nonEmpty"] }) */
  heading: string;
  dataPath: DataPath;
}

export function defaultValueColumnConfig(): ColumnConfig {
  return { heading: "", dataPath: DataPath.defaultValue() } as ColumnConfig;
}

export function toStringifiedJSONColumnConfig(value: ColumnConfig): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeColumnConfig(value, ctx));
}
export function toObjectColumnConfig(
  value: ColumnConfig,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeColumnConfig(value, ctx);
}
export function __serializeColumnConfig(
  value: ColumnConfig,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "ColumnConfig", __id };
  result["heading"] = value.heading;
  result["dataPath"] =
    typeof (value.dataPath as any)?.__serialize === "function"
      ? (value.dataPath as any).__serialize(ctx)
      : value.dataPath;
  return result;
}

export function fromStringifiedJSONColumnConfig(
  json: string,
  opts?: DeserializeOptions,
): Result<ColumnConfig, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectColumnConfig(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectColumnConfig(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<ColumnConfig, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeColumnConfig(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "ColumnConfig.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeColumnConfig(
  value: any,
  ctx: DeserializeContext,
): ColumnConfig | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "ColumnConfig.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("heading" in obj)) {
    errors.push({ field: "heading", message: "missing required field" });
  }
  if (!("dataPath" in obj)) {
    errors.push({ field: "dataPath", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_heading = obj["heading"] as string;
    if (__raw_heading.length === 0) {
      errors.push({ field: "heading", message: "must not be empty" });
    }
    instance.heading = __raw_heading;
  }
  {
    const __raw_dataPath = obj["dataPath"] as DataPath;
    if (typeof (DataPath as any)?.__deserialize === "function") {
      const __result = (DataPath as any).__deserialize(__raw_dataPath, ctx);
      ctx.assignOrDefer(instance, "dataPath", __result);
    } else {
      instance.dataPath = __raw_dataPath;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as ColumnConfig;
}
export function validateFieldColumnConfig<K extends keyof ColumnConfig>(
  field: K,
  value: ColumnConfig[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "heading": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "heading", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsColumnConfig(
  partial: Partial<ColumnConfig>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("heading" in partial && partial.heading !== undefined) {
    const __val = partial.heading as string;
    if (__val.length === 0) {
      errors.push({ field: "heading", message: "must not be empty" });
    }
  }
  return errors;
}
export function isColumnConfig(obj: unknown): obj is ColumnConfig {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "heading" in o && "dataPath" in o;
}

export namespace ColumnConfig {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    heading: Option<Array<string>>;
    dataPath: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { heading: Option<boolean>; dataPath: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly heading: FieldController<string>;
    readonly dataPath: FieldController<DataPath>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: ColumnConfig;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<ColumnConfig, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<ColumnConfig>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<ColumnConfig>,
  ): Gigaform {
    let data = $state({ ...ColumnConfig.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      heading: Option.none(),
      dataPath: Option.none(),
    });
    let tainted = $state<Tainted>({
      heading: Option.none(),
      dataPath: Option.none(),
    });
    const fields: FieldControllers = {
      heading: {
        path: ["heading"] as const,
        name: "heading",
        constraints: { required: true },

        get: () => data.heading,
        set: (value: string) => {
          data.heading = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.heading,
        setError: (value: Option<Array<string>>) => {
          errors.heading = value;
        },
        getTainted: () => tainted.heading,
        setTainted: (value: Option<boolean>) => {
          tainted.heading = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = ColumnConfig.validateField(
            "heading",
            data.heading,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      dataPath: {
        path: ["dataPath"] as const,
        name: "dataPath",
        constraints: { required: true },

        get: () => data.dataPath,
        set: (value: DataPath) => {
          data.dataPath = value;
        },
        transform: (value: DataPath): DataPath => value,
        getError: () => errors.dataPath,
        setError: (value: Option<Array<string>>) => {
          errors.dataPath = value;
        },
        getTainted: () => tainted.dataPath,
        setTainted: (value: Option<boolean>) => {
          tainted.dataPath = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = ColumnConfig.validateField(
            "dataPath",
            data.dataPath,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      ColumnConfig,
      Array<{ field: string; message: string }>
    > {
      return ColumnConfig.fromObject(data);
    }
    function reset(newOverrides?: Partial<ColumnConfig>): void {
      data = { ...ColumnConfig.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        heading: Option.none(),
        dataPath: Option.none(),
      };
      tainted = { heading: Option.none(), dataPath: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<ColumnConfig, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.heading = formData.get("heading") ?? "";
    {
      // Collect nested object fields with prefix "dataPath."
      const dataPathObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("dataPath.")) {
          const fieldName = key.slice("dataPath.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = dataPathObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.dataPath = dataPathObj;
    }
    return ColumnConfig.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface PhoneNumber {
  /** @switchController({ label: "Main" }) */
  main: boolean;
  /** @comboboxController({ label: "Phone Type", allowCustom: true }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  phoneType: string;
  /** @textController({ label: "Number" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  number: string;
  /** @switchController({ label: "Can Text" }) */
  canText: boolean;
  /** @switchController({ label: "Can Call" }) */
  canCall: boolean;
}

export function defaultValuePhoneNumber(): PhoneNumber {
  return {
    main: false,
    phoneType: "",
    number: "",
    canText: false,
    canCall: false,
  } as PhoneNumber;
}

export function toStringifiedJSONPhoneNumber(value: PhoneNumber): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializePhoneNumber(value, ctx));
}
export function toObjectPhoneNumber(
  value: PhoneNumber,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializePhoneNumber(value, ctx);
}
export function __serializePhoneNumber(
  value: PhoneNumber,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "PhoneNumber", __id };
  result["main"] = value.main;
  result["phoneType"] = value.phoneType;
  result["number"] = value.number;
  result["canText"] = value.canText;
  result["canCall"] = value.canCall;
  return result;
}

export function fromStringifiedJSONPhoneNumber(
  json: string,
  opts?: DeserializeOptions,
): Result<PhoneNumber, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectPhoneNumber(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectPhoneNumber(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<PhoneNumber, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializePhoneNumber(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "PhoneNumber.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializePhoneNumber(
  value: any,
  ctx: DeserializeContext,
): PhoneNumber | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "PhoneNumber.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("main" in obj)) {
    errors.push({ field: "main", message: "missing required field" });
  }
  if (!("phoneType" in obj)) {
    errors.push({ field: "phoneType", message: "missing required field" });
  }
  if (!("number" in obj)) {
    errors.push({ field: "number", message: "missing required field" });
  }
  if (!("canText" in obj)) {
    errors.push({ field: "canText", message: "missing required field" });
  }
  if (!("canCall" in obj)) {
    errors.push({ field: "canCall", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_main = obj["main"] as boolean;
    instance.main = __raw_main;
  }
  {
    const __raw_phoneType = obj["phoneType"] as string;
    if (__raw_phoneType.length === 0) {
      errors.push({ field: "phoneType", message: "must not be empty" });
    }
    instance.phoneType = __raw_phoneType;
  }
  {
    const __raw_number = obj["number"] as string;
    if (__raw_number.length === 0) {
      errors.push({ field: "number", message: "must not be empty" });
    }
    instance.number = __raw_number;
  }
  {
    const __raw_canText = obj["canText"] as boolean;
    instance.canText = __raw_canText;
  }
  {
    const __raw_canCall = obj["canCall"] as boolean;
    instance.canCall = __raw_canCall;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as PhoneNumber;
}
export function validateFieldPhoneNumber<K extends keyof PhoneNumber>(
  field: K,
  value: PhoneNumber[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "phoneType": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "phoneType", message: "must not be empty" });
      }
      break;
    }
    case "number": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "number", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsPhoneNumber(
  partial: Partial<PhoneNumber>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("phoneType" in partial && partial.phoneType !== undefined) {
    const __val = partial.phoneType as string;
    if (__val.length === 0) {
      errors.push({ field: "phoneType", message: "must not be empty" });
    }
  }
  if ("number" in partial && partial.number !== undefined) {
    const __val = partial.number as string;
    if (__val.length === 0) {
      errors.push({ field: "number", message: "must not be empty" });
    }
  }
  return errors;
}
export function isPhoneNumber(obj: unknown): obj is PhoneNumber {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "main" in o &&
    "phoneType" in o &&
    "number" in o &&
    "canText" in o &&
    "canCall" in o
  );
}

export namespace PhoneNumber {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    main: Option<Array<string>>;
    phoneType: Option<Array<string>>;
    number: Option<Array<string>>;
    canText: Option<Array<string>>;
    canCall: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      main: Option<boolean>;
      phoneType: Option<boolean>;
      number: Option<boolean>;
      canText: Option<boolean>;
      canCall: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly main: FieldController<boolean>;
    readonly phoneType: FieldController<string>;
    readonly number: FieldController<string>;
    readonly canText: FieldController<boolean>;
    readonly canCall: FieldController<boolean>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: PhoneNumber;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<PhoneNumber, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<PhoneNumber>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<PhoneNumber>,
  ): Gigaform {
    let data = $state({ ...PhoneNumber.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      main: Option.none(),
      phoneType: Option.none(),
      number: Option.none(),
      canText: Option.none(),
      canCall: Option.none(),
    });
    let tainted = $state<Tainted>({
      main: Option.none(),
      phoneType: Option.none(),
      number: Option.none(),
      canText: Option.none(),
      canCall: Option.none(),
    });
    const fields: FieldControllers = {
      main: {
        path: ["main"] as const,
        name: "main",
        constraints: { required: true },
        label: "Main",
        get: () => data.main,
        set: (value: boolean) => {
          data.main = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.main,
        setError: (value: Option<Array<string>>) => {
          errors.main = value;
        },
        getTainted: () => tainted.main,
        setTainted: (value: Option<boolean>) => {
          tainted.main = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = PhoneNumber.validateField("main", data.main);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      phoneType: {
        path: ["phoneType"] as const,
        name: "phoneType",
        constraints: { required: true },
        label: "Phone Type",
        get: () => data.phoneType,
        set: (value: string) => {
          data.phoneType = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.phoneType,
        setError: (value: Option<Array<string>>) => {
          errors.phoneType = value;
        },
        getTainted: () => tainted.phoneType,
        setTainted: (value: Option<boolean>) => {
          tainted.phoneType = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = PhoneNumber.validateField(
            "phoneType",
            data.phoneType,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      number: {
        path: ["number"] as const,
        name: "number",
        constraints: { required: true },
        label: "Number",
        get: () => data.number,
        set: (value: string) => {
          data.number = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.number,
        setError: (value: Option<Array<string>>) => {
          errors.number = value;
        },
        getTainted: () => tainted.number,
        setTainted: (value: Option<boolean>) => {
          tainted.number = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = PhoneNumber.validateField("number", data.number);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      canText: {
        path: ["canText"] as const,
        name: "canText",
        constraints: { required: true },
        label: "Can Text",
        get: () => data.canText,
        set: (value: boolean) => {
          data.canText = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.canText,
        setError: (value: Option<Array<string>>) => {
          errors.canText = value;
        },
        getTainted: () => tainted.canText,
        setTainted: (value: Option<boolean>) => {
          tainted.canText = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = PhoneNumber.validateField(
            "canText",
            data.canText,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      canCall: {
        path: ["canCall"] as const,
        name: "canCall",
        constraints: { required: true },
        label: "Can Call",
        get: () => data.canCall,
        set: (value: boolean) => {
          data.canCall = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.canCall,
        setError: (value: Option<Array<string>>) => {
          errors.canCall = value;
        },
        getTainted: () => tainted.canCall,
        setTainted: (value: Option<boolean>) => {
          tainted.canCall = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = PhoneNumber.validateField(
            "canCall",
            data.canCall,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      PhoneNumber,
      Array<{ field: string; message: string }>
    > {
      return PhoneNumber.fromObject(data);
    }
    function reset(newOverrides?: Partial<PhoneNumber>): void {
      data = { ...PhoneNumber.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        main: Option.none(),
        phoneType: Option.none(),
        number: Option.none(),
        canText: Option.none(),
        canCall: Option.none(),
      };
      tainted = {
        main: Option.none(),
        phoneType: Option.none(),
        number: Option.none(),
        canText: Option.none(),
        canCall: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<PhoneNumber, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const mainVal = formData.get("main");
      obj.main = mainVal === "true" || mainVal === "on" || mainVal === "1";
    }
    obj.phoneType = formData.get("phoneType") ?? "";
    obj.number = formData.get("number") ?? "";
    {
      const canTextVal = formData.get("canText");
      obj.canText =
        canTextVal === "true" || canTextVal === "on" || canTextVal === "1";
    }
    {
      const canCallVal = formData.get("canCall");
      obj.canCall =
        canCallVal === "true" || canCallVal === "on" || canCallVal === "1";
    }
    return PhoneNumber.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Gradient {
  startHue: number;
}

export function defaultValueGradient(): Gradient {
  return { startHue: 0 } as Gradient;
}

export function toStringifiedJSONGradient(value: Gradient): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeGradient(value, ctx));
}
export function toObjectGradient(value: Gradient): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeGradient(value, ctx);
}
export function __serializeGradient(
  value: Gradient,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Gradient", __id };
  result["startHue"] = value.startHue;
  return result;
}

export function fromStringifiedJSONGradient(
  json: string,
  opts?: DeserializeOptions,
): Result<Gradient, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectGradient(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectGradient(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Gradient, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeGradient(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Gradient.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeGradient(
  value: any,
  ctx: DeserializeContext,
): Gradient | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Gradient.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("startHue" in obj)) {
    errors.push({ field: "startHue", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_startHue = obj["startHue"] as number;
    instance.startHue = __raw_startHue;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Gradient;
}
export function validateFieldGradient<K extends keyof Gradient>(
  field: K,
  value: Gradient[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsGradient(
  partial: Partial<Gradient>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isGradient(obj: unknown): obj is Gradient {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "startHue" in o;
}

export namespace Gradient {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    startHue: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { startHue: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly startHue: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Gradient;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Gradient, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Gradient>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Gradient>,
  ): Gigaform {
    let data = $state({ ...Gradient.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      startHue: Option.none(),
    });
    let tainted = $state<Tainted>({ startHue: Option.none() });
    const fields: FieldControllers = {
      startHue: {
        path: ["startHue"] as const,
        name: "startHue",
        constraints: { required: true },

        get: () => data.startHue,
        set: (value: number) => {
          data.startHue = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.startHue,
        setError: (value: Option<Array<string>>) => {
          errors.startHue = value;
        },
        getTainted: () => tainted.startHue,
        setTainted: (value: Option<boolean>) => {
          tainted.startHue = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Gradient.validateField("startHue", data.startHue);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Gradient,
      Array<{ field: string; message: string }>
    > {
      return Gradient.fromObject(data);
    }
    function reset(newOverrides?: Partial<Gradient>): void {
      data = { ...Gradient.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), startHue: Option.none() };
      tainted = { startHue: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Gradient, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const startHueStr = formData.get("startHue");
      obj.startHue = startHueStr ? parseFloat(startHueStr as string) : 0;
      if (obj.startHue !== undefined && isNaN(obj.startHue as number))
        obj.startHue = 0;
    }
    return Gradient.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Product {
  /** @hiddenController({}) */
  id: string;
  /** @textController({ label: "Name" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  name: string;
  /** @textController({ label: "Quick Code" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  quickCode: string;
  /** @comboboxController({ label: "Group", allowCustom: true }) */
  group: string | null;
  /** @comboboxController({ label: "Subgroup", allowCustom: true }) */
  subgroup: string | null;
  /** @comboboxController({ label: "Unit", allowCustom: true }) */
  unit: string | null;
  /** @switchController({ label: "Active" }) */
  active: boolean;
  /** @switchController({ label: "Commission" }) */
  commission: boolean;
  /** @switchController({ label: "Favorite" }) */
  favorite: boolean;
  defaults: ProductDefaults;
}

export function defaultValueProduct(): Product {
  return {
    id: "",
    name: "",
    quickCode: "",
    group: null,
    subgroup: null,
    unit: null,
    active: false,
    commission: false,
    favorite: false,
    defaults: ProductDefaults.defaultValue(),
  } as Product;
}

export function toStringifiedJSONProduct(value: Product): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeProduct(value, ctx));
}
export function toObjectProduct(value: Product): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeProduct(value, ctx);
}
export function __serializeProduct(
  value: Product,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Product", __id };
  result["id"] = value.id;
  result["name"] = value.name;
  result["quickCode"] = value.quickCode;
  if (value.group !== null) {
    result["group"] =
      typeof (value.group as any)?.__serialize === "function"
        ? (value.group as any).__serialize(ctx)
        : value.group;
  } else {
    result["group"] = null;
  }
  if (value.subgroup !== null) {
    result["subgroup"] =
      typeof (value.subgroup as any)?.__serialize === "function"
        ? (value.subgroup as any).__serialize(ctx)
        : value.subgroup;
  } else {
    result["subgroup"] = null;
  }
  if (value.unit !== null) {
    result["unit"] =
      typeof (value.unit as any)?.__serialize === "function"
        ? (value.unit as any).__serialize(ctx)
        : value.unit;
  } else {
    result["unit"] = null;
  }
  result["active"] = value.active;
  result["commission"] = value.commission;
  result["favorite"] = value.favorite;
  result["defaults"] =
    typeof (value.defaults as any)?.__serialize === "function"
      ? (value.defaults as any).__serialize(ctx)
      : value.defaults;
  return result;
}

export function fromStringifiedJSONProduct(
  json: string,
  opts?: DeserializeOptions,
): Result<Product, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectProduct(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectProduct(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Product, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeProduct(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Product.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeProduct(
  value: any,
  ctx: DeserializeContext,
): Product | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Product.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("name" in obj)) {
    errors.push({ field: "name", message: "missing required field" });
  }
  if (!("quickCode" in obj)) {
    errors.push({ field: "quickCode", message: "missing required field" });
  }
  if (!("group" in obj)) {
    errors.push({ field: "group", message: "missing required field" });
  }
  if (!("subgroup" in obj)) {
    errors.push({ field: "subgroup", message: "missing required field" });
  }
  if (!("unit" in obj)) {
    errors.push({ field: "unit", message: "missing required field" });
  }
  if (!("active" in obj)) {
    errors.push({ field: "active", message: "missing required field" });
  }
  if (!("commission" in obj)) {
    errors.push({ field: "commission", message: "missing required field" });
  }
  if (!("favorite" in obj)) {
    errors.push({ field: "favorite", message: "missing required field" });
  }
  if (!("defaults" in obj)) {
    errors.push({ field: "defaults", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_name = obj["name"] as string;
    if (__raw_name.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
    instance.name = __raw_name;
  }
  {
    const __raw_quickCode = obj["quickCode"] as string;
    if (__raw_quickCode.length === 0) {
      errors.push({ field: "quickCode", message: "must not be empty" });
    }
    instance.quickCode = __raw_quickCode;
  }
  {
    const __raw_group = obj["group"] as string | null;
    if (__raw_group === null) {
      instance.group = null;
    } else if (typeof (__raw_group as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_group as any).__ref);
      ctx.assignOrDefer(instance, "group", __result);
    } else {
      instance.group = __raw_group;
    }
  }
  {
    const __raw_subgroup = obj["subgroup"] as string | null;
    if (__raw_subgroup === null) {
      instance.subgroup = null;
    } else if (typeof (__raw_subgroup as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_subgroup as any).__ref);
      ctx.assignOrDefer(instance, "subgroup", __result);
    } else {
      instance.subgroup = __raw_subgroup;
    }
  }
  {
    const __raw_unit = obj["unit"] as string | null;
    if (__raw_unit === null) {
      instance.unit = null;
    } else if (typeof (__raw_unit as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_unit as any).__ref);
      ctx.assignOrDefer(instance, "unit", __result);
    } else {
      instance.unit = __raw_unit;
    }
  }
  {
    const __raw_active = obj["active"] as boolean;
    instance.active = __raw_active;
  }
  {
    const __raw_commission = obj["commission"] as boolean;
    instance.commission = __raw_commission;
  }
  {
    const __raw_favorite = obj["favorite"] as boolean;
    instance.favorite = __raw_favorite;
  }
  {
    const __raw_defaults = obj["defaults"] as ProductDefaults;
    if (typeof (ProductDefaults as any)?.__deserialize === "function") {
      const __result = (ProductDefaults as any).__deserialize(
        __raw_defaults,
        ctx,
      );
      ctx.assignOrDefer(instance, "defaults", __result);
    } else {
      instance.defaults = __raw_defaults;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Product;
}
export function validateFieldProduct<K extends keyof Product>(
  field: K,
  value: Product[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "name": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
      break;
    }
    case "quickCode": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "quickCode", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsProduct(
  partial: Partial<Product>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("name" in partial && partial.name !== undefined) {
    const __val = partial.name as string;
    if (__val.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
  }
  if ("quickCode" in partial && partial.quickCode !== undefined) {
    const __val = partial.quickCode as string;
    if (__val.length === 0) {
      errors.push({ field: "quickCode", message: "must not be empty" });
    }
  }
  return errors;
}
export function isProduct(obj: unknown): obj is Product {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "id" in o &&
    "name" in o &&
    "quickCode" in o &&
    "group" in o &&
    "subgroup" in o &&
    "unit" in o &&
    "active" in o &&
    "commission" in o &&
    "favorite" in o &&
    "defaults" in o
  );
}

export namespace Product {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    name: Option<Array<string>>;
    quickCode: Option<Array<string>>;
    group: Option<Array<string>>;
    subgroup: Option<Array<string>>;
    unit: Option<Array<string>>;
    active: Option<Array<string>>;
    commission: Option<Array<string>>;
    favorite: Option<Array<string>>;
    defaults: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      name: Option<boolean>;
      quickCode: Option<boolean>;
      group: Option<boolean>;
      subgroup: Option<boolean>;
      unit: Option<boolean>;
      active: Option<boolean>;
      commission: Option<boolean>;
      favorite: Option<boolean>;
      defaults: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly name: FieldController<string>;
    readonly quickCode: FieldController<string>;
    readonly group: FieldController<string | null>;
    readonly subgroup: FieldController<string | null>;
    readonly unit: FieldController<string | null>;
    readonly active: FieldController<boolean>;
    readonly commission: FieldController<boolean>;
    readonly favorite: FieldController<boolean>;
    readonly defaults: FieldController<ProductDefaults>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Product;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Product, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Product>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Product>,
  ): Gigaform {
    let data = $state({ ...Product.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      name: Option.none(),
      quickCode: Option.none(),
      group: Option.none(),
      subgroup: Option.none(),
      unit: Option.none(),
      active: Option.none(),
      commission: Option.none(),
      favorite: Option.none(),
      defaults: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      name: Option.none(),
      quickCode: Option.none(),
      group: Option.none(),
      subgroup: Option.none(),
      unit: Option.none(),
      active: Option.none(),
      commission: Option.none(),
      favorite: Option.none(),
      defaults: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Product.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },
        label: "Name",
        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Product.validateField("name", data.name);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      quickCode: {
        path: ["quickCode"] as const,
        name: "quickCode",
        constraints: { required: true },
        label: "Quick Code",
        get: () => data.quickCode,
        set: (value: string) => {
          data.quickCode = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.quickCode,
        setError: (value: Option<Array<string>>) => {
          errors.quickCode = value;
        },
        getTainted: () => tainted.quickCode,
        setTainted: (value: Option<boolean>) => {
          tainted.quickCode = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Product.validateField(
            "quickCode",
            data.quickCode,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      group: {
        path: ["group"] as const,
        name: "group",
        constraints: { required: true },
        label: "Group",
        get: () => data.group,
        set: (value: string | null) => {
          data.group = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.group,
        setError: (value: Option<Array<string>>) => {
          errors.group = value;
        },
        getTainted: () => tainted.group,
        setTainted: (value: Option<boolean>) => {
          tainted.group = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Product.validateField("group", data.group);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      subgroup: {
        path: ["subgroup"] as const,
        name: "subgroup",
        constraints: { required: true },
        label: "Subgroup",
        get: () => data.subgroup,
        set: (value: string | null) => {
          data.subgroup = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.subgroup,
        setError: (value: Option<Array<string>>) => {
          errors.subgroup = value;
        },
        getTainted: () => tainted.subgroup,
        setTainted: (value: Option<boolean>) => {
          tainted.subgroup = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Product.validateField("subgroup", data.subgroup);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      unit: {
        path: ["unit"] as const,
        name: "unit",
        constraints: { required: true },
        label: "Unit",
        get: () => data.unit,
        set: (value: string | null) => {
          data.unit = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.unit,
        setError: (value: Option<Array<string>>) => {
          errors.unit = value;
        },
        getTainted: () => tainted.unit,
        setTainted: (value: Option<boolean>) => {
          tainted.unit = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Product.validateField("unit", data.unit);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      active: {
        path: ["active"] as const,
        name: "active",
        constraints: { required: true },
        label: "Active",
        get: () => data.active,
        set: (value: boolean) => {
          data.active = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.active,
        setError: (value: Option<Array<string>>) => {
          errors.active = value;
        },
        getTainted: () => tainted.active,
        setTainted: (value: Option<boolean>) => {
          tainted.active = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Product.validateField("active", data.active);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      commission: {
        path: ["commission"] as const,
        name: "commission",
        constraints: { required: true },
        label: "Commission",
        get: () => data.commission,
        set: (value: boolean) => {
          data.commission = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.commission,
        setError: (value: Option<Array<string>>) => {
          errors.commission = value;
        },
        getTainted: () => tainted.commission,
        setTainted: (value: Option<boolean>) => {
          tainted.commission = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Product.validateField(
            "commission",
            data.commission,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      favorite: {
        path: ["favorite"] as const,
        name: "favorite",
        constraints: { required: true },
        label: "Favorite",
        get: () => data.favorite,
        set: (value: boolean) => {
          data.favorite = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.favorite,
        setError: (value: Option<Array<string>>) => {
          errors.favorite = value;
        },
        getTainted: () => tainted.favorite,
        setTainted: (value: Option<boolean>) => {
          tainted.favorite = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Product.validateField("favorite", data.favorite);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      defaults: {
        path: ["defaults"] as const,
        name: "defaults",
        constraints: { required: true },

        get: () => data.defaults,
        set: (value: ProductDefaults) => {
          data.defaults = value;
        },
        transform: (value: ProductDefaults): ProductDefaults => value,
        getError: () => errors.defaults,
        setError: (value: Option<Array<string>>) => {
          errors.defaults = value;
        },
        getTainted: () => tainted.defaults,
        setTainted: (value: Option<boolean>) => {
          tainted.defaults = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Product.validateField("defaults", data.defaults);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Product,
      Array<{ field: string; message: string }>
    > {
      return Product.fromObject(data);
    }
    function reset(newOverrides?: Partial<Product>): void {
      data = { ...Product.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        name: Option.none(),
        quickCode: Option.none(),
        group: Option.none(),
        subgroup: Option.none(),
        unit: Option.none(),
        active: Option.none(),
        commission: Option.none(),
        favorite: Option.none(),
        defaults: Option.none(),
      };
      tainted = {
        id: Option.none(),
        name: Option.none(),
        quickCode: Option.none(),
        group: Option.none(),
        subgroup: Option.none(),
        unit: Option.none(),
        active: Option.none(),
        commission: Option.none(),
        favorite: Option.none(),
        defaults: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Product, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.name = formData.get("name") ?? "";
    obj.quickCode = formData.get("quickCode") ?? "";
    obj.group = formData.get("group") ?? "";
    obj.subgroup = formData.get("subgroup") ?? "";
    obj.unit = formData.get("unit") ?? "";
    {
      const activeVal = formData.get("active");
      obj.active =
        activeVal === "true" || activeVal === "on" || activeVal === "1";
    }
    {
      const commissionVal = formData.get("commission");
      obj.commission =
        commissionVal === "true" ||
        commissionVal === "on" ||
        commissionVal === "1";
    }
    {
      const favoriteVal = formData.get("favorite");
      obj.favorite =
        favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1";
    }
    {
      // Collect nested object fields with prefix "defaults."
      const defaultsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("defaults.")) {
          const fieldName = key.slice("defaults.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = defaultsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.defaults = defaultsObj;
    }
    return Product.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface YearlyRecurrenceRule {
  quantityOfYears: number;
}

export function defaultValueYearlyRecurrenceRule(): YearlyRecurrenceRule {
  return { quantityOfYears: 0 } as YearlyRecurrenceRule;
}

export function toStringifiedJSONYearlyRecurrenceRule(
  value: YearlyRecurrenceRule,
): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeYearlyRecurrenceRule(value, ctx));
}
export function toObjectYearlyRecurrenceRule(
  value: YearlyRecurrenceRule,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeYearlyRecurrenceRule(value, ctx);
}
export function __serializeYearlyRecurrenceRule(
  value: YearlyRecurrenceRule,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = {
    __type: "YearlyRecurrenceRule",
    __id,
  };
  result["quantityOfYears"] = value.quantityOfYears;
  return result;
}

export function fromStringifiedJSONYearlyRecurrenceRule(
  json: string,
  opts?: DeserializeOptions,
): Result<YearlyRecurrenceRule, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectYearlyRecurrenceRule(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectYearlyRecurrenceRule(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<YearlyRecurrenceRule, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeYearlyRecurrenceRule(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "YearlyRecurrenceRule.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeYearlyRecurrenceRule(
  value: any,
  ctx: DeserializeContext,
): YearlyRecurrenceRule | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "YearlyRecurrenceRule.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("quantityOfYears" in obj)) {
    errors.push({
      field: "quantityOfYears",
      message: "missing required field",
    });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_quantityOfYears = obj["quantityOfYears"] as number;
    instance.quantityOfYears = __raw_quantityOfYears;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as YearlyRecurrenceRule;
}
export function validateFieldYearlyRecurrenceRule<
  K extends keyof YearlyRecurrenceRule,
>(
  field: K,
  value: YearlyRecurrenceRule[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsYearlyRecurrenceRule(
  partial: Partial<YearlyRecurrenceRule>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isYearlyRecurrenceRule(
  obj: unknown,
): obj is YearlyRecurrenceRule {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "quantityOfYears" in o;
}

export namespace YearlyRecurrenceRule {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    quantityOfYears: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { quantityOfYears: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly quantityOfYears: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: YearlyRecurrenceRule;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      YearlyRecurrenceRule,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<YearlyRecurrenceRule>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<YearlyRecurrenceRule>,
  ): Gigaform {
    let data = $state({ ...YearlyRecurrenceRule.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      quantityOfYears: Option.none(),
    });
    let tainted = $state<Tainted>({ quantityOfYears: Option.none() });
    const fields: FieldControllers = {
      quantityOfYears: {
        path: ["quantityOfYears"] as const,
        name: "quantityOfYears",
        constraints: { required: true },

        get: () => data.quantityOfYears,
        set: (value: number) => {
          data.quantityOfYears = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.quantityOfYears,
        setError: (value: Option<Array<string>>) => {
          errors.quantityOfYears = value;
        },
        getTainted: () => tainted.quantityOfYears,
        setTainted: (value: Option<boolean>) => {
          tainted.quantityOfYears = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = YearlyRecurrenceRule.validateField(
            "quantityOfYears",
            data.quantityOfYears,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      YearlyRecurrenceRule,
      Array<{ field: string; message: string }>
    > {
      return YearlyRecurrenceRule.fromObject(data);
    }
    function reset(newOverrides?: Partial<YearlyRecurrenceRule>): void {
      data = { ...YearlyRecurrenceRule.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), quantityOfYears: Option.none() };
      tainted = { quantityOfYears: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<YearlyRecurrenceRule, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const quantityOfYearsStr = formData.get("quantityOfYears");
      obj.quantityOfYears = quantityOfYearsStr
        ? parseFloat(quantityOfYearsStr as string)
        : 0;
      if (
        obj.quantityOfYears !== undefined &&
        isNaN(obj.quantityOfYears as number)
      )
        obj.quantityOfYears = 0;
    }
    return YearlyRecurrenceRule.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface AppointmentNotifications {
  /** @serde({ validate: ["nonEmpty"] }) */
  personalScheduleChangeNotifications: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  allScheduleChangeNotifications: string;
}

export function defaultValueAppointmentNotifications(): AppointmentNotifications {
  return {
    personalScheduleChangeNotifications: "",
    allScheduleChangeNotifications: "",
  } as AppointmentNotifications;
}

export function toStringifiedJSONAppointmentNotifications(
  value: AppointmentNotifications,
): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeAppointmentNotifications(value, ctx));
}
export function toObjectAppointmentNotifications(
  value: AppointmentNotifications,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeAppointmentNotifications(value, ctx);
}
export function __serializeAppointmentNotifications(
  value: AppointmentNotifications,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = {
    __type: "AppointmentNotifications",
    __id,
  };
  result["personalScheduleChangeNotifications"] =
    value.personalScheduleChangeNotifications;
  result["allScheduleChangeNotifications"] =
    value.allScheduleChangeNotifications;
  return result;
}

export function fromStringifiedJSONAppointmentNotifications(
  json: string,
  opts?: DeserializeOptions,
): Result<AppointmentNotifications, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectAppointmentNotifications(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectAppointmentNotifications(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<AppointmentNotifications, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeAppointmentNotifications(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "AppointmentNotifications.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeAppointmentNotifications(
  value: any,
  ctx: DeserializeContext,
): AppointmentNotifications | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "AppointmentNotifications.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("personalScheduleChangeNotifications" in obj)) {
    errors.push({
      field: "personalScheduleChangeNotifications",
      message: "missing required field",
    });
  }
  if (!("allScheduleChangeNotifications" in obj)) {
    errors.push({
      field: "allScheduleChangeNotifications",
      message: "missing required field",
    });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_personalScheduleChangeNotifications = obj[
      "personalScheduleChangeNotifications"
    ] as string;
    if (__raw_personalScheduleChangeNotifications.length === 0) {
      errors.push({
        field: "personalScheduleChangeNotifications",
        message: "must not be empty",
      });
    }
    instance.personalScheduleChangeNotifications =
      __raw_personalScheduleChangeNotifications;
  }
  {
    const __raw_allScheduleChangeNotifications = obj[
      "allScheduleChangeNotifications"
    ] as string;
    if (__raw_allScheduleChangeNotifications.length === 0) {
      errors.push({
        field: "allScheduleChangeNotifications",
        message: "must not be empty",
      });
    }
    instance.allScheduleChangeNotifications =
      __raw_allScheduleChangeNotifications;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as AppointmentNotifications;
}
export function validateFieldAppointmentNotifications<
  K extends keyof AppointmentNotifications,
>(
  field: K,
  value: AppointmentNotifications[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "personalScheduleChangeNotifications": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({
          field: "personalScheduleChangeNotifications",
          message: "must not be empty",
        });
      }
      break;
    }
    case "allScheduleChangeNotifications": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({
          field: "allScheduleChangeNotifications",
          message: "must not be empty",
        });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsAppointmentNotifications(
  partial: Partial<AppointmentNotifications>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if (
    "personalScheduleChangeNotifications" in partial &&
    partial.personalScheduleChangeNotifications !== undefined
  ) {
    const __val = partial.personalScheduleChangeNotifications as string;
    if (__val.length === 0) {
      errors.push({
        field: "personalScheduleChangeNotifications",
        message: "must not be empty",
      });
    }
  }
  if (
    "allScheduleChangeNotifications" in partial &&
    partial.allScheduleChangeNotifications !== undefined
  ) {
    const __val = partial.allScheduleChangeNotifications as string;
    if (__val.length === 0) {
      errors.push({
        field: "allScheduleChangeNotifications",
        message: "must not be empty",
      });
    }
  }
  return errors;
}
export function isAppointmentNotifications(
  obj: unknown,
): obj is AppointmentNotifications {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "personalScheduleChangeNotifications" in o &&
    "allScheduleChangeNotifications" in o
  );
}

export namespace AppointmentNotifications {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    personalScheduleChangeNotifications: Option<Array<string>>;
    allScheduleChangeNotifications: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      personalScheduleChangeNotifications: Option<boolean>;
      allScheduleChangeNotifications: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly personalScheduleChangeNotifications: FieldController<string>;
    readonly allScheduleChangeNotifications: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: AppointmentNotifications;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      AppointmentNotifications,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<AppointmentNotifications>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<AppointmentNotifications>,
  ): Gigaform {
    let data = $state({
      ...AppointmentNotifications.defaultValue(),
      ...overrides,
    });
    let errors = $state<Errors>({
      _errors: Option.none(),
      personalScheduleChangeNotifications: Option.none(),
      allScheduleChangeNotifications: Option.none(),
    });
    let tainted = $state<Tainted>({
      personalScheduleChangeNotifications: Option.none(),
      allScheduleChangeNotifications: Option.none(),
    });
    const fields: FieldControllers = {
      personalScheduleChangeNotifications: {
        path: ["personalScheduleChangeNotifications"] as const,
        name: "personalScheduleChangeNotifications",
        constraints: { required: true },

        get: () => data.personalScheduleChangeNotifications,
        set: (value: string) => {
          data.personalScheduleChangeNotifications = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.personalScheduleChangeNotifications,
        setError: (value: Option<Array<string>>) => {
          errors.personalScheduleChangeNotifications = value;
        },
        getTainted: () => tainted.personalScheduleChangeNotifications,
        setTainted: (value: Option<boolean>) => {
          tainted.personalScheduleChangeNotifications = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = AppointmentNotifications.validateField(
            "personalScheduleChangeNotifications",
            data.personalScheduleChangeNotifications,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      allScheduleChangeNotifications: {
        path: ["allScheduleChangeNotifications"] as const,
        name: "allScheduleChangeNotifications",
        constraints: { required: true },

        get: () => data.allScheduleChangeNotifications,
        set: (value: string) => {
          data.allScheduleChangeNotifications = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.allScheduleChangeNotifications,
        setError: (value: Option<Array<string>>) => {
          errors.allScheduleChangeNotifications = value;
        },
        getTainted: () => tainted.allScheduleChangeNotifications,
        setTainted: (value: Option<boolean>) => {
          tainted.allScheduleChangeNotifications = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = AppointmentNotifications.validateField(
            "allScheduleChangeNotifications",
            data.allScheduleChangeNotifications,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      AppointmentNotifications,
      Array<{ field: string; message: string }>
    > {
      return AppointmentNotifications.fromObject(data);
    }
    function reset(newOverrides?: Partial<AppointmentNotifications>): void {
      data = { ...AppointmentNotifications.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        personalScheduleChangeNotifications: Option.none(),
        allScheduleChangeNotifications: Option.none(),
      };
      tainted = {
        personalScheduleChangeNotifications: Option.none(),
        allScheduleChangeNotifications: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<
    AppointmentNotifications,
    Array<{ field: string; message: string }>
  > {
    const obj: Record<string, unknown> = {};
    obj.personalScheduleChangeNotifications =
      formData.get("personalScheduleChangeNotifications") ?? "";
    obj.allScheduleChangeNotifications =
      formData.get("allScheduleChangeNotifications") ?? "";
    return AppointmentNotifications.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface DirectionHue {
  bearing: number;
  hue: number;
}

export function defaultValueDirectionHue(): DirectionHue {
  return { bearing: 0, hue: 0 } as DirectionHue;
}

export function toStringifiedJSONDirectionHue(value: DirectionHue): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeDirectionHue(value, ctx));
}
export function toObjectDirectionHue(
  value: DirectionHue,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeDirectionHue(value, ctx);
}
export function __serializeDirectionHue(
  value: DirectionHue,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "DirectionHue", __id };
  result["bearing"] = value.bearing;
  result["hue"] = value.hue;
  return result;
}

export function fromStringifiedJSONDirectionHue(
  json: string,
  opts?: DeserializeOptions,
): Result<DirectionHue, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectDirectionHue(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectDirectionHue(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<DirectionHue, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeDirectionHue(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "DirectionHue.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeDirectionHue(
  value: any,
  ctx: DeserializeContext,
): DirectionHue | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "DirectionHue.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("bearing" in obj)) {
    errors.push({ field: "bearing", message: "missing required field" });
  }
  if (!("hue" in obj)) {
    errors.push({ field: "hue", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_bearing = obj["bearing"] as number;
    instance.bearing = __raw_bearing;
  }
  {
    const __raw_hue = obj["hue"] as number;
    instance.hue = __raw_hue;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as DirectionHue;
}
export function validateFieldDirectionHue<K extends keyof DirectionHue>(
  field: K,
  value: DirectionHue[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsDirectionHue(
  partial: Partial<DirectionHue>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isDirectionHue(obj: unknown): obj is DirectionHue {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "bearing" in o && "hue" in o;
}

export namespace DirectionHue {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    bearing: Option<Array<string>>;
    hue: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { bearing: Option<boolean>; hue: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly bearing: FieldController<number>;
    readonly hue: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: DirectionHue;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<DirectionHue, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<DirectionHue>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<DirectionHue>,
  ): Gigaform {
    let data = $state({ ...DirectionHue.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      bearing: Option.none(),
      hue: Option.none(),
    });
    let tainted = $state<Tainted>({
      bearing: Option.none(),
      hue: Option.none(),
    });
    const fields: FieldControllers = {
      bearing: {
        path: ["bearing"] as const,
        name: "bearing",
        constraints: { required: true },

        get: () => data.bearing,
        set: (value: number) => {
          data.bearing = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.bearing,
        setError: (value: Option<Array<string>>) => {
          errors.bearing = value;
        },
        getTainted: () => tainted.bearing,
        setTainted: (value: Option<boolean>) => {
          tainted.bearing = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = DirectionHue.validateField(
            "bearing",
            data.bearing,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      hue: {
        path: ["hue"] as const,
        name: "hue",
        constraints: { required: true },

        get: () => data.hue,
        set: (value: number) => {
          data.hue = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.hue,
        setError: (value: Option<Array<string>>) => {
          errors.hue = value;
        },
        getTainted: () => tainted.hue,
        setTainted: (value: Option<boolean>) => {
          tainted.hue = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = DirectionHue.validateField("hue", data.hue);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      DirectionHue,
      Array<{ field: string; message: string }>
    > {
      return DirectionHue.fromObject(data);
    }
    function reset(newOverrides?: Partial<DirectionHue>): void {
      data = { ...DirectionHue.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        bearing: Option.none(),
        hue: Option.none(),
      };
      tainted = { bearing: Option.none(), hue: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<DirectionHue, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const bearingStr = formData.get("bearing");
      obj.bearing = bearingStr ? parseFloat(bearingStr as string) : 0;
      if (obj.bearing !== undefined && isNaN(obj.bearing as number))
        obj.bearing = 0;
    }
    {
      const hueStr = formData.get("hue");
      obj.hue = hueStr ? parseFloat(hueStr as string) : 0;
      if (obj.hue !== undefined && isNaN(obj.hue as number)) obj.hue = 0;
    }
    return DirectionHue.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface MonthlyRecurrenceRule {
  quantityOfMonths: number;
  day: number;
  /** @serde({ validate: ["nonEmpty"] }) */
  name: string;
}

export function defaultValueMonthlyRecurrenceRule(): MonthlyRecurrenceRule {
  return { quantityOfMonths: 0, day: 0, name: "" } as MonthlyRecurrenceRule;
}

export function toStringifiedJSONMonthlyRecurrenceRule(
  value: MonthlyRecurrenceRule,
): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeMonthlyRecurrenceRule(value, ctx));
}
export function toObjectMonthlyRecurrenceRule(
  value: MonthlyRecurrenceRule,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeMonthlyRecurrenceRule(value, ctx);
}
export function __serializeMonthlyRecurrenceRule(
  value: MonthlyRecurrenceRule,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = {
    __type: "MonthlyRecurrenceRule",
    __id,
  };
  result["quantityOfMonths"] = value.quantityOfMonths;
  result["day"] = value.day;
  result["name"] = value.name;
  return result;
}

export function fromStringifiedJSONMonthlyRecurrenceRule(
  json: string,
  opts?: DeserializeOptions,
): Result<MonthlyRecurrenceRule, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectMonthlyRecurrenceRule(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectMonthlyRecurrenceRule(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<MonthlyRecurrenceRule, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeMonthlyRecurrenceRule(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "MonthlyRecurrenceRule.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeMonthlyRecurrenceRule(
  value: any,
  ctx: DeserializeContext,
): MonthlyRecurrenceRule | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "MonthlyRecurrenceRule.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("quantityOfMonths" in obj)) {
    errors.push({
      field: "quantityOfMonths",
      message: "missing required field",
    });
  }
  if (!("day" in obj)) {
    errors.push({ field: "day", message: "missing required field" });
  }
  if (!("name" in obj)) {
    errors.push({ field: "name", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_quantityOfMonths = obj["quantityOfMonths"] as number;
    instance.quantityOfMonths = __raw_quantityOfMonths;
  }
  {
    const __raw_day = obj["day"] as number;
    instance.day = __raw_day;
  }
  {
    const __raw_name = obj["name"] as string;
    if (__raw_name.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
    instance.name = __raw_name;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as MonthlyRecurrenceRule;
}
export function validateFieldMonthlyRecurrenceRule<
  K extends keyof MonthlyRecurrenceRule,
>(
  field: K,
  value: MonthlyRecurrenceRule[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "name": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsMonthlyRecurrenceRule(
  partial: Partial<MonthlyRecurrenceRule>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("name" in partial && partial.name !== undefined) {
    const __val = partial.name as string;
    if (__val.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
  }
  return errors;
}
export function isMonthlyRecurrenceRule(
  obj: unknown,
): obj is MonthlyRecurrenceRule {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "quantityOfMonths" in o && "day" in o && "name" in o;
}

export namespace MonthlyRecurrenceRule {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    quantityOfMonths: Option<Array<string>>;
    day: Option<Array<string>>;
    name: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      quantityOfMonths: Option<boolean>;
      day: Option<boolean>;
      name: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly quantityOfMonths: FieldController<number>;
    readonly day: FieldController<number>;
    readonly name: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: MonthlyRecurrenceRule;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      MonthlyRecurrenceRule,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<MonthlyRecurrenceRule>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<MonthlyRecurrenceRule>,
  ): Gigaform {
    let data = $state({
      ...MonthlyRecurrenceRule.defaultValue(),
      ...overrides,
    });
    let errors = $state<Errors>({
      _errors: Option.none(),
      quantityOfMonths: Option.none(),
      day: Option.none(),
      name: Option.none(),
    });
    let tainted = $state<Tainted>({
      quantityOfMonths: Option.none(),
      day: Option.none(),
      name: Option.none(),
    });
    const fields: FieldControllers = {
      quantityOfMonths: {
        path: ["quantityOfMonths"] as const,
        name: "quantityOfMonths",
        constraints: { required: true },

        get: () => data.quantityOfMonths,
        set: (value: number) => {
          data.quantityOfMonths = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.quantityOfMonths,
        setError: (value: Option<Array<string>>) => {
          errors.quantityOfMonths = value;
        },
        getTainted: () => tainted.quantityOfMonths,
        setTainted: (value: Option<boolean>) => {
          tainted.quantityOfMonths = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = MonthlyRecurrenceRule.validateField(
            "quantityOfMonths",
            data.quantityOfMonths,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      day: {
        path: ["day"] as const,
        name: "day",
        constraints: { required: true },

        get: () => data.day,
        set: (value: number) => {
          data.day = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.day,
        setError: (value: Option<Array<string>>) => {
          errors.day = value;
        },
        getTainted: () => tainted.day,
        setTainted: (value: Option<boolean>) => {
          tainted.day = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = MonthlyRecurrenceRule.validateField(
            "day",
            data.day,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },

        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = MonthlyRecurrenceRule.validateField(
            "name",
            data.name,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      MonthlyRecurrenceRule,
      Array<{ field: string; message: string }>
    > {
      return MonthlyRecurrenceRule.fromObject(data);
    }
    function reset(newOverrides?: Partial<MonthlyRecurrenceRule>): void {
      data = { ...MonthlyRecurrenceRule.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        quantityOfMonths: Option.none(),
        day: Option.none(),
        name: Option.none(),
      };
      tainted = {
        quantityOfMonths: Option.none(),
        day: Option.none(),
        name: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<MonthlyRecurrenceRule, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const quantityOfMonthsStr = formData.get("quantityOfMonths");
      obj.quantityOfMonths = quantityOfMonthsStr
        ? parseFloat(quantityOfMonthsStr as string)
        : 0;
      if (
        obj.quantityOfMonths !== undefined &&
        isNaN(obj.quantityOfMonths as number)
      )
        obj.quantityOfMonths = 0;
    }
    {
      const dayStr = formData.get("day");
      obj.day = dayStr ? parseFloat(dayStr as string) : 0;
      if (obj.day !== undefined && isNaN(obj.day as number)) obj.day = 0;
    }
    obj.name = formData.get("name") ?? "";
    return MonthlyRecurrenceRule.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Represents {
  /** @default("") */
  in: string | Employee;
  /** @default("") */
  out: string | Account;
  id: string;
  dateStarted: string;
}

export function defaultValueRepresents(): Represents {
  return { in: "", out: "", id: "", dateStarted: "" } as Represents;
}

export function toStringifiedJSONRepresents(value: Represents): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeRepresents(value, ctx));
}
export function toObjectRepresents(value: Represents): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeRepresents(value, ctx);
}
export function __serializeRepresents(
  value: Represents,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Represents", __id };
  result["in"] = value.in;
  result["out"] = value.out;
  result["id"] = value.id;
  result["dateStarted"] = value.dateStarted;
  return result;
}

export function fromStringifiedJSONRepresents(
  json: string,
  opts?: DeserializeOptions,
): Result<Represents, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectRepresents(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectRepresents(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Represents, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeRepresents(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Represents.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeRepresents(
  value: any,
  ctx: DeserializeContext,
): Represents | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "Represents.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("in" in obj)) {
    errors.push({ field: "in", message: "missing required field" });
  }
  if (!("out" in obj)) {
    errors.push({ field: "out", message: "missing required field" });
  }
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("dateStarted" in obj)) {
    errors.push({ field: "dateStarted", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_in = obj["in"] as string | Employee;
    instance.in = __raw_in;
  }
  {
    const __raw_out = obj["out"] as string | Account;
    instance.out = __raw_out;
  }
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_dateStarted = obj["dateStarted"] as string;
    instance.dateStarted = __raw_dateStarted;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Represents;
}
export function validateFieldRepresents<K extends keyof Represents>(
  field: K,
  value: Represents[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsRepresents(
  partial: Partial<Represents>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isRepresents(obj: unknown): obj is Represents {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "in" in o && "out" in o && "id" in o && "dateStarted" in o;
}

export namespace Represents {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    in: Option<Array<string>>;
    out: Option<Array<string>>;
    id: Option<Array<string>>;
    dateStarted: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      in: Option<boolean>;
      out: Option<boolean>;
      id: Option<boolean>;
      dateStarted: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly in: FieldController<string | Employee>;
    readonly out: FieldController<string | Account>;
    readonly id: FieldController<string>;
    readonly dateStarted: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Represents;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Represents, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Represents>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Represents>,
  ): Gigaform {
    let data = $state({ ...Represents.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      in: Option.none(),
      out: Option.none(),
      id: Option.none(),
      dateStarted: Option.none(),
    });
    let tainted = $state<Tainted>({
      in: Option.none(),
      out: Option.none(),
      id: Option.none(),
      dateStarted: Option.none(),
    });
    const fields: FieldControllers = {
      in: {
        path: ["in"] as const,
        name: "in",
        constraints: { required: true },

        get: () => data.in,
        set: (value: string | Employee) => {
          data.in = value;
        },
        transform: (value: string | Employee): string | Employee => value,
        getError: () => errors.in,
        setError: (value: Option<Array<string>>) => {
          errors.in = value;
        },
        getTainted: () => tainted.in,
        setTainted: (value: Option<boolean>) => {
          tainted.in = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Represents.validateField("in", data.in);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      out: {
        path: ["out"] as const,
        name: "out",
        constraints: { required: true },

        get: () => data.out,
        set: (value: string | Account) => {
          data.out = value;
        },
        transform: (value: string | Account): string | Account => value,
        getError: () => errors.out,
        setError: (value: Option<Array<string>>) => {
          errors.out = value;
        },
        getTainted: () => tainted.out,
        setTainted: (value: Option<boolean>) => {
          tainted.out = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Represents.validateField("out", data.out);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Represents.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      dateStarted: {
        path: ["dateStarted"] as const,
        name: "dateStarted",
        constraints: { required: true },

        get: () => data.dateStarted,
        set: (value: string) => {
          data.dateStarted = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.dateStarted,
        setError: (value: Option<Array<string>>) => {
          errors.dateStarted = value;
        },
        getTainted: () => tainted.dateStarted,
        setTainted: (value: Option<boolean>) => {
          tainted.dateStarted = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Represents.validateField(
            "dateStarted",
            data.dateStarted,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Represents,
      Array<{ field: string; message: string }>
    > {
      return Represents.fromObject(data);
    }
    function reset(newOverrides?: Partial<Represents>): void {
      data = { ...Represents.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        in: Option.none(),
        out: Option.none(),
        id: Option.none(),
        dateStarted: Option.none(),
      };
      tainted = {
        in: Option.none(),
        out: Option.none(),
        id: Option.none(),
        dateStarted: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Represents, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.in = formData.get("in") ?? "";
    obj.out = formData.get("out") ?? "";
    obj.id = formData.get("id") ?? "";
    obj.dateStarted = formData.get("dateStarted") ?? "";
    return Represents.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Payment {
  id: string;
  date: string;
}

export function defaultValuePayment(): Payment {
  return { id: "", date: "" } as Payment;
}

export function toStringifiedJSONPayment(value: Payment): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializePayment(value, ctx));
}
export function toObjectPayment(value: Payment): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializePayment(value, ctx);
}
export function __serializePayment(
  value: Payment,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Payment", __id };
  result["id"] = value.id;
  result["date"] = value.date;
  return result;
}

export function fromStringifiedJSONPayment(
  json: string,
  opts?: DeserializeOptions,
): Result<Payment, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectPayment(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectPayment(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Payment, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializePayment(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Payment.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializePayment(
  value: any,
  ctx: DeserializeContext,
): Payment | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Payment.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("date" in obj)) {
    errors.push({ field: "date", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_date = obj["date"] as string;
    instance.date = __raw_date;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Payment;
}
export function validateFieldPayment<K extends keyof Payment>(
  field: K,
  value: Payment[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsPayment(
  partial: Partial<Payment>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isPayment(obj: unknown): obj is Payment {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "id" in o && "date" in o;
}

export namespace Payment {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    date: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { id: Option<boolean>; date: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly date: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Payment;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Payment, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Payment>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Payment>,
  ): Gigaform {
    let data = $state({ ...Payment.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      date: Option.none(),
    });
    let tainted = $state<Tainted>({ id: Option.none(), date: Option.none() });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Payment.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      date: {
        path: ["date"] as const,
        name: "date",
        constraints: { required: true },

        get: () => data.date,
        set: (value: string) => {
          data.date = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.date,
        setError: (value: Option<Array<string>>) => {
          errors.date = value;
        },
        getTainted: () => tainted.date,
        setTainted: (value: Option<boolean>) => {
          tainted.date = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Payment.validateField("date", data.date);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Payment,
      Array<{ field: string; message: string }>
    > {
      return Payment.fromObject(data);
    }
    function reset(newOverrides?: Partial<Payment>): void {
      data = { ...Payment.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        date: Option.none(),
      };
      tainted = { id: Option.none(), date: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Payment, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.date = formData.get("date") ?? "";
    return Payment.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Settings {
  appointmentNotifications: AppointmentNotifications | null;
  commissions: Commissions | null;
  scheduleSettings: ScheduleSettings;
  accountOverviewSettings: OverviewSettings;
  serviceOverviewSettings: OverviewSettings;
  appointmentOverviewSettings: OverviewSettings;
  leadOverviewSettings: OverviewSettings;
  packageOverviewSettings: OverviewSettings;
  productOverviewSettings: OverviewSettings;
  orderOverviewSettings: OverviewSettings;
  taxRateOverviewSettings: OverviewSettings;
  /** @default("UserHome") */
  homePage: Page;
}

export function defaultValueSettings(): Settings {
  return {
    appointmentNotifications: null,
    commissions: null,
    scheduleSettings: ScheduleSettings.defaultValue(),
    accountOverviewSettings: OverviewSettings.defaultValue(),
    serviceOverviewSettings: OverviewSettings.defaultValue(),
    appointmentOverviewSettings: OverviewSettings.defaultValue(),
    leadOverviewSettings: OverviewSettings.defaultValue(),
    packageOverviewSettings: OverviewSettings.defaultValue(),
    productOverviewSettings: OverviewSettings.defaultValue(),
    orderOverviewSettings: OverviewSettings.defaultValue(),
    taxRateOverviewSettings: OverviewSettings.defaultValue(),
    homePage: "UserHome",
  } as Settings;
}

export function toStringifiedJSONSettings(value: Settings): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeSettings(value, ctx));
}
export function toObjectSettings(value: Settings): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeSettings(value, ctx);
}
export function __serializeSettings(
  value: Settings,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Settings", __id };
  if (value.appointmentNotifications !== null) {
    result["appointmentNotifications"] =
      typeof (value.appointmentNotifications as any)?.__serialize === "function"
        ? (value.appointmentNotifications as any).__serialize(ctx)
        : value.appointmentNotifications;
  } else {
    result["appointmentNotifications"] = null;
  }
  if (value.commissions !== null) {
    result["commissions"] =
      typeof (value.commissions as any)?.__serialize === "function"
        ? (value.commissions as any).__serialize(ctx)
        : value.commissions;
  } else {
    result["commissions"] = null;
  }
  result["scheduleSettings"] =
    typeof (value.scheduleSettings as any)?.__serialize === "function"
      ? (value.scheduleSettings as any).__serialize(ctx)
      : value.scheduleSettings;
  result["accountOverviewSettings"] =
    typeof (value.accountOverviewSettings as any)?.__serialize === "function"
      ? (value.accountOverviewSettings as any).__serialize(ctx)
      : value.accountOverviewSettings;
  result["serviceOverviewSettings"] =
    typeof (value.serviceOverviewSettings as any)?.__serialize === "function"
      ? (value.serviceOverviewSettings as any).__serialize(ctx)
      : value.serviceOverviewSettings;
  result["appointmentOverviewSettings"] =
    typeof (value.appointmentOverviewSettings as any)?.__serialize ===
    "function"
      ? (value.appointmentOverviewSettings as any).__serialize(ctx)
      : value.appointmentOverviewSettings;
  result["leadOverviewSettings"] =
    typeof (value.leadOverviewSettings as any)?.__serialize === "function"
      ? (value.leadOverviewSettings as any).__serialize(ctx)
      : value.leadOverviewSettings;
  result["packageOverviewSettings"] =
    typeof (value.packageOverviewSettings as any)?.__serialize === "function"
      ? (value.packageOverviewSettings as any).__serialize(ctx)
      : value.packageOverviewSettings;
  result["productOverviewSettings"] =
    typeof (value.productOverviewSettings as any)?.__serialize === "function"
      ? (value.productOverviewSettings as any).__serialize(ctx)
      : value.productOverviewSettings;
  result["orderOverviewSettings"] =
    typeof (value.orderOverviewSettings as any)?.__serialize === "function"
      ? (value.orderOverviewSettings as any).__serialize(ctx)
      : value.orderOverviewSettings;
  result["taxRateOverviewSettings"] =
    typeof (value.taxRateOverviewSettings as any)?.__serialize === "function"
      ? (value.taxRateOverviewSettings as any).__serialize(ctx)
      : value.taxRateOverviewSettings;
  result["homePage"] =
    typeof (value.homePage as any)?.__serialize === "function"
      ? (value.homePage as any).__serialize(ctx)
      : value.homePage;
  return result;
}

export function fromStringifiedJSONSettings(
  json: string,
  opts?: DeserializeOptions,
): Result<Settings, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectSettings(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectSettings(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Settings, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeSettings(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Settings.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeSettings(
  value: any,
  ctx: DeserializeContext,
): Settings | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Settings.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("appointmentNotifications" in obj)) {
    errors.push({
      field: "appointmentNotifications",
      message: "missing required field",
    });
  }
  if (!("commissions" in obj)) {
    errors.push({ field: "commissions", message: "missing required field" });
  }
  if (!("scheduleSettings" in obj)) {
    errors.push({
      field: "scheduleSettings",
      message: "missing required field",
    });
  }
  if (!("accountOverviewSettings" in obj)) {
    errors.push({
      field: "accountOverviewSettings",
      message: "missing required field",
    });
  }
  if (!("serviceOverviewSettings" in obj)) {
    errors.push({
      field: "serviceOverviewSettings",
      message: "missing required field",
    });
  }
  if (!("appointmentOverviewSettings" in obj)) {
    errors.push({
      field: "appointmentOverviewSettings",
      message: "missing required field",
    });
  }
  if (!("leadOverviewSettings" in obj)) {
    errors.push({
      field: "leadOverviewSettings",
      message: "missing required field",
    });
  }
  if (!("packageOverviewSettings" in obj)) {
    errors.push({
      field: "packageOverviewSettings",
      message: "missing required field",
    });
  }
  if (!("productOverviewSettings" in obj)) {
    errors.push({
      field: "productOverviewSettings",
      message: "missing required field",
    });
  }
  if (!("orderOverviewSettings" in obj)) {
    errors.push({
      field: "orderOverviewSettings",
      message: "missing required field",
    });
  }
  if (!("taxRateOverviewSettings" in obj)) {
    errors.push({
      field: "taxRateOverviewSettings",
      message: "missing required field",
    });
  }
  if (!("homePage" in obj)) {
    errors.push({ field: "homePage", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_appointmentNotifications = obj[
      "appointmentNotifications"
    ] as AppointmentNotifications | null;
    if (__raw_appointmentNotifications === null) {
      instance.appointmentNotifications = null;
    } else if (
      typeof (__raw_appointmentNotifications as any)?.__ref !== "undefined"
    ) {
      const __result = ctx.getOrDefer(
        (__raw_appointmentNotifications as any).__ref,
      );
      ctx.assignOrDefer(instance, "appointmentNotifications", __result);
    } else {
      instance.appointmentNotifications = __raw_appointmentNotifications;
    }
  }
  {
    const __raw_commissions = obj["commissions"] as Commissions | null;
    if (__raw_commissions === null) {
      instance.commissions = null;
    } else if (typeof (__raw_commissions as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_commissions as any).__ref);
      ctx.assignOrDefer(instance, "commissions", __result);
    } else {
      instance.commissions = __raw_commissions;
    }
  }
  {
    const __raw_scheduleSettings = obj["scheduleSettings"] as ScheduleSettings;
    if (typeof (ScheduleSettings as any)?.__deserialize === "function") {
      const __result = (ScheduleSettings as any).__deserialize(
        __raw_scheduleSettings,
        ctx,
      );
      ctx.assignOrDefer(instance, "scheduleSettings", __result);
    } else {
      instance.scheduleSettings = __raw_scheduleSettings;
    }
  }
  {
    const __raw_accountOverviewSettings = obj[
      "accountOverviewSettings"
    ] as OverviewSettings;
    if (typeof (OverviewSettings as any)?.__deserialize === "function") {
      const __result = (OverviewSettings as any).__deserialize(
        __raw_accountOverviewSettings,
        ctx,
      );
      ctx.assignOrDefer(instance, "accountOverviewSettings", __result);
    } else {
      instance.accountOverviewSettings = __raw_accountOverviewSettings;
    }
  }
  {
    const __raw_serviceOverviewSettings = obj[
      "serviceOverviewSettings"
    ] as OverviewSettings;
    if (typeof (OverviewSettings as any)?.__deserialize === "function") {
      const __result = (OverviewSettings as any).__deserialize(
        __raw_serviceOverviewSettings,
        ctx,
      );
      ctx.assignOrDefer(instance, "serviceOverviewSettings", __result);
    } else {
      instance.serviceOverviewSettings = __raw_serviceOverviewSettings;
    }
  }
  {
    const __raw_appointmentOverviewSettings = obj[
      "appointmentOverviewSettings"
    ] as OverviewSettings;
    if (typeof (OverviewSettings as any)?.__deserialize === "function") {
      const __result = (OverviewSettings as any).__deserialize(
        __raw_appointmentOverviewSettings,
        ctx,
      );
      ctx.assignOrDefer(instance, "appointmentOverviewSettings", __result);
    } else {
      instance.appointmentOverviewSettings = __raw_appointmentOverviewSettings;
    }
  }
  {
    const __raw_leadOverviewSettings = obj[
      "leadOverviewSettings"
    ] as OverviewSettings;
    if (typeof (OverviewSettings as any)?.__deserialize === "function") {
      const __result = (OverviewSettings as any).__deserialize(
        __raw_leadOverviewSettings,
        ctx,
      );
      ctx.assignOrDefer(instance, "leadOverviewSettings", __result);
    } else {
      instance.leadOverviewSettings = __raw_leadOverviewSettings;
    }
  }
  {
    const __raw_packageOverviewSettings = obj[
      "packageOverviewSettings"
    ] as OverviewSettings;
    if (typeof (OverviewSettings as any)?.__deserialize === "function") {
      const __result = (OverviewSettings as any).__deserialize(
        __raw_packageOverviewSettings,
        ctx,
      );
      ctx.assignOrDefer(instance, "packageOverviewSettings", __result);
    } else {
      instance.packageOverviewSettings = __raw_packageOverviewSettings;
    }
  }
  {
    const __raw_productOverviewSettings = obj[
      "productOverviewSettings"
    ] as OverviewSettings;
    if (typeof (OverviewSettings as any)?.__deserialize === "function") {
      const __result = (OverviewSettings as any).__deserialize(
        __raw_productOverviewSettings,
        ctx,
      );
      ctx.assignOrDefer(instance, "productOverviewSettings", __result);
    } else {
      instance.productOverviewSettings = __raw_productOverviewSettings;
    }
  }
  {
    const __raw_orderOverviewSettings = obj[
      "orderOverviewSettings"
    ] as OverviewSettings;
    if (typeof (OverviewSettings as any)?.__deserialize === "function") {
      const __result = (OverviewSettings as any).__deserialize(
        __raw_orderOverviewSettings,
        ctx,
      );
      ctx.assignOrDefer(instance, "orderOverviewSettings", __result);
    } else {
      instance.orderOverviewSettings = __raw_orderOverviewSettings;
    }
  }
  {
    const __raw_taxRateOverviewSettings = obj[
      "taxRateOverviewSettings"
    ] as OverviewSettings;
    if (typeof (OverviewSettings as any)?.__deserialize === "function") {
      const __result = (OverviewSettings as any).__deserialize(
        __raw_taxRateOverviewSettings,
        ctx,
      );
      ctx.assignOrDefer(instance, "taxRateOverviewSettings", __result);
    } else {
      instance.taxRateOverviewSettings = __raw_taxRateOverviewSettings;
    }
  }
  {
    const __raw_homePage = obj["homePage"] as Page;
    if (typeof (Page as any)?.__deserialize === "function") {
      const __result = (Page as any).__deserialize(__raw_homePage, ctx);
      ctx.assignOrDefer(instance, "homePage", __result);
    } else {
      instance.homePage = __raw_homePage;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Settings;
}
export function validateFieldSettings<K extends keyof Settings>(
  field: K,
  value: Settings[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsSettings(
  partial: Partial<Settings>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isSettings(obj: unknown): obj is Settings {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "appointmentNotifications" in o &&
    "commissions" in o &&
    "scheduleSettings" in o &&
    "accountOverviewSettings" in o &&
    "serviceOverviewSettings" in o &&
    "appointmentOverviewSettings" in o &&
    "leadOverviewSettings" in o &&
    "packageOverviewSettings" in o &&
    "productOverviewSettings" in o &&
    "orderOverviewSettings" in o &&
    "taxRateOverviewSettings" in o &&
    "homePage" in o
  );
}

export namespace Settings {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    appointmentNotifications: Option<Array<string>>;
    commissions: Option<Array<string>>;
    scheduleSettings: Option<Array<string>>;
    accountOverviewSettings: Option<Array<string>>;
    serviceOverviewSettings: Option<Array<string>>;
    appointmentOverviewSettings: Option<Array<string>>;
    leadOverviewSettings: Option<Array<string>>;
    packageOverviewSettings: Option<Array<string>>;
    productOverviewSettings: Option<Array<string>>;
    orderOverviewSettings: Option<Array<string>>;
    taxRateOverviewSettings: Option<Array<string>>;
    homePage: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      appointmentNotifications: Option<boolean>;
      commissions: Option<boolean>;
      scheduleSettings: Option<boolean>;
      accountOverviewSettings: Option<boolean>;
      serviceOverviewSettings: Option<boolean>;
      appointmentOverviewSettings: Option<boolean>;
      leadOverviewSettings: Option<boolean>;
      packageOverviewSettings: Option<boolean>;
      productOverviewSettings: Option<boolean>;
      orderOverviewSettings: Option<boolean>;
      taxRateOverviewSettings: Option<boolean>;
      homePage: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly appointmentNotifications: FieldController<AppointmentNotifications | null>;
    readonly commissions: FieldController<Commissions | null>;
    readonly scheduleSettings: FieldController<ScheduleSettings>;
    readonly accountOverviewSettings: FieldController<OverviewSettings>;
    readonly serviceOverviewSettings: FieldController<OverviewSettings>;
    readonly appointmentOverviewSettings: FieldController<OverviewSettings>;
    readonly leadOverviewSettings: FieldController<OverviewSettings>;
    readonly packageOverviewSettings: FieldController<OverviewSettings>;
    readonly productOverviewSettings: FieldController<OverviewSettings>;
    readonly orderOverviewSettings: FieldController<OverviewSettings>;
    readonly taxRateOverviewSettings: FieldController<OverviewSettings>;
    readonly homePage: FieldController<Page>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Settings;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Settings, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Settings>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Settings>,
  ): Gigaform {
    let data = $state({ ...Settings.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      appointmentNotifications: Option.none(),
      commissions: Option.none(),
      scheduleSettings: Option.none(),
      accountOverviewSettings: Option.none(),
      serviceOverviewSettings: Option.none(),
      appointmentOverviewSettings: Option.none(),
      leadOverviewSettings: Option.none(),
      packageOverviewSettings: Option.none(),
      productOverviewSettings: Option.none(),
      orderOverviewSettings: Option.none(),
      taxRateOverviewSettings: Option.none(),
      homePage: Option.none(),
    });
    let tainted = $state<Tainted>({
      appointmentNotifications: Option.none(),
      commissions: Option.none(),
      scheduleSettings: Option.none(),
      accountOverviewSettings: Option.none(),
      serviceOverviewSettings: Option.none(),
      appointmentOverviewSettings: Option.none(),
      leadOverviewSettings: Option.none(),
      packageOverviewSettings: Option.none(),
      productOverviewSettings: Option.none(),
      orderOverviewSettings: Option.none(),
      taxRateOverviewSettings: Option.none(),
      homePage: Option.none(),
    });
    const fields: FieldControllers = {
      appointmentNotifications: {
        path: ["appointmentNotifications"] as const,
        name: "appointmentNotifications",
        constraints: { required: true },

        get: () => data.appointmentNotifications,
        set: (value: AppointmentNotifications | null) => {
          data.appointmentNotifications = value;
        },
        transform: (
          value: AppointmentNotifications | null,
        ): AppointmentNotifications | null => value,
        getError: () => errors.appointmentNotifications,
        setError: (value: Option<Array<string>>) => {
          errors.appointmentNotifications = value;
        },
        getTainted: () => tainted.appointmentNotifications,
        setTainted: (value: Option<boolean>) => {
          tainted.appointmentNotifications = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Settings.validateField(
            "appointmentNotifications",
            data.appointmentNotifications,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      commissions: {
        path: ["commissions"] as const,
        name: "commissions",
        constraints: { required: true },

        get: () => data.commissions,
        set: (value: Commissions | null) => {
          data.commissions = value;
        },
        transform: (value: Commissions | null): Commissions | null => value,
        getError: () => errors.commissions,
        setError: (value: Option<Array<string>>) => {
          errors.commissions = value;
        },
        getTainted: () => tainted.commissions,
        setTainted: (value: Option<boolean>) => {
          tainted.commissions = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Settings.validateField(
            "commissions",
            data.commissions,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      scheduleSettings: {
        path: ["scheduleSettings"] as const,
        name: "scheduleSettings",
        constraints: { required: true },

        get: () => data.scheduleSettings,
        set: (value: ScheduleSettings) => {
          data.scheduleSettings = value;
        },
        transform: (value: ScheduleSettings): ScheduleSettings => value,
        getError: () => errors.scheduleSettings,
        setError: (value: Option<Array<string>>) => {
          errors.scheduleSettings = value;
        },
        getTainted: () => tainted.scheduleSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.scheduleSettings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Settings.validateField(
            "scheduleSettings",
            data.scheduleSettings,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      accountOverviewSettings: {
        path: ["accountOverviewSettings"] as const,
        name: "accountOverviewSettings",
        constraints: { required: true },

        get: () => data.accountOverviewSettings,
        set: (value: OverviewSettings) => {
          data.accountOverviewSettings = value;
        },
        transform: (value: OverviewSettings): OverviewSettings => value,
        getError: () => errors.accountOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.accountOverviewSettings = value;
        },
        getTainted: () => tainted.accountOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.accountOverviewSettings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Settings.validateField(
            "accountOverviewSettings",
            data.accountOverviewSettings,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      serviceOverviewSettings: {
        path: ["serviceOverviewSettings"] as const,
        name: "serviceOverviewSettings",
        constraints: { required: true },

        get: () => data.serviceOverviewSettings,
        set: (value: OverviewSettings) => {
          data.serviceOverviewSettings = value;
        },
        transform: (value: OverviewSettings): OverviewSettings => value,
        getError: () => errors.serviceOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.serviceOverviewSettings = value;
        },
        getTainted: () => tainted.serviceOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.serviceOverviewSettings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Settings.validateField(
            "serviceOverviewSettings",
            data.serviceOverviewSettings,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      appointmentOverviewSettings: {
        path: ["appointmentOverviewSettings"] as const,
        name: "appointmentOverviewSettings",
        constraints: { required: true },

        get: () => data.appointmentOverviewSettings,
        set: (value: OverviewSettings) => {
          data.appointmentOverviewSettings = value;
        },
        transform: (value: OverviewSettings): OverviewSettings => value,
        getError: () => errors.appointmentOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.appointmentOverviewSettings = value;
        },
        getTainted: () => tainted.appointmentOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.appointmentOverviewSettings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Settings.validateField(
            "appointmentOverviewSettings",
            data.appointmentOverviewSettings,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      leadOverviewSettings: {
        path: ["leadOverviewSettings"] as const,
        name: "leadOverviewSettings",
        constraints: { required: true },

        get: () => data.leadOverviewSettings,
        set: (value: OverviewSettings) => {
          data.leadOverviewSettings = value;
        },
        transform: (value: OverviewSettings): OverviewSettings => value,
        getError: () => errors.leadOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.leadOverviewSettings = value;
        },
        getTainted: () => tainted.leadOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.leadOverviewSettings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Settings.validateField(
            "leadOverviewSettings",
            data.leadOverviewSettings,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      packageOverviewSettings: {
        path: ["packageOverviewSettings"] as const,
        name: "packageOverviewSettings",
        constraints: { required: true },

        get: () => data.packageOverviewSettings,
        set: (value: OverviewSettings) => {
          data.packageOverviewSettings = value;
        },
        transform: (value: OverviewSettings): OverviewSettings => value,
        getError: () => errors.packageOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.packageOverviewSettings = value;
        },
        getTainted: () => tainted.packageOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.packageOverviewSettings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Settings.validateField(
            "packageOverviewSettings",
            data.packageOverviewSettings,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      productOverviewSettings: {
        path: ["productOverviewSettings"] as const,
        name: "productOverviewSettings",
        constraints: { required: true },

        get: () => data.productOverviewSettings,
        set: (value: OverviewSettings) => {
          data.productOverviewSettings = value;
        },
        transform: (value: OverviewSettings): OverviewSettings => value,
        getError: () => errors.productOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.productOverviewSettings = value;
        },
        getTainted: () => tainted.productOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.productOverviewSettings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Settings.validateField(
            "productOverviewSettings",
            data.productOverviewSettings,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      orderOverviewSettings: {
        path: ["orderOverviewSettings"] as const,
        name: "orderOverviewSettings",
        constraints: { required: true },

        get: () => data.orderOverviewSettings,
        set: (value: OverviewSettings) => {
          data.orderOverviewSettings = value;
        },
        transform: (value: OverviewSettings): OverviewSettings => value,
        getError: () => errors.orderOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.orderOverviewSettings = value;
        },
        getTainted: () => tainted.orderOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.orderOverviewSettings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Settings.validateField(
            "orderOverviewSettings",
            data.orderOverviewSettings,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      taxRateOverviewSettings: {
        path: ["taxRateOverviewSettings"] as const,
        name: "taxRateOverviewSettings",
        constraints: { required: true },

        get: () => data.taxRateOverviewSettings,
        set: (value: OverviewSettings) => {
          data.taxRateOverviewSettings = value;
        },
        transform: (value: OverviewSettings): OverviewSettings => value,
        getError: () => errors.taxRateOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.taxRateOverviewSettings = value;
        },
        getTainted: () => tainted.taxRateOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.taxRateOverviewSettings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Settings.validateField(
            "taxRateOverviewSettings",
            data.taxRateOverviewSettings,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      homePage: {
        path: ["homePage"] as const,
        name: "homePage",
        constraints: { required: true },

        get: () => data.homePage,
        set: (value: Page) => {
          data.homePage = value;
        },
        transform: (value: Page): Page => value,
        getError: () => errors.homePage,
        setError: (value: Option<Array<string>>) => {
          errors.homePage = value;
        },
        getTainted: () => tainted.homePage,
        setTainted: (value: Option<boolean>) => {
          tainted.homePage = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Settings.validateField("homePage", data.homePage);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Settings,
      Array<{ field: string; message: string }>
    > {
      return Settings.fromObject(data);
    }
    function reset(newOverrides?: Partial<Settings>): void {
      data = { ...Settings.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        appointmentNotifications: Option.none(),
        commissions: Option.none(),
        scheduleSettings: Option.none(),
        accountOverviewSettings: Option.none(),
        serviceOverviewSettings: Option.none(),
        appointmentOverviewSettings: Option.none(),
        leadOverviewSettings: Option.none(),
        packageOverviewSettings: Option.none(),
        productOverviewSettings: Option.none(),
        orderOverviewSettings: Option.none(),
        taxRateOverviewSettings: Option.none(),
        homePage: Option.none(),
      };
      tainted = {
        appointmentNotifications: Option.none(),
        commissions: Option.none(),
        scheduleSettings: Option.none(),
        accountOverviewSettings: Option.none(),
        serviceOverviewSettings: Option.none(),
        appointmentOverviewSettings: Option.none(),
        leadOverviewSettings: Option.none(),
        packageOverviewSettings: Option.none(),
        productOverviewSettings: Option.none(),
        orderOverviewSettings: Option.none(),
        taxRateOverviewSettings: Option.none(),
        homePage: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Settings, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.appointmentNotifications =
      formData.get("appointmentNotifications") ?? "";
    obj.commissions = formData.get("commissions") ?? "";
    {
      // Collect nested object fields with prefix "scheduleSettings."
      const scheduleSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("scheduleSettings.")) {
          const fieldName = key.slice("scheduleSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = scheduleSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.scheduleSettings = scheduleSettingsObj;
    }
    {
      // Collect nested object fields with prefix "accountOverviewSettings."
      const accountOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("accountOverviewSettings.")) {
          const fieldName = key.slice("accountOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = accountOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.accountOverviewSettings = accountOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "serviceOverviewSettings."
      const serviceOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("serviceOverviewSettings.")) {
          const fieldName = key.slice("serviceOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = serviceOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.serviceOverviewSettings = serviceOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "appointmentOverviewSettings."
      const appointmentOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("appointmentOverviewSettings.")) {
          const fieldName = key.slice("appointmentOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = appointmentOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.appointmentOverviewSettings = appointmentOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "leadOverviewSettings."
      const leadOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("leadOverviewSettings.")) {
          const fieldName = key.slice("leadOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = leadOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.leadOverviewSettings = leadOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "packageOverviewSettings."
      const packageOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("packageOverviewSettings.")) {
          const fieldName = key.slice("packageOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = packageOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.packageOverviewSettings = packageOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "productOverviewSettings."
      const productOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("productOverviewSettings.")) {
          const fieldName = key.slice("productOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = productOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.productOverviewSettings = productOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "orderOverviewSettings."
      const orderOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("orderOverviewSettings.")) {
          const fieldName = key.slice("orderOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = orderOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.orderOverviewSettings = orderOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "taxRateOverviewSettings."
      const taxRateOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("taxRateOverviewSettings.")) {
          const fieldName = key.slice("taxRateOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = taxRateOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.taxRateOverviewSettings = taxRateOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "homePage."
      const homePageObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("homePage.")) {
          const fieldName = key.slice("homePage.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = homePageObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.homePage = homePageObj;
    }
    return Settings.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Color {
  red: number;
  green: number;
  blue: number;
}

export function defaultValueColor(): Color {
  return { red: 0, green: 0, blue: 0 } as Color;
}

export function toStringifiedJSONColor(value: Color): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeColor(value, ctx));
}
export function toObjectColor(value: Color): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeColor(value, ctx);
}
export function __serializeColor(
  value: Color,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Color", __id };
  result["red"] = value.red;
  result["green"] = value.green;
  result["blue"] = value.blue;
  return result;
}

export function fromStringifiedJSONColor(
  json: string,
  opts?: DeserializeOptions,
): Result<Color, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectColor(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectColor(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Color, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeColor(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Color.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeColor(
  value: any,
  ctx: DeserializeContext,
): Color | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Color.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("red" in obj)) {
    errors.push({ field: "red", message: "missing required field" });
  }
  if (!("green" in obj)) {
    errors.push({ field: "green", message: "missing required field" });
  }
  if (!("blue" in obj)) {
    errors.push({ field: "blue", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_red = obj["red"] as number;
    instance.red = __raw_red;
  }
  {
    const __raw_green = obj["green"] as number;
    instance.green = __raw_green;
  }
  {
    const __raw_blue = obj["blue"] as number;
    instance.blue = __raw_blue;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Color;
}
export function validateFieldColor<K extends keyof Color>(
  field: K,
  value: Color[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsColor(
  partial: Partial<Color>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isColor(obj: unknown): obj is Color {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "red" in o && "green" in o && "blue" in o;
}

export namespace Color {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    red: Option<Array<string>>;
    green: Option<Array<string>>;
    blue: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { red: Option<boolean>; green: Option<boolean>; blue: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly red: FieldController<number>;
    readonly green: FieldController<number>;
    readonly blue: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Color;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Color, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Color>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Color>,
  ): Gigaform {
    let data = $state({ ...Color.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      red: Option.none(),
      green: Option.none(),
      blue: Option.none(),
    });
    let tainted = $state<Tainted>({
      red: Option.none(),
      green: Option.none(),
      blue: Option.none(),
    });
    const fields: FieldControllers = {
      red: {
        path: ["red"] as const,
        name: "red",
        constraints: { required: true },

        get: () => data.red,
        set: (value: number) => {
          data.red = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.red,
        setError: (value: Option<Array<string>>) => {
          errors.red = value;
        },
        getTainted: () => tainted.red,
        setTainted: (value: Option<boolean>) => {
          tainted.red = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Color.validateField("red", data.red);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      green: {
        path: ["green"] as const,
        name: "green",
        constraints: { required: true },

        get: () => data.green,
        set: (value: number) => {
          data.green = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.green,
        setError: (value: Option<Array<string>>) => {
          errors.green = value;
        },
        getTainted: () => tainted.green,
        setTainted: (value: Option<boolean>) => {
          tainted.green = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Color.validateField("green", data.green);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      blue: {
        path: ["blue"] as const,
        name: "blue",
        constraints: { required: true },

        get: () => data.blue,
        set: (value: number) => {
          data.blue = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.blue,
        setError: (value: Option<Array<string>>) => {
          errors.blue = value;
        },
        getTainted: () => tainted.blue,
        setTainted: (value: Option<boolean>) => {
          tainted.blue = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Color.validateField("blue", data.blue);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Color,
      Array<{ field: string; message: string }>
    > {
      return Color.fromObject(data);
    }
    function reset(newOverrides?: Partial<Color>): void {
      data = { ...Color.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        red: Option.none(),
        green: Option.none(),
        blue: Option.none(),
      };
      tainted = {
        red: Option.none(),
        green: Option.none(),
        blue: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Color, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const redStr = formData.get("red");
      obj.red = redStr ? parseFloat(redStr as string) : 0;
      if (obj.red !== undefined && isNaN(obj.red as number)) obj.red = 0;
    }
    {
      const greenStr = formData.get("green");
      obj.green = greenStr ? parseFloat(greenStr as string) : 0;
      if (obj.green !== undefined && isNaN(obj.green as number)) obj.green = 0;
    }
    {
      const blueStr = formData.get("blue");
      obj.blue = blueStr ? parseFloat(blueStr as string) : 0;
      if (obj.blue !== undefined && isNaN(obj.blue as number)) obj.blue = 0;
    }
    return Color.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface CompanyName {
  /** @textController({ label: "Company Name" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  companyName: string;
}

export function defaultValueCompanyName(): CompanyName {
  return { companyName: "" } as CompanyName;
}

export function toStringifiedJSONCompanyName(value: CompanyName): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeCompanyName(value, ctx));
}
export function toObjectCompanyName(
  value: CompanyName,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeCompanyName(value, ctx);
}
export function __serializeCompanyName(
  value: CompanyName,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "CompanyName", __id };
  result["companyName"] = value.companyName;
  return result;
}

export function fromStringifiedJSONCompanyName(
  json: string,
  opts?: DeserializeOptions,
): Result<CompanyName, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectCompanyName(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectCompanyName(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<CompanyName, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeCompanyName(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "CompanyName.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeCompanyName(
  value: any,
  ctx: DeserializeContext,
): CompanyName | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "CompanyName.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("companyName" in obj)) {
    errors.push({ field: "companyName", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_companyName = obj["companyName"] as string;
    if (__raw_companyName.length === 0) {
      errors.push({ field: "companyName", message: "must not be empty" });
    }
    instance.companyName = __raw_companyName;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as CompanyName;
}
export function validateFieldCompanyName<K extends keyof CompanyName>(
  field: K,
  value: CompanyName[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "companyName": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "companyName", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsCompanyName(
  partial: Partial<CompanyName>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("companyName" in partial && partial.companyName !== undefined) {
    const __val = partial.companyName as string;
    if (__val.length === 0) {
      errors.push({ field: "companyName", message: "must not be empty" });
    }
  }
  return errors;
}
export function isCompanyName(obj: unknown): obj is CompanyName {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "companyName" in o;
}

export namespace CompanyName {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    companyName: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { companyName: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly companyName: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: CompanyName;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<CompanyName, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<CompanyName>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<CompanyName>,
  ): Gigaform {
    let data = $state({ ...CompanyName.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      companyName: Option.none(),
    });
    let tainted = $state<Tainted>({ companyName: Option.none() });
    const fields: FieldControllers = {
      companyName: {
        path: ["companyName"] as const,
        name: "companyName",
        constraints: { required: true },
        label: "Company Name",
        get: () => data.companyName,
        set: (value: string) => {
          data.companyName = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.companyName,
        setError: (value: Option<Array<string>>) => {
          errors.companyName = value;
        },
        getTainted: () => tainted.companyName,
        setTainted: (value: Option<boolean>) => {
          tainted.companyName = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = CompanyName.validateField(
            "companyName",
            data.companyName,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      CompanyName,
      Array<{ field: string; message: string }>
    > {
      return CompanyName.fromObject(data);
    }
    function reset(newOverrides?: Partial<CompanyName>): void {
      data = { ...CompanyName.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), companyName: Option.none() };
      tainted = { companyName: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<CompanyName, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.companyName = formData.get("companyName") ?? "";
    return CompanyName.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Appointment {
  /** @hiddenController({}) */
  id: string;
  /** @textController({ label: "Title" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  title: string;
  /** @selectController({ label: "Status", options: [{ label: "Scheduled", value: "Scheduled" }, { label: "On Deck", value: "OnDeck" }, { label: "Waiting", value: "Waiting" }] }) */
  /** @default("Scheduled") */
  status: Status;
  /** @dateTimeController({ label: "Begins" }) */
  begins: string;
  /** @numberController({ label: "Duration", min: 0 }) */
  duration: number;
  /** @textController({ label: "Time Zone" }) */
  timeZone: string;
  /** @hiddenController({}) */
  offsetMs: number;
  /** @switchController({ label: "All Day" }) */
  allDay: boolean;
  /** @switchController({ label: "Multi Day" }) */
  multiDay: boolean;
  /** @comboboxMultipleController({ label: "Employees", fetchUrls: ["/api/employees"] }) */
  employees: (string | Employee)[];
  /** @siteFieldsetController({ label: "Location" }) */
  /** @default("") */
  location: string | Site;
  /** @textAreaController({ label: "Description" }) */
  description: string | null;
  /** @hiddenController({}) */
  /** @default({ main: "#000000", hover: "#333333", active: "#666666" }) */
  colors: Colors;
  /** @hiddenController({}) */
  recurrenceRule: RecurrenceRule | null;
}

export function defaultValueAppointment(): Appointment {
  return {
    id: "",
    title: "",
    status: "Scheduled",
    begins: "",
    duration: 0,
    timeZone: "",
    offsetMs: 0,
    allDay: false,
    multiDay: false,
    employees: [],
    location: "",
    description: null,
    colors: { main: "#000000", hover: "#333333", active: "#666666" },
    recurrenceRule: null,
  } as Appointment;
}

export function toStringifiedJSONAppointment(value: Appointment): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeAppointment(value, ctx));
}
export function toObjectAppointment(
  value: Appointment,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeAppointment(value, ctx);
}
export function __serializeAppointment(
  value: Appointment,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Appointment", __id };
  result["id"] = value.id;
  result["title"] = value.title;
  result["status"] =
    typeof (value.status as any)?.__serialize === "function"
      ? (value.status as any).__serialize(ctx)
      : value.status;
  result["begins"] = value.begins;
  result["duration"] = value.duration;
  result["timeZone"] = value.timeZone;
  result["offsetMs"] = value.offsetMs;
  result["allDay"] = value.allDay;
  result["multiDay"] = value.multiDay;
  result["employees"] = value.employees.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["location"] = value.location;
  if (value.description !== null) {
    result["description"] =
      typeof (value.description as any)?.__serialize === "function"
        ? (value.description as any).__serialize(ctx)
        : value.description;
  } else {
    result["description"] = null;
  }
  result["colors"] =
    typeof (value.colors as any)?.__serialize === "function"
      ? (value.colors as any).__serialize(ctx)
      : value.colors;
  if (value.recurrenceRule !== null) {
    result["recurrenceRule"] =
      typeof (value.recurrenceRule as any)?.__serialize === "function"
        ? (value.recurrenceRule as any).__serialize(ctx)
        : value.recurrenceRule;
  } else {
    result["recurrenceRule"] = null;
  }
  return result;
}

export function fromStringifiedJSONAppointment(
  json: string,
  opts?: DeserializeOptions,
): Result<Appointment, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectAppointment(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectAppointment(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Appointment, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeAppointment(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Appointment.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeAppointment(
  value: any,
  ctx: DeserializeContext,
): Appointment | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "Appointment.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("title" in obj)) {
    errors.push({ field: "title", message: "missing required field" });
  }
  if (!("status" in obj)) {
    errors.push({ field: "status", message: "missing required field" });
  }
  if (!("begins" in obj)) {
    errors.push({ field: "begins", message: "missing required field" });
  }
  if (!("duration" in obj)) {
    errors.push({ field: "duration", message: "missing required field" });
  }
  if (!("timeZone" in obj)) {
    errors.push({ field: "timeZone", message: "missing required field" });
  }
  if (!("offsetMs" in obj)) {
    errors.push({ field: "offsetMs", message: "missing required field" });
  }
  if (!("allDay" in obj)) {
    errors.push({ field: "allDay", message: "missing required field" });
  }
  if (!("multiDay" in obj)) {
    errors.push({ field: "multiDay", message: "missing required field" });
  }
  if (!("employees" in obj)) {
    errors.push({ field: "employees", message: "missing required field" });
  }
  if (!("location" in obj)) {
    errors.push({ field: "location", message: "missing required field" });
  }
  if (!("description" in obj)) {
    errors.push({ field: "description", message: "missing required field" });
  }
  if (!("colors" in obj)) {
    errors.push({ field: "colors", message: "missing required field" });
  }
  if (!("recurrenceRule" in obj)) {
    errors.push({ field: "recurrenceRule", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_title = obj["title"] as string;
    if (__raw_title.length === 0) {
      errors.push({ field: "title", message: "must not be empty" });
    }
    instance.title = __raw_title;
  }
  {
    const __raw_status = obj["status"] as Status;
    if (typeof (Status as any)?.__deserialize === "function") {
      const __result = (Status as any).__deserialize(__raw_status, ctx);
      ctx.assignOrDefer(instance, "status", __result);
    } else {
      instance.status = __raw_status;
    }
  }
  {
    const __raw_begins = obj["begins"] as string;
    instance.begins = __raw_begins;
  }
  {
    const __raw_duration = obj["duration"] as number;
    instance.duration = __raw_duration;
  }
  {
    const __raw_timeZone = obj["timeZone"] as string;
    instance.timeZone = __raw_timeZone;
  }
  {
    const __raw_offsetMs = obj["offsetMs"] as number;
    instance.offsetMs = __raw_offsetMs;
  }
  {
    const __raw_allDay = obj["allDay"] as boolean;
    instance.allDay = __raw_allDay;
  }
  {
    const __raw_multiDay = obj["multiDay"] as boolean;
    instance.multiDay = __raw_multiDay;
  }
  {
    const __raw_employees = obj["employees"] as (string | Employee)[];
    if (Array.isArray(__raw_employees)) {
      instance.employees = __raw_employees as (string | Employee)[];
    }
  }
  {
    const __raw_location = obj["location"] as string | Site;
    instance.location = __raw_location;
  }
  {
    const __raw_description = obj["description"] as string | null;
    if (__raw_description === null) {
      instance.description = null;
    } else if (typeof (__raw_description as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_description as any).__ref);
      ctx.assignOrDefer(instance, "description", __result);
    } else {
      instance.description = __raw_description;
    }
  }
  {
    const __raw_colors = obj["colors"] as Colors;
    if (typeof (Colors as any)?.__deserialize === "function") {
      const __result = (Colors as any).__deserialize(__raw_colors, ctx);
      ctx.assignOrDefer(instance, "colors", __result);
    } else {
      instance.colors = __raw_colors;
    }
  }
  {
    const __raw_recurrenceRule = obj["recurrenceRule"] as RecurrenceRule | null;
    if (__raw_recurrenceRule === null) {
      instance.recurrenceRule = null;
    } else if (typeof (__raw_recurrenceRule as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_recurrenceRule as any).__ref);
      ctx.assignOrDefer(instance, "recurrenceRule", __result);
    } else {
      instance.recurrenceRule = __raw_recurrenceRule;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Appointment;
}
export function validateFieldAppointment<K extends keyof Appointment>(
  field: K,
  value: Appointment[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "title": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "title", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsAppointment(
  partial: Partial<Appointment>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("title" in partial && partial.title !== undefined) {
    const __val = partial.title as string;
    if (__val.length === 0) {
      errors.push({ field: "title", message: "must not be empty" });
    }
  }
  return errors;
}
export function isAppointment(obj: unknown): obj is Appointment {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "id" in o &&
    "title" in o &&
    "status" in o &&
    "begins" in o &&
    "duration" in o &&
    "timeZone" in o &&
    "offsetMs" in o &&
    "allDay" in o &&
    "multiDay" in o &&
    "employees" in o &&
    "location" in o &&
    "description" in o &&
    "colors" in o &&
    "recurrenceRule" in o
  );
}

export namespace Appointment {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    title: Option<Array<string>>;
    status: Option<Array<string>>;
    begins: Option<Array<string>>;
    duration: Option<Array<string>>;
    timeZone: Option<Array<string>>;
    offsetMs: Option<Array<string>>;
    allDay: Option<Array<string>>;
    multiDay: Option<Array<string>>;
    employees: Option<Array<string>>;
    location: Option<Array<string>>;
    description: Option<Array<string>>;
    colors: Option<Array<string>>;
    recurrenceRule: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      title: Option<boolean>;
      status: Option<boolean>;
      begins: Option<boolean>;
      duration: Option<boolean>;
      timeZone: Option<boolean>;
      offsetMs: Option<boolean>;
      allDay: Option<boolean>;
      multiDay: Option<boolean>;
      employees: Option<boolean>;
      location: Option<boolean>;
      description: Option<boolean>;
      colors: Option<boolean>;
      recurrenceRule: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly title: FieldController<string>;
    readonly status: FieldController<Status>;
    readonly begins: FieldController<string>;
    readonly duration: FieldController<number>;
    readonly timeZone: FieldController<string>;
    readonly offsetMs: FieldController<number>;
    readonly allDay: FieldController<boolean>;
    readonly multiDay: FieldController<boolean>;
    readonly employees: ArrayFieldController<string | Employee>;
    readonly location: FieldController<string | Site>;
    readonly description: FieldController<string | null>;
    readonly colors: FieldController<Colors>;
    readonly recurrenceRule: FieldController<RecurrenceRule | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Appointment;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Appointment, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Appointment>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Appointment>,
  ): Gigaform {
    let data = $state({ ...Appointment.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      title: Option.none(),
      status: Option.none(),
      begins: Option.none(),
      duration: Option.none(),
      timeZone: Option.none(),
      offsetMs: Option.none(),
      allDay: Option.none(),
      multiDay: Option.none(),
      employees: Option.none(),
      location: Option.none(),
      description: Option.none(),
      colors: Option.none(),
      recurrenceRule: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      title: Option.none(),
      status: Option.none(),
      begins: Option.none(),
      duration: Option.none(),
      timeZone: Option.none(),
      offsetMs: Option.none(),
      allDay: Option.none(),
      multiDay: Option.none(),
      employees: Option.none(),
      location: Option.none(),
      description: Option.none(),
      colors: Option.none(),
      recurrenceRule: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      title: {
        path: ["title"] as const,
        name: "title",
        constraints: { required: true },
        label: "Title",
        get: () => data.title,
        set: (value: string) => {
          data.title = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.title,
        setError: (value: Option<Array<string>>) => {
          errors.title = value;
        },
        getTainted: () => tainted.title,
        setTainted: (value: Option<boolean>) => {
          tainted.title = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField("title", data.title);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      status: {
        path: ["status"] as const,
        name: "status",
        constraints: { required: true },
        label: "Status",
        get: () => data.status,
        set: (value: Status) => {
          data.status = value;
        },
        transform: (value: Status): Status => value,
        getError: () => errors.status,
        setError: (value: Option<Array<string>>) => {
          errors.status = value;
        },
        getTainted: () => tainted.status,
        setTainted: (value: Option<boolean>) => {
          tainted.status = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField("status", data.status);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      begins: {
        path: ["begins"] as const,
        name: "begins",
        constraints: { required: true },
        label: "Begins",
        get: () => data.begins,
        set: (value: string) => {
          data.begins = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.begins,
        setError: (value: Option<Array<string>>) => {
          errors.begins = value;
        },
        getTainted: () => tainted.begins,
        setTainted: (value: Option<boolean>) => {
          tainted.begins = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField("begins", data.begins);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      duration: {
        path: ["duration"] as const,
        name: "duration",
        constraints: { required: true },
        label: "Duration",
        get: () => data.duration,
        set: (value: number) => {
          data.duration = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.duration,
        setError: (value: Option<Array<string>>) => {
          errors.duration = value;
        },
        getTainted: () => tainted.duration,
        setTainted: (value: Option<boolean>) => {
          tainted.duration = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "duration",
            data.duration,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      timeZone: {
        path: ["timeZone"] as const,
        name: "timeZone",
        constraints: { required: true },
        label: "Time Zone",
        get: () => data.timeZone,
        set: (value: string) => {
          data.timeZone = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.timeZone,
        setError: (value: Option<Array<string>>) => {
          errors.timeZone = value;
        },
        getTainted: () => tainted.timeZone,
        setTainted: (value: Option<boolean>) => {
          tainted.timeZone = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "timeZone",
            data.timeZone,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      offsetMs: {
        path: ["offsetMs"] as const,
        name: "offsetMs",
        constraints: { required: true },

        get: () => data.offsetMs,
        set: (value: number) => {
          data.offsetMs = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.offsetMs,
        setError: (value: Option<Array<string>>) => {
          errors.offsetMs = value;
        },
        getTainted: () => tainted.offsetMs,
        setTainted: (value: Option<boolean>) => {
          tainted.offsetMs = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "offsetMs",
            data.offsetMs,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      allDay: {
        path: ["allDay"] as const,
        name: "allDay",
        constraints: { required: true },
        label: "All Day",
        get: () => data.allDay,
        set: (value: boolean) => {
          data.allDay = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.allDay,
        setError: (value: Option<Array<string>>) => {
          errors.allDay = value;
        },
        getTainted: () => tainted.allDay,
        setTainted: (value: Option<boolean>) => {
          tainted.allDay = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField("allDay", data.allDay);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      multiDay: {
        path: ["multiDay"] as const,
        name: "multiDay",
        constraints: { required: true },
        label: "Multi Day",
        get: () => data.multiDay,
        set: (value: boolean) => {
          data.multiDay = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.multiDay,
        setError: (value: Option<Array<string>>) => {
          errors.multiDay = value;
        },
        getTainted: () => tainted.multiDay,
        setTainted: (value: Option<boolean>) => {
          tainted.multiDay = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "multiDay",
            data.multiDay,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      employees: {
        path: ["employees"] as const,
        name: "employees",
        constraints: { required: true },
        label: "Employees",
        get: () => data.employees,
        set: (value: (string | Employee)[]) => {
          data.employees = value;
        },
        transform: (value: (string | Employee)[]): (string | Employee)[] =>
          value,
        getError: () => errors.employees,
        setError: (value: Option<Array<string>>) => {
          errors.employees = value;
        },
        getTainted: () => tainted.employees,
        setTainted: (value: Option<boolean>) => {
          tainted.employees = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "employees",
            data.employees,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["employees", index] as const,
          name: `employees.${index}`,
          constraints: { required: true },
          get: () => data.employees[index]!,
          set: (value: string | Employee) => {
            data.employees[index] = value;
          },
          transform: (value: string | Employee): string | Employee => value,
          getError: () => errors.employees,
          setError: (value: Option<Array<string>>) => {
            errors.employees = value;
          },
          getTainted: () => tainted.employees,
          setTainted: (value: Option<boolean>) => {
            tainted.employees = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string | Employee) => {
          data.employees.push(item);
        },
        remove: (index: number) => {
          data.employees.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.employees[a]!;
          data.employees[a] = data.employees[b]!;
          data.employees[b] = tmp;
        },
      },
      location: {
        path: ["location"] as const,
        name: "location",
        constraints: { required: true },
        label: "Location",
        get: () => data.location,
        set: (value: string | Site) => {
          data.location = value;
        },
        transform: (value: string | Site): string | Site => value,
        getError: () => errors.location,
        setError: (value: Option<Array<string>>) => {
          errors.location = value;
        },
        getTainted: () => tainted.location,
        setTainted: (value: Option<boolean>) => {
          tainted.location = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "location",
            data.location,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      description: {
        path: ["description"] as const,
        name: "description",
        constraints: { required: true },
        label: "Description",
        get: () => data.description,
        set: (value: string | null) => {
          data.description = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.description,
        setError: (value: Option<Array<string>>) => {
          errors.description = value;
        },
        getTainted: () => tainted.description,
        setTainted: (value: Option<boolean>) => {
          tainted.description = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "description",
            data.description,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      colors: {
        path: ["colors"] as const,
        name: "colors",
        constraints: { required: true },

        get: () => data.colors,
        set: (value: Colors) => {
          data.colors = value;
        },
        transform: (value: Colors): Colors => value,
        getError: () => errors.colors,
        setError: (value: Option<Array<string>>) => {
          errors.colors = value;
        },
        getTainted: () => tainted.colors,
        setTainted: (value: Option<boolean>) => {
          tainted.colors = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField("colors", data.colors);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      recurrenceRule: {
        path: ["recurrenceRule"] as const,
        name: "recurrenceRule",
        constraints: { required: true },

        get: () => data.recurrenceRule,
        set: (value: RecurrenceRule | null) => {
          data.recurrenceRule = value;
        },
        transform: (value: RecurrenceRule | null): RecurrenceRule | null =>
          value,
        getError: () => errors.recurrenceRule,
        setError: (value: Option<Array<string>>) => {
          errors.recurrenceRule = value;
        },
        getTainted: () => tainted.recurrenceRule,
        setTainted: (value: Option<boolean>) => {
          tainted.recurrenceRule = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "recurrenceRule",
            data.recurrenceRule,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Appointment,
      Array<{ field: string; message: string }>
    > {
      return Appointment.fromObject(data);
    }
    function reset(newOverrides?: Partial<Appointment>): void {
      data = { ...Appointment.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        title: Option.none(),
        status: Option.none(),
        begins: Option.none(),
        duration: Option.none(),
        timeZone: Option.none(),
        offsetMs: Option.none(),
        allDay: Option.none(),
        multiDay: Option.none(),
        employees: Option.none(),
        location: Option.none(),
        description: Option.none(),
        colors: Option.none(),
        recurrenceRule: Option.none(),
      };
      tainted = {
        id: Option.none(),
        title: Option.none(),
        status: Option.none(),
        begins: Option.none(),
        duration: Option.none(),
        timeZone: Option.none(),
        offsetMs: Option.none(),
        allDay: Option.none(),
        multiDay: Option.none(),
        employees: Option.none(),
        location: Option.none(),
        description: Option.none(),
        colors: Option.none(),
        recurrenceRule: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Appointment, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.title = formData.get("title") ?? "";
    {
      // Collect nested object fields with prefix "status."
      const statusObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("status.")) {
          const fieldName = key.slice("status.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = statusObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.status = statusObj;
    }
    obj.begins = formData.get("begins") ?? "";
    {
      const durationStr = formData.get("duration");
      obj.duration = durationStr ? parseFloat(durationStr as string) : 0;
      if (obj.duration !== undefined && isNaN(obj.duration as number))
        obj.duration = 0;
    }
    obj.timeZone = formData.get("timeZone") ?? "";
    {
      const offsetMsStr = formData.get("offsetMs");
      obj.offsetMs = offsetMsStr ? parseFloat(offsetMsStr as string) : 0;
      if (obj.offsetMs !== undefined && isNaN(obj.offsetMs as number))
        obj.offsetMs = 0;
    }
    {
      const allDayVal = formData.get("allDay");
      obj.allDay =
        allDayVal === "true" || allDayVal === "on" || allDayVal === "1";
    }
    {
      const multiDayVal = formData.get("multiDay");
      obj.multiDay =
        multiDayVal === "true" || multiDayVal === "on" || multiDayVal === "1";
    }
    {
      // Collect array items from indexed form fields
      const employeesItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("employees." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("employees." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("employees." + idx + ".")) {
              const fieldName = key.slice(
                "employees.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          employeesItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.employees = employeesItems;
    }
    obj.location = formData.get("location") ?? "";
    obj.description = formData.get("description") ?? "";
    {
      // Collect nested object fields with prefix "colors."
      const colorsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("colors.")) {
          const fieldName = key.slice("colors.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = colorsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.colors = colorsObj;
    }
    obj.recurrenceRule = formData.get("recurrenceRule") ?? "";
    return Appointment.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Package {
  /** @hiddenController({}) */
  id: string;
  /** @dateTimeController({ label: "Date" }) */
  date: string;
}

export function defaultValuePackage(): Package {
  return { id: "", date: "" } as Package;
}

export function toStringifiedJSONPackage(value: Package): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializePackage(value, ctx));
}
export function toObjectPackage(value: Package): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializePackage(value, ctx);
}
export function __serializePackage(
  value: Package,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Package", __id };
  result["id"] = value.id;
  result["date"] = value.date;
  return result;
}

export function fromStringifiedJSONPackage(
  json: string,
  opts?: DeserializeOptions,
): Result<Package, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectPackage(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectPackage(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Package, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializePackage(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Package.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializePackage(
  value: any,
  ctx: DeserializeContext,
): Package | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Package.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("date" in obj)) {
    errors.push({ field: "date", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_date = obj["date"] as string;
    instance.date = __raw_date;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Package;
}
export function validateFieldPackage<K extends keyof Package>(
  field: K,
  value: Package[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsPackage(
  partial: Partial<Package>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isPackage(obj: unknown): obj is Package {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "id" in o && "date" in o;
}

export namespace Package {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    date: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { id: Option<boolean>; date: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly date: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Package;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Package, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Package>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Package>,
  ): Gigaform {
    let data = $state({ ...Package.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      date: Option.none(),
    });
    let tainted = $state<Tainted>({ id: Option.none(), date: Option.none() });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Package.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      date: {
        path: ["date"] as const,
        name: "date",
        constraints: { required: true },
        label: "Date",
        get: () => data.date,
        set: (value: string) => {
          data.date = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.date,
        setError: (value: Option<Array<string>>) => {
          errors.date = value;
        },
        getTainted: () => tainted.date,
        setTainted: (value: Option<boolean>) => {
          tainted.date = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Package.validateField("date", data.date);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Package,
      Array<{ field: string; message: string }>
    > {
      return Package.fromObject(data);
    }
    function reset(newOverrides?: Partial<Package>): void {
      data = { ...Package.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        date: Option.none(),
      };
      tainted = { id: Option.none(), date: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Package, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.date = formData.get("date") ?? "";
    return Package.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface ScheduleSettings {
  daysPerWeek: number;
  /** @default("Medium") */
  rowHeight: RowHeight;
  visibleRoutes: string[];
  detailedCards: boolean;
}

export function defaultValueScheduleSettings(): ScheduleSettings {
  return {
    daysPerWeek: 0,
    rowHeight: "Medium",
    visibleRoutes: [],
    detailedCards: false,
  } as ScheduleSettings;
}

export function toStringifiedJSONScheduleSettings(
  value: ScheduleSettings,
): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeScheduleSettings(value, ctx));
}
export function toObjectScheduleSettings(
  value: ScheduleSettings,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeScheduleSettings(value, ctx);
}
export function __serializeScheduleSettings(
  value: ScheduleSettings,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "ScheduleSettings", __id };
  result["daysPerWeek"] = value.daysPerWeek;
  result["rowHeight"] =
    typeof (value.rowHeight as any)?.__serialize === "function"
      ? (value.rowHeight as any).__serialize(ctx)
      : value.rowHeight;
  result["visibleRoutes"] = value.visibleRoutes.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["detailedCards"] = value.detailedCards;
  return result;
}

export function fromStringifiedJSONScheduleSettings(
  json: string,
  opts?: DeserializeOptions,
): Result<ScheduleSettings, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectScheduleSettings(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectScheduleSettings(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<ScheduleSettings, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeScheduleSettings(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "ScheduleSettings.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeScheduleSettings(
  value: any,
  ctx: DeserializeContext,
): ScheduleSettings | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "ScheduleSettings.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("daysPerWeek" in obj)) {
    errors.push({ field: "daysPerWeek", message: "missing required field" });
  }
  if (!("rowHeight" in obj)) {
    errors.push({ field: "rowHeight", message: "missing required field" });
  }
  if (!("visibleRoutes" in obj)) {
    errors.push({ field: "visibleRoutes", message: "missing required field" });
  }
  if (!("detailedCards" in obj)) {
    errors.push({ field: "detailedCards", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_daysPerWeek = obj["daysPerWeek"] as number;
    instance.daysPerWeek = __raw_daysPerWeek;
  }
  {
    const __raw_rowHeight = obj["rowHeight"] as RowHeight;
    if (typeof (RowHeight as any)?.__deserialize === "function") {
      const __result = (RowHeight as any).__deserialize(__raw_rowHeight, ctx);
      ctx.assignOrDefer(instance, "rowHeight", __result);
    } else {
      instance.rowHeight = __raw_rowHeight;
    }
  }
  {
    const __raw_visibleRoutes = obj["visibleRoutes"] as string[];
    if (Array.isArray(__raw_visibleRoutes)) {
      instance.visibleRoutes = __raw_visibleRoutes as string[];
    }
  }
  {
    const __raw_detailedCards = obj["detailedCards"] as boolean;
    instance.detailedCards = __raw_detailedCards;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as ScheduleSettings;
}
export function validateFieldScheduleSettings<K extends keyof ScheduleSettings>(
  field: K,
  value: ScheduleSettings[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsScheduleSettings(
  partial: Partial<ScheduleSettings>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isScheduleSettings(obj: unknown): obj is ScheduleSettings {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "daysPerWeek" in o &&
    "rowHeight" in o &&
    "visibleRoutes" in o &&
    "detailedCards" in o
  );
}

export namespace ScheduleSettings {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    daysPerWeek: Option<Array<string>>;
    rowHeight: Option<Array<string>>;
    visibleRoutes: Option<Array<string>>;
    detailedCards: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      daysPerWeek: Option<boolean>;
      rowHeight: Option<boolean>;
      visibleRoutes: Option<boolean>;
      detailedCards: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly daysPerWeek: FieldController<number>;
    readonly rowHeight: FieldController<RowHeight>;
    readonly visibleRoutes: ArrayFieldController<string>;
    readonly detailedCards: FieldController<boolean>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: ScheduleSettings;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      ScheduleSettings,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<ScheduleSettings>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<ScheduleSettings>,
  ): Gigaform {
    let data = $state({ ...ScheduleSettings.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      daysPerWeek: Option.none(),
      rowHeight: Option.none(),
      visibleRoutes: Option.none(),
      detailedCards: Option.none(),
    });
    let tainted = $state<Tainted>({
      daysPerWeek: Option.none(),
      rowHeight: Option.none(),
      visibleRoutes: Option.none(),
      detailedCards: Option.none(),
    });
    const fields: FieldControllers = {
      daysPerWeek: {
        path: ["daysPerWeek"] as const,
        name: "daysPerWeek",
        constraints: { required: true },

        get: () => data.daysPerWeek,
        set: (value: number) => {
          data.daysPerWeek = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.daysPerWeek,
        setError: (value: Option<Array<string>>) => {
          errors.daysPerWeek = value;
        },
        getTainted: () => tainted.daysPerWeek,
        setTainted: (value: Option<boolean>) => {
          tainted.daysPerWeek = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = ScheduleSettings.validateField(
            "daysPerWeek",
            data.daysPerWeek,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      rowHeight: {
        path: ["rowHeight"] as const,
        name: "rowHeight",
        constraints: { required: true },

        get: () => data.rowHeight,
        set: (value: RowHeight) => {
          data.rowHeight = value;
        },
        transform: (value: RowHeight): RowHeight => value,
        getError: () => errors.rowHeight,
        setError: (value: Option<Array<string>>) => {
          errors.rowHeight = value;
        },
        getTainted: () => tainted.rowHeight,
        setTainted: (value: Option<boolean>) => {
          tainted.rowHeight = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = ScheduleSettings.validateField(
            "rowHeight",
            data.rowHeight,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      visibleRoutes: {
        path: ["visibleRoutes"] as const,
        name: "visibleRoutes",
        constraints: { required: true },

        get: () => data.visibleRoutes,
        set: (value: string[]) => {
          data.visibleRoutes = value;
        },
        transform: (value: string[]): string[] => value,
        getError: () => errors.visibleRoutes,
        setError: (value: Option<Array<string>>) => {
          errors.visibleRoutes = value;
        },
        getTainted: () => tainted.visibleRoutes,
        setTainted: (value: Option<boolean>) => {
          tainted.visibleRoutes = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = ScheduleSettings.validateField(
            "visibleRoutes",
            data.visibleRoutes,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["visibleRoutes", index] as const,
          name: `visibleRoutes.${index}`,
          constraints: { required: true },
          get: () => data.visibleRoutes[index]!,
          set: (value: string) => {
            data.visibleRoutes[index] = value;
          },
          transform: (value: string): string => value,
          getError: () => errors.visibleRoutes,
          setError: (value: Option<Array<string>>) => {
            errors.visibleRoutes = value;
          },
          getTainted: () => tainted.visibleRoutes,
          setTainted: (value: Option<boolean>) => {
            tainted.visibleRoutes = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.visibleRoutes.push(item);
        },
        remove: (index: number) => {
          data.visibleRoutes.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.visibleRoutes[a]!;
          data.visibleRoutes[a] = data.visibleRoutes[b]!;
          data.visibleRoutes[b] = tmp;
        },
      },
      detailedCards: {
        path: ["detailedCards"] as const,
        name: "detailedCards",
        constraints: { required: true },

        get: () => data.detailedCards,
        set: (value: boolean) => {
          data.detailedCards = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.detailedCards,
        setError: (value: Option<Array<string>>) => {
          errors.detailedCards = value;
        },
        getTainted: () => tainted.detailedCards,
        setTainted: (value: Option<boolean>) => {
          tainted.detailedCards = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = ScheduleSettings.validateField(
            "detailedCards",
            data.detailedCards,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      ScheduleSettings,
      Array<{ field: string; message: string }>
    > {
      return ScheduleSettings.fromObject(data);
    }
    function reset(newOverrides?: Partial<ScheduleSettings>): void {
      data = { ...ScheduleSettings.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        daysPerWeek: Option.none(),
        rowHeight: Option.none(),
        visibleRoutes: Option.none(),
        detailedCards: Option.none(),
      };
      tainted = {
        daysPerWeek: Option.none(),
        rowHeight: Option.none(),
        visibleRoutes: Option.none(),
        detailedCards: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<ScheduleSettings, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const daysPerWeekStr = formData.get("daysPerWeek");
      obj.daysPerWeek = daysPerWeekStr
        ? parseFloat(daysPerWeekStr as string)
        : 0;
      if (obj.daysPerWeek !== undefined && isNaN(obj.daysPerWeek as number))
        obj.daysPerWeek = 0;
    }
    {
      // Collect nested object fields with prefix "rowHeight."
      const rowHeightObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("rowHeight.")) {
          const fieldName = key.slice("rowHeight.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = rowHeightObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.rowHeight = rowHeightObj;
    }
    obj.visibleRoutes = formData.getAll("visibleRoutes") as Array<string>;
    {
      const detailedCardsVal = formData.get("detailedCards");
      obj.detailedCards =
        detailedCardsVal === "true" ||
        detailedCardsVal === "on" ||
        detailedCardsVal === "1";
    }
    return ScheduleSettings.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface DailyRecurrenceRule {
  quantityOfDays: number;
}

export function defaultValueDailyRecurrenceRule(): DailyRecurrenceRule {
  return { quantityOfDays: 0 } as DailyRecurrenceRule;
}

export function toStringifiedJSONDailyRecurrenceRule(
  value: DailyRecurrenceRule,
): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeDailyRecurrenceRule(value, ctx));
}
export function toObjectDailyRecurrenceRule(
  value: DailyRecurrenceRule,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeDailyRecurrenceRule(value, ctx);
}
export function __serializeDailyRecurrenceRule(
  value: DailyRecurrenceRule,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = {
    __type: "DailyRecurrenceRule",
    __id,
  };
  result["quantityOfDays"] = value.quantityOfDays;
  return result;
}

export function fromStringifiedJSONDailyRecurrenceRule(
  json: string,
  opts?: DeserializeOptions,
): Result<DailyRecurrenceRule, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectDailyRecurrenceRule(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectDailyRecurrenceRule(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<DailyRecurrenceRule, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeDailyRecurrenceRule(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "DailyRecurrenceRule.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeDailyRecurrenceRule(
  value: any,
  ctx: DeserializeContext,
): DailyRecurrenceRule | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "DailyRecurrenceRule.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("quantityOfDays" in obj)) {
    errors.push({ field: "quantityOfDays", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_quantityOfDays = obj["quantityOfDays"] as number;
    instance.quantityOfDays = __raw_quantityOfDays;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as DailyRecurrenceRule;
}
export function validateFieldDailyRecurrenceRule<
  K extends keyof DailyRecurrenceRule,
>(
  field: K,
  value: DailyRecurrenceRule[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsDailyRecurrenceRule(
  partial: Partial<DailyRecurrenceRule>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isDailyRecurrenceRule(
  obj: unknown,
): obj is DailyRecurrenceRule {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "quantityOfDays" in o;
}

export namespace DailyRecurrenceRule {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    quantityOfDays: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { quantityOfDays: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly quantityOfDays: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: DailyRecurrenceRule;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      DailyRecurrenceRule,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<DailyRecurrenceRule>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<DailyRecurrenceRule>,
  ): Gigaform {
    let data = $state({ ...DailyRecurrenceRule.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      quantityOfDays: Option.none(),
    });
    let tainted = $state<Tainted>({ quantityOfDays: Option.none() });
    const fields: FieldControllers = {
      quantityOfDays: {
        path: ["quantityOfDays"] as const,
        name: "quantityOfDays",
        constraints: { required: true },

        get: () => data.quantityOfDays,
        set: (value: number) => {
          data.quantityOfDays = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.quantityOfDays,
        setError: (value: Option<Array<string>>) => {
          errors.quantityOfDays = value;
        },
        getTainted: () => tainted.quantityOfDays,
        setTainted: (value: Option<boolean>) => {
          tainted.quantityOfDays = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = DailyRecurrenceRule.validateField(
            "quantityOfDays",
            data.quantityOfDays,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      DailyRecurrenceRule,
      Array<{ field: string; message: string }>
    > {
      return DailyRecurrenceRule.fromObject(data);
    }
    function reset(newOverrides?: Partial<DailyRecurrenceRule>): void {
      data = { ...DailyRecurrenceRule.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), quantityOfDays: Option.none() };
      tainted = { quantityOfDays: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<DailyRecurrenceRule, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const quantityOfDaysStr = formData.get("quantityOfDays");
      obj.quantityOfDays = quantityOfDaysStr
        ? parseFloat(quantityOfDaysStr as string)
        : 0;
      if (
        obj.quantityOfDays !== undefined &&
        isNaN(obj.quantityOfDays as number)
      )
        obj.quantityOfDays = 0;
    }
    return DailyRecurrenceRule.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface SignUpCredentials {
  firstName: FirstName;
  lastName: LastName;
  email: EmailParts;
  password: Password;
  rememberMe: boolean;
}

export function defaultValueSignUpCredentials(): SignUpCredentials {
  return {
    firstName: FirstName.defaultValue(),
    lastName: LastName.defaultValue(),
    email: EmailParts.defaultValue(),
    password: Password.defaultValue(),
    rememberMe: false,
  } as SignUpCredentials;
}

export function toStringifiedJSONSignUpCredentials(
  value: SignUpCredentials,
): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeSignUpCredentials(value, ctx));
}
export function toObjectSignUpCredentials(
  value: SignUpCredentials,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeSignUpCredentials(value, ctx);
}
export function __serializeSignUpCredentials(
  value: SignUpCredentials,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "SignUpCredentials", __id };
  result["firstName"] =
    typeof (value.firstName as any)?.__serialize === "function"
      ? (value.firstName as any).__serialize(ctx)
      : value.firstName;
  result["lastName"] =
    typeof (value.lastName as any)?.__serialize === "function"
      ? (value.lastName as any).__serialize(ctx)
      : value.lastName;
  result["email"] =
    typeof (value.email as any)?.__serialize === "function"
      ? (value.email as any).__serialize(ctx)
      : value.email;
  result["password"] =
    typeof (value.password as any)?.__serialize === "function"
      ? (value.password as any).__serialize(ctx)
      : value.password;
  result["rememberMe"] = value.rememberMe;
  return result;
}

export function fromStringifiedJSONSignUpCredentials(
  json: string,
  opts?: DeserializeOptions,
): Result<SignUpCredentials, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectSignUpCredentials(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectSignUpCredentials(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<SignUpCredentials, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeSignUpCredentials(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "SignUpCredentials.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeSignUpCredentials(
  value: any,
  ctx: DeserializeContext,
): SignUpCredentials | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "SignUpCredentials.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("firstName" in obj)) {
    errors.push({ field: "firstName", message: "missing required field" });
  }
  if (!("lastName" in obj)) {
    errors.push({ field: "lastName", message: "missing required field" });
  }
  if (!("email" in obj)) {
    errors.push({ field: "email", message: "missing required field" });
  }
  if (!("password" in obj)) {
    errors.push({ field: "password", message: "missing required field" });
  }
  if (!("rememberMe" in obj)) {
    errors.push({ field: "rememberMe", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_firstName = obj["firstName"] as FirstName;
    if (typeof (FirstName as any)?.__deserialize === "function") {
      const __result = (FirstName as any).__deserialize(__raw_firstName, ctx);
      ctx.assignOrDefer(instance, "firstName", __result);
    } else {
      instance.firstName = __raw_firstName;
    }
  }
  {
    const __raw_lastName = obj["lastName"] as LastName;
    if (typeof (LastName as any)?.__deserialize === "function") {
      const __result = (LastName as any).__deserialize(__raw_lastName, ctx);
      ctx.assignOrDefer(instance, "lastName", __result);
    } else {
      instance.lastName = __raw_lastName;
    }
  }
  {
    const __raw_email = obj["email"] as EmailParts;
    if (typeof (EmailParts as any)?.__deserialize === "function") {
      const __result = (EmailParts as any).__deserialize(__raw_email, ctx);
      ctx.assignOrDefer(instance, "email", __result);
    } else {
      instance.email = __raw_email;
    }
  }
  {
    const __raw_password = obj["password"] as Password;
    if (typeof (Password as any)?.__deserialize === "function") {
      const __result = (Password as any).__deserialize(__raw_password, ctx);
      ctx.assignOrDefer(instance, "password", __result);
    } else {
      instance.password = __raw_password;
    }
  }
  {
    const __raw_rememberMe = obj["rememberMe"] as boolean;
    instance.rememberMe = __raw_rememberMe;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as SignUpCredentials;
}
export function validateFieldSignUpCredentials<
  K extends keyof SignUpCredentials,
>(
  field: K,
  value: SignUpCredentials[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsSignUpCredentials(
  partial: Partial<SignUpCredentials>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isSignUpCredentials(obj: unknown): obj is SignUpCredentials {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "firstName" in o &&
    "lastName" in o &&
    "email" in o &&
    "password" in o &&
    "rememberMe" in o
  );
}

export namespace SignUpCredentials {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    firstName: Option<Array<string>>;
    lastName: Option<Array<string>>;
    email: Option<Array<string>>;
    password: Option<Array<string>>;
    rememberMe: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      firstName: Option<boolean>;
      lastName: Option<boolean>;
      email: Option<boolean>;
      password: Option<boolean>;
      rememberMe: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly firstName: FieldController<FirstName>;
    readonly lastName: FieldController<LastName>;
    readonly email: FieldController<EmailParts>;
    readonly password: FieldController<Password>;
    readonly rememberMe: FieldController<boolean>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: SignUpCredentials;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      SignUpCredentials,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<SignUpCredentials>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<SignUpCredentials>,
  ): Gigaform {
    let data = $state({ ...SignUpCredentials.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      firstName: Option.none(),
      lastName: Option.none(),
      email: Option.none(),
      password: Option.none(),
      rememberMe: Option.none(),
    });
    let tainted = $state<Tainted>({
      firstName: Option.none(),
      lastName: Option.none(),
      email: Option.none(),
      password: Option.none(),
      rememberMe: Option.none(),
    });
    const fields: FieldControllers = {
      firstName: {
        path: ["firstName"] as const,
        name: "firstName",
        constraints: { required: true },

        get: () => data.firstName,
        set: (value: FirstName) => {
          data.firstName = value;
        },
        transform: (value: FirstName): FirstName => value,
        getError: () => errors.firstName,
        setError: (value: Option<Array<string>>) => {
          errors.firstName = value;
        },
        getTainted: () => tainted.firstName,
        setTainted: (value: Option<boolean>) => {
          tainted.firstName = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = SignUpCredentials.validateField(
            "firstName",
            data.firstName,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      lastName: {
        path: ["lastName"] as const,
        name: "lastName",
        constraints: { required: true },

        get: () => data.lastName,
        set: (value: LastName) => {
          data.lastName = value;
        },
        transform: (value: LastName): LastName => value,
        getError: () => errors.lastName,
        setError: (value: Option<Array<string>>) => {
          errors.lastName = value;
        },
        getTainted: () => tainted.lastName,
        setTainted: (value: Option<boolean>) => {
          tainted.lastName = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = SignUpCredentials.validateField(
            "lastName",
            data.lastName,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      email: {
        path: ["email"] as const,
        name: "email",
        constraints: { required: true },

        get: () => data.email,
        set: (value: EmailParts) => {
          data.email = value;
        },
        transform: (value: EmailParts): EmailParts => value,
        getError: () => errors.email,
        setError: (value: Option<Array<string>>) => {
          errors.email = value;
        },
        getTainted: () => tainted.email,
        setTainted: (value: Option<boolean>) => {
          tainted.email = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = SignUpCredentials.validateField(
            "email",
            data.email,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      password: {
        path: ["password"] as const,
        name: "password",
        constraints: { required: true },

        get: () => data.password,
        set: (value: Password) => {
          data.password = value;
        },
        transform: (value: Password): Password => value,
        getError: () => errors.password,
        setError: (value: Option<Array<string>>) => {
          errors.password = value;
        },
        getTainted: () => tainted.password,
        setTainted: (value: Option<boolean>) => {
          tainted.password = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = SignUpCredentials.validateField(
            "password",
            data.password,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      rememberMe: {
        path: ["rememberMe"] as const,
        name: "rememberMe",
        constraints: { required: true },

        get: () => data.rememberMe,
        set: (value: boolean) => {
          data.rememberMe = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.rememberMe,
        setError: (value: Option<Array<string>>) => {
          errors.rememberMe = value;
        },
        getTainted: () => tainted.rememberMe,
        setTainted: (value: Option<boolean>) => {
          tainted.rememberMe = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = SignUpCredentials.validateField(
            "rememberMe",
            data.rememberMe,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      SignUpCredentials,
      Array<{ field: string; message: string }>
    > {
      return SignUpCredentials.fromObject(data);
    }
    function reset(newOverrides?: Partial<SignUpCredentials>): void {
      data = { ...SignUpCredentials.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        firstName: Option.none(),
        lastName: Option.none(),
        email: Option.none(),
        password: Option.none(),
        rememberMe: Option.none(),
      };
      tainted = {
        firstName: Option.none(),
        lastName: Option.none(),
        email: Option.none(),
        password: Option.none(),
        rememberMe: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<SignUpCredentials, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect nested object fields with prefix "firstName."
      const firstNameObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("firstName.")) {
          const fieldName = key.slice("firstName.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = firstNameObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.firstName = firstNameObj;
    }
    {
      // Collect nested object fields with prefix "lastName."
      const lastNameObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("lastName.")) {
          const fieldName = key.slice("lastName.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = lastNameObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.lastName = lastNameObj;
    }
    {
      // Collect nested object fields with prefix "email."
      const emailObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("email.")) {
          const fieldName = key.slice("email.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = emailObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.email = emailObj;
    }
    {
      // Collect nested object fields with prefix "password."
      const passwordObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("password.")) {
          const fieldName = key.slice("password.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = passwordObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.password = passwordObj;
    }
    {
      const rememberMeVal = formData.get("rememberMe");
      obj.rememberMe =
        rememberMeVal === "true" ||
        rememberMeVal === "on" ||
        rememberMeVal === "1";
    }
    return SignUpCredentials.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface OverviewSettings {
  /** @default("Medium") */
  rowHeight: RowHeight;
  /** @default("Table") */
  cardOrRow: OverviewDisplay;
  perPage: number;
  columnConfigs: ColumnConfig[];
}

export function defaultValueOverviewSettings(): OverviewSettings {
  return {
    rowHeight: "Medium",
    cardOrRow: "Table",
    perPage: 0,
    columnConfigs: [],
  } as OverviewSettings;
}

export function toStringifiedJSONOverviewSettings(
  value: OverviewSettings,
): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeOverviewSettings(value, ctx));
}
export function toObjectOverviewSettings(
  value: OverviewSettings,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeOverviewSettings(value, ctx);
}
export function __serializeOverviewSettings(
  value: OverviewSettings,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "OverviewSettings", __id };
  result["rowHeight"] =
    typeof (value.rowHeight as any)?.__serialize === "function"
      ? (value.rowHeight as any).__serialize(ctx)
      : value.rowHeight;
  result["cardOrRow"] =
    typeof (value.cardOrRow as any)?.__serialize === "function"
      ? (value.cardOrRow as any).__serialize(ctx)
      : value.cardOrRow;
  result["perPage"] = value.perPage;
  result["columnConfigs"] = value.columnConfigs.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  return result;
}

export function fromStringifiedJSONOverviewSettings(
  json: string,
  opts?: DeserializeOptions,
): Result<OverviewSettings, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectOverviewSettings(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectOverviewSettings(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<OverviewSettings, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeOverviewSettings(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "OverviewSettings.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeOverviewSettings(
  value: any,
  ctx: DeserializeContext,
): OverviewSettings | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "OverviewSettings.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("rowHeight" in obj)) {
    errors.push({ field: "rowHeight", message: "missing required field" });
  }
  if (!("cardOrRow" in obj)) {
    errors.push({ field: "cardOrRow", message: "missing required field" });
  }
  if (!("perPage" in obj)) {
    errors.push({ field: "perPage", message: "missing required field" });
  }
  if (!("columnConfigs" in obj)) {
    errors.push({ field: "columnConfigs", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_rowHeight = obj["rowHeight"] as RowHeight;
    if (typeof (RowHeight as any)?.__deserialize === "function") {
      const __result = (RowHeight as any).__deserialize(__raw_rowHeight, ctx);
      ctx.assignOrDefer(instance, "rowHeight", __result);
    } else {
      instance.rowHeight = __raw_rowHeight;
    }
  }
  {
    const __raw_cardOrRow = obj["cardOrRow"] as OverviewDisplay;
    if (typeof (OverviewDisplay as any)?.__deserialize === "function") {
      const __result = (OverviewDisplay as any).__deserialize(
        __raw_cardOrRow,
        ctx,
      );
      ctx.assignOrDefer(instance, "cardOrRow", __result);
    } else {
      instance.cardOrRow = __raw_cardOrRow;
    }
  }
  {
    const __raw_perPage = obj["perPage"] as number;
    instance.perPage = __raw_perPage;
  }
  {
    const __raw_columnConfigs = obj["columnConfigs"] as ColumnConfig[];
    if (Array.isArray(__raw_columnConfigs)) {
      instance.columnConfigs = __raw_columnConfigs as ColumnConfig[];
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as OverviewSettings;
}
export function validateFieldOverviewSettings<K extends keyof OverviewSettings>(
  field: K,
  value: OverviewSettings[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsOverviewSettings(
  partial: Partial<OverviewSettings>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isOverviewSettings(obj: unknown): obj is OverviewSettings {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "rowHeight" in o &&
    "cardOrRow" in o &&
    "perPage" in o &&
    "columnConfigs" in o
  );
}

export namespace OverviewSettings {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    rowHeight: Option<Array<string>>;
    cardOrRow: Option<Array<string>>;
    perPage: Option<Array<string>>;
    columnConfigs: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      rowHeight: Option<boolean>;
      cardOrRow: Option<boolean>;
      perPage: Option<boolean>;
      columnConfigs: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly rowHeight: FieldController<RowHeight>;
    readonly cardOrRow: FieldController<OverviewDisplay>;
    readonly perPage: FieldController<number>;
    readonly columnConfigs: ArrayFieldController<ColumnConfig>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: OverviewSettings;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      OverviewSettings,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<OverviewSettings>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<OverviewSettings>,
  ): Gigaform {
    let data = $state({ ...OverviewSettings.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      rowHeight: Option.none(),
      cardOrRow: Option.none(),
      perPage: Option.none(),
      columnConfigs: Option.none(),
    });
    let tainted = $state<Tainted>({
      rowHeight: Option.none(),
      cardOrRow: Option.none(),
      perPage: Option.none(),
      columnConfigs: Option.none(),
    });
    const fields: FieldControllers = {
      rowHeight: {
        path: ["rowHeight"] as const,
        name: "rowHeight",
        constraints: { required: true },

        get: () => data.rowHeight,
        set: (value: RowHeight) => {
          data.rowHeight = value;
        },
        transform: (value: RowHeight): RowHeight => value,
        getError: () => errors.rowHeight,
        setError: (value: Option<Array<string>>) => {
          errors.rowHeight = value;
        },
        getTainted: () => tainted.rowHeight,
        setTainted: (value: Option<boolean>) => {
          tainted.rowHeight = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = OverviewSettings.validateField(
            "rowHeight",
            data.rowHeight,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      cardOrRow: {
        path: ["cardOrRow"] as const,
        name: "cardOrRow",
        constraints: { required: true },

        get: () => data.cardOrRow,
        set: (value: OverviewDisplay) => {
          data.cardOrRow = value;
        },
        transform: (value: OverviewDisplay): OverviewDisplay => value,
        getError: () => errors.cardOrRow,
        setError: (value: Option<Array<string>>) => {
          errors.cardOrRow = value;
        },
        getTainted: () => tainted.cardOrRow,
        setTainted: (value: Option<boolean>) => {
          tainted.cardOrRow = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = OverviewSettings.validateField(
            "cardOrRow",
            data.cardOrRow,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      perPage: {
        path: ["perPage"] as const,
        name: "perPage",
        constraints: { required: true },

        get: () => data.perPage,
        set: (value: number) => {
          data.perPage = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.perPage,
        setError: (value: Option<Array<string>>) => {
          errors.perPage = value;
        },
        getTainted: () => tainted.perPage,
        setTainted: (value: Option<boolean>) => {
          tainted.perPage = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = OverviewSettings.validateField(
            "perPage",
            data.perPage,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      columnConfigs: {
        path: ["columnConfigs"] as const,
        name: "columnConfigs",
        constraints: { required: true },

        get: () => data.columnConfigs,
        set: (value: ColumnConfig[]) => {
          data.columnConfigs = value;
        },
        transform: (value: ColumnConfig[]): ColumnConfig[] => value,
        getError: () => errors.columnConfigs,
        setError: (value: Option<Array<string>>) => {
          errors.columnConfigs = value;
        },
        getTainted: () => tainted.columnConfigs,
        setTainted: (value: Option<boolean>) => {
          tainted.columnConfigs = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = OverviewSettings.validateField(
            "columnConfigs",
            data.columnConfigs,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["columnConfigs", index] as const,
          name: `columnConfigs.${index}`,
          constraints: { required: true },
          get: () => data.columnConfigs[index]!,
          set: (value: ColumnConfig) => {
            data.columnConfigs[index] = value;
          },
          transform: (value: ColumnConfig): ColumnConfig => value,
          getError: () => errors.columnConfigs,
          setError: (value: Option<Array<string>>) => {
            errors.columnConfigs = value;
          },
          getTainted: () => tainted.columnConfigs,
          setTainted: (value: Option<boolean>) => {
            tainted.columnConfigs = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: ColumnConfig) => {
          data.columnConfigs.push(item);
        },
        remove: (index: number) => {
          data.columnConfigs.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.columnConfigs[a]!;
          data.columnConfigs[a] = data.columnConfigs[b]!;
          data.columnConfigs[b] = tmp;
        },
      },
    };
    function validate(): Result<
      OverviewSettings,
      Array<{ field: string; message: string }>
    > {
      return OverviewSettings.fromObject(data);
    }
    function reset(newOverrides?: Partial<OverviewSettings>): void {
      data = { ...OverviewSettings.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        rowHeight: Option.none(),
        cardOrRow: Option.none(),
        perPage: Option.none(),
        columnConfigs: Option.none(),
      };
      tainted = {
        rowHeight: Option.none(),
        cardOrRow: Option.none(),
        perPage: Option.none(),
        columnConfigs: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<OverviewSettings, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect nested object fields with prefix "rowHeight."
      const rowHeightObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("rowHeight.")) {
          const fieldName = key.slice("rowHeight.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = rowHeightObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.rowHeight = rowHeightObj;
    }
    {
      // Collect nested object fields with prefix "cardOrRow."
      const cardOrRowObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("cardOrRow.")) {
          const fieldName = key.slice("cardOrRow.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = cardOrRowObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.cardOrRow = cardOrRowObj;
    }
    {
      const perPageStr = formData.get("perPage");
      obj.perPage = perPageStr ? parseFloat(perPageStr as string) : 0;
      if (obj.perPage !== undefined && isNaN(obj.perPage as number))
        obj.perPage = 0;
    }
    {
      // Collect array items from indexed form fields
      const columnConfigsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("columnConfigs." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("columnConfigs." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("columnConfigs." + idx + ".")) {
              const fieldName = key.slice(
                "columnConfigs.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          columnConfigsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.columnConfigs = columnConfigsItems;
    }
    return OverviewSettings.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface FirstName {
  /** @serde({ validate: ["nonEmpty"] }) */
  name: string;
}

export function defaultValueFirstName(): FirstName {
  return { name: "" } as FirstName;
}

export function toStringifiedJSONFirstName(value: FirstName): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeFirstName(value, ctx));
}
export function toObjectFirstName(value: FirstName): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeFirstName(value, ctx);
}
export function __serializeFirstName(
  value: FirstName,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "FirstName", __id };
  result["name"] = value.name;
  return result;
}

export function fromStringifiedJSONFirstName(
  json: string,
  opts?: DeserializeOptions,
): Result<FirstName, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectFirstName(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectFirstName(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<FirstName, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeFirstName(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "FirstName.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeFirstName(
  value: any,
  ctx: DeserializeContext,
): FirstName | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "FirstName.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("name" in obj)) {
    errors.push({ field: "name", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_name = obj["name"] as string;
    if (__raw_name.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
    instance.name = __raw_name;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as FirstName;
}
export function validateFieldFirstName<K extends keyof FirstName>(
  field: K,
  value: FirstName[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "name": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsFirstName(
  partial: Partial<FirstName>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("name" in partial && partial.name !== undefined) {
    const __val = partial.name as string;
    if (__val.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
  }
  return errors;
}
export function isFirstName(obj: unknown): obj is FirstName {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "name" in o;
}

export namespace FirstName {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    name: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { name: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly name: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: FirstName;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<FirstName, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<FirstName>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<FirstName>,
  ): Gigaform {
    let data = $state({ ...FirstName.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      name: Option.none(),
    });
    let tainted = $state<Tainted>({ name: Option.none() });
    const fields: FieldControllers = {
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },

        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = FirstName.validateField("name", data.name);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      FirstName,
      Array<{ field: string; message: string }>
    > {
      return FirstName.fromObject(data);
    }
    function reset(newOverrides?: Partial<FirstName>): void {
      data = { ...FirstName.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), name: Option.none() };
      tainted = { name: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<FirstName, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.name = formData.get("name") ?? "";
    return FirstName.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Account {
  /** @hiddenController({}) */
  id: string;
  /** @comboboxController({ label: "Tax Rate", allowCustom: false, fetchUrls: ["/api/tax-rates"] }) */
  /** @default("") */
  taxRate: string | TaxRate;
  /** @siteFieldsetController({ label: "Site" }) */
  /** @default("") */
  site: string | Site;
  /** @comboboxMultipleController({ label: "Sales Rep", fetchUrls: ["/api/employees"] }) */
  salesRep: Represents[] | null;
  /** @hiddenController({}) */
  orders: Ordered[];
  /** @hiddenController({}) */
  activity: Did[];
  /** @arrayFieldsetController({ legend: "Custom Fields" }) */
  customFields: [string, string][];
  /** @enumFieldsetController({ legend: "Name", variants: { CompanyName: { label: "Company" }, PersonName: { label: "Person" } } }) */
  accountName: AccountName;
  /** @radioGroupController({ label: "Sector", options: [{ label: "Residential", value: "Residential" }, { label: "Commercial", value: "Commercial" }], orientation: "horizontal" }) */
  /** @default("Residential") */
  sector: Sector;
  /** @textAreaController({ label: "Memo" }) */
  memo: string | null;
  /** @arrayFieldsetController({ legend: "Phones" }) */
  phones: PhoneNumber[];
  /** @emailFieldController({ label: "Email" }) */
  email: Email;
  /** @comboboxController({ label: "Lead Source", allowCustom: true }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  leadSource: string;
  /** @hiddenController({}) */
  colors: Colors;
  /** @toggleController({ label: "Needs Review" }) */
  needsReview: boolean;
  /** @toggleController({ label: "Has Alert" }) */
  hasAlert: boolean;
  /** @comboboxController({ label: "Account Type", allowCustom: true }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  accountType: string;
  /** @comboboxController({ label: "Subtype", allowCustom: true }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  subtype: string;
  /** @toggleController({ label: "Tax Exempt" }) */
  isTaxExempt: boolean;
  /** @comboboxController({ label: "Payment Terms", allowCustom: true }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  paymentTerms: string;
  /** @tagsController({ label: "Tags" }) */
  tags: string[];
  /** @hiddenController({}) */
  dateAdded: string;
}

export function defaultValueAccount(): Account {
  return {
    id: "",
    taxRate: "",
    site: "",
    salesRep: null,
    orders: [],
    activity: [],
    customFields: [],
    accountName: AccountName.defaultValue(),
    sector: "Residential",
    memo: null,
    phones: [],
    email: Email.defaultValue(),
    leadSource: "",
    colors: Colors.defaultValue(),
    needsReview: false,
    hasAlert: false,
    accountType: "",
    subtype: "",
    isTaxExempt: false,
    paymentTerms: "",
    tags: [],
    dateAdded: "",
  } as Account;
}

export function toStringifiedJSONAccount(value: Account): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeAccount(value, ctx));
}
export function toObjectAccount(value: Account): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeAccount(value, ctx);
}
export function __serializeAccount(
  value: Account,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Account", __id };
  result["id"] = value.id;
  result["taxRate"] = value.taxRate;
  result["site"] = value.site;
  if (value.salesRep !== null) {
    result["salesRep"] =
      typeof (value.salesRep as any)?.__serialize === "function"
        ? (value.salesRep as any).__serialize(ctx)
        : value.salesRep;
  } else {
    result["salesRep"] = null;
  }
  result["orders"] = value.orders.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["activity"] = value.activity.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["customFields"] = value.customFields.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["accountName"] =
    typeof (value.accountName as any)?.__serialize === "function"
      ? (value.accountName as any).__serialize(ctx)
      : value.accountName;
  result["sector"] =
    typeof (value.sector as any)?.__serialize === "function"
      ? (value.sector as any).__serialize(ctx)
      : value.sector;
  if (value.memo !== null) {
    result["memo"] =
      typeof (value.memo as any)?.__serialize === "function"
        ? (value.memo as any).__serialize(ctx)
        : value.memo;
  } else {
    result["memo"] = null;
  }
  result["phones"] = value.phones.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["email"] =
    typeof (value.email as any)?.__serialize === "function"
      ? (value.email as any).__serialize(ctx)
      : value.email;
  result["leadSource"] = value.leadSource;
  result["colors"] =
    typeof (value.colors as any)?.__serialize === "function"
      ? (value.colors as any).__serialize(ctx)
      : value.colors;
  result["needsReview"] = value.needsReview;
  result["hasAlert"] = value.hasAlert;
  result["accountType"] = value.accountType;
  result["subtype"] = value.subtype;
  result["isTaxExempt"] = value.isTaxExempt;
  result["paymentTerms"] = value.paymentTerms;
  result["tags"] = value.tags.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["dateAdded"] = value.dateAdded;
  return result;
}

export function fromStringifiedJSONAccount(
  json: string,
  opts?: DeserializeOptions,
): Result<Account, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectAccount(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectAccount(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Account, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeAccount(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Account.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeAccount(
  value: any,
  ctx: DeserializeContext,
): Account | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Account.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("taxRate" in obj)) {
    errors.push({ field: "taxRate", message: "missing required field" });
  }
  if (!("site" in obj)) {
    errors.push({ field: "site", message: "missing required field" });
  }
  if (!("salesRep" in obj)) {
    errors.push({ field: "salesRep", message: "missing required field" });
  }
  if (!("orders" in obj)) {
    errors.push({ field: "orders", message: "missing required field" });
  }
  if (!("activity" in obj)) {
    errors.push({ field: "activity", message: "missing required field" });
  }
  if (!("customFields" in obj)) {
    errors.push({ field: "customFields", message: "missing required field" });
  }
  if (!("accountName" in obj)) {
    errors.push({ field: "accountName", message: "missing required field" });
  }
  if (!("sector" in obj)) {
    errors.push({ field: "sector", message: "missing required field" });
  }
  if (!("memo" in obj)) {
    errors.push({ field: "memo", message: "missing required field" });
  }
  if (!("phones" in obj)) {
    errors.push({ field: "phones", message: "missing required field" });
  }
  if (!("email" in obj)) {
    errors.push({ field: "email", message: "missing required field" });
  }
  if (!("leadSource" in obj)) {
    errors.push({ field: "leadSource", message: "missing required field" });
  }
  if (!("colors" in obj)) {
    errors.push({ field: "colors", message: "missing required field" });
  }
  if (!("needsReview" in obj)) {
    errors.push({ field: "needsReview", message: "missing required field" });
  }
  if (!("hasAlert" in obj)) {
    errors.push({ field: "hasAlert", message: "missing required field" });
  }
  if (!("accountType" in obj)) {
    errors.push({ field: "accountType", message: "missing required field" });
  }
  if (!("subtype" in obj)) {
    errors.push({ field: "subtype", message: "missing required field" });
  }
  if (!("isTaxExempt" in obj)) {
    errors.push({ field: "isTaxExempt", message: "missing required field" });
  }
  if (!("paymentTerms" in obj)) {
    errors.push({ field: "paymentTerms", message: "missing required field" });
  }
  if (!("tags" in obj)) {
    errors.push({ field: "tags", message: "missing required field" });
  }
  if (!("dateAdded" in obj)) {
    errors.push({ field: "dateAdded", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_taxRate = obj["taxRate"] as string | TaxRate;
    instance.taxRate = __raw_taxRate;
  }
  {
    const __raw_site = obj["site"] as string | Site;
    instance.site = __raw_site;
  }
  {
    const __raw_salesRep = obj["salesRep"] as Represents[] | null;
    if (__raw_salesRep === null) {
      instance.salesRep = null;
    } else if (typeof (__raw_salesRep as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_salesRep as any).__ref);
      ctx.assignOrDefer(instance, "salesRep", __result);
    } else {
      instance.salesRep = __raw_salesRep;
    }
  }
  {
    const __raw_orders = obj["orders"] as Ordered[];
    if (Array.isArray(__raw_orders)) {
      instance.orders = __raw_orders as Ordered[];
    }
  }
  {
    const __raw_activity = obj["activity"] as Did[];
    if (Array.isArray(__raw_activity)) {
      instance.activity = __raw_activity as Did[];
    }
  }
  {
    const __raw_customFields = obj["customFields"] as [string, string][];
    if (Array.isArray(__raw_customFields)) {
      instance.customFields = __raw_customFields as [string, string][];
    }
  }
  {
    const __raw_accountName = obj["accountName"] as AccountName;
    if (typeof (AccountName as any)?.__deserialize === "function") {
      const __result = (AccountName as any).__deserialize(
        __raw_accountName,
        ctx,
      );
      ctx.assignOrDefer(instance, "accountName", __result);
    } else {
      instance.accountName = __raw_accountName;
    }
  }
  {
    const __raw_sector = obj["sector"] as Sector;
    if (typeof (Sector as any)?.__deserialize === "function") {
      const __result = (Sector as any).__deserialize(__raw_sector, ctx);
      ctx.assignOrDefer(instance, "sector", __result);
    } else {
      instance.sector = __raw_sector;
    }
  }
  {
    const __raw_memo = obj["memo"] as string | null;
    if (__raw_memo === null) {
      instance.memo = null;
    } else if (typeof (__raw_memo as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_memo as any).__ref);
      ctx.assignOrDefer(instance, "memo", __result);
    } else {
      instance.memo = __raw_memo;
    }
  }
  {
    const __raw_phones = obj["phones"] as PhoneNumber[];
    if (Array.isArray(__raw_phones)) {
      instance.phones = __raw_phones as PhoneNumber[];
    }
  }
  {
    const __raw_email = obj["email"] as Email;
    if (typeof (Email as any)?.__deserialize === "function") {
      const __result = (Email as any).__deserialize(__raw_email, ctx);
      ctx.assignOrDefer(instance, "email", __result);
    } else {
      instance.email = __raw_email;
    }
  }
  {
    const __raw_leadSource = obj["leadSource"] as string;
    if (__raw_leadSource.length === 0) {
      errors.push({ field: "leadSource", message: "must not be empty" });
    }
    instance.leadSource = __raw_leadSource;
  }
  {
    const __raw_colors = obj["colors"] as Colors;
    if (typeof (Colors as any)?.__deserialize === "function") {
      const __result = (Colors as any).__deserialize(__raw_colors, ctx);
      ctx.assignOrDefer(instance, "colors", __result);
    } else {
      instance.colors = __raw_colors;
    }
  }
  {
    const __raw_needsReview = obj["needsReview"] as boolean;
    instance.needsReview = __raw_needsReview;
  }
  {
    const __raw_hasAlert = obj["hasAlert"] as boolean;
    instance.hasAlert = __raw_hasAlert;
  }
  {
    const __raw_accountType = obj["accountType"] as string;
    if (__raw_accountType.length === 0) {
      errors.push({ field: "accountType", message: "must not be empty" });
    }
    instance.accountType = __raw_accountType;
  }
  {
    const __raw_subtype = obj["subtype"] as string;
    if (__raw_subtype.length === 0) {
      errors.push({ field: "subtype", message: "must not be empty" });
    }
    instance.subtype = __raw_subtype;
  }
  {
    const __raw_isTaxExempt = obj["isTaxExempt"] as boolean;
    instance.isTaxExempt = __raw_isTaxExempt;
  }
  {
    const __raw_paymentTerms = obj["paymentTerms"] as string;
    if (__raw_paymentTerms.length === 0) {
      errors.push({ field: "paymentTerms", message: "must not be empty" });
    }
    instance.paymentTerms = __raw_paymentTerms;
  }
  {
    const __raw_tags = obj["tags"] as string[];
    if (Array.isArray(__raw_tags)) {
      instance.tags = __raw_tags as string[];
    }
  }
  {
    const __raw_dateAdded = obj["dateAdded"] as string;
    instance.dateAdded = __raw_dateAdded;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Account;
}
export function validateFieldAccount<K extends keyof Account>(
  field: K,
  value: Account[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "leadSource": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "leadSource", message: "must not be empty" });
      }
      break;
    }
    case "accountType": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "accountType", message: "must not be empty" });
      }
      break;
    }
    case "subtype": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "subtype", message: "must not be empty" });
      }
      break;
    }
    case "paymentTerms": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "paymentTerms", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsAccount(
  partial: Partial<Account>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("leadSource" in partial && partial.leadSource !== undefined) {
    const __val = partial.leadSource as string;
    if (__val.length === 0) {
      errors.push({ field: "leadSource", message: "must not be empty" });
    }
  }
  if ("accountType" in partial && partial.accountType !== undefined) {
    const __val = partial.accountType as string;
    if (__val.length === 0) {
      errors.push({ field: "accountType", message: "must not be empty" });
    }
  }
  if ("subtype" in partial && partial.subtype !== undefined) {
    const __val = partial.subtype as string;
    if (__val.length === 0) {
      errors.push({ field: "subtype", message: "must not be empty" });
    }
  }
  if ("paymentTerms" in partial && partial.paymentTerms !== undefined) {
    const __val = partial.paymentTerms as string;
    if (__val.length === 0) {
      errors.push({ field: "paymentTerms", message: "must not be empty" });
    }
  }
  return errors;
}
export function isAccount(obj: unknown): obj is Account {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "id" in o &&
    "taxRate" in o &&
    "site" in o &&
    "salesRep" in o &&
    "orders" in o &&
    "activity" in o &&
    "customFields" in o &&
    "accountName" in o &&
    "sector" in o &&
    "memo" in o &&
    "phones" in o &&
    "email" in o &&
    "leadSource" in o &&
    "colors" in o &&
    "needsReview" in o &&
    "hasAlert" in o &&
    "accountType" in o &&
    "subtype" in o &&
    "isTaxExempt" in o &&
    "paymentTerms" in o &&
    "tags" in o &&
    "dateAdded" in o
  );
}

export namespace Account {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    taxRate: Option<Array<string>>;
    site: Option<Array<string>>;
    salesRep: Option<Array<string>>;
    orders: Option<Array<string>>;
    activity: Option<Array<string>>;
    customFields: Option<Array<string>>;
    accountName: Option<Array<string>>;
    sector: Option<Array<string>>;
    memo: Option<Array<string>>;
    phones: Option<Array<string>>;
    email: Option<Array<string>>;
    leadSource: Option<Array<string>>;
    colors: Option<Array<string>>;
    needsReview: Option<Array<string>>;
    hasAlert: Option<Array<string>>;
    accountType: Option<Array<string>>;
    subtype: Option<Array<string>>;
    isTaxExempt: Option<Array<string>>;
    paymentTerms: Option<Array<string>>;
    tags: Option<Array<string>>;
    dateAdded: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      taxRate: Option<boolean>;
      site: Option<boolean>;
      salesRep: Option<boolean>;
      orders: Option<boolean>;
      activity: Option<boolean>;
      customFields: Option<boolean>;
      accountName: Option<boolean>;
      sector: Option<boolean>;
      memo: Option<boolean>;
      phones: Option<boolean>;
      email: Option<boolean>;
      leadSource: Option<boolean>;
      colors: Option<boolean>;
      needsReview: Option<boolean>;
      hasAlert: Option<boolean>;
      accountType: Option<boolean>;
      subtype: Option<boolean>;
      isTaxExempt: Option<boolean>;
      paymentTerms: Option<boolean>;
      tags: Option<boolean>;
      dateAdded: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly taxRate: FieldController<string | TaxRate>;
    readonly site: FieldController<string | Site>;
    readonly salesRep: FieldController<Represents[] | null>;
    readonly orders: ArrayFieldController<Ordered>;
    readonly activity: ArrayFieldController<Did>;
    readonly customFields: ArrayFieldController<[string, string]>;
    readonly accountName: FieldController<AccountName>;
    readonly sector: FieldController<Sector>;
    readonly memo: FieldController<string | null>;
    readonly phones: ArrayFieldController<PhoneNumber>;
    readonly email: FieldController<Email>;
    readonly leadSource: FieldController<string>;
    readonly colors: FieldController<Colors>;
    readonly needsReview: FieldController<boolean>;
    readonly hasAlert: FieldController<boolean>;
    readonly accountType: FieldController<string>;
    readonly subtype: FieldController<string>;
    readonly isTaxExempt: FieldController<boolean>;
    readonly paymentTerms: FieldController<string>;
    readonly tags: ArrayFieldController<string>;
    readonly dateAdded: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Account;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Account, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Account>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Account>,
  ): Gigaform {
    let data = $state({ ...Account.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      taxRate: Option.none(),
      site: Option.none(),
      salesRep: Option.none(),
      orders: Option.none(),
      activity: Option.none(),
      customFields: Option.none(),
      accountName: Option.none(),
      sector: Option.none(),
      memo: Option.none(),
      phones: Option.none(),
      email: Option.none(),
      leadSource: Option.none(),
      colors: Option.none(),
      needsReview: Option.none(),
      hasAlert: Option.none(),
      accountType: Option.none(),
      subtype: Option.none(),
      isTaxExempt: Option.none(),
      paymentTerms: Option.none(),
      tags: Option.none(),
      dateAdded: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      taxRate: Option.none(),
      site: Option.none(),
      salesRep: Option.none(),
      orders: Option.none(),
      activity: Option.none(),
      customFields: Option.none(),
      accountName: Option.none(),
      sector: Option.none(),
      memo: Option.none(),
      phones: Option.none(),
      email: Option.none(),
      leadSource: Option.none(),
      colors: Option.none(),
      needsReview: Option.none(),
      hasAlert: Option.none(),
      accountType: Option.none(),
      subtype: Option.none(),
      isTaxExempt: Option.none(),
      paymentTerms: Option.none(),
      tags: Option.none(),
      dateAdded: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      taxRate: {
        path: ["taxRate"] as const,
        name: "taxRate",
        constraints: { required: true },
        label: "Tax Rate",
        get: () => data.taxRate,
        set: (value: string | TaxRate) => {
          data.taxRate = value;
        },
        transform: (value: string | TaxRate): string | TaxRate => value,
        getError: () => errors.taxRate,
        setError: (value: Option<Array<string>>) => {
          errors.taxRate = value;
        },
        getTainted: () => tainted.taxRate,
        setTainted: (value: Option<boolean>) => {
          tainted.taxRate = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField("taxRate", data.taxRate);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      site: {
        path: ["site"] as const,
        name: "site",
        constraints: { required: true },
        label: "Site",
        get: () => data.site,
        set: (value: string | Site) => {
          data.site = value;
        },
        transform: (value: string | Site): string | Site => value,
        getError: () => errors.site,
        setError: (value: Option<Array<string>>) => {
          errors.site = value;
        },
        getTainted: () => tainted.site,
        setTainted: (value: Option<boolean>) => {
          tainted.site = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField("site", data.site);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      salesRep: {
        path: ["salesRep"] as const,
        name: "salesRep",
        constraints: { required: true },
        label: "Sales Rep",
        get: () => data.salesRep,
        set: (value: Represents[] | null) => {
          data.salesRep = value;
        },
        transform: (value: Represents[] | null): Represents[] | null => value,
        getError: () => errors.salesRep,
        setError: (value: Option<Array<string>>) => {
          errors.salesRep = value;
        },
        getTainted: () => tainted.salesRep,
        setTainted: (value: Option<boolean>) => {
          tainted.salesRep = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField("salesRep", data.salesRep);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      orders: {
        path: ["orders"] as const,
        name: "orders",
        constraints: { required: true },

        get: () => data.orders,
        set: (value: Ordered[]) => {
          data.orders = value;
        },
        transform: (value: Ordered[]): Ordered[] => value,
        getError: () => errors.orders,
        setError: (value: Option<Array<string>>) => {
          errors.orders = value;
        },
        getTainted: () => tainted.orders,
        setTainted: (value: Option<boolean>) => {
          tainted.orders = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField("orders", data.orders);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["orders", index] as const,
          name: `orders.${index}`,
          constraints: { required: true },
          get: () => data.orders[index]!,
          set: (value: Ordered) => {
            data.orders[index] = value;
          },
          transform: (value: Ordered): Ordered => value,
          getError: () => errors.orders,
          setError: (value: Option<Array<string>>) => {
            errors.orders = value;
          },
          getTainted: () => tainted.orders,
          setTainted: (value: Option<boolean>) => {
            tainted.orders = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: Ordered) => {
          data.orders.push(item);
        },
        remove: (index: number) => {
          data.orders.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.orders[a]!;
          data.orders[a] = data.orders[b]!;
          data.orders[b] = tmp;
        },
      },
      activity: {
        path: ["activity"] as const,
        name: "activity",
        constraints: { required: true },

        get: () => data.activity,
        set: (value: Did[]) => {
          data.activity = value;
        },
        transform: (value: Did[]): Did[] => value,
        getError: () => errors.activity,
        setError: (value: Option<Array<string>>) => {
          errors.activity = value;
        },
        getTainted: () => tainted.activity,
        setTainted: (value: Option<boolean>) => {
          tainted.activity = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField("activity", data.activity);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["activity", index] as const,
          name: `activity.${index}`,
          constraints: { required: true },
          get: () => data.activity[index]!,
          set: (value: Did) => {
            data.activity[index] = value;
          },
          transform: (value: Did): Did => value,
          getError: () => errors.activity,
          setError: (value: Option<Array<string>>) => {
            errors.activity = value;
          },
          getTainted: () => tainted.activity,
          setTainted: (value: Option<boolean>) => {
            tainted.activity = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: Did) => {
          data.activity.push(item);
        },
        remove: (index: number) => {
          data.activity.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.activity[a]!;
          data.activity[a] = data.activity[b]!;
          data.activity[b] = tmp;
        },
      },
      customFields: {
        path: ["customFields"] as const,
        name: "customFields",
        constraints: { required: true },

        get: () => data.customFields,
        set: (value: [string, string][]) => {
          data.customFields = value;
        },
        transform: (value: [string, string][]): [string, string][] => value,
        getError: () => errors.customFields,
        setError: (value: Option<Array<string>>) => {
          errors.customFields = value;
        },
        getTainted: () => tainted.customFields,
        setTainted: (value: Option<boolean>) => {
          tainted.customFields = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField(
            "customFields",
            data.customFields,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["customFields", index] as const,
          name: `customFields.${index}`,
          constraints: { required: true },
          get: () => data.customFields[index]!,
          set: (value: [string, string]) => {
            data.customFields[index] = value;
          },
          transform: (value: [string, string]): [string, string] => value,
          getError: () => errors.customFields,
          setError: (value: Option<Array<string>>) => {
            errors.customFields = value;
          },
          getTainted: () => tainted.customFields,
          setTainted: (value: Option<boolean>) => {
            tainted.customFields = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: [string, string]) => {
          data.customFields.push(item);
        },
        remove: (index: number) => {
          data.customFields.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.customFields[a]!;
          data.customFields[a] = data.customFields[b]!;
          data.customFields[b] = tmp;
        },
      },
      accountName: {
        path: ["accountName"] as const,
        name: "accountName",
        constraints: { required: true },

        get: () => data.accountName,
        set: (value: AccountName) => {
          data.accountName = value;
        },
        transform: (value: AccountName): AccountName => value,
        getError: () => errors.accountName,
        setError: (value: Option<Array<string>>) => {
          errors.accountName = value;
        },
        getTainted: () => tainted.accountName,
        setTainted: (value: Option<boolean>) => {
          tainted.accountName = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField(
            "accountName",
            data.accountName,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      sector: {
        path: ["sector"] as const,
        name: "sector",
        constraints: { required: true },
        label: "Sector",
        get: () => data.sector,
        set: (value: Sector) => {
          data.sector = value;
        },
        transform: (value: Sector): Sector => value,
        getError: () => errors.sector,
        setError: (value: Option<Array<string>>) => {
          errors.sector = value;
        },
        getTainted: () => tainted.sector,
        setTainted: (value: Option<boolean>) => {
          tainted.sector = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField("sector", data.sector);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      memo: {
        path: ["memo"] as const,
        name: "memo",
        constraints: { required: true },
        label: "Memo",
        get: () => data.memo,
        set: (value: string | null) => {
          data.memo = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.memo,
        setError: (value: Option<Array<string>>) => {
          errors.memo = value;
        },
        getTainted: () => tainted.memo,
        setTainted: (value: Option<boolean>) => {
          tainted.memo = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField("memo", data.memo);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      phones: {
        path: ["phones"] as const,
        name: "phones",
        constraints: { required: true },

        get: () => data.phones,
        set: (value: PhoneNumber[]) => {
          data.phones = value;
        },
        transform: (value: PhoneNumber[]): PhoneNumber[] => value,
        getError: () => errors.phones,
        setError: (value: Option<Array<string>>) => {
          errors.phones = value;
        },
        getTainted: () => tainted.phones,
        setTainted: (value: Option<boolean>) => {
          tainted.phones = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField("phones", data.phones);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["phones", index] as const,
          name: `phones.${index}`,
          constraints: { required: true },
          get: () => data.phones[index]!,
          set: (value: PhoneNumber) => {
            data.phones[index] = value;
          },
          transform: (value: PhoneNumber): PhoneNumber => value,
          getError: () => errors.phones,
          setError: (value: Option<Array<string>>) => {
            errors.phones = value;
          },
          getTainted: () => tainted.phones,
          setTainted: (value: Option<boolean>) => {
            tainted.phones = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: PhoneNumber) => {
          data.phones.push(item);
        },
        remove: (index: number) => {
          data.phones.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.phones[a]!;
          data.phones[a] = data.phones[b]!;
          data.phones[b] = tmp;
        },
      },
      email: {
        path: ["email"] as const,
        name: "email",
        constraints: { required: true },
        label: "Email",
        get: () => data.email,
        set: (value: Email) => {
          data.email = value;
        },
        transform: (value: Email): Email => value,
        getError: () => errors.email,
        setError: (value: Option<Array<string>>) => {
          errors.email = value;
        },
        getTainted: () => tainted.email,
        setTainted: (value: Option<boolean>) => {
          tainted.email = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField("email", data.email);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      leadSource: {
        path: ["leadSource"] as const,
        name: "leadSource",
        constraints: { required: true },
        label: "Lead Source",
        get: () => data.leadSource,
        set: (value: string) => {
          data.leadSource = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.leadSource,
        setError: (value: Option<Array<string>>) => {
          errors.leadSource = value;
        },
        getTainted: () => tainted.leadSource,
        setTainted: (value: Option<boolean>) => {
          tainted.leadSource = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField(
            "leadSource",
            data.leadSource,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      colors: {
        path: ["colors"] as const,
        name: "colors",
        constraints: { required: true },

        get: () => data.colors,
        set: (value: Colors) => {
          data.colors = value;
        },
        transform: (value: Colors): Colors => value,
        getError: () => errors.colors,
        setError: (value: Option<Array<string>>) => {
          errors.colors = value;
        },
        getTainted: () => tainted.colors,
        setTainted: (value: Option<boolean>) => {
          tainted.colors = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField("colors", data.colors);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      needsReview: {
        path: ["needsReview"] as const,
        name: "needsReview",
        constraints: { required: true },
        label: "Needs Review",
        get: () => data.needsReview,
        set: (value: boolean) => {
          data.needsReview = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.needsReview,
        setError: (value: Option<Array<string>>) => {
          errors.needsReview = value;
        },
        getTainted: () => tainted.needsReview,
        setTainted: (value: Option<boolean>) => {
          tainted.needsReview = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField(
            "needsReview",
            data.needsReview,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      hasAlert: {
        path: ["hasAlert"] as const,
        name: "hasAlert",
        constraints: { required: true },
        label: "Has Alert",
        get: () => data.hasAlert,
        set: (value: boolean) => {
          data.hasAlert = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.hasAlert,
        setError: (value: Option<Array<string>>) => {
          errors.hasAlert = value;
        },
        getTainted: () => tainted.hasAlert,
        setTainted: (value: Option<boolean>) => {
          tainted.hasAlert = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField("hasAlert", data.hasAlert);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      accountType: {
        path: ["accountType"] as const,
        name: "accountType",
        constraints: { required: true },
        label: "Account Type",
        get: () => data.accountType,
        set: (value: string) => {
          data.accountType = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.accountType,
        setError: (value: Option<Array<string>>) => {
          errors.accountType = value;
        },
        getTainted: () => tainted.accountType,
        setTainted: (value: Option<boolean>) => {
          tainted.accountType = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField(
            "accountType",
            data.accountType,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      subtype: {
        path: ["subtype"] as const,
        name: "subtype",
        constraints: { required: true },
        label: "Subtype",
        get: () => data.subtype,
        set: (value: string) => {
          data.subtype = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.subtype,
        setError: (value: Option<Array<string>>) => {
          errors.subtype = value;
        },
        getTainted: () => tainted.subtype,
        setTainted: (value: Option<boolean>) => {
          tainted.subtype = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField("subtype", data.subtype);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      isTaxExempt: {
        path: ["isTaxExempt"] as const,
        name: "isTaxExempt",
        constraints: { required: true },
        label: "Tax Exempt",
        get: () => data.isTaxExempt,
        set: (value: boolean) => {
          data.isTaxExempt = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.isTaxExempt,
        setError: (value: Option<Array<string>>) => {
          errors.isTaxExempt = value;
        },
        getTainted: () => tainted.isTaxExempt,
        setTainted: (value: Option<boolean>) => {
          tainted.isTaxExempt = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField(
            "isTaxExempt",
            data.isTaxExempt,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      paymentTerms: {
        path: ["paymentTerms"] as const,
        name: "paymentTerms",
        constraints: { required: true },
        label: "Payment Terms",
        get: () => data.paymentTerms,
        set: (value: string) => {
          data.paymentTerms = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.paymentTerms,
        setError: (value: Option<Array<string>>) => {
          errors.paymentTerms = value;
        },
        getTainted: () => tainted.paymentTerms,
        setTainted: (value: Option<boolean>) => {
          tainted.paymentTerms = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField(
            "paymentTerms",
            data.paymentTerms,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      tags: {
        path: ["tags"] as const,
        name: "tags",
        constraints: { required: true },
        label: "Tags",
        get: () => data.tags,
        set: (value: string[]) => {
          data.tags = value;
        },
        transform: (value: string[]): string[] => value,
        getError: () => errors.tags,
        setError: (value: Option<Array<string>>) => {
          errors.tags = value;
        },
        getTainted: () => tainted.tags,
        setTainted: (value: Option<boolean>) => {
          tainted.tags = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField("tags", data.tags);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["tags", index] as const,
          name: `tags.${index}`,
          constraints: { required: true },
          get: () => data.tags[index]!,
          set: (value: string) => {
            data.tags[index] = value;
          },
          transform: (value: string): string => value,
          getError: () => errors.tags,
          setError: (value: Option<Array<string>>) => {
            errors.tags = value;
          },
          getTainted: () => tainted.tags,
          setTainted: (value: Option<boolean>) => {
            tainted.tags = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.tags.push(item);
        },
        remove: (index: number) => {
          data.tags.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.tags[a]!;
          data.tags[a] = data.tags[b]!;
          data.tags[b] = tmp;
        },
      },
      dateAdded: {
        path: ["dateAdded"] as const,
        name: "dateAdded",
        constraints: { required: true },

        get: () => data.dateAdded,
        set: (value: string) => {
          data.dateAdded = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.dateAdded,
        setError: (value: Option<Array<string>>) => {
          errors.dateAdded = value;
        },
        getTainted: () => tainted.dateAdded,
        setTainted: (value: Option<boolean>) => {
          tainted.dateAdded = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Account.validateField(
            "dateAdded",
            data.dateAdded,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Account,
      Array<{ field: string; message: string }>
    > {
      return Account.fromObject(data);
    }
    function reset(newOverrides?: Partial<Account>): void {
      data = { ...Account.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        taxRate: Option.none(),
        site: Option.none(),
        salesRep: Option.none(),
        orders: Option.none(),
        activity: Option.none(),
        customFields: Option.none(),
        accountName: Option.none(),
        sector: Option.none(),
        memo: Option.none(),
        phones: Option.none(),
        email: Option.none(),
        leadSource: Option.none(),
        colors: Option.none(),
        needsReview: Option.none(),
        hasAlert: Option.none(),
        accountType: Option.none(),
        subtype: Option.none(),
        isTaxExempt: Option.none(),
        paymentTerms: Option.none(),
        tags: Option.none(),
        dateAdded: Option.none(),
      };
      tainted = {
        id: Option.none(),
        taxRate: Option.none(),
        site: Option.none(),
        salesRep: Option.none(),
        orders: Option.none(),
        activity: Option.none(),
        customFields: Option.none(),
        accountName: Option.none(),
        sector: Option.none(),
        memo: Option.none(),
        phones: Option.none(),
        email: Option.none(),
        leadSource: Option.none(),
        colors: Option.none(),
        needsReview: Option.none(),
        hasAlert: Option.none(),
        accountType: Option.none(),
        subtype: Option.none(),
        isTaxExempt: Option.none(),
        paymentTerms: Option.none(),
        tags: Option.none(),
        dateAdded: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Account, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.taxRate = formData.get("taxRate") ?? "";
    obj.site = formData.get("site") ?? "";
    obj.salesRep = formData.get("salesRep") ?? "";
    {
      // Collect array items from indexed form fields
      const ordersItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("orders." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("orders." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("orders." + idx + ".")) {
              const fieldName = key.slice(
                "orders.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          ordersItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.orders = ordersItems;
    }
    {
      // Collect array items from indexed form fields
      const activityItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("activity." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("activity." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("activity." + idx + ".")) {
              const fieldName = key.slice(
                "activity.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          activityItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.activity = activityItems;
    }
    {
      // Collect array items from indexed form fields
      const customFieldsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("customFields." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("customFields." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("customFields." + idx + ".")) {
              const fieldName = key.slice(
                "customFields.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          customFieldsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.customFields = customFieldsItems;
    }
    {
      // Collect nested object fields with prefix "accountName."
      const accountNameObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("accountName.")) {
          const fieldName = key.slice("accountName.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = accountNameObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.accountName = accountNameObj;
    }
    {
      // Collect nested object fields with prefix "sector."
      const sectorObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("sector.")) {
          const fieldName = key.slice("sector.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = sectorObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.sector = sectorObj;
    }
    obj.memo = formData.get("memo") ?? "";
    {
      // Collect array items from indexed form fields
      const phonesItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("phones." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("phones." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("phones." + idx + ".")) {
              const fieldName = key.slice(
                "phones.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          phonesItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.phones = phonesItems;
    }
    {
      // Collect nested object fields with prefix "email."
      const emailObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("email.")) {
          const fieldName = key.slice("email.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = emailObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.email = emailObj;
    }
    obj.leadSource = formData.get("leadSource") ?? "";
    {
      // Collect nested object fields with prefix "colors."
      const colorsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("colors.")) {
          const fieldName = key.slice("colors.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = colorsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.colors = colorsObj;
    }
    {
      const needsReviewVal = formData.get("needsReview");
      obj.needsReview =
        needsReviewVal === "true" ||
        needsReviewVal === "on" ||
        needsReviewVal === "1";
    }
    {
      const hasAlertVal = formData.get("hasAlert");
      obj.hasAlert =
        hasAlertVal === "true" || hasAlertVal === "on" || hasAlertVal === "1";
    }
    obj.accountType = formData.get("accountType") ?? "";
    obj.subtype = formData.get("subtype") ?? "";
    {
      const isTaxExemptVal = formData.get("isTaxExempt");
      obj.isTaxExempt =
        isTaxExemptVal === "true" ||
        isTaxExemptVal === "on" ||
        isTaxExemptVal === "1";
    }
    obj.paymentTerms = formData.get("paymentTerms") ?? "";
    obj.tags = formData.getAll("tags") as Array<string>;
    obj.dateAdded = formData.get("dateAdded") ?? "";
    return Account.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Edited {
  /** @serde({ validate: ["nonEmpty"] }) */
  fieldName: string;
  oldValue: string | null;
  newValue: string | null;
}

export function defaultValueEdited(): Edited {
  return { fieldName: "", oldValue: null, newValue: null } as Edited;
}

export function toStringifiedJSONEdited(value: Edited): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeEdited(value, ctx));
}
export function toObjectEdited(value: Edited): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeEdited(value, ctx);
}
export function __serializeEdited(
  value: Edited,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Edited", __id };
  result["fieldName"] = value.fieldName;
  if (value.oldValue !== null) {
    result["oldValue"] =
      typeof (value.oldValue as any)?.__serialize === "function"
        ? (value.oldValue as any).__serialize(ctx)
        : value.oldValue;
  } else {
    result["oldValue"] = null;
  }
  if (value.newValue !== null) {
    result["newValue"] =
      typeof (value.newValue as any)?.__serialize === "function"
        ? (value.newValue as any).__serialize(ctx)
        : value.newValue;
  } else {
    result["newValue"] = null;
  }
  return result;
}

export function fromStringifiedJSONEdited(
  json: string,
  opts?: DeserializeOptions,
): Result<Edited, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectEdited(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectEdited(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Edited, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeEdited(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Edited.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeEdited(
  value: any,
  ctx: DeserializeContext,
): Edited | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Edited.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("fieldName" in obj)) {
    errors.push({ field: "fieldName", message: "missing required field" });
  }
  if (!("oldValue" in obj)) {
    errors.push({ field: "oldValue", message: "missing required field" });
  }
  if (!("newValue" in obj)) {
    errors.push({ field: "newValue", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_fieldName = obj["fieldName"] as string;
    if (__raw_fieldName.length === 0) {
      errors.push({ field: "fieldName", message: "must not be empty" });
    }
    instance.fieldName = __raw_fieldName;
  }
  {
    const __raw_oldValue = obj["oldValue"] as string | null;
    if (__raw_oldValue === null) {
      instance.oldValue = null;
    } else if (typeof (__raw_oldValue as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_oldValue as any).__ref);
      ctx.assignOrDefer(instance, "oldValue", __result);
    } else {
      instance.oldValue = __raw_oldValue;
    }
  }
  {
    const __raw_newValue = obj["newValue"] as string | null;
    if (__raw_newValue === null) {
      instance.newValue = null;
    } else if (typeof (__raw_newValue as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_newValue as any).__ref);
      ctx.assignOrDefer(instance, "newValue", __result);
    } else {
      instance.newValue = __raw_newValue;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Edited;
}
export function validateFieldEdited<K extends keyof Edited>(
  field: K,
  value: Edited[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "fieldName": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "fieldName", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsEdited(
  partial: Partial<Edited>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("fieldName" in partial && partial.fieldName !== undefined) {
    const __val = partial.fieldName as string;
    if (__val.length === 0) {
      errors.push({ field: "fieldName", message: "must not be empty" });
    }
  }
  return errors;
}
export function isEdited(obj: unknown): obj is Edited {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "fieldName" in o && "oldValue" in o && "newValue" in o;
}

export namespace Edited {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    fieldName: Option<Array<string>>;
    oldValue: Option<Array<string>>;
    newValue: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      fieldName: Option<boolean>;
      oldValue: Option<boolean>;
      newValue: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly fieldName: FieldController<string>;
    readonly oldValue: FieldController<string | null>;
    readonly newValue: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Edited;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Edited, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Edited>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Edited>,
  ): Gigaform {
    let data = $state({ ...Edited.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      fieldName: Option.none(),
      oldValue: Option.none(),
      newValue: Option.none(),
    });
    let tainted = $state<Tainted>({
      fieldName: Option.none(),
      oldValue: Option.none(),
      newValue: Option.none(),
    });
    const fields: FieldControllers = {
      fieldName: {
        path: ["fieldName"] as const,
        name: "fieldName",
        constraints: { required: true },

        get: () => data.fieldName,
        set: (value: string) => {
          data.fieldName = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.fieldName,
        setError: (value: Option<Array<string>>) => {
          errors.fieldName = value;
        },
        getTainted: () => tainted.fieldName,
        setTainted: (value: Option<boolean>) => {
          tainted.fieldName = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Edited.validateField("fieldName", data.fieldName);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      oldValue: {
        path: ["oldValue"] as const,
        name: "oldValue",
        constraints: { required: true },

        get: () => data.oldValue,
        set: (value: string | null) => {
          data.oldValue = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.oldValue,
        setError: (value: Option<Array<string>>) => {
          errors.oldValue = value;
        },
        getTainted: () => tainted.oldValue,
        setTainted: (value: Option<boolean>) => {
          tainted.oldValue = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Edited.validateField("oldValue", data.oldValue);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      newValue: {
        path: ["newValue"] as const,
        name: "newValue",
        constraints: { required: true },

        get: () => data.newValue,
        set: (value: string | null) => {
          data.newValue = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.newValue,
        setError: (value: Option<Array<string>>) => {
          errors.newValue = value;
        },
        getTainted: () => tainted.newValue,
        setTainted: (value: Option<boolean>) => {
          tainted.newValue = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Edited.validateField("newValue", data.newValue);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Edited,
      Array<{ field: string; message: string }>
    > {
      return Edited.fromObject(data);
    }
    function reset(newOverrides?: Partial<Edited>): void {
      data = { ...Edited.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        fieldName: Option.none(),
        oldValue: Option.none(),
        newValue: Option.none(),
      };
      tainted = {
        fieldName: Option.none(),
        oldValue: Option.none(),
        newValue: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Edited, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.fieldName = formData.get("fieldName") ?? "";
    obj.oldValue = formData.get("oldValue") ?? "";
    obj.newValue = formData.get("newValue") ?? "";
    return Edited.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Order {
  /** @hiddenController({}) */
  id: string;
  /** @comboboxController({ label: "Account", allowCustom: false, fetchUrls: ["/api/accounts"] }) */
  /** @default("") */
  account: string | Account;
  /** @selectController({ label: "Stage", options: [{ label: "Estimate", value: "Estimate" }, { label: "Active", value: "Active" }, { label: "Invoice", value: "Invoice" }] }) */
  /** @default("Estimate") */
  stage: OrderStage;
  /** @hiddenController({}) */
  number: number;
  /** @hiddenController({}) */
  payments: (string | Payment)[];
  /** @textController({ label: "Opportunity" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  opportunity: string;
  /** @textController({ label: "Reference" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  reference: string;
  /** @comboboxController({ label: "Lead Source", allowCustom: true }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  leadSource: string;
  /** @comboboxController({ label: "Sales Rep", allowCustom: false, fetchUrls: ["/api/employees"] }) */
  /** @default("") */
  salesRep: string | Employee;
  /** @comboboxController({ label: "Group", allowCustom: true }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  group: string;
  /** @comboboxController({ label: "Subgroup", allowCustom: true }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  subgroup: string;
  /** @switchController({ label: "Posted" }) */
  isPosted: boolean;
  /** @switchController({ label: "Needs Review" }) */
  needsReview: boolean;
  /** @textController({ label: "Action Item" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  actionItem: string;
  /** @hiddenController({}) */
  upsale: number;
  /** @hiddenController({}) */
  dateCreated: string;
  /** @comboboxController({ label: "Appointment", allowCustom: false, fetchUrls: ["/api/appointments"] }) */
  /** @default("") */
  appointment: string | Appointment;
  /** @comboboxMultipleController({ label: "Technicians", fetchUrls: ["/api/employees"] }) */
  lastTechs: (string | Employee)[];
  /** @hiddenController({}) */
  package: (string | Package)[] | null;
  /** @hiddenController({}) */
  promotion: (string | Promotion)[] | null;
  /** @hiddenController({}) */
  balance: number;
  /** @dateTimeController({ label: "Due" }) */
  due: string;
  /** @hiddenController({}) */
  total: number;
  /** @siteFieldsetController({ label: "Site" }) */
  /** @default("") */
  site: string | Site;
  /** @arrayFieldsetController({ legend: "Billed Items" }) */
  billedItems: BilledItem[];
  /** @textAreaController({ label: "Memo" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  memo: string;
  /** @hiddenController({}) */
  discount: number;
  /** @hiddenController({}) */
  tip: number;
  /** @hiddenController({}) */
  commissions: number[];
}

export function defaultValueOrder(): Order {
  return {
    id: "",
    account: "",
    stage: "Estimate",
    number: 0,
    payments: [],
    opportunity: "",
    reference: "",
    leadSource: "",
    salesRep: "",
    group: "",
    subgroup: "",
    isPosted: false,
    needsReview: false,
    actionItem: "",
    upsale: 0,
    dateCreated: "",
    appointment: "",
    lastTechs: [],
    package: null,
    promotion: null,
    balance: 0,
    due: "",
    total: 0,
    site: "",
    billedItems: [],
    memo: "",
    discount: 0,
    tip: 0,
    commissions: [],
  } as Order;
}

export function toStringifiedJSONOrder(value: Order): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeOrder(value, ctx));
}
export function toObjectOrder(value: Order): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeOrder(value, ctx);
}
export function __serializeOrder(
  value: Order,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Order", __id };
  result["id"] = value.id;
  result["account"] = value.account;
  result["stage"] =
    typeof (value.stage as any)?.__serialize === "function"
      ? (value.stage as any).__serialize(ctx)
      : value.stage;
  result["number"] = value.number;
  result["payments"] = value.payments.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["opportunity"] = value.opportunity;
  result["reference"] = value.reference;
  result["leadSource"] = value.leadSource;
  result["salesRep"] = value.salesRep;
  result["group"] = value.group;
  result["subgroup"] = value.subgroup;
  result["isPosted"] = value.isPosted;
  result["needsReview"] = value.needsReview;
  result["actionItem"] = value.actionItem;
  result["upsale"] = value.upsale;
  result["dateCreated"] = value.dateCreated;
  result["appointment"] = value.appointment;
  result["lastTechs"] = value.lastTechs.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  if (value.package !== null) {
    result["package"] =
      typeof (value.package as any)?.__serialize === "function"
        ? (value.package as any).__serialize(ctx)
        : value.package;
  } else {
    result["package"] = null;
  }
  if (value.promotion !== null) {
    result["promotion"] =
      typeof (value.promotion as any)?.__serialize === "function"
        ? (value.promotion as any).__serialize(ctx)
        : value.promotion;
  } else {
    result["promotion"] = null;
  }
  result["balance"] = value.balance;
  result["due"] = value.due;
  result["total"] = value.total;
  result["site"] = value.site;
  result["billedItems"] = value.billedItems.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["memo"] = value.memo;
  result["discount"] = value.discount;
  result["tip"] = value.tip;
  result["commissions"] = value.commissions.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  return result;
}

export function fromStringifiedJSONOrder(
  json: string,
  opts?: DeserializeOptions,
): Result<Order, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectOrder(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectOrder(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Order, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeOrder(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Order.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeOrder(
  value: any,
  ctx: DeserializeContext,
): Order | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Order.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("account" in obj)) {
    errors.push({ field: "account", message: "missing required field" });
  }
  if (!("stage" in obj)) {
    errors.push({ field: "stage", message: "missing required field" });
  }
  if (!("number" in obj)) {
    errors.push({ field: "number", message: "missing required field" });
  }
  if (!("payments" in obj)) {
    errors.push({ field: "payments", message: "missing required field" });
  }
  if (!("opportunity" in obj)) {
    errors.push({ field: "opportunity", message: "missing required field" });
  }
  if (!("reference" in obj)) {
    errors.push({ field: "reference", message: "missing required field" });
  }
  if (!("leadSource" in obj)) {
    errors.push({ field: "leadSource", message: "missing required field" });
  }
  if (!("salesRep" in obj)) {
    errors.push({ field: "salesRep", message: "missing required field" });
  }
  if (!("group" in obj)) {
    errors.push({ field: "group", message: "missing required field" });
  }
  if (!("subgroup" in obj)) {
    errors.push({ field: "subgroup", message: "missing required field" });
  }
  if (!("isPosted" in obj)) {
    errors.push({ field: "isPosted", message: "missing required field" });
  }
  if (!("needsReview" in obj)) {
    errors.push({ field: "needsReview", message: "missing required field" });
  }
  if (!("actionItem" in obj)) {
    errors.push({ field: "actionItem", message: "missing required field" });
  }
  if (!("upsale" in obj)) {
    errors.push({ field: "upsale", message: "missing required field" });
  }
  if (!("dateCreated" in obj)) {
    errors.push({ field: "dateCreated", message: "missing required field" });
  }
  if (!("appointment" in obj)) {
    errors.push({ field: "appointment", message: "missing required field" });
  }
  if (!("lastTechs" in obj)) {
    errors.push({ field: "lastTechs", message: "missing required field" });
  }
  if (!("package" in obj)) {
    errors.push({ field: "package", message: "missing required field" });
  }
  if (!("promotion" in obj)) {
    errors.push({ field: "promotion", message: "missing required field" });
  }
  if (!("balance" in obj)) {
    errors.push({ field: "balance", message: "missing required field" });
  }
  if (!("due" in obj)) {
    errors.push({ field: "due", message: "missing required field" });
  }
  if (!("total" in obj)) {
    errors.push({ field: "total", message: "missing required field" });
  }
  if (!("site" in obj)) {
    errors.push({ field: "site", message: "missing required field" });
  }
  if (!("billedItems" in obj)) {
    errors.push({ field: "billedItems", message: "missing required field" });
  }
  if (!("memo" in obj)) {
    errors.push({ field: "memo", message: "missing required field" });
  }
  if (!("discount" in obj)) {
    errors.push({ field: "discount", message: "missing required field" });
  }
  if (!("tip" in obj)) {
    errors.push({ field: "tip", message: "missing required field" });
  }
  if (!("commissions" in obj)) {
    errors.push({ field: "commissions", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_account = obj["account"] as string | Account;
    instance.account = __raw_account;
  }
  {
    const __raw_stage = obj["stage"] as OrderStage;
    if (typeof (OrderStage as any)?.__deserialize === "function") {
      const __result = (OrderStage as any).__deserialize(__raw_stage, ctx);
      ctx.assignOrDefer(instance, "stage", __result);
    } else {
      instance.stage = __raw_stage;
    }
  }
  {
    const __raw_number = obj["number"] as number;
    instance.number = __raw_number;
  }
  {
    const __raw_payments = obj["payments"] as (string | Payment)[];
    if (Array.isArray(__raw_payments)) {
      instance.payments = __raw_payments as (string | Payment)[];
    }
  }
  {
    const __raw_opportunity = obj["opportunity"] as string;
    if (__raw_opportunity.length === 0) {
      errors.push({ field: "opportunity", message: "must not be empty" });
    }
    instance.opportunity = __raw_opportunity;
  }
  {
    const __raw_reference = obj["reference"] as string;
    if (__raw_reference.length === 0) {
      errors.push({ field: "reference", message: "must not be empty" });
    }
    instance.reference = __raw_reference;
  }
  {
    const __raw_leadSource = obj["leadSource"] as string;
    if (__raw_leadSource.length === 0) {
      errors.push({ field: "leadSource", message: "must not be empty" });
    }
    instance.leadSource = __raw_leadSource;
  }
  {
    const __raw_salesRep = obj["salesRep"] as string | Employee;
    instance.salesRep = __raw_salesRep;
  }
  {
    const __raw_group = obj["group"] as string;
    if (__raw_group.length === 0) {
      errors.push({ field: "group", message: "must not be empty" });
    }
    instance.group = __raw_group;
  }
  {
    const __raw_subgroup = obj["subgroup"] as string;
    if (__raw_subgroup.length === 0) {
      errors.push({ field: "subgroup", message: "must not be empty" });
    }
    instance.subgroup = __raw_subgroup;
  }
  {
    const __raw_isPosted = obj["isPosted"] as boolean;
    instance.isPosted = __raw_isPosted;
  }
  {
    const __raw_needsReview = obj["needsReview"] as boolean;
    instance.needsReview = __raw_needsReview;
  }
  {
    const __raw_actionItem = obj["actionItem"] as string;
    if (__raw_actionItem.length === 0) {
      errors.push({ field: "actionItem", message: "must not be empty" });
    }
    instance.actionItem = __raw_actionItem;
  }
  {
    const __raw_upsale = obj["upsale"] as number;
    instance.upsale = __raw_upsale;
  }
  {
    const __raw_dateCreated = obj["dateCreated"] as string;
    instance.dateCreated = __raw_dateCreated;
  }
  {
    const __raw_appointment = obj["appointment"] as string | Appointment;
    instance.appointment = __raw_appointment;
  }
  {
    const __raw_lastTechs = obj["lastTechs"] as (string | Employee)[];
    if (Array.isArray(__raw_lastTechs)) {
      instance.lastTechs = __raw_lastTechs as (string | Employee)[];
    }
  }
  {
    const __raw_package = obj["package"] as (string | Package)[] | null;
    if (__raw_package === null) {
      instance.package = null;
    } else if (typeof (__raw_package as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_package as any).__ref);
      ctx.assignOrDefer(instance, "package", __result);
    } else {
      instance.package = __raw_package;
    }
  }
  {
    const __raw_promotion = obj["promotion"] as (string | Promotion)[] | null;
    if (__raw_promotion === null) {
      instance.promotion = null;
    } else if (typeof (__raw_promotion as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_promotion as any).__ref);
      ctx.assignOrDefer(instance, "promotion", __result);
    } else {
      instance.promotion = __raw_promotion;
    }
  }
  {
    const __raw_balance = obj["balance"] as number;
    instance.balance = __raw_balance;
  }
  {
    const __raw_due = obj["due"] as string;
    instance.due = __raw_due;
  }
  {
    const __raw_total = obj["total"] as number;
    instance.total = __raw_total;
  }
  {
    const __raw_site = obj["site"] as string | Site;
    instance.site = __raw_site;
  }
  {
    const __raw_billedItems = obj["billedItems"] as BilledItem[];
    if (Array.isArray(__raw_billedItems)) {
      instance.billedItems = __raw_billedItems as BilledItem[];
    }
  }
  {
    const __raw_memo = obj["memo"] as string;
    if (__raw_memo.length === 0) {
      errors.push({ field: "memo", message: "must not be empty" });
    }
    instance.memo = __raw_memo;
  }
  {
    const __raw_discount = obj["discount"] as number;
    instance.discount = __raw_discount;
  }
  {
    const __raw_tip = obj["tip"] as number;
    instance.tip = __raw_tip;
  }
  {
    const __raw_commissions = obj["commissions"] as number[];
    if (Array.isArray(__raw_commissions)) {
      instance.commissions = __raw_commissions as number[];
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Order;
}
export function validateFieldOrder<K extends keyof Order>(
  field: K,
  value: Order[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "opportunity": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "opportunity", message: "must not be empty" });
      }
      break;
    }
    case "reference": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "reference", message: "must not be empty" });
      }
      break;
    }
    case "leadSource": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "leadSource", message: "must not be empty" });
      }
      break;
    }
    case "group": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "group", message: "must not be empty" });
      }
      break;
    }
    case "subgroup": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "subgroup", message: "must not be empty" });
      }
      break;
    }
    case "actionItem": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "actionItem", message: "must not be empty" });
      }
      break;
    }
    case "memo": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "memo", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsOrder(
  partial: Partial<Order>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("opportunity" in partial && partial.opportunity !== undefined) {
    const __val = partial.opportunity as string;
    if (__val.length === 0) {
      errors.push({ field: "opportunity", message: "must not be empty" });
    }
  }
  if ("reference" in partial && partial.reference !== undefined) {
    const __val = partial.reference as string;
    if (__val.length === 0) {
      errors.push({ field: "reference", message: "must not be empty" });
    }
  }
  if ("leadSource" in partial && partial.leadSource !== undefined) {
    const __val = partial.leadSource as string;
    if (__val.length === 0) {
      errors.push({ field: "leadSource", message: "must not be empty" });
    }
  }
  if ("group" in partial && partial.group !== undefined) {
    const __val = partial.group as string;
    if (__val.length === 0) {
      errors.push({ field: "group", message: "must not be empty" });
    }
  }
  if ("subgroup" in partial && partial.subgroup !== undefined) {
    const __val = partial.subgroup as string;
    if (__val.length === 0) {
      errors.push({ field: "subgroup", message: "must not be empty" });
    }
  }
  if ("actionItem" in partial && partial.actionItem !== undefined) {
    const __val = partial.actionItem as string;
    if (__val.length === 0) {
      errors.push({ field: "actionItem", message: "must not be empty" });
    }
  }
  if ("memo" in partial && partial.memo !== undefined) {
    const __val = partial.memo as string;
    if (__val.length === 0) {
      errors.push({ field: "memo", message: "must not be empty" });
    }
  }
  return errors;
}
export function isOrder(obj: unknown): obj is Order {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "id" in o &&
    "account" in o &&
    "stage" in o &&
    "number" in o &&
    "payments" in o &&
    "opportunity" in o &&
    "reference" in o &&
    "leadSource" in o &&
    "salesRep" in o &&
    "group" in o &&
    "subgroup" in o &&
    "isPosted" in o &&
    "needsReview" in o &&
    "actionItem" in o &&
    "upsale" in o &&
    "dateCreated" in o &&
    "appointment" in o &&
    "lastTechs" in o &&
    "package" in o &&
    "promotion" in o &&
    "balance" in o &&
    "due" in o &&
    "total" in o &&
    "site" in o &&
    "billedItems" in o &&
    "memo" in o &&
    "discount" in o &&
    "tip" in o &&
    "commissions" in o
  );
}

export namespace Order {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    account: Option<Array<string>>;
    stage: Option<Array<string>>;
    number: Option<Array<string>>;
    payments: Option<Array<string>>;
    opportunity: Option<Array<string>>;
    reference: Option<Array<string>>;
    leadSource: Option<Array<string>>;
    salesRep: Option<Array<string>>;
    group: Option<Array<string>>;
    subgroup: Option<Array<string>>;
    isPosted: Option<Array<string>>;
    needsReview: Option<Array<string>>;
    actionItem: Option<Array<string>>;
    upsale: Option<Array<string>>;
    dateCreated: Option<Array<string>>;
    appointment: Option<Array<string>>;
    lastTechs: Option<Array<string>>;
    package: Option<Array<string>>;
    promotion: Option<Array<string>>;
    balance: Option<Array<string>>;
    due: Option<Array<string>>;
    total: Option<Array<string>>;
    site: Option<Array<string>>;
    billedItems: Option<Array<string>>;
    memo: Option<Array<string>>;
    discount: Option<Array<string>>;
    tip: Option<Array<string>>;
    commissions: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      account: Option<boolean>;
      stage: Option<boolean>;
      number: Option<boolean>;
      payments: Option<boolean>;
      opportunity: Option<boolean>;
      reference: Option<boolean>;
      leadSource: Option<boolean>;
      salesRep: Option<boolean>;
      group: Option<boolean>;
      subgroup: Option<boolean>;
      isPosted: Option<boolean>;
      needsReview: Option<boolean>;
      actionItem: Option<boolean>;
      upsale: Option<boolean>;
      dateCreated: Option<boolean>;
      appointment: Option<boolean>;
      lastTechs: Option<boolean>;
      package: Option<boolean>;
      promotion: Option<boolean>;
      balance: Option<boolean>;
      due: Option<boolean>;
      total: Option<boolean>;
      site: Option<boolean>;
      billedItems: Option<boolean>;
      memo: Option<boolean>;
      discount: Option<boolean>;
      tip: Option<boolean>;
      commissions: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly account: FieldController<string | Account>;
    readonly stage: FieldController<OrderStage>;
    readonly number: FieldController<number>;
    readonly payments: ArrayFieldController<string | Payment>;
    readonly opportunity: FieldController<string>;
    readonly reference: FieldController<string>;
    readonly leadSource: FieldController<string>;
    readonly salesRep: FieldController<string | Employee>;
    readonly group: FieldController<string>;
    readonly subgroup: FieldController<string>;
    readonly isPosted: FieldController<boolean>;
    readonly needsReview: FieldController<boolean>;
    readonly actionItem: FieldController<string>;
    readonly upsale: FieldController<number>;
    readonly dateCreated: FieldController<string>;
    readonly appointment: FieldController<string | Appointment>;
    readonly lastTechs: ArrayFieldController<string | Employee>;
    readonly package: FieldController<(string | Package)[] | null>;
    readonly promotion: FieldController<(string | Promotion)[] | null>;
    readonly balance: FieldController<number>;
    readonly due: FieldController<string>;
    readonly total: FieldController<number>;
    readonly site: FieldController<string | Site>;
    readonly billedItems: ArrayFieldController<BilledItem>;
    readonly memo: FieldController<string>;
    readonly discount: FieldController<number>;
    readonly tip: FieldController<number>;
    readonly commissions: ArrayFieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Order;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Order, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Order>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Order>,
  ): Gigaform {
    let data = $state({ ...Order.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      account: Option.none(),
      stage: Option.none(),
      number: Option.none(),
      payments: Option.none(),
      opportunity: Option.none(),
      reference: Option.none(),
      leadSource: Option.none(),
      salesRep: Option.none(),
      group: Option.none(),
      subgroup: Option.none(),
      isPosted: Option.none(),
      needsReview: Option.none(),
      actionItem: Option.none(),
      upsale: Option.none(),
      dateCreated: Option.none(),
      appointment: Option.none(),
      lastTechs: Option.none(),
      package: Option.none(),
      promotion: Option.none(),
      balance: Option.none(),
      due: Option.none(),
      total: Option.none(),
      site: Option.none(),
      billedItems: Option.none(),
      memo: Option.none(),
      discount: Option.none(),
      tip: Option.none(),
      commissions: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      account: Option.none(),
      stage: Option.none(),
      number: Option.none(),
      payments: Option.none(),
      opportunity: Option.none(),
      reference: Option.none(),
      leadSource: Option.none(),
      salesRep: Option.none(),
      group: Option.none(),
      subgroup: Option.none(),
      isPosted: Option.none(),
      needsReview: Option.none(),
      actionItem: Option.none(),
      upsale: Option.none(),
      dateCreated: Option.none(),
      appointment: Option.none(),
      lastTechs: Option.none(),
      package: Option.none(),
      promotion: Option.none(),
      balance: Option.none(),
      due: Option.none(),
      total: Option.none(),
      site: Option.none(),
      billedItems: Option.none(),
      memo: Option.none(),
      discount: Option.none(),
      tip: Option.none(),
      commissions: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      account: {
        path: ["account"] as const,
        name: "account",
        constraints: { required: true },
        label: "Account",
        get: () => data.account,
        set: (value: string | Account) => {
          data.account = value;
        },
        transform: (value: string | Account): string | Account => value,
        getError: () => errors.account,
        setError: (value: Option<Array<string>>) => {
          errors.account = value;
        },
        getTainted: () => tainted.account,
        setTainted: (value: Option<boolean>) => {
          tainted.account = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("account", data.account);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      stage: {
        path: ["stage"] as const,
        name: "stage",
        constraints: { required: true },
        label: "Stage",
        get: () => data.stage,
        set: (value: OrderStage) => {
          data.stage = value;
        },
        transform: (value: OrderStage): OrderStage => value,
        getError: () => errors.stage,
        setError: (value: Option<Array<string>>) => {
          errors.stage = value;
        },
        getTainted: () => tainted.stage,
        setTainted: (value: Option<boolean>) => {
          tainted.stage = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("stage", data.stage);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      number: {
        path: ["number"] as const,
        name: "number",
        constraints: { required: true },

        get: () => data.number,
        set: (value: number) => {
          data.number = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.number,
        setError: (value: Option<Array<string>>) => {
          errors.number = value;
        },
        getTainted: () => tainted.number,
        setTainted: (value: Option<boolean>) => {
          tainted.number = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("number", data.number);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      payments: {
        path: ["payments"] as const,
        name: "payments",
        constraints: { required: true },

        get: () => data.payments,
        set: (value: (string | Payment)[]) => {
          data.payments = value;
        },
        transform: (value: (string | Payment)[]): (string | Payment)[] => value,
        getError: () => errors.payments,
        setError: (value: Option<Array<string>>) => {
          errors.payments = value;
        },
        getTainted: () => tainted.payments,
        setTainted: (value: Option<boolean>) => {
          tainted.payments = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("payments", data.payments);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["payments", index] as const,
          name: `payments.${index}`,
          constraints: { required: true },
          get: () => data.payments[index]!,
          set: (value: string | Payment) => {
            data.payments[index] = value;
          },
          transform: (value: string | Payment): string | Payment => value,
          getError: () => errors.payments,
          setError: (value: Option<Array<string>>) => {
            errors.payments = value;
          },
          getTainted: () => tainted.payments,
          setTainted: (value: Option<boolean>) => {
            tainted.payments = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string | Payment) => {
          data.payments.push(item);
        },
        remove: (index: number) => {
          data.payments.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.payments[a]!;
          data.payments[a] = data.payments[b]!;
          data.payments[b] = tmp;
        },
      },
      opportunity: {
        path: ["opportunity"] as const,
        name: "opportunity",
        constraints: { required: true },
        label: "Opportunity",
        get: () => data.opportunity,
        set: (value: string) => {
          data.opportunity = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.opportunity,
        setError: (value: Option<Array<string>>) => {
          errors.opportunity = value;
        },
        getTainted: () => tainted.opportunity,
        setTainted: (value: Option<boolean>) => {
          tainted.opportunity = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "opportunity",
            data.opportunity,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      reference: {
        path: ["reference"] as const,
        name: "reference",
        constraints: { required: true },
        label: "Reference",
        get: () => data.reference,
        set: (value: string) => {
          data.reference = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.reference,
        setError: (value: Option<Array<string>>) => {
          errors.reference = value;
        },
        getTainted: () => tainted.reference,
        setTainted: (value: Option<boolean>) => {
          tainted.reference = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("reference", data.reference);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      leadSource: {
        path: ["leadSource"] as const,
        name: "leadSource",
        constraints: { required: true },
        label: "Lead Source",
        get: () => data.leadSource,
        set: (value: string) => {
          data.leadSource = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.leadSource,
        setError: (value: Option<Array<string>>) => {
          errors.leadSource = value;
        },
        getTainted: () => tainted.leadSource,
        setTainted: (value: Option<boolean>) => {
          tainted.leadSource = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "leadSource",
            data.leadSource,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      salesRep: {
        path: ["salesRep"] as const,
        name: "salesRep",
        constraints: { required: true },
        label: "Sales Rep",
        get: () => data.salesRep,
        set: (value: string | Employee) => {
          data.salesRep = value;
        },
        transform: (value: string | Employee): string | Employee => value,
        getError: () => errors.salesRep,
        setError: (value: Option<Array<string>>) => {
          errors.salesRep = value;
        },
        getTainted: () => tainted.salesRep,
        setTainted: (value: Option<boolean>) => {
          tainted.salesRep = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("salesRep", data.salesRep);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      group: {
        path: ["group"] as const,
        name: "group",
        constraints: { required: true },
        label: "Group",
        get: () => data.group,
        set: (value: string) => {
          data.group = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.group,
        setError: (value: Option<Array<string>>) => {
          errors.group = value;
        },
        getTainted: () => tainted.group,
        setTainted: (value: Option<boolean>) => {
          tainted.group = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("group", data.group);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      subgroup: {
        path: ["subgroup"] as const,
        name: "subgroup",
        constraints: { required: true },
        label: "Subgroup",
        get: () => data.subgroup,
        set: (value: string) => {
          data.subgroup = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.subgroup,
        setError: (value: Option<Array<string>>) => {
          errors.subgroup = value;
        },
        getTainted: () => tainted.subgroup,
        setTainted: (value: Option<boolean>) => {
          tainted.subgroup = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("subgroup", data.subgroup);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      isPosted: {
        path: ["isPosted"] as const,
        name: "isPosted",
        constraints: { required: true },
        label: "Posted",
        get: () => data.isPosted,
        set: (value: boolean) => {
          data.isPosted = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.isPosted,
        setError: (value: Option<Array<string>>) => {
          errors.isPosted = value;
        },
        getTainted: () => tainted.isPosted,
        setTainted: (value: Option<boolean>) => {
          tainted.isPosted = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("isPosted", data.isPosted);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      needsReview: {
        path: ["needsReview"] as const,
        name: "needsReview",
        constraints: { required: true },
        label: "Needs Review",
        get: () => data.needsReview,
        set: (value: boolean) => {
          data.needsReview = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.needsReview,
        setError: (value: Option<Array<string>>) => {
          errors.needsReview = value;
        },
        getTainted: () => tainted.needsReview,
        setTainted: (value: Option<boolean>) => {
          tainted.needsReview = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "needsReview",
            data.needsReview,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      actionItem: {
        path: ["actionItem"] as const,
        name: "actionItem",
        constraints: { required: true },
        label: "Action Item",
        get: () => data.actionItem,
        set: (value: string) => {
          data.actionItem = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.actionItem,
        setError: (value: Option<Array<string>>) => {
          errors.actionItem = value;
        },
        getTainted: () => tainted.actionItem,
        setTainted: (value: Option<boolean>) => {
          tainted.actionItem = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "actionItem",
            data.actionItem,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      upsale: {
        path: ["upsale"] as const,
        name: "upsale",
        constraints: { required: true },

        get: () => data.upsale,
        set: (value: number) => {
          data.upsale = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.upsale,
        setError: (value: Option<Array<string>>) => {
          errors.upsale = value;
        },
        getTainted: () => tainted.upsale,
        setTainted: (value: Option<boolean>) => {
          tainted.upsale = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("upsale", data.upsale);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      dateCreated: {
        path: ["dateCreated"] as const,
        name: "dateCreated",
        constraints: { required: true },

        get: () => data.dateCreated,
        set: (value: string) => {
          data.dateCreated = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.dateCreated,
        setError: (value: Option<Array<string>>) => {
          errors.dateCreated = value;
        },
        getTainted: () => tainted.dateCreated,
        setTainted: (value: Option<boolean>) => {
          tainted.dateCreated = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "dateCreated",
            data.dateCreated,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      appointment: {
        path: ["appointment"] as const,
        name: "appointment",
        constraints: { required: true },
        label: "Appointment",
        get: () => data.appointment,
        set: (value: string | Appointment) => {
          data.appointment = value;
        },
        transform: (value: string | Appointment): string | Appointment => value,
        getError: () => errors.appointment,
        setError: (value: Option<Array<string>>) => {
          errors.appointment = value;
        },
        getTainted: () => tainted.appointment,
        setTainted: (value: Option<boolean>) => {
          tainted.appointment = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "appointment",
            data.appointment,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      lastTechs: {
        path: ["lastTechs"] as const,
        name: "lastTechs",
        constraints: { required: true },
        label: "Technicians",
        get: () => data.lastTechs,
        set: (value: (string | Employee)[]) => {
          data.lastTechs = value;
        },
        transform: (value: (string | Employee)[]): (string | Employee)[] =>
          value,
        getError: () => errors.lastTechs,
        setError: (value: Option<Array<string>>) => {
          errors.lastTechs = value;
        },
        getTainted: () => tainted.lastTechs,
        setTainted: (value: Option<boolean>) => {
          tainted.lastTechs = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("lastTechs", data.lastTechs);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["lastTechs", index] as const,
          name: `lastTechs.${index}`,
          constraints: { required: true },
          get: () => data.lastTechs[index]!,
          set: (value: string | Employee) => {
            data.lastTechs[index] = value;
          },
          transform: (value: string | Employee): string | Employee => value,
          getError: () => errors.lastTechs,
          setError: (value: Option<Array<string>>) => {
            errors.lastTechs = value;
          },
          getTainted: () => tainted.lastTechs,
          setTainted: (value: Option<boolean>) => {
            tainted.lastTechs = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string | Employee) => {
          data.lastTechs.push(item);
        },
        remove: (index: number) => {
          data.lastTechs.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.lastTechs[a]!;
          data.lastTechs[a] = data.lastTechs[b]!;
          data.lastTechs[b] = tmp;
        },
      },
      package: {
        path: ["package"] as const,
        name: "package",
        constraints: { required: true },

        get: () => data.package,
        set: (value: (string | Package)[] | null) => {
          data.package = value;
        },
        transform: (
          value: (string | Package)[] | null,
        ): (string | Package)[] | null => value,
        getError: () => errors.package,
        setError: (value: Option<Array<string>>) => {
          errors.package = value;
        },
        getTainted: () => tainted.package,
        setTainted: (value: Option<boolean>) => {
          tainted.package = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("package", data.package);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      promotion: {
        path: ["promotion"] as const,
        name: "promotion",
        constraints: { required: true },

        get: () => data.promotion,
        set: (value: (string | Promotion)[] | null) => {
          data.promotion = value;
        },
        transform: (
          value: (string | Promotion)[] | null,
        ): (string | Promotion)[] | null => value,
        getError: () => errors.promotion,
        setError: (value: Option<Array<string>>) => {
          errors.promotion = value;
        },
        getTainted: () => tainted.promotion,
        setTainted: (value: Option<boolean>) => {
          tainted.promotion = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("promotion", data.promotion);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      balance: {
        path: ["balance"] as const,
        name: "balance",
        constraints: { required: true },

        get: () => data.balance,
        set: (value: number) => {
          data.balance = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.balance,
        setError: (value: Option<Array<string>>) => {
          errors.balance = value;
        },
        getTainted: () => tainted.balance,
        setTainted: (value: Option<boolean>) => {
          tainted.balance = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("balance", data.balance);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      due: {
        path: ["due"] as const,
        name: "due",
        constraints: { required: true },
        label: "Due",
        get: () => data.due,
        set: (value: string) => {
          data.due = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.due,
        setError: (value: Option<Array<string>>) => {
          errors.due = value;
        },
        getTainted: () => tainted.due,
        setTainted: (value: Option<boolean>) => {
          tainted.due = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("due", data.due);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      total: {
        path: ["total"] as const,
        name: "total",
        constraints: { required: true },

        get: () => data.total,
        set: (value: number) => {
          data.total = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.total,
        setError: (value: Option<Array<string>>) => {
          errors.total = value;
        },
        getTainted: () => tainted.total,
        setTainted: (value: Option<boolean>) => {
          tainted.total = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("total", data.total);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      site: {
        path: ["site"] as const,
        name: "site",
        constraints: { required: true },
        label: "Site",
        get: () => data.site,
        set: (value: string | Site) => {
          data.site = value;
        },
        transform: (value: string | Site): string | Site => value,
        getError: () => errors.site,
        setError: (value: Option<Array<string>>) => {
          errors.site = value;
        },
        getTainted: () => tainted.site,
        setTainted: (value: Option<boolean>) => {
          tainted.site = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("site", data.site);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      billedItems: {
        path: ["billedItems"] as const,
        name: "billedItems",
        constraints: { required: true },

        get: () => data.billedItems,
        set: (value: BilledItem[]) => {
          data.billedItems = value;
        },
        transform: (value: BilledItem[]): BilledItem[] => value,
        getError: () => errors.billedItems,
        setError: (value: Option<Array<string>>) => {
          errors.billedItems = value;
        },
        getTainted: () => tainted.billedItems,
        setTainted: (value: Option<boolean>) => {
          tainted.billedItems = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "billedItems",
            data.billedItems,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["billedItems", index] as const,
          name: `billedItems.${index}`,
          constraints: { required: true },
          get: () => data.billedItems[index]!,
          set: (value: BilledItem) => {
            data.billedItems[index] = value;
          },
          transform: (value: BilledItem): BilledItem => value,
          getError: () => errors.billedItems,
          setError: (value: Option<Array<string>>) => {
            errors.billedItems = value;
          },
          getTainted: () => tainted.billedItems,
          setTainted: (value: Option<boolean>) => {
            tainted.billedItems = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: BilledItem) => {
          data.billedItems.push(item);
        },
        remove: (index: number) => {
          data.billedItems.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.billedItems[a]!;
          data.billedItems[a] = data.billedItems[b]!;
          data.billedItems[b] = tmp;
        },
      },
      memo: {
        path: ["memo"] as const,
        name: "memo",
        constraints: { required: true },
        label: "Memo",
        get: () => data.memo,
        set: (value: string) => {
          data.memo = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.memo,
        setError: (value: Option<Array<string>>) => {
          errors.memo = value;
        },
        getTainted: () => tainted.memo,
        setTainted: (value: Option<boolean>) => {
          tainted.memo = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("memo", data.memo);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      discount: {
        path: ["discount"] as const,
        name: "discount",
        constraints: { required: true },

        get: () => data.discount,
        set: (value: number) => {
          data.discount = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.discount,
        setError: (value: Option<Array<string>>) => {
          errors.discount = value;
        },
        getTainted: () => tainted.discount,
        setTainted: (value: Option<boolean>) => {
          tainted.discount = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("discount", data.discount);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      tip: {
        path: ["tip"] as const,
        name: "tip",
        constraints: { required: true },

        get: () => data.tip,
        set: (value: number) => {
          data.tip = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.tip,
        setError: (value: Option<Array<string>>) => {
          errors.tip = value;
        },
        getTainted: () => tainted.tip,
        setTainted: (value: Option<boolean>) => {
          tainted.tip = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("tip", data.tip);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      commissions: {
        path: ["commissions"] as const,
        name: "commissions",
        constraints: { required: true },

        get: () => data.commissions,
        set: (value: number[]) => {
          data.commissions = value;
        },
        transform: (value: number[]): number[] => value,
        getError: () => errors.commissions,
        setError: (value: Option<Array<string>>) => {
          errors.commissions = value;
        },
        getTainted: () => tainted.commissions,
        setTainted: (value: Option<boolean>) => {
          tainted.commissions = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "commissions",
            data.commissions,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["commissions", index] as const,
          name: `commissions.${index}`,
          constraints: { required: true },
          get: () => data.commissions[index]!,
          set: (value: number) => {
            data.commissions[index] = value;
          },
          transform: (value: number): number => value,
          getError: () => errors.commissions,
          setError: (value: Option<Array<string>>) => {
            errors.commissions = value;
          },
          getTainted: () => tainted.commissions,
          setTainted: (value: Option<boolean>) => {
            tainted.commissions = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: number) => {
          data.commissions.push(item);
        },
        remove: (index: number) => {
          data.commissions.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.commissions[a]!;
          data.commissions[a] = data.commissions[b]!;
          data.commissions[b] = tmp;
        },
      },
    };
    function validate(): Result<
      Order,
      Array<{ field: string; message: string }>
    > {
      return Order.fromObject(data);
    }
    function reset(newOverrides?: Partial<Order>): void {
      data = { ...Order.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        account: Option.none(),
        stage: Option.none(),
        number: Option.none(),
        payments: Option.none(),
        opportunity: Option.none(),
        reference: Option.none(),
        leadSource: Option.none(),
        salesRep: Option.none(),
        group: Option.none(),
        subgroup: Option.none(),
        isPosted: Option.none(),
        needsReview: Option.none(),
        actionItem: Option.none(),
        upsale: Option.none(),
        dateCreated: Option.none(),
        appointment: Option.none(),
        lastTechs: Option.none(),
        package: Option.none(),
        promotion: Option.none(),
        balance: Option.none(),
        due: Option.none(),
        total: Option.none(),
        site: Option.none(),
        billedItems: Option.none(),
        memo: Option.none(),
        discount: Option.none(),
        tip: Option.none(),
        commissions: Option.none(),
      };
      tainted = {
        id: Option.none(),
        account: Option.none(),
        stage: Option.none(),
        number: Option.none(),
        payments: Option.none(),
        opportunity: Option.none(),
        reference: Option.none(),
        leadSource: Option.none(),
        salesRep: Option.none(),
        group: Option.none(),
        subgroup: Option.none(),
        isPosted: Option.none(),
        needsReview: Option.none(),
        actionItem: Option.none(),
        upsale: Option.none(),
        dateCreated: Option.none(),
        appointment: Option.none(),
        lastTechs: Option.none(),
        package: Option.none(),
        promotion: Option.none(),
        balance: Option.none(),
        due: Option.none(),
        total: Option.none(),
        site: Option.none(),
        billedItems: Option.none(),
        memo: Option.none(),
        discount: Option.none(),
        tip: Option.none(),
        commissions: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Order, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.account = formData.get("account") ?? "";
    {
      // Collect nested object fields with prefix "stage."
      const stageObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("stage.")) {
          const fieldName = key.slice("stage.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = stageObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.stage = stageObj;
    }
    {
      const numberStr = formData.get("number");
      obj.number = numberStr ? parseFloat(numberStr as string) : 0;
      if (obj.number !== undefined && isNaN(obj.number as number))
        obj.number = 0;
    }
    {
      // Collect array items from indexed form fields
      const paymentsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("payments." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("payments." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("payments." + idx + ".")) {
              const fieldName = key.slice(
                "payments.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          paymentsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.payments = paymentsItems;
    }
    obj.opportunity = formData.get("opportunity") ?? "";
    obj.reference = formData.get("reference") ?? "";
    obj.leadSource = formData.get("leadSource") ?? "";
    obj.salesRep = formData.get("salesRep") ?? "";
    obj.group = formData.get("group") ?? "";
    obj.subgroup = formData.get("subgroup") ?? "";
    {
      const isPostedVal = formData.get("isPosted");
      obj.isPosted =
        isPostedVal === "true" || isPostedVal === "on" || isPostedVal === "1";
    }
    {
      const needsReviewVal = formData.get("needsReview");
      obj.needsReview =
        needsReviewVal === "true" ||
        needsReviewVal === "on" ||
        needsReviewVal === "1";
    }
    obj.actionItem = formData.get("actionItem") ?? "";
    {
      const upsaleStr = formData.get("upsale");
      obj.upsale = upsaleStr ? parseFloat(upsaleStr as string) : 0;
      if (obj.upsale !== undefined && isNaN(obj.upsale as number))
        obj.upsale = 0;
    }
    obj.dateCreated = formData.get("dateCreated") ?? "";
    obj.appointment = formData.get("appointment") ?? "";
    {
      // Collect array items from indexed form fields
      const lastTechsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("lastTechs." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("lastTechs." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("lastTechs." + idx + ".")) {
              const fieldName = key.slice(
                "lastTechs.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          lastTechsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.lastTechs = lastTechsItems;
    }
    obj.package = formData.get("package") ?? "";
    obj.promotion = formData.get("promotion") ?? "";
    {
      const balanceStr = formData.get("balance");
      obj.balance = balanceStr ? parseFloat(balanceStr as string) : 0;
      if (obj.balance !== undefined && isNaN(obj.balance as number))
        obj.balance = 0;
    }
    obj.due = formData.get("due") ?? "";
    {
      const totalStr = formData.get("total");
      obj.total = totalStr ? parseFloat(totalStr as string) : 0;
      if (obj.total !== undefined && isNaN(obj.total as number)) obj.total = 0;
    }
    obj.site = formData.get("site") ?? "";
    {
      // Collect array items from indexed form fields
      const billedItemsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("billedItems." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("billedItems." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("billedItems." + idx + ".")) {
              const fieldName = key.slice(
                "billedItems.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          billedItemsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.billedItems = billedItemsItems;
    }
    obj.memo = formData.get("memo") ?? "";
    {
      const discountStr = formData.get("discount");
      obj.discount = discountStr ? parseFloat(discountStr as string) : 0;
      if (obj.discount !== undefined && isNaN(obj.discount as number))
        obj.discount = 0;
    }
    {
      const tipStr = formData.get("tip");
      obj.tip = tipStr ? parseFloat(tipStr as string) : 0;
      if (obj.tip !== undefined && isNaN(obj.tip as number)) obj.tip = 0;
    }
    obj.commissions = formData
      .getAll("commissions")
      .map((v) => parseFloat(v as string))
      .filter((n) => !isNaN(n));
    return Order.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Commented {
  /** @serde({ validate: ["nonEmpty"] }) */
  comment: string;
  replyTo: string | null;
}

export function defaultValueCommented(): Commented {
  return { comment: "", replyTo: null } as Commented;
}

export function toStringifiedJSONCommented(value: Commented): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeCommented(value, ctx));
}
export function toObjectCommented(value: Commented): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeCommented(value, ctx);
}
export function __serializeCommented(
  value: Commented,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Commented", __id };
  result["comment"] = value.comment;
  if (value.replyTo !== null) {
    result["replyTo"] =
      typeof (value.replyTo as any)?.__serialize === "function"
        ? (value.replyTo as any).__serialize(ctx)
        : value.replyTo;
  } else {
    result["replyTo"] = null;
  }
  return result;
}

export function fromStringifiedJSONCommented(
  json: string,
  opts?: DeserializeOptions,
): Result<Commented, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectCommented(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectCommented(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Commented, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeCommented(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Commented.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeCommented(
  value: any,
  ctx: DeserializeContext,
): Commented | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "Commented.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("comment" in obj)) {
    errors.push({ field: "comment", message: "missing required field" });
  }
  if (!("replyTo" in obj)) {
    errors.push({ field: "replyTo", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_comment = obj["comment"] as string;
    if (__raw_comment.length === 0) {
      errors.push({ field: "comment", message: "must not be empty" });
    }
    instance.comment = __raw_comment;
  }
  {
    const __raw_replyTo = obj["replyTo"] as string | null;
    if (__raw_replyTo === null) {
      instance.replyTo = null;
    } else if (typeof (__raw_replyTo as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_replyTo as any).__ref);
      ctx.assignOrDefer(instance, "replyTo", __result);
    } else {
      instance.replyTo = __raw_replyTo;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Commented;
}
export function validateFieldCommented<K extends keyof Commented>(
  field: K,
  value: Commented[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "comment": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "comment", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsCommented(
  partial: Partial<Commented>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("comment" in partial && partial.comment !== undefined) {
    const __val = partial.comment as string;
    if (__val.length === 0) {
      errors.push({ field: "comment", message: "must not be empty" });
    }
  }
  return errors;
}
export function isCommented(obj: unknown): obj is Commented {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "comment" in o && "replyTo" in o;
}

export namespace Commented {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    comment: Option<Array<string>>;
    replyTo: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { comment: Option<boolean>; replyTo: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly comment: FieldController<string>;
    readonly replyTo: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Commented;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Commented, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Commented>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Commented>,
  ): Gigaform {
    let data = $state({ ...Commented.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      comment: Option.none(),
      replyTo: Option.none(),
    });
    let tainted = $state<Tainted>({
      comment: Option.none(),
      replyTo: Option.none(),
    });
    const fields: FieldControllers = {
      comment: {
        path: ["comment"] as const,
        name: "comment",
        constraints: { required: true },

        get: () => data.comment,
        set: (value: string) => {
          data.comment = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.comment,
        setError: (value: Option<Array<string>>) => {
          errors.comment = value;
        },
        getTainted: () => tainted.comment,
        setTainted: (value: Option<boolean>) => {
          tainted.comment = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Commented.validateField("comment", data.comment);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      replyTo: {
        path: ["replyTo"] as const,
        name: "replyTo",
        constraints: { required: true },

        get: () => data.replyTo,
        set: (value: string | null) => {
          data.replyTo = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.replyTo,
        setError: (value: Option<Array<string>>) => {
          errors.replyTo = value;
        },
        getTainted: () => tainted.replyTo,
        setTainted: (value: Option<boolean>) => {
          tainted.replyTo = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Commented.validateField("replyTo", data.replyTo);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Commented,
      Array<{ field: string; message: string }>
    > {
      return Commented.fromObject(data);
    }
    function reset(newOverrides?: Partial<Commented>): void {
      data = { ...Commented.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        comment: Option.none(),
        replyTo: Option.none(),
      };
      tainted = { comment: Option.none(), replyTo: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Commented, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.comment = formData.get("comment") ?? "";
    obj.replyTo = formData.get("replyTo") ?? "";
    return Commented.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Custom {
  mappings: DirectionHue[];
}

export function defaultValueCustom(): Custom {
  return { mappings: [] } as Custom;
}

export function toStringifiedJSONCustom(value: Custom): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeCustom(value, ctx));
}
export function toObjectCustom(value: Custom): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeCustom(value, ctx);
}
export function __serializeCustom(
  value: Custom,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Custom", __id };
  result["mappings"] = value.mappings.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  return result;
}

export function fromStringifiedJSONCustom(
  json: string,
  opts?: DeserializeOptions,
): Result<Custom, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectCustom(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectCustom(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Custom, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeCustom(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Custom.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeCustom(
  value: any,
  ctx: DeserializeContext,
): Custom | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Custom.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("mappings" in obj)) {
    errors.push({ field: "mappings", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_mappings = obj["mappings"] as DirectionHue[];
    if (Array.isArray(__raw_mappings)) {
      instance.mappings = __raw_mappings as DirectionHue[];
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Custom;
}
export function validateFieldCustom<K extends keyof Custom>(
  field: K,
  value: Custom[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsCustom(
  partial: Partial<Custom>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isCustom(obj: unknown): obj is Custom {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "mappings" in o;
}

export namespace Custom {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    mappings: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { mappings: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly mappings: ArrayFieldController<DirectionHue>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Custom;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Custom, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Custom>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Custom>,
  ): Gigaform {
    let data = $state({ ...Custom.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      mappings: Option.none(),
    });
    let tainted = $state<Tainted>({ mappings: Option.none() });
    const fields: FieldControllers = {
      mappings: {
        path: ["mappings"] as const,
        name: "mappings",
        constraints: { required: true },

        get: () => data.mappings,
        set: (value: DirectionHue[]) => {
          data.mappings = value;
        },
        transform: (value: DirectionHue[]): DirectionHue[] => value,
        getError: () => errors.mappings,
        setError: (value: Option<Array<string>>) => {
          errors.mappings = value;
        },
        getTainted: () => tainted.mappings,
        setTainted: (value: Option<boolean>) => {
          tainted.mappings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Custom.validateField("mappings", data.mappings);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["mappings", index] as const,
          name: `mappings.${index}`,
          constraints: { required: true },
          get: () => data.mappings[index]!,
          set: (value: DirectionHue) => {
            data.mappings[index] = value;
          },
          transform: (value: DirectionHue): DirectionHue => value,
          getError: () => errors.mappings,
          setError: (value: Option<Array<string>>) => {
            errors.mappings = value;
          },
          getTainted: () => tainted.mappings,
          setTainted: (value: Option<boolean>) => {
            tainted.mappings = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: DirectionHue) => {
          data.mappings.push(item);
        },
        remove: (index: number) => {
          data.mappings.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.mappings[a]!;
          data.mappings[a] = data.mappings[b]!;
          data.mappings[b] = tmp;
        },
      },
    };
    function validate(): Result<
      Custom,
      Array<{ field: string; message: string }>
    > {
      return Custom.fromObject(data);
    }
    function reset(newOverrides?: Partial<Custom>): void {
      data = { ...Custom.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), mappings: Option.none() };
      tainted = { mappings: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Custom, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect array items from indexed form fields
      const mappingsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("mappings." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("mappings." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("mappings." + idx + ".")) {
              const fieldName = key.slice(
                "mappings.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          mappingsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.mappings = mappingsItems;
    }
    return Custom.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Colors {
  /** @serde({ validate: ["nonEmpty"] }) */
  main: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  hover: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  active: string;
}

export function defaultValueColors(): Colors {
  return { main: "", hover: "", active: "" } as Colors;
}

export function toStringifiedJSONColors(value: Colors): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeColors(value, ctx));
}
export function toObjectColors(value: Colors): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeColors(value, ctx);
}
export function __serializeColors(
  value: Colors,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Colors", __id };
  result["main"] = value.main;
  result["hover"] = value.hover;
  result["active"] = value.active;
  return result;
}

export function fromStringifiedJSONColors(
  json: string,
  opts?: DeserializeOptions,
): Result<Colors, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectColors(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectColors(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Colors, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeColors(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Colors.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeColors(
  value: any,
  ctx: DeserializeContext,
): Colors | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Colors.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("main" in obj)) {
    errors.push({ field: "main", message: "missing required field" });
  }
  if (!("hover" in obj)) {
    errors.push({ field: "hover", message: "missing required field" });
  }
  if (!("active" in obj)) {
    errors.push({ field: "active", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_main = obj["main"] as string;
    if (__raw_main.length === 0) {
      errors.push({ field: "main", message: "must not be empty" });
    }
    instance.main = __raw_main;
  }
  {
    const __raw_hover = obj["hover"] as string;
    if (__raw_hover.length === 0) {
      errors.push({ field: "hover", message: "must not be empty" });
    }
    instance.hover = __raw_hover;
  }
  {
    const __raw_active = obj["active"] as string;
    if (__raw_active.length === 0) {
      errors.push({ field: "active", message: "must not be empty" });
    }
    instance.active = __raw_active;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Colors;
}
export function validateFieldColors<K extends keyof Colors>(
  field: K,
  value: Colors[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "main": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "main", message: "must not be empty" });
      }
      break;
    }
    case "hover": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "hover", message: "must not be empty" });
      }
      break;
    }
    case "active": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "active", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsColors(
  partial: Partial<Colors>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("main" in partial && partial.main !== undefined) {
    const __val = partial.main as string;
    if (__val.length === 0) {
      errors.push({ field: "main", message: "must not be empty" });
    }
  }
  if ("hover" in partial && partial.hover !== undefined) {
    const __val = partial.hover as string;
    if (__val.length === 0) {
      errors.push({ field: "hover", message: "must not be empty" });
    }
  }
  if ("active" in partial && partial.active !== undefined) {
    const __val = partial.active as string;
    if (__val.length === 0) {
      errors.push({ field: "active", message: "must not be empty" });
    }
  }
  return errors;
}
export function isColors(obj: unknown): obj is Colors {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "main" in o && "hover" in o && "active" in o;
}

export namespace Colors {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    main: Option<Array<string>>;
    hover: Option<Array<string>>;
    active: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { main: Option<boolean>; hover: Option<boolean>; active: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly main: FieldController<string>;
    readonly hover: FieldController<string>;
    readonly active: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Colors;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Colors, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Colors>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Colors>,
  ): Gigaform {
    let data = $state({ ...Colors.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      main: Option.none(),
      hover: Option.none(),
      active: Option.none(),
    });
    let tainted = $state<Tainted>({
      main: Option.none(),
      hover: Option.none(),
      active: Option.none(),
    });
    const fields: FieldControllers = {
      main: {
        path: ["main"] as const,
        name: "main",
        constraints: { required: true },

        get: () => data.main,
        set: (value: string) => {
          data.main = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.main,
        setError: (value: Option<Array<string>>) => {
          errors.main = value;
        },
        getTainted: () => tainted.main,
        setTainted: (value: Option<boolean>) => {
          tainted.main = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Colors.validateField("main", data.main);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      hover: {
        path: ["hover"] as const,
        name: "hover",
        constraints: { required: true },

        get: () => data.hover,
        set: (value: string) => {
          data.hover = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.hover,
        setError: (value: Option<Array<string>>) => {
          errors.hover = value;
        },
        getTainted: () => tainted.hover,
        setTainted: (value: Option<boolean>) => {
          tainted.hover = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Colors.validateField("hover", data.hover);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      active: {
        path: ["active"] as const,
        name: "active",
        constraints: { required: true },

        get: () => data.active,
        set: (value: string) => {
          data.active = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.active,
        setError: (value: Option<Array<string>>) => {
          errors.active = value;
        },
        getTainted: () => tainted.active,
        setTainted: (value: Option<boolean>) => {
          tainted.active = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Colors.validateField("active", data.active);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Colors,
      Array<{ field: string; message: string }>
    > {
      return Colors.fromObject(data);
    }
    function reset(newOverrides?: Partial<Colors>): void {
      data = { ...Colors.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        main: Option.none(),
        hover: Option.none(),
        active: Option.none(),
      };
      tainted = {
        main: Option.none(),
        hover: Option.none(),
        active: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Colors, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.main = formData.get("main") ?? "";
    obj.hover = formData.get("hover") ?? "";
    obj.active = formData.get("active") ?? "";
    return Colors.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface ProductDefaults {
  /** @numberController({ label: "Price", min: 0, step: 0.01 }) */
  price: number;
  /** @textAreaController({ label: "Description" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  description: string;
}

export function defaultValueProductDefaults(): ProductDefaults {
  return { price: 0, description: "" } as ProductDefaults;
}

export function toStringifiedJSONProductDefaults(
  value: ProductDefaults,
): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeProductDefaults(value, ctx));
}
export function toObjectProductDefaults(
  value: ProductDefaults,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeProductDefaults(value, ctx);
}
export function __serializeProductDefaults(
  value: ProductDefaults,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "ProductDefaults", __id };
  result["price"] = value.price;
  result["description"] = value.description;
  return result;
}

export function fromStringifiedJSONProductDefaults(
  json: string,
  opts?: DeserializeOptions,
): Result<ProductDefaults, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectProductDefaults(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectProductDefaults(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<ProductDefaults, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeProductDefaults(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "ProductDefaults.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeProductDefaults(
  value: any,
  ctx: DeserializeContext,
): ProductDefaults | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "ProductDefaults.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("price" in obj)) {
    errors.push({ field: "price", message: "missing required field" });
  }
  if (!("description" in obj)) {
    errors.push({ field: "description", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_price = obj["price"] as number;
    instance.price = __raw_price;
  }
  {
    const __raw_description = obj["description"] as string;
    if (__raw_description.length === 0) {
      errors.push({ field: "description", message: "must not be empty" });
    }
    instance.description = __raw_description;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as ProductDefaults;
}
export function validateFieldProductDefaults<K extends keyof ProductDefaults>(
  field: K,
  value: ProductDefaults[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "description": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "description", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsProductDefaults(
  partial: Partial<ProductDefaults>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("description" in partial && partial.description !== undefined) {
    const __val = partial.description as string;
    if (__val.length === 0) {
      errors.push({ field: "description", message: "must not be empty" });
    }
  }
  return errors;
}
export function isProductDefaults(obj: unknown): obj is ProductDefaults {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "price" in o && "description" in o;
}

export namespace ProductDefaults {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    price: Option<Array<string>>;
    description: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { price: Option<boolean>; description: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly price: FieldController<number>;
    readonly description: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: ProductDefaults;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      ProductDefaults,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<ProductDefaults>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<ProductDefaults>,
  ): Gigaform {
    let data = $state({ ...ProductDefaults.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      price: Option.none(),
      description: Option.none(),
    });
    let tainted = $state<Tainted>({
      price: Option.none(),
      description: Option.none(),
    });
    const fields: FieldControllers = {
      price: {
        path: ["price"] as const,
        name: "price",
        constraints: { required: true },
        label: "Price",
        get: () => data.price,
        set: (value: number) => {
          data.price = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.price,
        setError: (value: Option<Array<string>>) => {
          errors.price = value;
        },
        getTainted: () => tainted.price,
        setTainted: (value: Option<boolean>) => {
          tainted.price = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = ProductDefaults.validateField(
            "price",
            data.price,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      description: {
        path: ["description"] as const,
        name: "description",
        constraints: { required: true },
        label: "Description",
        get: () => data.description,
        set: (value: string) => {
          data.description = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.description,
        setError: (value: Option<Array<string>>) => {
          errors.description = value;
        },
        getTainted: () => tainted.description,
        setTainted: (value: Option<boolean>) => {
          tainted.description = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = ProductDefaults.validateField(
            "description",
            data.description,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      ProductDefaults,
      Array<{ field: string; message: string }>
    > {
      return ProductDefaults.fromObject(data);
    }
    function reset(newOverrides?: Partial<ProductDefaults>): void {
      data = { ...ProductDefaults.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        price: Option.none(),
        description: Option.none(),
      };
      tainted = { price: Option.none(), description: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<ProductDefaults, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const priceStr = formData.get("price");
      obj.price = priceStr ? parseFloat(priceStr as string) : 0;
      if (obj.price !== undefined && isNaN(obj.price as number)) obj.price = 0;
    }
    obj.description = formData.get("description") ?? "";
    return ProductDefaults.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Viewed {
  durationSeconds: number | null;
  source: string | null;
}

export function defaultValueViewed(): Viewed {
  return { durationSeconds: null, source: null } as Viewed;
}

export function toStringifiedJSONViewed(value: Viewed): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeViewed(value, ctx));
}
export function toObjectViewed(value: Viewed): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeViewed(value, ctx);
}
export function __serializeViewed(
  value: Viewed,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Viewed", __id };
  if (value.durationSeconds !== null) {
    result["durationSeconds"] =
      typeof (value.durationSeconds as any)?.__serialize === "function"
        ? (value.durationSeconds as any).__serialize(ctx)
        : value.durationSeconds;
  } else {
    result["durationSeconds"] = null;
  }
  if (value.source !== null) {
    result["source"] =
      typeof (value.source as any)?.__serialize === "function"
        ? (value.source as any).__serialize(ctx)
        : value.source;
  } else {
    result["source"] = null;
  }
  return result;
}

export function fromStringifiedJSONViewed(
  json: string,
  opts?: DeserializeOptions,
): Result<Viewed, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectViewed(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectViewed(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Viewed, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeViewed(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Viewed.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeViewed(
  value: any,
  ctx: DeserializeContext,
): Viewed | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Viewed.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("durationSeconds" in obj)) {
    errors.push({
      field: "durationSeconds",
      message: "missing required field",
    });
  }
  if (!("source" in obj)) {
    errors.push({ field: "source", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_durationSeconds = obj["durationSeconds"] as number | null;
    if (__raw_durationSeconds === null) {
      instance.durationSeconds = null;
    } else if (typeof (__raw_durationSeconds as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_durationSeconds as any).__ref);
      ctx.assignOrDefer(instance, "durationSeconds", __result);
    } else {
      instance.durationSeconds = __raw_durationSeconds;
    }
  }
  {
    const __raw_source = obj["source"] as string | null;
    if (__raw_source === null) {
      instance.source = null;
    } else if (typeof (__raw_source as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_source as any).__ref);
      ctx.assignOrDefer(instance, "source", __result);
    } else {
      instance.source = __raw_source;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Viewed;
}
export function validateFieldViewed<K extends keyof Viewed>(
  field: K,
  value: Viewed[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsViewed(
  partial: Partial<Viewed>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isViewed(obj: unknown): obj is Viewed {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "durationSeconds" in o && "source" in o;
}

export namespace Viewed {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    durationSeconds: Option<Array<string>>;
    source: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { durationSeconds: Option<boolean>; source: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly durationSeconds: FieldController<number | null>;
    readonly source: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Viewed;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Viewed, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Viewed>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Viewed>,
  ): Gigaform {
    let data = $state({ ...Viewed.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      durationSeconds: Option.none(),
      source: Option.none(),
    });
    let tainted = $state<Tainted>({
      durationSeconds: Option.none(),
      source: Option.none(),
    });
    const fields: FieldControllers = {
      durationSeconds: {
        path: ["durationSeconds"] as const,
        name: "durationSeconds",
        constraints: { required: true },

        get: () => data.durationSeconds,
        set: (value: number | null) => {
          data.durationSeconds = value;
        },
        transform: (value: number | null): number | null => value,
        getError: () => errors.durationSeconds,
        setError: (value: Option<Array<string>>) => {
          errors.durationSeconds = value;
        },
        getTainted: () => tainted.durationSeconds,
        setTainted: (value: Option<boolean>) => {
          tainted.durationSeconds = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Viewed.validateField(
            "durationSeconds",
            data.durationSeconds,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      source: {
        path: ["source"] as const,
        name: "source",
        constraints: { required: true },

        get: () => data.source,
        set: (value: string | null) => {
          data.source = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.source,
        setError: (value: Option<Array<string>>) => {
          errors.source = value;
        },
        getTainted: () => tainted.source,
        setTainted: (value: Option<boolean>) => {
          tainted.source = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Viewed.validateField("source", data.source);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Viewed,
      Array<{ field: string; message: string }>
    > {
      return Viewed.fromObject(data);
    }
    function reset(newOverrides?: Partial<Viewed>): void {
      data = { ...Viewed.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        durationSeconds: Option.none(),
        source: Option.none(),
      };
      tainted = { durationSeconds: Option.none(), source: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Viewed, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const durationSecondsStr = formData.get("durationSeconds");
      obj.durationSeconds = durationSecondsStr
        ? parseFloat(durationSecondsStr as string)
        : 0;
      if (
        obj.durationSeconds !== undefined &&
        isNaN(obj.durationSeconds as number)
      )
        obj.durationSeconds = 0;
    }
    obj.source = formData.get("source") ?? "";
    return Viewed.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface WeeklyRecurrenceRule {
  quantityOfWeeks: number;
  weekdays: Weekday[];
}

export function defaultValueWeeklyRecurrenceRule(): WeeklyRecurrenceRule {
  return { quantityOfWeeks: 0, weekdays: [] } as WeeklyRecurrenceRule;
}

export function toStringifiedJSONWeeklyRecurrenceRule(
  value: WeeklyRecurrenceRule,
): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeWeeklyRecurrenceRule(value, ctx));
}
export function toObjectWeeklyRecurrenceRule(
  value: WeeklyRecurrenceRule,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeWeeklyRecurrenceRule(value, ctx);
}
export function __serializeWeeklyRecurrenceRule(
  value: WeeklyRecurrenceRule,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = {
    __type: "WeeklyRecurrenceRule",
    __id,
  };
  result["quantityOfWeeks"] = value.quantityOfWeeks;
  result["weekdays"] = value.weekdays.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  return result;
}

export function fromStringifiedJSONWeeklyRecurrenceRule(
  json: string,
  opts?: DeserializeOptions,
): Result<WeeklyRecurrenceRule, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectWeeklyRecurrenceRule(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectWeeklyRecurrenceRule(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<WeeklyRecurrenceRule, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeWeeklyRecurrenceRule(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "WeeklyRecurrenceRule.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeWeeklyRecurrenceRule(
  value: any,
  ctx: DeserializeContext,
): WeeklyRecurrenceRule | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "WeeklyRecurrenceRule.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("quantityOfWeeks" in obj)) {
    errors.push({
      field: "quantityOfWeeks",
      message: "missing required field",
    });
  }
  if (!("weekdays" in obj)) {
    errors.push({ field: "weekdays", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_quantityOfWeeks = obj["quantityOfWeeks"] as number;
    instance.quantityOfWeeks = __raw_quantityOfWeeks;
  }
  {
    const __raw_weekdays = obj["weekdays"] as Weekday[];
    if (Array.isArray(__raw_weekdays)) {
      instance.weekdays = __raw_weekdays as Weekday[];
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as WeeklyRecurrenceRule;
}
export function validateFieldWeeklyRecurrenceRule<
  K extends keyof WeeklyRecurrenceRule,
>(
  field: K,
  value: WeeklyRecurrenceRule[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsWeeklyRecurrenceRule(
  partial: Partial<WeeklyRecurrenceRule>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isWeeklyRecurrenceRule(
  obj: unknown,
): obj is WeeklyRecurrenceRule {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "quantityOfWeeks" in o && "weekdays" in o;
}

export namespace WeeklyRecurrenceRule {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    quantityOfWeeks: Option<Array<string>>;
    weekdays: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { quantityOfWeeks: Option<boolean>; weekdays: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly quantityOfWeeks: FieldController<number>;
    readonly weekdays: ArrayFieldController<Weekday>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: WeeklyRecurrenceRule;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      WeeklyRecurrenceRule,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<WeeklyRecurrenceRule>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<WeeklyRecurrenceRule>,
  ): Gigaform {
    let data = $state({ ...WeeklyRecurrenceRule.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      quantityOfWeeks: Option.none(),
      weekdays: Option.none(),
    });
    let tainted = $state<Tainted>({
      quantityOfWeeks: Option.none(),
      weekdays: Option.none(),
    });
    const fields: FieldControllers = {
      quantityOfWeeks: {
        path: ["quantityOfWeeks"] as const,
        name: "quantityOfWeeks",
        constraints: { required: true },

        get: () => data.quantityOfWeeks,
        set: (value: number) => {
          data.quantityOfWeeks = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.quantityOfWeeks,
        setError: (value: Option<Array<string>>) => {
          errors.quantityOfWeeks = value;
        },
        getTainted: () => tainted.quantityOfWeeks,
        setTainted: (value: Option<boolean>) => {
          tainted.quantityOfWeeks = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = WeeklyRecurrenceRule.validateField(
            "quantityOfWeeks",
            data.quantityOfWeeks,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      weekdays: {
        path: ["weekdays"] as const,
        name: "weekdays",
        constraints: { required: true },

        get: () => data.weekdays,
        set: (value: Weekday[]) => {
          data.weekdays = value;
        },
        transform: (value: Weekday[]): Weekday[] => value,
        getError: () => errors.weekdays,
        setError: (value: Option<Array<string>>) => {
          errors.weekdays = value;
        },
        getTainted: () => tainted.weekdays,
        setTainted: (value: Option<boolean>) => {
          tainted.weekdays = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = WeeklyRecurrenceRule.validateField(
            "weekdays",
            data.weekdays,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["weekdays", index] as const,
          name: `weekdays.${index}`,
          constraints: { required: true },
          get: () => data.weekdays[index]!,
          set: (value: Weekday) => {
            data.weekdays[index] = value;
          },
          transform: (value: Weekday): Weekday => value,
          getError: () => errors.weekdays,
          setError: (value: Option<Array<string>>) => {
            errors.weekdays = value;
          },
          getTainted: () => tainted.weekdays,
          setTainted: (value: Option<boolean>) => {
            tainted.weekdays = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: Weekday) => {
          data.weekdays.push(item);
        },
        remove: (index: number) => {
          data.weekdays.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.weekdays[a]!;
          data.weekdays[a] = data.weekdays[b]!;
          data.weekdays[b] = tmp;
        },
      },
    };
    function validate(): Result<
      WeeklyRecurrenceRule,
      Array<{ field: string; message: string }>
    > {
      return WeeklyRecurrenceRule.fromObject(data);
    }
    function reset(newOverrides?: Partial<WeeklyRecurrenceRule>): void {
      data = { ...WeeklyRecurrenceRule.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        quantityOfWeeks: Option.none(),
        weekdays: Option.none(),
      };
      tainted = { quantityOfWeeks: Option.none(), weekdays: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<WeeklyRecurrenceRule, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const quantityOfWeeksStr = formData.get("quantityOfWeeks");
      obj.quantityOfWeeks = quantityOfWeeksStr
        ? parseFloat(quantityOfWeeksStr as string)
        : 0;
      if (
        obj.quantityOfWeeks !== undefined &&
        isNaN(obj.quantityOfWeeks as number)
      )
        obj.quantityOfWeeks = 0;
    }
    {
      // Collect array items from indexed form fields
      const weekdaysItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("weekdays." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("weekdays." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("weekdays." + idx + ".")) {
              const fieldName = key.slice(
                "weekdays.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          weekdaysItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.weekdays = weekdaysItems;
    }
    return WeeklyRecurrenceRule.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Paid {
  amount: number | null;
  currency: string | null;
  paymentMethod: string | null;
}

export function defaultValuePaid(): Paid {
  return { amount: null, currency: null, paymentMethod: null } as Paid;
}

export function toStringifiedJSONPaid(value: Paid): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializePaid(value, ctx));
}
export function toObjectPaid(value: Paid): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializePaid(value, ctx);
}
export function __serializePaid(
  value: Paid,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Paid", __id };
  if (value.amount !== null) {
    result["amount"] =
      typeof (value.amount as any)?.__serialize === "function"
        ? (value.amount as any).__serialize(ctx)
        : value.amount;
  } else {
    result["amount"] = null;
  }
  if (value.currency !== null) {
    result["currency"] =
      typeof (value.currency as any)?.__serialize === "function"
        ? (value.currency as any).__serialize(ctx)
        : value.currency;
  } else {
    result["currency"] = null;
  }
  if (value.paymentMethod !== null) {
    result["paymentMethod"] =
      typeof (value.paymentMethod as any)?.__serialize === "function"
        ? (value.paymentMethod as any).__serialize(ctx)
        : value.paymentMethod;
  } else {
    result["paymentMethod"] = null;
  }
  return result;
}

export function fromStringifiedJSONPaid(
  json: string,
  opts?: DeserializeOptions,
): Result<Paid, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectPaid(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectPaid(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Paid, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializePaid(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Paid.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializePaid(
  value: any,
  ctx: DeserializeContext,
): Paid | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Paid.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("amount" in obj)) {
    errors.push({ field: "amount", message: "missing required field" });
  }
  if (!("currency" in obj)) {
    errors.push({ field: "currency", message: "missing required field" });
  }
  if (!("paymentMethod" in obj)) {
    errors.push({ field: "paymentMethod", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_amount = obj["amount"] as number | null;
    if (__raw_amount === null) {
      instance.amount = null;
    } else if (typeof (__raw_amount as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_amount as any).__ref);
      ctx.assignOrDefer(instance, "amount", __result);
    } else {
      instance.amount = __raw_amount;
    }
  }
  {
    const __raw_currency = obj["currency"] as string | null;
    if (__raw_currency === null) {
      instance.currency = null;
    } else if (typeof (__raw_currency as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_currency as any).__ref);
      ctx.assignOrDefer(instance, "currency", __result);
    } else {
      instance.currency = __raw_currency;
    }
  }
  {
    const __raw_paymentMethod = obj["paymentMethod"] as string | null;
    if (__raw_paymentMethod === null) {
      instance.paymentMethod = null;
    } else if (typeof (__raw_paymentMethod as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_paymentMethod as any).__ref);
      ctx.assignOrDefer(instance, "paymentMethod", __result);
    } else {
      instance.paymentMethod = __raw_paymentMethod;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Paid;
}
export function validateFieldPaid<K extends keyof Paid>(
  field: K,
  value: Paid[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsPaid(
  partial: Partial<Paid>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isPaid(obj: unknown): obj is Paid {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "amount" in o && "currency" in o && "paymentMethod" in o;
}

export namespace Paid {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    amount: Option<Array<string>>;
    currency: Option<Array<string>>;
    paymentMethod: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      amount: Option<boolean>;
      currency: Option<boolean>;
      paymentMethod: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly amount: FieldController<number | null>;
    readonly currency: FieldController<string | null>;
    readonly paymentMethod: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Paid;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Paid, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Paid>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Paid>,
  ): Gigaform {
    let data = $state({ ...Paid.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      amount: Option.none(),
      currency: Option.none(),
      paymentMethod: Option.none(),
    });
    let tainted = $state<Tainted>({
      amount: Option.none(),
      currency: Option.none(),
      paymentMethod: Option.none(),
    });
    const fields: FieldControllers = {
      amount: {
        path: ["amount"] as const,
        name: "amount",
        constraints: { required: true },

        get: () => data.amount,
        set: (value: number | null) => {
          data.amount = value;
        },
        transform: (value: number | null): number | null => value,
        getError: () => errors.amount,
        setError: (value: Option<Array<string>>) => {
          errors.amount = value;
        },
        getTainted: () => tainted.amount,
        setTainted: (value: Option<boolean>) => {
          tainted.amount = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Paid.validateField("amount", data.amount);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      currency: {
        path: ["currency"] as const,
        name: "currency",
        constraints: { required: true },

        get: () => data.currency,
        set: (value: string | null) => {
          data.currency = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.currency,
        setError: (value: Option<Array<string>>) => {
          errors.currency = value;
        },
        getTainted: () => tainted.currency,
        setTainted: (value: Option<boolean>) => {
          tainted.currency = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Paid.validateField("currency", data.currency);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      paymentMethod: {
        path: ["paymentMethod"] as const,
        name: "paymentMethod",
        constraints: { required: true },

        get: () => data.paymentMethod,
        set: (value: string | null) => {
          data.paymentMethod = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.paymentMethod,
        setError: (value: Option<Array<string>>) => {
          errors.paymentMethod = value;
        },
        getTainted: () => tainted.paymentMethod,
        setTainted: (value: Option<boolean>) => {
          tainted.paymentMethod = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Paid.validateField(
            "paymentMethod",
            data.paymentMethod,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Paid,
      Array<{ field: string; message: string }>
    > {
      return Paid.fromObject(data);
    }
    function reset(newOverrides?: Partial<Paid>): void {
      data = { ...Paid.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        amount: Option.none(),
        currency: Option.none(),
        paymentMethod: Option.none(),
      };
      tainted = {
        amount: Option.none(),
        currency: Option.none(),
        paymentMethod: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Paid, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const amountStr = formData.get("amount");
      obj.amount = amountStr ? parseFloat(amountStr as string) : 0;
      if (obj.amount !== undefined && isNaN(obj.amount as number))
        obj.amount = 0;
    }
    obj.currency = formData.get("currency") ?? "";
    obj.paymentMethod = formData.get("paymentMethod") ?? "";
    return Paid.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface TaxRate {
  /** @hiddenController({}) */
  id: string;
  /** @textController({ label: "Name" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  name: string;
  /** @textController({ label: "Tax Agency" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  taxAgency: string;
  /** @numberController({ label: "Zip", min: 0 }) */
  zip: number;
  /** @textController({ label: "City" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  city: string;
  /** @textController({ label: "County" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  county: string;
  /** @textController({ label: "State" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  state: string;
  /** @switchController({ label: "Active" }) */
  isActive: boolean;
  /** @textAreaController({ label: "Description" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  description: string;
  /** @hiddenController({}) */
  /** @default({}) */
  taxComponents: { [key: string]: number };
}

export function defaultValueTaxRate(): TaxRate {
  return {
    id: "",
    name: "",
    taxAgency: "",
    zip: 0,
    city: "",
    county: "",
    state: "",
    isActive: false,
    description: "",
    taxComponents: {},
  } as TaxRate;
}

export function toStringifiedJSONTaxRate(value: TaxRate): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeTaxRate(value, ctx));
}
export function toObjectTaxRate(value: TaxRate): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeTaxRate(value, ctx);
}
export function __serializeTaxRate(
  value: TaxRate,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "TaxRate", __id };
  result["id"] = value.id;
  result["name"] = value.name;
  result["taxAgency"] = value.taxAgency;
  result["zip"] = value.zip;
  result["city"] = value.city;
  result["county"] = value.county;
  result["state"] = value.state;
  result["isActive"] = value.isActive;
  result["description"] = value.description;
  result["taxComponents"] = value.taxComponents;
  return result;
}

export function fromStringifiedJSONTaxRate(
  json: string,
  opts?: DeserializeOptions,
): Result<TaxRate, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectTaxRate(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectTaxRate(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<TaxRate, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeTaxRate(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "TaxRate.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeTaxRate(
  value: any,
  ctx: DeserializeContext,
): TaxRate | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "TaxRate.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("name" in obj)) {
    errors.push({ field: "name", message: "missing required field" });
  }
  if (!("taxAgency" in obj)) {
    errors.push({ field: "taxAgency", message: "missing required field" });
  }
  if (!("zip" in obj)) {
    errors.push({ field: "zip", message: "missing required field" });
  }
  if (!("city" in obj)) {
    errors.push({ field: "city", message: "missing required field" });
  }
  if (!("county" in obj)) {
    errors.push({ field: "county", message: "missing required field" });
  }
  if (!("state" in obj)) {
    errors.push({ field: "state", message: "missing required field" });
  }
  if (!("isActive" in obj)) {
    errors.push({ field: "isActive", message: "missing required field" });
  }
  if (!("description" in obj)) {
    errors.push({ field: "description", message: "missing required field" });
  }
  if (!("taxComponents" in obj)) {
    errors.push({ field: "taxComponents", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_name = obj["name"] as string;
    if (__raw_name.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
    instance.name = __raw_name;
  }
  {
    const __raw_taxAgency = obj["taxAgency"] as string;
    if (__raw_taxAgency.length === 0) {
      errors.push({ field: "taxAgency", message: "must not be empty" });
    }
    instance.taxAgency = __raw_taxAgency;
  }
  {
    const __raw_zip = obj["zip"] as number;
    instance.zip = __raw_zip;
  }
  {
    const __raw_city = obj["city"] as string;
    if (__raw_city.length === 0) {
      errors.push({ field: "city", message: "must not be empty" });
    }
    instance.city = __raw_city;
  }
  {
    const __raw_county = obj["county"] as string;
    if (__raw_county.length === 0) {
      errors.push({ field: "county", message: "must not be empty" });
    }
    instance.county = __raw_county;
  }
  {
    const __raw_state = obj["state"] as string;
    if (__raw_state.length === 0) {
      errors.push({ field: "state", message: "must not be empty" });
    }
    instance.state = __raw_state;
  }
  {
    const __raw_isActive = obj["isActive"] as boolean;
    instance.isActive = __raw_isActive;
  }
  {
    const __raw_description = obj["description"] as string;
    if (__raw_description.length === 0) {
      errors.push({ field: "description", message: "must not be empty" });
    }
    instance.description = __raw_description;
  }
  {
    const __raw_taxComponents = obj["taxComponents"] as {
      [key: string]: number;
    };
    instance.taxComponents = __raw_taxComponents;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as TaxRate;
}
export function validateFieldTaxRate<K extends keyof TaxRate>(
  field: K,
  value: TaxRate[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "name": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
      break;
    }
    case "taxAgency": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "taxAgency", message: "must not be empty" });
      }
      break;
    }
    case "city": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "city", message: "must not be empty" });
      }
      break;
    }
    case "county": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "county", message: "must not be empty" });
      }
      break;
    }
    case "state": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "state", message: "must not be empty" });
      }
      break;
    }
    case "description": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "description", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsTaxRate(
  partial: Partial<TaxRate>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("name" in partial && partial.name !== undefined) {
    const __val = partial.name as string;
    if (__val.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
  }
  if ("taxAgency" in partial && partial.taxAgency !== undefined) {
    const __val = partial.taxAgency as string;
    if (__val.length === 0) {
      errors.push({ field: "taxAgency", message: "must not be empty" });
    }
  }
  if ("city" in partial && partial.city !== undefined) {
    const __val = partial.city as string;
    if (__val.length === 0) {
      errors.push({ field: "city", message: "must not be empty" });
    }
  }
  if ("county" in partial && partial.county !== undefined) {
    const __val = partial.county as string;
    if (__val.length === 0) {
      errors.push({ field: "county", message: "must not be empty" });
    }
  }
  if ("state" in partial && partial.state !== undefined) {
    const __val = partial.state as string;
    if (__val.length === 0) {
      errors.push({ field: "state", message: "must not be empty" });
    }
  }
  if ("description" in partial && partial.description !== undefined) {
    const __val = partial.description as string;
    if (__val.length === 0) {
      errors.push({ field: "description", message: "must not be empty" });
    }
  }
  return errors;
}
export function isTaxRate(obj: unknown): obj is TaxRate {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "id" in o &&
    "name" in o &&
    "taxAgency" in o &&
    "zip" in o &&
    "city" in o &&
    "county" in o &&
    "state" in o &&
    "isActive" in o &&
    "description" in o &&
    "taxComponents" in o
  );
}

export namespace TaxRate {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    name: Option<Array<string>>;
    taxAgency: Option<Array<string>>;
    zip: Option<Array<string>>;
    city: Option<Array<string>>;
    county: Option<Array<string>>;
    state: Option<Array<string>>;
    isActive: Option<Array<string>>;
    description: Option<Array<string>>;
    taxComponents: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      name: Option<boolean>;
      taxAgency: Option<boolean>;
      zip: Option<boolean>;
      city: Option<boolean>;
      county: Option<boolean>;
      state: Option<boolean>;
      isActive: Option<boolean>;
      description: Option<boolean>;
      taxComponents: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly name: FieldController<string>;
    readonly taxAgency: FieldController<string>;
    readonly zip: FieldController<number>;
    readonly city: FieldController<string>;
    readonly county: FieldController<string>;
    readonly state: FieldController<string>;
    readonly isActive: FieldController<boolean>;
    readonly description: FieldController<string>;
    readonly taxComponents: FieldController<{ [key: string]: number }>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: TaxRate;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<TaxRate, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<TaxRate>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<TaxRate>,
  ): Gigaform {
    let data = $state({ ...TaxRate.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      name: Option.none(),
      taxAgency: Option.none(),
      zip: Option.none(),
      city: Option.none(),
      county: Option.none(),
      state: Option.none(),
      isActive: Option.none(),
      description: Option.none(),
      taxComponents: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      name: Option.none(),
      taxAgency: Option.none(),
      zip: Option.none(),
      city: Option.none(),
      county: Option.none(),
      state: Option.none(),
      isActive: Option.none(),
      description: Option.none(),
      taxComponents: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = TaxRate.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },
        label: "Name",
        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = TaxRate.validateField("name", data.name);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      taxAgency: {
        path: ["taxAgency"] as const,
        name: "taxAgency",
        constraints: { required: true },
        label: "Tax Agency",
        get: () => data.taxAgency,
        set: (value: string) => {
          data.taxAgency = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.taxAgency,
        setError: (value: Option<Array<string>>) => {
          errors.taxAgency = value;
        },
        getTainted: () => tainted.taxAgency,
        setTainted: (value: Option<boolean>) => {
          tainted.taxAgency = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = TaxRate.validateField(
            "taxAgency",
            data.taxAgency,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      zip: {
        path: ["zip"] as const,
        name: "zip",
        constraints: { required: true },
        label: "Zip",
        get: () => data.zip,
        set: (value: number) => {
          data.zip = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.zip,
        setError: (value: Option<Array<string>>) => {
          errors.zip = value;
        },
        getTainted: () => tainted.zip,
        setTainted: (value: Option<boolean>) => {
          tainted.zip = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = TaxRate.validateField("zip", data.zip);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      city: {
        path: ["city"] as const,
        name: "city",
        constraints: { required: true },
        label: "City",
        get: () => data.city,
        set: (value: string) => {
          data.city = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.city,
        setError: (value: Option<Array<string>>) => {
          errors.city = value;
        },
        getTainted: () => tainted.city,
        setTainted: (value: Option<boolean>) => {
          tainted.city = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = TaxRate.validateField("city", data.city);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      county: {
        path: ["county"] as const,
        name: "county",
        constraints: { required: true },
        label: "County",
        get: () => data.county,
        set: (value: string) => {
          data.county = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.county,
        setError: (value: Option<Array<string>>) => {
          errors.county = value;
        },
        getTainted: () => tainted.county,
        setTainted: (value: Option<boolean>) => {
          tainted.county = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = TaxRate.validateField("county", data.county);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      state: {
        path: ["state"] as const,
        name: "state",
        constraints: { required: true },
        label: "State",
        get: () => data.state,
        set: (value: string) => {
          data.state = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.state,
        setError: (value: Option<Array<string>>) => {
          errors.state = value;
        },
        getTainted: () => tainted.state,
        setTainted: (value: Option<boolean>) => {
          tainted.state = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = TaxRate.validateField("state", data.state);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      isActive: {
        path: ["isActive"] as const,
        name: "isActive",
        constraints: { required: true },
        label: "Active",
        get: () => data.isActive,
        set: (value: boolean) => {
          data.isActive = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.isActive,
        setError: (value: Option<Array<string>>) => {
          errors.isActive = value;
        },
        getTainted: () => tainted.isActive,
        setTainted: (value: Option<boolean>) => {
          tainted.isActive = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = TaxRate.validateField("isActive", data.isActive);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      description: {
        path: ["description"] as const,
        name: "description",
        constraints: { required: true },
        label: "Description",
        get: () => data.description,
        set: (value: string) => {
          data.description = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.description,
        setError: (value: Option<Array<string>>) => {
          errors.description = value;
        },
        getTainted: () => tainted.description,
        setTainted: (value: Option<boolean>) => {
          tainted.description = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = TaxRate.validateField(
            "description",
            data.description,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      taxComponents: {
        path: ["taxComponents"] as const,
        name: "taxComponents",
        constraints: { required: true },

        get: () => data.taxComponents,
        set: (value: { [key: string]: number }) => {
          data.taxComponents = value;
        },
        transform: (value: {
          [key: string]: number;
        }): { [key: string]: number } => value,
        getError: () => errors.taxComponents,
        setError: (value: Option<Array<string>>) => {
          errors.taxComponents = value;
        },
        getTainted: () => tainted.taxComponents,
        setTainted: (value: Option<boolean>) => {
          tainted.taxComponents = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = TaxRate.validateField(
            "taxComponents",
            data.taxComponents,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      TaxRate,
      Array<{ field: string; message: string }>
    > {
      return TaxRate.fromObject(data);
    }
    function reset(newOverrides?: Partial<TaxRate>): void {
      data = { ...TaxRate.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        name: Option.none(),
        taxAgency: Option.none(),
        zip: Option.none(),
        city: Option.none(),
        county: Option.none(),
        state: Option.none(),
        isActive: Option.none(),
        description: Option.none(),
        taxComponents: Option.none(),
      };
      tainted = {
        id: Option.none(),
        name: Option.none(),
        taxAgency: Option.none(),
        zip: Option.none(),
        city: Option.none(),
        county: Option.none(),
        state: Option.none(),
        isActive: Option.none(),
        description: Option.none(),
        taxComponents: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<TaxRate, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.name = formData.get("name") ?? "";
    obj.taxAgency = formData.get("taxAgency") ?? "";
    {
      const zipStr = formData.get("zip");
      obj.zip = zipStr ? parseFloat(zipStr as string) : 0;
      if (obj.zip !== undefined && isNaN(obj.zip as number)) obj.zip = 0;
    }
    obj.city = formData.get("city") ?? "";
    obj.county = formData.get("county") ?? "";
    obj.state = formData.get("state") ?? "";
    {
      const isActiveVal = formData.get("isActive");
      obj.isActive =
        isActiveVal === "true" || isActiveVal === "on" || isActiveVal === "1";
    }
    obj.description = formData.get("description") ?? "";
    obj.taxComponents = formData.get("taxComponents") ?? "";
    return TaxRate.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Address {
  /** @serde({ validate: ["nonEmpty"] }) */
  street: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  city: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  state: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  zipcode: string;
}

export function defaultValueAddress(): Address {
  return { street: "", city: "", state: "", zipcode: "" } as Address;
}

export function toStringifiedJSONAddress(value: Address): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeAddress(value, ctx));
}
export function toObjectAddress(value: Address): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeAddress(value, ctx);
}
export function __serializeAddress(
  value: Address,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Address", __id };
  result["street"] = value.street;
  result["city"] = value.city;
  result["state"] = value.state;
  result["zipcode"] = value.zipcode;
  return result;
}

export function fromStringifiedJSONAddress(
  json: string,
  opts?: DeserializeOptions,
): Result<Address, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectAddress(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectAddress(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Address, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeAddress(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Address.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeAddress(
  value: any,
  ctx: DeserializeContext,
): Address | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Address.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("street" in obj)) {
    errors.push({ field: "street", message: "missing required field" });
  }
  if (!("city" in obj)) {
    errors.push({ field: "city", message: "missing required field" });
  }
  if (!("state" in obj)) {
    errors.push({ field: "state", message: "missing required field" });
  }
  if (!("zipcode" in obj)) {
    errors.push({ field: "zipcode", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_street = obj["street"] as string;
    if (__raw_street.length === 0) {
      errors.push({ field: "street", message: "must not be empty" });
    }
    instance.street = __raw_street;
  }
  {
    const __raw_city = obj["city"] as string;
    if (__raw_city.length === 0) {
      errors.push({ field: "city", message: "must not be empty" });
    }
    instance.city = __raw_city;
  }
  {
    const __raw_state = obj["state"] as string;
    if (__raw_state.length === 0) {
      errors.push({ field: "state", message: "must not be empty" });
    }
    instance.state = __raw_state;
  }
  {
    const __raw_zipcode = obj["zipcode"] as string;
    if (__raw_zipcode.length === 0) {
      errors.push({ field: "zipcode", message: "must not be empty" });
    }
    instance.zipcode = __raw_zipcode;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Address;
}
export function validateFieldAddress<K extends keyof Address>(
  field: K,
  value: Address[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "street": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "street", message: "must not be empty" });
      }
      break;
    }
    case "city": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "city", message: "must not be empty" });
      }
      break;
    }
    case "state": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "state", message: "must not be empty" });
      }
      break;
    }
    case "zipcode": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "zipcode", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsAddress(
  partial: Partial<Address>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("street" in partial && partial.street !== undefined) {
    const __val = partial.street as string;
    if (__val.length === 0) {
      errors.push({ field: "street", message: "must not be empty" });
    }
  }
  if ("city" in partial && partial.city !== undefined) {
    const __val = partial.city as string;
    if (__val.length === 0) {
      errors.push({ field: "city", message: "must not be empty" });
    }
  }
  if ("state" in partial && partial.state !== undefined) {
    const __val = partial.state as string;
    if (__val.length === 0) {
      errors.push({ field: "state", message: "must not be empty" });
    }
  }
  if ("zipcode" in partial && partial.zipcode !== undefined) {
    const __val = partial.zipcode as string;
    if (__val.length === 0) {
      errors.push({ field: "zipcode", message: "must not be empty" });
    }
  }
  return errors;
}
export function isAddress(obj: unknown): obj is Address {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "street" in o && "city" in o && "state" in o && "zipcode" in o;
}

export namespace Address {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    street: Option<Array<string>>;
    city: Option<Array<string>>;
    state: Option<Array<string>>;
    zipcode: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      street: Option<boolean>;
      city: Option<boolean>;
      state: Option<boolean>;
      zipcode: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly street: FieldController<string>;
    readonly city: FieldController<string>;
    readonly state: FieldController<string>;
    readonly zipcode: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Address;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Address, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Address>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Address>,
  ): Gigaform {
    let data = $state({ ...Address.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      street: Option.none(),
      city: Option.none(),
      state: Option.none(),
      zipcode: Option.none(),
    });
    let tainted = $state<Tainted>({
      street: Option.none(),
      city: Option.none(),
      state: Option.none(),
      zipcode: Option.none(),
    });
    const fields: FieldControllers = {
      street: {
        path: ["street"] as const,
        name: "street",
        constraints: { required: true },

        get: () => data.street,
        set: (value: string) => {
          data.street = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.street,
        setError: (value: Option<Array<string>>) => {
          errors.street = value;
        },
        getTainted: () => tainted.street,
        setTainted: (value: Option<boolean>) => {
          tainted.street = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Address.validateField("street", data.street);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      city: {
        path: ["city"] as const,
        name: "city",
        constraints: { required: true },

        get: () => data.city,
        set: (value: string) => {
          data.city = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.city,
        setError: (value: Option<Array<string>>) => {
          errors.city = value;
        },
        getTainted: () => tainted.city,
        setTainted: (value: Option<boolean>) => {
          tainted.city = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Address.validateField("city", data.city);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      state: {
        path: ["state"] as const,
        name: "state",
        constraints: { required: true },

        get: () => data.state,
        set: (value: string) => {
          data.state = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.state,
        setError: (value: Option<Array<string>>) => {
          errors.state = value;
        },
        getTainted: () => tainted.state,
        setTainted: (value: Option<boolean>) => {
          tainted.state = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Address.validateField("state", data.state);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      zipcode: {
        path: ["zipcode"] as const,
        name: "zipcode",
        constraints: { required: true },

        get: () => data.zipcode,
        set: (value: string) => {
          data.zipcode = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.zipcode,
        setError: (value: Option<Array<string>>) => {
          errors.zipcode = value;
        },
        getTainted: () => tainted.zipcode,
        setTainted: (value: Option<boolean>) => {
          tainted.zipcode = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Address.validateField("zipcode", data.zipcode);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Address,
      Array<{ field: string; message: string }>
    > {
      return Address.fromObject(data);
    }
    function reset(newOverrides?: Partial<Address>): void {
      data = { ...Address.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        street: Option.none(),
        city: Option.none(),
        state: Option.none(),
        zipcode: Option.none(),
      };
      tainted = {
        street: Option.none(),
        city: Option.none(),
        state: Option.none(),
        zipcode: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Address, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.street = formData.get("street") ?? "";
    obj.city = formData.get("city") ?? "";
    obj.state = formData.get("state") ?? "";
    obj.zipcode = formData.get("zipcode") ?? "";
    return Address.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Lead {
  /** @hiddenController({}) */
  id: string;
  /** @hiddenController({}) */
  number: number | null;
  /** @hiddenController({}) */
  accepted: boolean;
  /** @numberController({ label: "Probability", min: 0, max: 100 }) */
  probability: number;
  /** @radioGroupController({ label: "Priority", options: [{ label: "High", value: "High" }, { label: "Medium", value: "Medium" }, { label: "Low", value: "Low" }], orientation: "horizontal" }) */
  /** @default("Medium") */
  priority: Priority;
  /** @dateTimeController({ label: "Due Date" }) */
  dueDate: string | null;
  /** @dateTimeController({ label: "Close Date" }) */
  closeDate: string | null;
  /** @numberController({ label: "Value", min: 0, step: 0.01 }) */
  value: number;
  /** @selectController({ label: "Stage", options: [{ label: "Open", value: "Open" }, { label: "Working", value: "Working" }, { label: "Lost", value: "Lost" }, { label: "Qualified", value: "Qualified" }, { label: "Estimate", value: "Estimate" }, { label: "Negotiation", value: "Negotiation" }] }) */
  /** @default("Open") */
  stage: LeadStage;
  /** @textController({ label: "Status" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  status: string;
  /** @textAreaController({ label: "Description" }) */
  description: string | null;
  /** @hiddenController({}) */
  /** @default("InitialContact") */
  nextStep: NextStep;
  /** @switchController({ label: "Favorite" }) */
  favorite: boolean;
  /** @hiddenController({}) */
  dateAdded: string | null;
  /** @comboboxController({ label: "Tax Rate", allowCustom: false, fetchUrls: ["/api/tax-rates"] }) */
  taxRate: (string | TaxRate) | null;
  /** @radioGroupController({ label: "Sector", options: [{ label: "Residential", value: "Residential" }, { label: "Commercial", value: "Commercial" }], orientation: "horizontal" }) */
  /** @default("Residential") */
  sector: Sector;
  /** @enumFieldsetController({ legend: "Name", variants: { CompanyName: { label: "Company" }, PersonName: { label: "Person" } } }) */
  leadName: AccountName;
  /** @arrayFieldsetController({ legend: "Phones" }) */
  phones: PhoneNumber[];
  /** @emailFieldController({ label: "Email" }) */
  email: Email;
  /** @comboboxController({ label: "Lead Source", allowCustom: true }) */
  leadSource: string | null;
  /** @siteFieldsetController({ label: "Site" }) */
  /** @default("") */
  site: string | Site;
  /** @textAreaController({ label: "Memo" }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  memo: string;
  /** @toggleController({ label: "Needs Review" }) */
  needsReview: boolean;
  /** @toggleController({ label: "Has Alert" }) */
  hasAlert: boolean;
  /** @comboboxMultipleController({ label: "Sales Rep", fetchUrls: ["/api/employees"] }) */
  salesRep: Represents[] | null;
  /** @hiddenController({}) */
  color: string | null;
  /** @comboboxController({ label: "Account Type", allowCustom: true }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  accountType: string;
  /** @comboboxController({ label: "Subtype", allowCustom: true }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  subtype: string;
  /** @toggleController({ label: "Tax Exempt" }) */
  isTaxExempt: boolean;
  /** @comboboxController({ label: "Payment Terms", allowCustom: true }) */
  /** @serde({ validate: ["nonEmpty"] }) */
  paymentTerms: string;
  /** @tagsController({ label: "Tags" }) */
  tags: string[];
  /** @arrayFieldsetController({ legend: "Custom Fields" }) */
  customFields: [string, string][];
}

export function defaultValueLead(): Lead {
  return {
    id: "",
    number: null,
    accepted: false,
    probability: 0,
    priority: "Medium",
    dueDate: null,
    closeDate: null,
    value: 0,
    stage: "Open",
    status: "",
    description: null,
    nextStep: "InitialContact",
    favorite: false,
    dateAdded: null,
    taxRate: null,
    sector: "Residential",
    leadName: AccountName.defaultValue(),
    phones: [],
    email: Email.defaultValue(),
    leadSource: null,
    site: "",
    memo: "",
    needsReview: false,
    hasAlert: false,
    salesRep: null,
    color: null,
    accountType: "",
    subtype: "",
    isTaxExempt: false,
    paymentTerms: "",
    tags: [],
    customFields: [],
  } as Lead;
}

export function toStringifiedJSONLead(value: Lead): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeLead(value, ctx));
}
export function toObjectLead(value: Lead): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeLead(value, ctx);
}
export function __serializeLead(
  value: Lead,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Lead", __id };
  result["id"] = value.id;
  if (value.number !== null) {
    result["number"] =
      typeof (value.number as any)?.__serialize === "function"
        ? (value.number as any).__serialize(ctx)
        : value.number;
  } else {
    result["number"] = null;
  }
  result["accepted"] = value.accepted;
  result["probability"] = value.probability;
  result["priority"] =
    typeof (value.priority as any)?.__serialize === "function"
      ? (value.priority as any).__serialize(ctx)
      : value.priority;
  if (value.dueDate !== null) {
    result["dueDate"] =
      typeof (value.dueDate as any)?.__serialize === "function"
        ? (value.dueDate as any).__serialize(ctx)
        : value.dueDate;
  } else {
    result["dueDate"] = null;
  }
  if (value.closeDate !== null) {
    result["closeDate"] =
      typeof (value.closeDate as any)?.__serialize === "function"
        ? (value.closeDate as any).__serialize(ctx)
        : value.closeDate;
  } else {
    result["closeDate"] = null;
  }
  result["value"] = value.value;
  result["stage"] =
    typeof (value.stage as any)?.__serialize === "function"
      ? (value.stage as any).__serialize(ctx)
      : value.stage;
  result["status"] = value.status;
  if (value.description !== null) {
    result["description"] =
      typeof (value.description as any)?.__serialize === "function"
        ? (value.description as any).__serialize(ctx)
        : value.description;
  } else {
    result["description"] = null;
  }
  result["nextStep"] =
    typeof (value.nextStep as any)?.__serialize === "function"
      ? (value.nextStep as any).__serialize(ctx)
      : value.nextStep;
  result["favorite"] = value.favorite;
  if (value.dateAdded !== null) {
    result["dateAdded"] =
      typeof (value.dateAdded as any)?.__serialize === "function"
        ? (value.dateAdded as any).__serialize(ctx)
        : value.dateAdded;
  } else {
    result["dateAdded"] = null;
  }
  if (value.taxRate !== null) {
    result["taxRate"] =
      typeof (value.taxRate as any)?.__serialize === "function"
        ? (value.taxRate as any).__serialize(ctx)
        : value.taxRate;
  } else {
    result["taxRate"] = null;
  }
  result["sector"] =
    typeof (value.sector as any)?.__serialize === "function"
      ? (value.sector as any).__serialize(ctx)
      : value.sector;
  result["leadName"] =
    typeof (value.leadName as any)?.__serialize === "function"
      ? (value.leadName as any).__serialize(ctx)
      : value.leadName;
  result["phones"] = value.phones.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["email"] =
    typeof (value.email as any)?.__serialize === "function"
      ? (value.email as any).__serialize(ctx)
      : value.email;
  if (value.leadSource !== null) {
    result["leadSource"] =
      typeof (value.leadSource as any)?.__serialize === "function"
        ? (value.leadSource as any).__serialize(ctx)
        : value.leadSource;
  } else {
    result["leadSource"] = null;
  }
  result["site"] = value.site;
  result["memo"] = value.memo;
  result["needsReview"] = value.needsReview;
  result["hasAlert"] = value.hasAlert;
  if (value.salesRep !== null) {
    result["salesRep"] =
      typeof (value.salesRep as any)?.__serialize === "function"
        ? (value.salesRep as any).__serialize(ctx)
        : value.salesRep;
  } else {
    result["salesRep"] = null;
  }
  if (value.color !== null) {
    result["color"] =
      typeof (value.color as any)?.__serialize === "function"
        ? (value.color as any).__serialize(ctx)
        : value.color;
  } else {
    result["color"] = null;
  }
  result["accountType"] = value.accountType;
  result["subtype"] = value.subtype;
  result["isTaxExempt"] = value.isTaxExempt;
  result["paymentTerms"] = value.paymentTerms;
  result["tags"] = value.tags.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["customFields"] = value.customFields.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  return result;
}

export function fromStringifiedJSONLead(
  json: string,
  opts?: DeserializeOptions,
): Result<Lead, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectLead(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectLead(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Lead, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeLead(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Lead.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeLead(
  value: any,
  ctx: DeserializeContext,
): Lead | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Lead.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("number" in obj)) {
    errors.push({ field: "number", message: "missing required field" });
  }
  if (!("accepted" in obj)) {
    errors.push({ field: "accepted", message: "missing required field" });
  }
  if (!("probability" in obj)) {
    errors.push({ field: "probability", message: "missing required field" });
  }
  if (!("priority" in obj)) {
    errors.push({ field: "priority", message: "missing required field" });
  }
  if (!("dueDate" in obj)) {
    errors.push({ field: "dueDate", message: "missing required field" });
  }
  if (!("closeDate" in obj)) {
    errors.push({ field: "closeDate", message: "missing required field" });
  }
  if (!("value" in obj)) {
    errors.push({ field: "value", message: "missing required field" });
  }
  if (!("stage" in obj)) {
    errors.push({ field: "stage", message: "missing required field" });
  }
  if (!("status" in obj)) {
    errors.push({ field: "status", message: "missing required field" });
  }
  if (!("description" in obj)) {
    errors.push({ field: "description", message: "missing required field" });
  }
  if (!("nextStep" in obj)) {
    errors.push({ field: "nextStep", message: "missing required field" });
  }
  if (!("favorite" in obj)) {
    errors.push({ field: "favorite", message: "missing required field" });
  }
  if (!("dateAdded" in obj)) {
    errors.push({ field: "dateAdded", message: "missing required field" });
  }
  if (!("taxRate" in obj)) {
    errors.push({ field: "taxRate", message: "missing required field" });
  }
  if (!("sector" in obj)) {
    errors.push({ field: "sector", message: "missing required field" });
  }
  if (!("leadName" in obj)) {
    errors.push({ field: "leadName", message: "missing required field" });
  }
  if (!("phones" in obj)) {
    errors.push({ field: "phones", message: "missing required field" });
  }
  if (!("email" in obj)) {
    errors.push({ field: "email", message: "missing required field" });
  }
  if (!("leadSource" in obj)) {
    errors.push({ field: "leadSource", message: "missing required field" });
  }
  if (!("site" in obj)) {
    errors.push({ field: "site", message: "missing required field" });
  }
  if (!("memo" in obj)) {
    errors.push({ field: "memo", message: "missing required field" });
  }
  if (!("needsReview" in obj)) {
    errors.push({ field: "needsReview", message: "missing required field" });
  }
  if (!("hasAlert" in obj)) {
    errors.push({ field: "hasAlert", message: "missing required field" });
  }
  if (!("salesRep" in obj)) {
    errors.push({ field: "salesRep", message: "missing required field" });
  }
  if (!("color" in obj)) {
    errors.push({ field: "color", message: "missing required field" });
  }
  if (!("accountType" in obj)) {
    errors.push({ field: "accountType", message: "missing required field" });
  }
  if (!("subtype" in obj)) {
    errors.push({ field: "subtype", message: "missing required field" });
  }
  if (!("isTaxExempt" in obj)) {
    errors.push({ field: "isTaxExempt", message: "missing required field" });
  }
  if (!("paymentTerms" in obj)) {
    errors.push({ field: "paymentTerms", message: "missing required field" });
  }
  if (!("tags" in obj)) {
    errors.push({ field: "tags", message: "missing required field" });
  }
  if (!("customFields" in obj)) {
    errors.push({ field: "customFields", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_number = obj["number"] as number | null;
    if (__raw_number === null) {
      instance.number = null;
    } else if (typeof (__raw_number as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_number as any).__ref);
      ctx.assignOrDefer(instance, "number", __result);
    } else {
      instance.number = __raw_number;
    }
  }
  {
    const __raw_accepted = obj["accepted"] as boolean;
    instance.accepted = __raw_accepted;
  }
  {
    const __raw_probability = obj["probability"] as number;
    instance.probability = __raw_probability;
  }
  {
    const __raw_priority = obj["priority"] as Priority;
    if (typeof (Priority as any)?.__deserialize === "function") {
      const __result = (Priority as any).__deserialize(__raw_priority, ctx);
      ctx.assignOrDefer(instance, "priority", __result);
    } else {
      instance.priority = __raw_priority;
    }
  }
  {
    const __raw_dueDate = obj["dueDate"] as string | null;
    if (__raw_dueDate === null) {
      instance.dueDate = null;
    } else if (typeof (__raw_dueDate as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_dueDate as any).__ref);
      ctx.assignOrDefer(instance, "dueDate", __result);
    } else {
      instance.dueDate = __raw_dueDate;
    }
  }
  {
    const __raw_closeDate = obj["closeDate"] as string | null;
    if (__raw_closeDate === null) {
      instance.closeDate = null;
    } else if (typeof (__raw_closeDate as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_closeDate as any).__ref);
      ctx.assignOrDefer(instance, "closeDate", __result);
    } else {
      instance.closeDate = __raw_closeDate;
    }
  }
  {
    const __raw_value = obj["value"] as number;
    instance.value = __raw_value;
  }
  {
    const __raw_stage = obj["stage"] as LeadStage;
    if (typeof (LeadStage as any)?.__deserialize === "function") {
      const __result = (LeadStage as any).__deserialize(__raw_stage, ctx);
      ctx.assignOrDefer(instance, "stage", __result);
    } else {
      instance.stage = __raw_stage;
    }
  }
  {
    const __raw_status = obj["status"] as string;
    if (__raw_status.length === 0) {
      errors.push({ field: "status", message: "must not be empty" });
    }
    instance.status = __raw_status;
  }
  {
    const __raw_description = obj["description"] as string | null;
    if (__raw_description === null) {
      instance.description = null;
    } else if (typeof (__raw_description as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_description as any).__ref);
      ctx.assignOrDefer(instance, "description", __result);
    } else {
      instance.description = __raw_description;
    }
  }
  {
    const __raw_nextStep = obj["nextStep"] as NextStep;
    if (typeof (NextStep as any)?.__deserialize === "function") {
      const __result = (NextStep as any).__deserialize(__raw_nextStep, ctx);
      ctx.assignOrDefer(instance, "nextStep", __result);
    } else {
      instance.nextStep = __raw_nextStep;
    }
  }
  {
    const __raw_favorite = obj["favorite"] as boolean;
    instance.favorite = __raw_favorite;
  }
  {
    const __raw_dateAdded = obj["dateAdded"] as string | null;
    if (__raw_dateAdded === null) {
      instance.dateAdded = null;
    } else if (typeof (__raw_dateAdded as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_dateAdded as any).__ref);
      ctx.assignOrDefer(instance, "dateAdded", __result);
    } else {
      instance.dateAdded = __raw_dateAdded;
    }
  }
  {
    const __raw_taxRate = obj["taxRate"] as (string | TaxRate) | null;
    if (__raw_taxRate === null) {
      instance.taxRate = null;
    } else if (typeof (__raw_taxRate as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_taxRate as any).__ref);
      ctx.assignOrDefer(instance, "taxRate", __result);
    } else {
      instance.taxRate = __raw_taxRate;
    }
  }
  {
    const __raw_sector = obj["sector"] as Sector;
    if (typeof (Sector as any)?.__deserialize === "function") {
      const __result = (Sector as any).__deserialize(__raw_sector, ctx);
      ctx.assignOrDefer(instance, "sector", __result);
    } else {
      instance.sector = __raw_sector;
    }
  }
  {
    const __raw_leadName = obj["leadName"] as AccountName;
    if (typeof (AccountName as any)?.__deserialize === "function") {
      const __result = (AccountName as any).__deserialize(__raw_leadName, ctx);
      ctx.assignOrDefer(instance, "leadName", __result);
    } else {
      instance.leadName = __raw_leadName;
    }
  }
  {
    const __raw_phones = obj["phones"] as PhoneNumber[];
    if (Array.isArray(__raw_phones)) {
      instance.phones = __raw_phones as PhoneNumber[];
    }
  }
  {
    const __raw_email = obj["email"] as Email;
    if (typeof (Email as any)?.__deserialize === "function") {
      const __result = (Email as any).__deserialize(__raw_email, ctx);
      ctx.assignOrDefer(instance, "email", __result);
    } else {
      instance.email = __raw_email;
    }
  }
  {
    const __raw_leadSource = obj["leadSource"] as string | null;
    if (__raw_leadSource === null) {
      instance.leadSource = null;
    } else if (typeof (__raw_leadSource as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_leadSource as any).__ref);
      ctx.assignOrDefer(instance, "leadSource", __result);
    } else {
      instance.leadSource = __raw_leadSource;
    }
  }
  {
    const __raw_site = obj["site"] as string | Site;
    instance.site = __raw_site;
  }
  {
    const __raw_memo = obj["memo"] as string;
    if (__raw_memo.length === 0) {
      errors.push({ field: "memo", message: "must not be empty" });
    }
    instance.memo = __raw_memo;
  }
  {
    const __raw_needsReview = obj["needsReview"] as boolean;
    instance.needsReview = __raw_needsReview;
  }
  {
    const __raw_hasAlert = obj["hasAlert"] as boolean;
    instance.hasAlert = __raw_hasAlert;
  }
  {
    const __raw_salesRep = obj["salesRep"] as Represents[] | null;
    if (__raw_salesRep === null) {
      instance.salesRep = null;
    } else if (typeof (__raw_salesRep as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_salesRep as any).__ref);
      ctx.assignOrDefer(instance, "salesRep", __result);
    } else {
      instance.salesRep = __raw_salesRep;
    }
  }
  {
    const __raw_color = obj["color"] as string | null;
    if (__raw_color === null) {
      instance.color = null;
    } else if (typeof (__raw_color as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_color as any).__ref);
      ctx.assignOrDefer(instance, "color", __result);
    } else {
      instance.color = __raw_color;
    }
  }
  {
    const __raw_accountType = obj["accountType"] as string;
    if (__raw_accountType.length === 0) {
      errors.push({ field: "accountType", message: "must not be empty" });
    }
    instance.accountType = __raw_accountType;
  }
  {
    const __raw_subtype = obj["subtype"] as string;
    if (__raw_subtype.length === 0) {
      errors.push({ field: "subtype", message: "must not be empty" });
    }
    instance.subtype = __raw_subtype;
  }
  {
    const __raw_isTaxExempt = obj["isTaxExempt"] as boolean;
    instance.isTaxExempt = __raw_isTaxExempt;
  }
  {
    const __raw_paymentTerms = obj["paymentTerms"] as string;
    if (__raw_paymentTerms.length === 0) {
      errors.push({ field: "paymentTerms", message: "must not be empty" });
    }
    instance.paymentTerms = __raw_paymentTerms;
  }
  {
    const __raw_tags = obj["tags"] as string[];
    if (Array.isArray(__raw_tags)) {
      instance.tags = __raw_tags as string[];
    }
  }
  {
    const __raw_customFields = obj["customFields"] as [string, string][];
    if (Array.isArray(__raw_customFields)) {
      instance.customFields = __raw_customFields as [string, string][];
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Lead;
}
export function validateFieldLead<K extends keyof Lead>(
  field: K,
  value: Lead[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "status": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "status", message: "must not be empty" });
      }
      break;
    }
    case "memo": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "memo", message: "must not be empty" });
      }
      break;
    }
    case "accountType": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "accountType", message: "must not be empty" });
      }
      break;
    }
    case "subtype": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "subtype", message: "must not be empty" });
      }
      break;
    }
    case "paymentTerms": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "paymentTerms", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsLead(
  partial: Partial<Lead>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("status" in partial && partial.status !== undefined) {
    const __val = partial.status as string;
    if (__val.length === 0) {
      errors.push({ field: "status", message: "must not be empty" });
    }
  }
  if ("memo" in partial && partial.memo !== undefined) {
    const __val = partial.memo as string;
    if (__val.length === 0) {
      errors.push({ field: "memo", message: "must not be empty" });
    }
  }
  if ("accountType" in partial && partial.accountType !== undefined) {
    const __val = partial.accountType as string;
    if (__val.length === 0) {
      errors.push({ field: "accountType", message: "must not be empty" });
    }
  }
  if ("subtype" in partial && partial.subtype !== undefined) {
    const __val = partial.subtype as string;
    if (__val.length === 0) {
      errors.push({ field: "subtype", message: "must not be empty" });
    }
  }
  if ("paymentTerms" in partial && partial.paymentTerms !== undefined) {
    const __val = partial.paymentTerms as string;
    if (__val.length === 0) {
      errors.push({ field: "paymentTerms", message: "must not be empty" });
    }
  }
  return errors;
}
export function isLead(obj: unknown): obj is Lead {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "id" in o &&
    "number" in o &&
    "accepted" in o &&
    "probability" in o &&
    "priority" in o &&
    "dueDate" in o &&
    "closeDate" in o &&
    "value" in o &&
    "stage" in o &&
    "status" in o &&
    "description" in o &&
    "nextStep" in o &&
    "favorite" in o &&
    "dateAdded" in o &&
    "taxRate" in o &&
    "sector" in o &&
    "leadName" in o &&
    "phones" in o &&
    "email" in o &&
    "leadSource" in o &&
    "site" in o &&
    "memo" in o &&
    "needsReview" in o &&
    "hasAlert" in o &&
    "salesRep" in o &&
    "color" in o &&
    "accountType" in o &&
    "subtype" in o &&
    "isTaxExempt" in o &&
    "paymentTerms" in o &&
    "tags" in o &&
    "customFields" in o
  );
}

export namespace Lead {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    number: Option<Array<string>>;
    accepted: Option<Array<string>>;
    probability: Option<Array<string>>;
    priority: Option<Array<string>>;
    dueDate: Option<Array<string>>;
    closeDate: Option<Array<string>>;
    value: Option<Array<string>>;
    stage: Option<Array<string>>;
    status: Option<Array<string>>;
    description: Option<Array<string>>;
    nextStep: Option<Array<string>>;
    favorite: Option<Array<string>>;
    dateAdded: Option<Array<string>>;
    taxRate: Option<Array<string>>;
    sector: Option<Array<string>>;
    leadName: Option<Array<string>>;
    phones: Option<Array<string>>;
    email: Option<Array<string>>;
    leadSource: Option<Array<string>>;
    site: Option<Array<string>>;
    memo: Option<Array<string>>;
    needsReview: Option<Array<string>>;
    hasAlert: Option<Array<string>>;
    salesRep: Option<Array<string>>;
    color: Option<Array<string>>;
    accountType: Option<Array<string>>;
    subtype: Option<Array<string>>;
    isTaxExempt: Option<Array<string>>;
    paymentTerms: Option<Array<string>>;
    tags: Option<Array<string>>;
    customFields: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      number: Option<boolean>;
      accepted: Option<boolean>;
      probability: Option<boolean>;
      priority: Option<boolean>;
      dueDate: Option<boolean>;
      closeDate: Option<boolean>;
      value: Option<boolean>;
      stage: Option<boolean>;
      status: Option<boolean>;
      description: Option<boolean>;
      nextStep: Option<boolean>;
      favorite: Option<boolean>;
      dateAdded: Option<boolean>;
      taxRate: Option<boolean>;
      sector: Option<boolean>;
      leadName: Option<boolean>;
      phones: Option<boolean>;
      email: Option<boolean>;
      leadSource: Option<boolean>;
      site: Option<boolean>;
      memo: Option<boolean>;
      needsReview: Option<boolean>;
      hasAlert: Option<boolean>;
      salesRep: Option<boolean>;
      color: Option<boolean>;
      accountType: Option<boolean>;
      subtype: Option<boolean>;
      isTaxExempt: Option<boolean>;
      paymentTerms: Option<boolean>;
      tags: Option<boolean>;
      customFields: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly number: FieldController<number | null>;
    readonly accepted: FieldController<boolean>;
    readonly probability: FieldController<number>;
    readonly priority: FieldController<Priority>;
    readonly dueDate: FieldController<string | null>;
    readonly closeDate: FieldController<string | null>;
    readonly value: FieldController<number>;
    readonly stage: FieldController<LeadStage>;
    readonly status: FieldController<string>;
    readonly description: FieldController<string | null>;
    readonly nextStep: FieldController<NextStep>;
    readonly favorite: FieldController<boolean>;
    readonly dateAdded: FieldController<string | null>;
    readonly taxRate: FieldController<(string | TaxRate) | null>;
    readonly sector: FieldController<Sector>;
    readonly leadName: FieldController<AccountName>;
    readonly phones: ArrayFieldController<PhoneNumber>;
    readonly email: FieldController<Email>;
    readonly leadSource: FieldController<string | null>;
    readonly site: FieldController<string | Site>;
    readonly memo: FieldController<string>;
    readonly needsReview: FieldController<boolean>;
    readonly hasAlert: FieldController<boolean>;
    readonly salesRep: FieldController<Represents[] | null>;
    readonly color: FieldController<string | null>;
    readonly accountType: FieldController<string>;
    readonly subtype: FieldController<string>;
    readonly isTaxExempt: FieldController<boolean>;
    readonly paymentTerms: FieldController<string>;
    readonly tags: ArrayFieldController<string>;
    readonly customFields: ArrayFieldController<[string, string]>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Lead;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Lead, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Lead>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Lead>,
  ): Gigaform {
    let data = $state({ ...Lead.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      number: Option.none(),
      accepted: Option.none(),
      probability: Option.none(),
      priority: Option.none(),
      dueDate: Option.none(),
      closeDate: Option.none(),
      value: Option.none(),
      stage: Option.none(),
      status: Option.none(),
      description: Option.none(),
      nextStep: Option.none(),
      favorite: Option.none(),
      dateAdded: Option.none(),
      taxRate: Option.none(),
      sector: Option.none(),
      leadName: Option.none(),
      phones: Option.none(),
      email: Option.none(),
      leadSource: Option.none(),
      site: Option.none(),
      memo: Option.none(),
      needsReview: Option.none(),
      hasAlert: Option.none(),
      salesRep: Option.none(),
      color: Option.none(),
      accountType: Option.none(),
      subtype: Option.none(),
      isTaxExempt: Option.none(),
      paymentTerms: Option.none(),
      tags: Option.none(),
      customFields: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      number: Option.none(),
      accepted: Option.none(),
      probability: Option.none(),
      priority: Option.none(),
      dueDate: Option.none(),
      closeDate: Option.none(),
      value: Option.none(),
      stage: Option.none(),
      status: Option.none(),
      description: Option.none(),
      nextStep: Option.none(),
      favorite: Option.none(),
      dateAdded: Option.none(),
      taxRate: Option.none(),
      sector: Option.none(),
      leadName: Option.none(),
      phones: Option.none(),
      email: Option.none(),
      leadSource: Option.none(),
      site: Option.none(),
      memo: Option.none(),
      needsReview: Option.none(),
      hasAlert: Option.none(),
      salesRep: Option.none(),
      color: Option.none(),
      accountType: Option.none(),
      subtype: Option.none(),
      isTaxExempt: Option.none(),
      paymentTerms: Option.none(),
      tags: Option.none(),
      customFields: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      number: {
        path: ["number"] as const,
        name: "number",
        constraints: { required: true },

        get: () => data.number,
        set: (value: number | null) => {
          data.number = value;
        },
        transform: (value: number | null): number | null => value,
        getError: () => errors.number,
        setError: (value: Option<Array<string>>) => {
          errors.number = value;
        },
        getTainted: () => tainted.number,
        setTainted: (value: Option<boolean>) => {
          tainted.number = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("number", data.number);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      accepted: {
        path: ["accepted"] as const,
        name: "accepted",
        constraints: { required: true },

        get: () => data.accepted,
        set: (value: boolean) => {
          data.accepted = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.accepted,
        setError: (value: Option<Array<string>>) => {
          errors.accepted = value;
        },
        getTainted: () => tainted.accepted,
        setTainted: (value: Option<boolean>) => {
          tainted.accepted = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("accepted", data.accepted);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      probability: {
        path: ["probability"] as const,
        name: "probability",
        constraints: { required: true },
        label: "Probability",
        get: () => data.probability,
        set: (value: number) => {
          data.probability = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.probability,
        setError: (value: Option<Array<string>>) => {
          errors.probability = value;
        },
        getTainted: () => tainted.probability,
        setTainted: (value: Option<boolean>) => {
          tainted.probability = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField(
            "probability",
            data.probability,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      priority: {
        path: ["priority"] as const,
        name: "priority",
        constraints: { required: true },
        label: "Priority",
        get: () => data.priority,
        set: (value: Priority) => {
          data.priority = value;
        },
        transform: (value: Priority): Priority => value,
        getError: () => errors.priority,
        setError: (value: Option<Array<string>>) => {
          errors.priority = value;
        },
        getTainted: () => tainted.priority,
        setTainted: (value: Option<boolean>) => {
          tainted.priority = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("priority", data.priority);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      dueDate: {
        path: ["dueDate"] as const,
        name: "dueDate",
        constraints: { required: true },
        label: "Due Date",
        get: () => data.dueDate,
        set: (value: string | null) => {
          data.dueDate = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.dueDate,
        setError: (value: Option<Array<string>>) => {
          errors.dueDate = value;
        },
        getTainted: () => tainted.dueDate,
        setTainted: (value: Option<boolean>) => {
          tainted.dueDate = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("dueDate", data.dueDate);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      closeDate: {
        path: ["closeDate"] as const,
        name: "closeDate",
        constraints: { required: true },
        label: "Close Date",
        get: () => data.closeDate,
        set: (value: string | null) => {
          data.closeDate = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.closeDate,
        setError: (value: Option<Array<string>>) => {
          errors.closeDate = value;
        },
        getTainted: () => tainted.closeDate,
        setTainted: (value: Option<boolean>) => {
          tainted.closeDate = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("closeDate", data.closeDate);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      value: {
        path: ["value"] as const,
        name: "value",
        constraints: { required: true },
        label: "Value",
        get: () => data.value,
        set: (value: number) => {
          data.value = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.value,
        setError: (value: Option<Array<string>>) => {
          errors.value = value;
        },
        getTainted: () => tainted.value,
        setTainted: (value: Option<boolean>) => {
          tainted.value = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("value", data.value);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      stage: {
        path: ["stage"] as const,
        name: "stage",
        constraints: { required: true },
        label: "Stage",
        get: () => data.stage,
        set: (value: LeadStage) => {
          data.stage = value;
        },
        transform: (value: LeadStage): LeadStage => value,
        getError: () => errors.stage,
        setError: (value: Option<Array<string>>) => {
          errors.stage = value;
        },
        getTainted: () => tainted.stage,
        setTainted: (value: Option<boolean>) => {
          tainted.stage = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("stage", data.stage);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      status: {
        path: ["status"] as const,
        name: "status",
        constraints: { required: true },
        label: "Status",
        get: () => data.status,
        set: (value: string) => {
          data.status = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.status,
        setError: (value: Option<Array<string>>) => {
          errors.status = value;
        },
        getTainted: () => tainted.status,
        setTainted: (value: Option<boolean>) => {
          tainted.status = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("status", data.status);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      description: {
        path: ["description"] as const,
        name: "description",
        constraints: { required: true },
        label: "Description",
        get: () => data.description,
        set: (value: string | null) => {
          data.description = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.description,
        setError: (value: Option<Array<string>>) => {
          errors.description = value;
        },
        getTainted: () => tainted.description,
        setTainted: (value: Option<boolean>) => {
          tainted.description = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField(
            "description",
            data.description,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      nextStep: {
        path: ["nextStep"] as const,
        name: "nextStep",
        constraints: { required: true },

        get: () => data.nextStep,
        set: (value: NextStep) => {
          data.nextStep = value;
        },
        transform: (value: NextStep): NextStep => value,
        getError: () => errors.nextStep,
        setError: (value: Option<Array<string>>) => {
          errors.nextStep = value;
        },
        getTainted: () => tainted.nextStep,
        setTainted: (value: Option<boolean>) => {
          tainted.nextStep = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("nextStep", data.nextStep);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      favorite: {
        path: ["favorite"] as const,
        name: "favorite",
        constraints: { required: true },
        label: "Favorite",
        get: () => data.favorite,
        set: (value: boolean) => {
          data.favorite = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.favorite,
        setError: (value: Option<Array<string>>) => {
          errors.favorite = value;
        },
        getTainted: () => tainted.favorite,
        setTainted: (value: Option<boolean>) => {
          tainted.favorite = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("favorite", data.favorite);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      dateAdded: {
        path: ["dateAdded"] as const,
        name: "dateAdded",
        constraints: { required: true },

        get: () => data.dateAdded,
        set: (value: string | null) => {
          data.dateAdded = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.dateAdded,
        setError: (value: Option<Array<string>>) => {
          errors.dateAdded = value;
        },
        getTainted: () => tainted.dateAdded,
        setTainted: (value: Option<boolean>) => {
          tainted.dateAdded = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("dateAdded", data.dateAdded);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      taxRate: {
        path: ["taxRate"] as const,
        name: "taxRate",
        constraints: { required: true },
        label: "Tax Rate",
        get: () => data.taxRate,
        set: (value: (string | TaxRate) | null) => {
          data.taxRate = value;
        },
        transform: (
          value: (string | TaxRate) | null,
        ): (string | TaxRate) | null => value,
        getError: () => errors.taxRate,
        setError: (value: Option<Array<string>>) => {
          errors.taxRate = value;
        },
        getTainted: () => tainted.taxRate,
        setTainted: (value: Option<boolean>) => {
          tainted.taxRate = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("taxRate", data.taxRate);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      sector: {
        path: ["sector"] as const,
        name: "sector",
        constraints: { required: true },
        label: "Sector",
        get: () => data.sector,
        set: (value: Sector) => {
          data.sector = value;
        },
        transform: (value: Sector): Sector => value,
        getError: () => errors.sector,
        setError: (value: Option<Array<string>>) => {
          errors.sector = value;
        },
        getTainted: () => tainted.sector,
        setTainted: (value: Option<boolean>) => {
          tainted.sector = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("sector", data.sector);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      leadName: {
        path: ["leadName"] as const,
        name: "leadName",
        constraints: { required: true },

        get: () => data.leadName,
        set: (value: AccountName) => {
          data.leadName = value;
        },
        transform: (value: AccountName): AccountName => value,
        getError: () => errors.leadName,
        setError: (value: Option<Array<string>>) => {
          errors.leadName = value;
        },
        getTainted: () => tainted.leadName,
        setTainted: (value: Option<boolean>) => {
          tainted.leadName = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("leadName", data.leadName);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      phones: {
        path: ["phones"] as const,
        name: "phones",
        constraints: { required: true },

        get: () => data.phones,
        set: (value: PhoneNumber[]) => {
          data.phones = value;
        },
        transform: (value: PhoneNumber[]): PhoneNumber[] => value,
        getError: () => errors.phones,
        setError: (value: Option<Array<string>>) => {
          errors.phones = value;
        },
        getTainted: () => tainted.phones,
        setTainted: (value: Option<boolean>) => {
          tainted.phones = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("phones", data.phones);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["phones", index] as const,
          name: `phones.${index}`,
          constraints: { required: true },
          get: () => data.phones[index]!,
          set: (value: PhoneNumber) => {
            data.phones[index] = value;
          },
          transform: (value: PhoneNumber): PhoneNumber => value,
          getError: () => errors.phones,
          setError: (value: Option<Array<string>>) => {
            errors.phones = value;
          },
          getTainted: () => tainted.phones,
          setTainted: (value: Option<boolean>) => {
            tainted.phones = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: PhoneNumber) => {
          data.phones.push(item);
        },
        remove: (index: number) => {
          data.phones.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.phones[a]!;
          data.phones[a] = data.phones[b]!;
          data.phones[b] = tmp;
        },
      },
      email: {
        path: ["email"] as const,
        name: "email",
        constraints: { required: true },
        label: "Email",
        get: () => data.email,
        set: (value: Email) => {
          data.email = value;
        },
        transform: (value: Email): Email => value,
        getError: () => errors.email,
        setError: (value: Option<Array<string>>) => {
          errors.email = value;
        },
        getTainted: () => tainted.email,
        setTainted: (value: Option<boolean>) => {
          tainted.email = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("email", data.email);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      leadSource: {
        path: ["leadSource"] as const,
        name: "leadSource",
        constraints: { required: true },
        label: "Lead Source",
        get: () => data.leadSource,
        set: (value: string | null) => {
          data.leadSource = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.leadSource,
        setError: (value: Option<Array<string>>) => {
          errors.leadSource = value;
        },
        getTainted: () => tainted.leadSource,
        setTainted: (value: Option<boolean>) => {
          tainted.leadSource = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("leadSource", data.leadSource);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      site: {
        path: ["site"] as const,
        name: "site",
        constraints: { required: true },
        label: "Site",
        get: () => data.site,
        set: (value: string | Site) => {
          data.site = value;
        },
        transform: (value: string | Site): string | Site => value,
        getError: () => errors.site,
        setError: (value: Option<Array<string>>) => {
          errors.site = value;
        },
        getTainted: () => tainted.site,
        setTainted: (value: Option<boolean>) => {
          tainted.site = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("site", data.site);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      memo: {
        path: ["memo"] as const,
        name: "memo",
        constraints: { required: true },
        label: "Memo",
        get: () => data.memo,
        set: (value: string) => {
          data.memo = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.memo,
        setError: (value: Option<Array<string>>) => {
          errors.memo = value;
        },
        getTainted: () => tainted.memo,
        setTainted: (value: Option<boolean>) => {
          tainted.memo = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("memo", data.memo);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      needsReview: {
        path: ["needsReview"] as const,
        name: "needsReview",
        constraints: { required: true },
        label: "Needs Review",
        get: () => data.needsReview,
        set: (value: boolean) => {
          data.needsReview = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.needsReview,
        setError: (value: Option<Array<string>>) => {
          errors.needsReview = value;
        },
        getTainted: () => tainted.needsReview,
        setTainted: (value: Option<boolean>) => {
          tainted.needsReview = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField(
            "needsReview",
            data.needsReview,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      hasAlert: {
        path: ["hasAlert"] as const,
        name: "hasAlert",
        constraints: { required: true },
        label: "Has Alert",
        get: () => data.hasAlert,
        set: (value: boolean) => {
          data.hasAlert = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.hasAlert,
        setError: (value: Option<Array<string>>) => {
          errors.hasAlert = value;
        },
        getTainted: () => tainted.hasAlert,
        setTainted: (value: Option<boolean>) => {
          tainted.hasAlert = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("hasAlert", data.hasAlert);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      salesRep: {
        path: ["salesRep"] as const,
        name: "salesRep",
        constraints: { required: true },
        label: "Sales Rep",
        get: () => data.salesRep,
        set: (value: Represents[] | null) => {
          data.salesRep = value;
        },
        transform: (value: Represents[] | null): Represents[] | null => value,
        getError: () => errors.salesRep,
        setError: (value: Option<Array<string>>) => {
          errors.salesRep = value;
        },
        getTainted: () => tainted.salesRep,
        setTainted: (value: Option<boolean>) => {
          tainted.salesRep = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("salesRep", data.salesRep);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      color: {
        path: ["color"] as const,
        name: "color",
        constraints: { required: true },

        get: () => data.color,
        set: (value: string | null) => {
          data.color = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.color,
        setError: (value: Option<Array<string>>) => {
          errors.color = value;
        },
        getTainted: () => tainted.color,
        setTainted: (value: Option<boolean>) => {
          tainted.color = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("color", data.color);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      accountType: {
        path: ["accountType"] as const,
        name: "accountType",
        constraints: { required: true },
        label: "Account Type",
        get: () => data.accountType,
        set: (value: string) => {
          data.accountType = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.accountType,
        setError: (value: Option<Array<string>>) => {
          errors.accountType = value;
        },
        getTainted: () => tainted.accountType,
        setTainted: (value: Option<boolean>) => {
          tainted.accountType = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField(
            "accountType",
            data.accountType,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      subtype: {
        path: ["subtype"] as const,
        name: "subtype",
        constraints: { required: true },
        label: "Subtype",
        get: () => data.subtype,
        set: (value: string) => {
          data.subtype = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.subtype,
        setError: (value: Option<Array<string>>) => {
          errors.subtype = value;
        },
        getTainted: () => tainted.subtype,
        setTainted: (value: Option<boolean>) => {
          tainted.subtype = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("subtype", data.subtype);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      isTaxExempt: {
        path: ["isTaxExempt"] as const,
        name: "isTaxExempt",
        constraints: { required: true },
        label: "Tax Exempt",
        get: () => data.isTaxExempt,
        set: (value: boolean) => {
          data.isTaxExempt = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.isTaxExempt,
        setError: (value: Option<Array<string>>) => {
          errors.isTaxExempt = value;
        },
        getTainted: () => tainted.isTaxExempt,
        setTainted: (value: Option<boolean>) => {
          tainted.isTaxExempt = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField(
            "isTaxExempt",
            data.isTaxExempt,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      paymentTerms: {
        path: ["paymentTerms"] as const,
        name: "paymentTerms",
        constraints: { required: true },
        label: "Payment Terms",
        get: () => data.paymentTerms,
        set: (value: string) => {
          data.paymentTerms = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.paymentTerms,
        setError: (value: Option<Array<string>>) => {
          errors.paymentTerms = value;
        },
        getTainted: () => tainted.paymentTerms,
        setTainted: (value: Option<boolean>) => {
          tainted.paymentTerms = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField(
            "paymentTerms",
            data.paymentTerms,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      tags: {
        path: ["tags"] as const,
        name: "tags",
        constraints: { required: true },
        label: "Tags",
        get: () => data.tags,
        set: (value: string[]) => {
          data.tags = value;
        },
        transform: (value: string[]): string[] => value,
        getError: () => errors.tags,
        setError: (value: Option<Array<string>>) => {
          errors.tags = value;
        },
        getTainted: () => tainted.tags,
        setTainted: (value: Option<boolean>) => {
          tainted.tags = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField("tags", data.tags);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["tags", index] as const,
          name: `tags.${index}`,
          constraints: { required: true },
          get: () => data.tags[index]!,
          set: (value: string) => {
            data.tags[index] = value;
          },
          transform: (value: string): string => value,
          getError: () => errors.tags,
          setError: (value: Option<Array<string>>) => {
            errors.tags = value;
          },
          getTainted: () => tainted.tags,
          setTainted: (value: Option<boolean>) => {
            tainted.tags = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.tags.push(item);
        },
        remove: (index: number) => {
          data.tags.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.tags[a]!;
          data.tags[a] = data.tags[b]!;
          data.tags[b] = tmp;
        },
      },
      customFields: {
        path: ["customFields"] as const,
        name: "customFields",
        constraints: { required: true },

        get: () => data.customFields,
        set: (value: [string, string][]) => {
          data.customFields = value;
        },
        transform: (value: [string, string][]): [string, string][] => value,
        getError: () => errors.customFields,
        setError: (value: Option<Array<string>>) => {
          errors.customFields = value;
        },
        getTainted: () => tainted.customFields,
        setTainted: (value: Option<boolean>) => {
          tainted.customFields = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Lead.validateField(
            "customFields",
            data.customFields,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["customFields", index] as const,
          name: `customFields.${index}`,
          constraints: { required: true },
          get: () => data.customFields[index]!,
          set: (value: [string, string]) => {
            data.customFields[index] = value;
          },
          transform: (value: [string, string]): [string, string] => value,
          getError: () => errors.customFields,
          setError: (value: Option<Array<string>>) => {
            errors.customFields = value;
          },
          getTainted: () => tainted.customFields,
          setTainted: (value: Option<boolean>) => {
            tainted.customFields = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: [string, string]) => {
          data.customFields.push(item);
        },
        remove: (index: number) => {
          data.customFields.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.customFields[a]!;
          data.customFields[a] = data.customFields[b]!;
          data.customFields[b] = tmp;
        },
      },
    };
    function validate(): Result<
      Lead,
      Array<{ field: string; message: string }>
    > {
      return Lead.fromObject(data);
    }
    function reset(newOverrides?: Partial<Lead>): void {
      data = { ...Lead.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        number: Option.none(),
        accepted: Option.none(),
        probability: Option.none(),
        priority: Option.none(),
        dueDate: Option.none(),
        closeDate: Option.none(),
        value: Option.none(),
        stage: Option.none(),
        status: Option.none(),
        description: Option.none(),
        nextStep: Option.none(),
        favorite: Option.none(),
        dateAdded: Option.none(),
        taxRate: Option.none(),
        sector: Option.none(),
        leadName: Option.none(),
        phones: Option.none(),
        email: Option.none(),
        leadSource: Option.none(),
        site: Option.none(),
        memo: Option.none(),
        needsReview: Option.none(),
        hasAlert: Option.none(),
        salesRep: Option.none(),
        color: Option.none(),
        accountType: Option.none(),
        subtype: Option.none(),
        isTaxExempt: Option.none(),
        paymentTerms: Option.none(),
        tags: Option.none(),
        customFields: Option.none(),
      };
      tainted = {
        id: Option.none(),
        number: Option.none(),
        accepted: Option.none(),
        probability: Option.none(),
        priority: Option.none(),
        dueDate: Option.none(),
        closeDate: Option.none(),
        value: Option.none(),
        stage: Option.none(),
        status: Option.none(),
        description: Option.none(),
        nextStep: Option.none(),
        favorite: Option.none(),
        dateAdded: Option.none(),
        taxRate: Option.none(),
        sector: Option.none(),
        leadName: Option.none(),
        phones: Option.none(),
        email: Option.none(),
        leadSource: Option.none(),
        site: Option.none(),
        memo: Option.none(),
        needsReview: Option.none(),
        hasAlert: Option.none(),
        salesRep: Option.none(),
        color: Option.none(),
        accountType: Option.none(),
        subtype: Option.none(),
        isTaxExempt: Option.none(),
        paymentTerms: Option.none(),
        tags: Option.none(),
        customFields: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Lead, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    {
      const numberStr = formData.get("number");
      obj.number = numberStr ? parseFloat(numberStr as string) : 0;
      if (obj.number !== undefined && isNaN(obj.number as number))
        obj.number = 0;
    }
    {
      const acceptedVal = formData.get("accepted");
      obj.accepted =
        acceptedVal === "true" || acceptedVal === "on" || acceptedVal === "1";
    }
    {
      const probabilityStr = formData.get("probability");
      obj.probability = probabilityStr
        ? parseFloat(probabilityStr as string)
        : 0;
      if (obj.probability !== undefined && isNaN(obj.probability as number))
        obj.probability = 0;
    }
    {
      // Collect nested object fields with prefix "priority."
      const priorityObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("priority.")) {
          const fieldName = key.slice("priority.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = priorityObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.priority = priorityObj;
    }
    obj.dueDate = formData.get("dueDate") ?? "";
    obj.closeDate = formData.get("closeDate") ?? "";
    {
      const valueStr = formData.get("value");
      obj.value = valueStr ? parseFloat(valueStr as string) : 0;
      if (obj.value !== undefined && isNaN(obj.value as number)) obj.value = 0;
    }
    {
      // Collect nested object fields with prefix "stage."
      const stageObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("stage.")) {
          const fieldName = key.slice("stage.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = stageObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.stage = stageObj;
    }
    obj.status = formData.get("status") ?? "";
    obj.description = formData.get("description") ?? "";
    {
      // Collect nested object fields with prefix "nextStep."
      const nextStepObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("nextStep.")) {
          const fieldName = key.slice("nextStep.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = nextStepObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.nextStep = nextStepObj;
    }
    {
      const favoriteVal = formData.get("favorite");
      obj.favorite =
        favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1";
    }
    obj.dateAdded = formData.get("dateAdded") ?? "";
    obj.taxRate = formData.get("taxRate") ?? "";
    {
      // Collect nested object fields with prefix "sector."
      const sectorObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("sector.")) {
          const fieldName = key.slice("sector.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = sectorObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.sector = sectorObj;
    }
    {
      // Collect nested object fields with prefix "leadName."
      const leadNameObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("leadName.")) {
          const fieldName = key.slice("leadName.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = leadNameObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.leadName = leadNameObj;
    }
    {
      // Collect array items from indexed form fields
      const phonesItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("phones." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("phones." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("phones." + idx + ".")) {
              const fieldName = key.slice(
                "phones.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          phonesItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.phones = phonesItems;
    }
    {
      // Collect nested object fields with prefix "email."
      const emailObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("email.")) {
          const fieldName = key.slice("email.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = emailObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.email = emailObj;
    }
    obj.leadSource = formData.get("leadSource") ?? "";
    obj.site = formData.get("site") ?? "";
    obj.memo = formData.get("memo") ?? "";
    {
      const needsReviewVal = formData.get("needsReview");
      obj.needsReview =
        needsReviewVal === "true" ||
        needsReviewVal === "on" ||
        needsReviewVal === "1";
    }
    {
      const hasAlertVal = formData.get("hasAlert");
      obj.hasAlert =
        hasAlertVal === "true" || hasAlertVal === "on" || hasAlertVal === "1";
    }
    obj.salesRep = formData.get("salesRep") ?? "";
    obj.color = formData.get("color") ?? "";
    obj.accountType = formData.get("accountType") ?? "";
    obj.subtype = formData.get("subtype") ?? "";
    {
      const isTaxExemptVal = formData.get("isTaxExempt");
      obj.isTaxExempt =
        isTaxExemptVal === "true" ||
        isTaxExemptVal === "on" ||
        isTaxExemptVal === "1";
    }
    obj.paymentTerms = formData.get("paymentTerms") ?? "";
    obj.tags = formData.getAll("tags") as Array<string>;
    {
      // Collect array items from indexed form fields
      const customFieldsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("customFields." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("customFields." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("customFields." + idx + ".")) {
              const fieldName = key.slice(
                "customFields.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          customFieldsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.customFields = customFieldsItems;
    }
    return Lead.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface AppPermissions {
  applications: Applications[];
  pages: Page[];
  data: Table[];
}

export function defaultValueAppPermissions(): AppPermissions {
  return { applications: [], pages: [], data: [] } as AppPermissions;
}

export function toStringifiedJSONAppPermissions(value: AppPermissions): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeAppPermissions(value, ctx));
}
export function toObjectAppPermissions(
  value: AppPermissions,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeAppPermissions(value, ctx);
}
export function __serializeAppPermissions(
  value: AppPermissions,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "AppPermissions", __id };
  result["applications"] = value.applications.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["pages"] = value.pages.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["data"] = value.data.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  return result;
}

export function fromStringifiedJSONAppPermissions(
  json: string,
  opts?: DeserializeOptions,
): Result<AppPermissions, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectAppPermissions(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectAppPermissions(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<AppPermissions, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeAppPermissions(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "AppPermissions.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeAppPermissions(
  value: any,
  ctx: DeserializeContext,
): AppPermissions | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "AppPermissions.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("applications" in obj)) {
    errors.push({ field: "applications", message: "missing required field" });
  }
  if (!("pages" in obj)) {
    errors.push({ field: "pages", message: "missing required field" });
  }
  if (!("data" in obj)) {
    errors.push({ field: "data", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_applications = obj["applications"] as Applications[];
    if (Array.isArray(__raw_applications)) {
      instance.applications = __raw_applications as Applications[];
    }
  }
  {
    const __raw_pages = obj["pages"] as Page[];
    if (Array.isArray(__raw_pages)) {
      instance.pages = __raw_pages as Page[];
    }
  }
  {
    const __raw_data = obj["data"] as Table[];
    if (Array.isArray(__raw_data)) {
      instance.data = __raw_data as Table[];
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as AppPermissions;
}
export function validateFieldAppPermissions<K extends keyof AppPermissions>(
  field: K,
  value: AppPermissions[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsAppPermissions(
  partial: Partial<AppPermissions>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isAppPermissions(obj: unknown): obj is AppPermissions {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "applications" in o && "pages" in o && "data" in o;
}

export namespace AppPermissions {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    applications: Option<Array<string>>;
    pages: Option<Array<string>>;
    data: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      applications: Option<boolean>;
      pages: Option<boolean>;
      data: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly applications: ArrayFieldController<Applications>;
    readonly pages: ArrayFieldController<Page>;
    readonly data: ArrayFieldController<Table>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: AppPermissions;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      AppPermissions,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<AppPermissions>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<AppPermissions>,
  ): Gigaform {
    let data = $state({ ...AppPermissions.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      applications: Option.none(),
      pages: Option.none(),
      data: Option.none(),
    });
    let tainted = $state<Tainted>({
      applications: Option.none(),
      pages: Option.none(),
      data: Option.none(),
    });
    const fields: FieldControllers = {
      applications: {
        path: ["applications"] as const,
        name: "applications",
        constraints: { required: true },

        get: () => data.applications,
        set: (value: Applications[]) => {
          data.applications = value;
        },
        transform: (value: Applications[]): Applications[] => value,
        getError: () => errors.applications,
        setError: (value: Option<Array<string>>) => {
          errors.applications = value;
        },
        getTainted: () => tainted.applications,
        setTainted: (value: Option<boolean>) => {
          tainted.applications = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = AppPermissions.validateField(
            "applications",
            data.applications,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["applications", index] as const,
          name: `applications.${index}`,
          constraints: { required: true },
          get: () => data.applications[index]!,
          set: (value: Applications) => {
            data.applications[index] = value;
          },
          transform: (value: Applications): Applications => value,
          getError: () => errors.applications,
          setError: (value: Option<Array<string>>) => {
            errors.applications = value;
          },
          getTainted: () => tainted.applications,
          setTainted: (value: Option<boolean>) => {
            tainted.applications = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: Applications) => {
          data.applications.push(item);
        },
        remove: (index: number) => {
          data.applications.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.applications[a]!;
          data.applications[a] = data.applications[b]!;
          data.applications[b] = tmp;
        },
      },
      pages: {
        path: ["pages"] as const,
        name: "pages",
        constraints: { required: true },

        get: () => data.pages,
        set: (value: Page[]) => {
          data.pages = value;
        },
        transform: (value: Page[]): Page[] => value,
        getError: () => errors.pages,
        setError: (value: Option<Array<string>>) => {
          errors.pages = value;
        },
        getTainted: () => tainted.pages,
        setTainted: (value: Option<boolean>) => {
          tainted.pages = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = AppPermissions.validateField("pages", data.pages);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["pages", index] as const,
          name: `pages.${index}`,
          constraints: { required: true },
          get: () => data.pages[index]!,
          set: (value: Page) => {
            data.pages[index] = value;
          },
          transform: (value: Page): Page => value,
          getError: () => errors.pages,
          setError: (value: Option<Array<string>>) => {
            errors.pages = value;
          },
          getTainted: () => tainted.pages,
          setTainted: (value: Option<boolean>) => {
            tainted.pages = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: Page) => {
          data.pages.push(item);
        },
        remove: (index: number) => {
          data.pages.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.pages[a]!;
          data.pages[a] = data.pages[b]!;
          data.pages[b] = tmp;
        },
      },
      data: {
        path: ["data"] as const,
        name: "data",
        constraints: { required: true },

        get: () => data.data,
        set: (value: Table[]) => {
          data.data = value;
        },
        transform: (value: Table[]): Table[] => value,
        getError: () => errors.data,
        setError: (value: Option<Array<string>>) => {
          errors.data = value;
        },
        getTainted: () => tainted.data,
        setTainted: (value: Option<boolean>) => {
          tainted.data = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = AppPermissions.validateField("data", data.data);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["data", index] as const,
          name: `data.${index}`,
          constraints: { required: true },
          get: () => data.data[index]!,
          set: (value: Table) => {
            data.data[index] = value;
          },
          transform: (value: Table): Table => value,
          getError: () => errors.data,
          setError: (value: Option<Array<string>>) => {
            errors.data = value;
          },
          getTainted: () => tainted.data,
          setTainted: (value: Option<boolean>) => {
            tainted.data = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: Table) => {
          data.data.push(item);
        },
        remove: (index: number) => {
          data.data.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.data[a]!;
          data.data[a] = data.data[b]!;
          data.data[b] = tmp;
        },
      },
    };
    function validate(): Result<
      AppPermissions,
      Array<{ field: string; message: string }>
    > {
      return AppPermissions.fromObject(data);
    }
    function reset(newOverrides?: Partial<AppPermissions>): void {
      data = { ...AppPermissions.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        applications: Option.none(),
        pages: Option.none(),
        data: Option.none(),
      };
      tainted = {
        applications: Option.none(),
        pages: Option.none(),
        data: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<AppPermissions, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect array items from indexed form fields
      const applicationsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("applications." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("applications." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("applications." + idx + ".")) {
              const fieldName = key.slice(
                "applications.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          applicationsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.applications = applicationsItems;
    }
    {
      // Collect array items from indexed form fields
      const pagesItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("pages." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("pages." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("pages." + idx + ".")) {
              const fieldName = key.slice(
                "pages.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          pagesItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.pages = pagesItems;
    }
    {
      // Collect array items from indexed form fields
      const dataItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("data." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("data." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("data." + idx + ".")) {
              const fieldName = key.slice(
                "data.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          dataItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.data = dataItems;
    }
    return AppPermissions.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Company {
  id: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  legalName: string;
  /** @default("") */
  headquarters: string | Site;
  phones: PhoneNumber[];
  /** @serde({ validate: ["nonEmpty"] }) */
  fax: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  email: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  website: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  taxId: string;
  referenceNumber: number;
  /** @serde({ validate: ["nonEmpty"] }) */
  postalCodeLookup: string;
  timeZone: string;
  /** @default("") */
  defaultTax: string | TaxRate;
  /** @serde({ validate: ["nonEmpty"] }) */
  defaultTaxLocation: string;
  defaultAreaCode: number;
  /** @serde({ validate: ["nonEmpty"] }) */
  defaultAccountType: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  lookupFormatting: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  accountNameFormat: string;
  merchantServiceProvider: string | null;
  /** @serde({ validate: ["nonEmpty"] }) */
  dateDisplayStyle: string;
  hasAutoCommission: boolean;
  hasAutoDaylightSavings: boolean;
  hasAutoFmsTracking: boolean;
  hasNotifications: boolean;
  hasRequiredLeadSource: boolean;
  hasRequiredEmail: boolean;
  hasSortServiceItemsAlphabetically: boolean;
  hasAttachOrderToAppointmentEmails: boolean;
  scheduleInterval: number;
  colorsConfig: ColorsConfig;
}

export function defaultValueCompany(): Company {
  return {
    id: "",
    legalName: "",
    headquarters: "",
    phones: [],
    fax: "",
    email: "",
    website: "",
    taxId: "",
    referenceNumber: 0,
    postalCodeLookup: "",
    timeZone: "",
    defaultTax: "",
    defaultTaxLocation: "",
    defaultAreaCode: 0,
    defaultAccountType: "",
    lookupFormatting: "",
    accountNameFormat: "",
    merchantServiceProvider: null,
    dateDisplayStyle: "",
    hasAutoCommission: false,
    hasAutoDaylightSavings: false,
    hasAutoFmsTracking: false,
    hasNotifications: false,
    hasRequiredLeadSource: false,
    hasRequiredEmail: false,
    hasSortServiceItemsAlphabetically: false,
    hasAttachOrderToAppointmentEmails: false,
    scheduleInterval: 0,
    colorsConfig: ColorsConfig.defaultValue(),
  } as Company;
}

export function toStringifiedJSONCompany(value: Company): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeCompany(value, ctx));
}
export function toObjectCompany(value: Company): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeCompany(value, ctx);
}
export function __serializeCompany(
  value: Company,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Company", __id };
  result["id"] = value.id;
  result["legalName"] = value.legalName;
  result["headquarters"] = value.headquarters;
  result["phones"] = value.phones.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["fax"] = value.fax;
  result["email"] = value.email;
  result["website"] = value.website;
  result["taxId"] = value.taxId;
  result["referenceNumber"] = value.referenceNumber;
  result["postalCodeLookup"] = value.postalCodeLookup;
  result["timeZone"] = value.timeZone;
  result["defaultTax"] = value.defaultTax;
  result["defaultTaxLocation"] = value.defaultTaxLocation;
  result["defaultAreaCode"] = value.defaultAreaCode;
  result["defaultAccountType"] = value.defaultAccountType;
  result["lookupFormatting"] = value.lookupFormatting;
  result["accountNameFormat"] = value.accountNameFormat;
  if (value.merchantServiceProvider !== null) {
    result["merchantServiceProvider"] =
      typeof (value.merchantServiceProvider as any)?.__serialize === "function"
        ? (value.merchantServiceProvider as any).__serialize(ctx)
        : value.merchantServiceProvider;
  } else {
    result["merchantServiceProvider"] = null;
  }
  result["dateDisplayStyle"] = value.dateDisplayStyle;
  result["hasAutoCommission"] = value.hasAutoCommission;
  result["hasAutoDaylightSavings"] = value.hasAutoDaylightSavings;
  result["hasAutoFmsTracking"] = value.hasAutoFmsTracking;
  result["hasNotifications"] = value.hasNotifications;
  result["hasRequiredLeadSource"] = value.hasRequiredLeadSource;
  result["hasRequiredEmail"] = value.hasRequiredEmail;
  result["hasSortServiceItemsAlphabetically"] =
    value.hasSortServiceItemsAlphabetically;
  result["hasAttachOrderToAppointmentEmails"] =
    value.hasAttachOrderToAppointmentEmails;
  result["scheduleInterval"] = value.scheduleInterval;
  result["colorsConfig"] =
    typeof (value.colorsConfig as any)?.__serialize === "function"
      ? (value.colorsConfig as any).__serialize(ctx)
      : value.colorsConfig;
  return result;
}

export function fromStringifiedJSONCompany(
  json: string,
  opts?: DeserializeOptions,
): Result<Company, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectCompany(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectCompany(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Company, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeCompany(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Company.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeCompany(
  value: any,
  ctx: DeserializeContext,
): Company | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Company.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("legalName" in obj)) {
    errors.push({ field: "legalName", message: "missing required field" });
  }
  if (!("headquarters" in obj)) {
    errors.push({ field: "headquarters", message: "missing required field" });
  }
  if (!("phones" in obj)) {
    errors.push({ field: "phones", message: "missing required field" });
  }
  if (!("fax" in obj)) {
    errors.push({ field: "fax", message: "missing required field" });
  }
  if (!("email" in obj)) {
    errors.push({ field: "email", message: "missing required field" });
  }
  if (!("website" in obj)) {
    errors.push({ field: "website", message: "missing required field" });
  }
  if (!("taxId" in obj)) {
    errors.push({ field: "taxId", message: "missing required field" });
  }
  if (!("referenceNumber" in obj)) {
    errors.push({
      field: "referenceNumber",
      message: "missing required field",
    });
  }
  if (!("postalCodeLookup" in obj)) {
    errors.push({
      field: "postalCodeLookup",
      message: "missing required field",
    });
  }
  if (!("timeZone" in obj)) {
    errors.push({ field: "timeZone", message: "missing required field" });
  }
  if (!("defaultTax" in obj)) {
    errors.push({ field: "defaultTax", message: "missing required field" });
  }
  if (!("defaultTaxLocation" in obj)) {
    errors.push({
      field: "defaultTaxLocation",
      message: "missing required field",
    });
  }
  if (!("defaultAreaCode" in obj)) {
    errors.push({
      field: "defaultAreaCode",
      message: "missing required field",
    });
  }
  if (!("defaultAccountType" in obj)) {
    errors.push({
      field: "defaultAccountType",
      message: "missing required field",
    });
  }
  if (!("lookupFormatting" in obj)) {
    errors.push({
      field: "lookupFormatting",
      message: "missing required field",
    });
  }
  if (!("accountNameFormat" in obj)) {
    errors.push({
      field: "accountNameFormat",
      message: "missing required field",
    });
  }
  if (!("merchantServiceProvider" in obj)) {
    errors.push({
      field: "merchantServiceProvider",
      message: "missing required field",
    });
  }
  if (!("dateDisplayStyle" in obj)) {
    errors.push({
      field: "dateDisplayStyle",
      message: "missing required field",
    });
  }
  if (!("hasAutoCommission" in obj)) {
    errors.push({
      field: "hasAutoCommission",
      message: "missing required field",
    });
  }
  if (!("hasAutoDaylightSavings" in obj)) {
    errors.push({
      field: "hasAutoDaylightSavings",
      message: "missing required field",
    });
  }
  if (!("hasAutoFmsTracking" in obj)) {
    errors.push({
      field: "hasAutoFmsTracking",
      message: "missing required field",
    });
  }
  if (!("hasNotifications" in obj)) {
    errors.push({
      field: "hasNotifications",
      message: "missing required field",
    });
  }
  if (!("hasRequiredLeadSource" in obj)) {
    errors.push({
      field: "hasRequiredLeadSource",
      message: "missing required field",
    });
  }
  if (!("hasRequiredEmail" in obj)) {
    errors.push({
      field: "hasRequiredEmail",
      message: "missing required field",
    });
  }
  if (!("hasSortServiceItemsAlphabetically" in obj)) {
    errors.push({
      field: "hasSortServiceItemsAlphabetically",
      message: "missing required field",
    });
  }
  if (!("hasAttachOrderToAppointmentEmails" in obj)) {
    errors.push({
      field: "hasAttachOrderToAppointmentEmails",
      message: "missing required field",
    });
  }
  if (!("scheduleInterval" in obj)) {
    errors.push({
      field: "scheduleInterval",
      message: "missing required field",
    });
  }
  if (!("colorsConfig" in obj)) {
    errors.push({ field: "colorsConfig", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_legalName = obj["legalName"] as string;
    if (__raw_legalName.length === 0) {
      errors.push({ field: "legalName", message: "must not be empty" });
    }
    instance.legalName = __raw_legalName;
  }
  {
    const __raw_headquarters = obj["headquarters"] as string | Site;
    instance.headquarters = __raw_headquarters;
  }
  {
    const __raw_phones = obj["phones"] as PhoneNumber[];
    if (Array.isArray(__raw_phones)) {
      instance.phones = __raw_phones as PhoneNumber[];
    }
  }
  {
    const __raw_fax = obj["fax"] as string;
    if (__raw_fax.length === 0) {
      errors.push({ field: "fax", message: "must not be empty" });
    }
    instance.fax = __raw_fax;
  }
  {
    const __raw_email = obj["email"] as string;
    if (__raw_email.length === 0) {
      errors.push({ field: "email", message: "must not be empty" });
    }
    instance.email = __raw_email;
  }
  {
    const __raw_website = obj["website"] as string;
    if (__raw_website.length === 0) {
      errors.push({ field: "website", message: "must not be empty" });
    }
    instance.website = __raw_website;
  }
  {
    const __raw_taxId = obj["taxId"] as string;
    if (__raw_taxId.length === 0) {
      errors.push({ field: "taxId", message: "must not be empty" });
    }
    instance.taxId = __raw_taxId;
  }
  {
    const __raw_referenceNumber = obj["referenceNumber"] as number;
    instance.referenceNumber = __raw_referenceNumber;
  }
  {
    const __raw_postalCodeLookup = obj["postalCodeLookup"] as string;
    if (__raw_postalCodeLookup.length === 0) {
      errors.push({ field: "postalCodeLookup", message: "must not be empty" });
    }
    instance.postalCodeLookup = __raw_postalCodeLookup;
  }
  {
    const __raw_timeZone = obj["timeZone"] as string;
    instance.timeZone = __raw_timeZone;
  }
  {
    const __raw_defaultTax = obj["defaultTax"] as string | TaxRate;
    instance.defaultTax = __raw_defaultTax;
  }
  {
    const __raw_defaultTaxLocation = obj["defaultTaxLocation"] as string;
    if (__raw_defaultTaxLocation.length === 0) {
      errors.push({
        field: "defaultTaxLocation",
        message: "must not be empty",
      });
    }
    instance.defaultTaxLocation = __raw_defaultTaxLocation;
  }
  {
    const __raw_defaultAreaCode = obj["defaultAreaCode"] as number;
    instance.defaultAreaCode = __raw_defaultAreaCode;
  }
  {
    const __raw_defaultAccountType = obj["defaultAccountType"] as string;
    if (__raw_defaultAccountType.length === 0) {
      errors.push({
        field: "defaultAccountType",
        message: "must not be empty",
      });
    }
    instance.defaultAccountType = __raw_defaultAccountType;
  }
  {
    const __raw_lookupFormatting = obj["lookupFormatting"] as string;
    if (__raw_lookupFormatting.length === 0) {
      errors.push({ field: "lookupFormatting", message: "must not be empty" });
    }
    instance.lookupFormatting = __raw_lookupFormatting;
  }
  {
    const __raw_accountNameFormat = obj["accountNameFormat"] as string;
    if (__raw_accountNameFormat.length === 0) {
      errors.push({ field: "accountNameFormat", message: "must not be empty" });
    }
    instance.accountNameFormat = __raw_accountNameFormat;
  }
  {
    const __raw_merchantServiceProvider = obj["merchantServiceProvider"] as
      | string
      | null;
    if (__raw_merchantServiceProvider === null) {
      instance.merchantServiceProvider = null;
    } else if (
      typeof (__raw_merchantServiceProvider as any)?.__ref !== "undefined"
    ) {
      const __result = ctx.getOrDefer(
        (__raw_merchantServiceProvider as any).__ref,
      );
      ctx.assignOrDefer(instance, "merchantServiceProvider", __result);
    } else {
      instance.merchantServiceProvider = __raw_merchantServiceProvider;
    }
  }
  {
    const __raw_dateDisplayStyle = obj["dateDisplayStyle"] as string;
    if (__raw_dateDisplayStyle.length === 0) {
      errors.push({ field: "dateDisplayStyle", message: "must not be empty" });
    }
    instance.dateDisplayStyle = __raw_dateDisplayStyle;
  }
  {
    const __raw_hasAutoCommission = obj["hasAutoCommission"] as boolean;
    instance.hasAutoCommission = __raw_hasAutoCommission;
  }
  {
    const __raw_hasAutoDaylightSavings = obj[
      "hasAutoDaylightSavings"
    ] as boolean;
    instance.hasAutoDaylightSavings = __raw_hasAutoDaylightSavings;
  }
  {
    const __raw_hasAutoFmsTracking = obj["hasAutoFmsTracking"] as boolean;
    instance.hasAutoFmsTracking = __raw_hasAutoFmsTracking;
  }
  {
    const __raw_hasNotifications = obj["hasNotifications"] as boolean;
    instance.hasNotifications = __raw_hasNotifications;
  }
  {
    const __raw_hasRequiredLeadSource = obj["hasRequiredLeadSource"] as boolean;
    instance.hasRequiredLeadSource = __raw_hasRequiredLeadSource;
  }
  {
    const __raw_hasRequiredEmail = obj["hasRequiredEmail"] as boolean;
    instance.hasRequiredEmail = __raw_hasRequiredEmail;
  }
  {
    const __raw_hasSortServiceItemsAlphabetically = obj[
      "hasSortServiceItemsAlphabetically"
    ] as boolean;
    instance.hasSortServiceItemsAlphabetically =
      __raw_hasSortServiceItemsAlphabetically;
  }
  {
    const __raw_hasAttachOrderToAppointmentEmails = obj[
      "hasAttachOrderToAppointmentEmails"
    ] as boolean;
    instance.hasAttachOrderToAppointmentEmails =
      __raw_hasAttachOrderToAppointmentEmails;
  }
  {
    const __raw_scheduleInterval = obj["scheduleInterval"] as number;
    instance.scheduleInterval = __raw_scheduleInterval;
  }
  {
    const __raw_colorsConfig = obj["colorsConfig"] as ColorsConfig;
    if (typeof (ColorsConfig as any)?.__deserialize === "function") {
      const __result = (ColorsConfig as any).__deserialize(
        __raw_colorsConfig,
        ctx,
      );
      ctx.assignOrDefer(instance, "colorsConfig", __result);
    } else {
      instance.colorsConfig = __raw_colorsConfig;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Company;
}
export function validateFieldCompany<K extends keyof Company>(
  field: K,
  value: Company[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "legalName": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "legalName", message: "must not be empty" });
      }
      break;
    }
    case "fax": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "fax", message: "must not be empty" });
      }
      break;
    }
    case "email": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "email", message: "must not be empty" });
      }
      break;
    }
    case "website": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "website", message: "must not be empty" });
      }
      break;
    }
    case "taxId": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "taxId", message: "must not be empty" });
      }
      break;
    }
    case "postalCodeLookup": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({
          field: "postalCodeLookup",
          message: "must not be empty",
        });
      }
      break;
    }
    case "defaultTaxLocation": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({
          field: "defaultTaxLocation",
          message: "must not be empty",
        });
      }
      break;
    }
    case "defaultAccountType": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({
          field: "defaultAccountType",
          message: "must not be empty",
        });
      }
      break;
    }
    case "lookupFormatting": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({
          field: "lookupFormatting",
          message: "must not be empty",
        });
      }
      break;
    }
    case "accountNameFormat": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({
          field: "accountNameFormat",
          message: "must not be empty",
        });
      }
      break;
    }
    case "dateDisplayStyle": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({
          field: "dateDisplayStyle",
          message: "must not be empty",
        });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsCompany(
  partial: Partial<Company>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("legalName" in partial && partial.legalName !== undefined) {
    const __val = partial.legalName as string;
    if (__val.length === 0) {
      errors.push({ field: "legalName", message: "must not be empty" });
    }
  }
  if ("fax" in partial && partial.fax !== undefined) {
    const __val = partial.fax as string;
    if (__val.length === 0) {
      errors.push({ field: "fax", message: "must not be empty" });
    }
  }
  if ("email" in partial && partial.email !== undefined) {
    const __val = partial.email as string;
    if (__val.length === 0) {
      errors.push({ field: "email", message: "must not be empty" });
    }
  }
  if ("website" in partial && partial.website !== undefined) {
    const __val = partial.website as string;
    if (__val.length === 0) {
      errors.push({ field: "website", message: "must not be empty" });
    }
  }
  if ("taxId" in partial && partial.taxId !== undefined) {
    const __val = partial.taxId as string;
    if (__val.length === 0) {
      errors.push({ field: "taxId", message: "must not be empty" });
    }
  }
  if ("postalCodeLookup" in partial && partial.postalCodeLookup !== undefined) {
    const __val = partial.postalCodeLookup as string;
    if (__val.length === 0) {
      errors.push({ field: "postalCodeLookup", message: "must not be empty" });
    }
  }
  if (
    "defaultTaxLocation" in partial &&
    partial.defaultTaxLocation !== undefined
  ) {
    const __val = partial.defaultTaxLocation as string;
    if (__val.length === 0) {
      errors.push({
        field: "defaultTaxLocation",
        message: "must not be empty",
      });
    }
  }
  if (
    "defaultAccountType" in partial &&
    partial.defaultAccountType !== undefined
  ) {
    const __val = partial.defaultAccountType as string;
    if (__val.length === 0) {
      errors.push({
        field: "defaultAccountType",
        message: "must not be empty",
      });
    }
  }
  if ("lookupFormatting" in partial && partial.lookupFormatting !== undefined) {
    const __val = partial.lookupFormatting as string;
    if (__val.length === 0) {
      errors.push({ field: "lookupFormatting", message: "must not be empty" });
    }
  }
  if (
    "accountNameFormat" in partial &&
    partial.accountNameFormat !== undefined
  ) {
    const __val = partial.accountNameFormat as string;
    if (__val.length === 0) {
      errors.push({ field: "accountNameFormat", message: "must not be empty" });
    }
  }
  if ("dateDisplayStyle" in partial && partial.dateDisplayStyle !== undefined) {
    const __val = partial.dateDisplayStyle as string;
    if (__val.length === 0) {
      errors.push({ field: "dateDisplayStyle", message: "must not be empty" });
    }
  }
  return errors;
}
export function isCompany(obj: unknown): obj is Company {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "id" in o &&
    "legalName" in o &&
    "headquarters" in o &&
    "phones" in o &&
    "fax" in o &&
    "email" in o &&
    "website" in o &&
    "taxId" in o &&
    "referenceNumber" in o &&
    "postalCodeLookup" in o &&
    "timeZone" in o &&
    "defaultTax" in o &&
    "defaultTaxLocation" in o &&
    "defaultAreaCode" in o &&
    "defaultAccountType" in o &&
    "lookupFormatting" in o &&
    "accountNameFormat" in o &&
    "merchantServiceProvider" in o &&
    "dateDisplayStyle" in o &&
    "hasAutoCommission" in o &&
    "hasAutoDaylightSavings" in o &&
    "hasAutoFmsTracking" in o &&
    "hasNotifications" in o &&
    "hasRequiredLeadSource" in o &&
    "hasRequiredEmail" in o &&
    "hasSortServiceItemsAlphabetically" in o &&
    "hasAttachOrderToAppointmentEmails" in o &&
    "scheduleInterval" in o &&
    "colorsConfig" in o
  );
}

export namespace Company {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    legalName: Option<Array<string>>;
    headquarters: Option<Array<string>>;
    phones: Option<Array<string>>;
    fax: Option<Array<string>>;
    email: Option<Array<string>>;
    website: Option<Array<string>>;
    taxId: Option<Array<string>>;
    referenceNumber: Option<Array<string>>;
    postalCodeLookup: Option<Array<string>>;
    timeZone: Option<Array<string>>;
    defaultTax: Option<Array<string>>;
    defaultTaxLocation: Option<Array<string>>;
    defaultAreaCode: Option<Array<string>>;
    defaultAccountType: Option<Array<string>>;
    lookupFormatting: Option<Array<string>>;
    accountNameFormat: Option<Array<string>>;
    merchantServiceProvider: Option<Array<string>>;
    dateDisplayStyle: Option<Array<string>>;
    hasAutoCommission: Option<Array<string>>;
    hasAutoDaylightSavings: Option<Array<string>>;
    hasAutoFmsTracking: Option<Array<string>>;
    hasNotifications: Option<Array<string>>;
    hasRequiredLeadSource: Option<Array<string>>;
    hasRequiredEmail: Option<Array<string>>;
    hasSortServiceItemsAlphabetically: Option<Array<string>>;
    hasAttachOrderToAppointmentEmails: Option<Array<string>>;
    scheduleInterval: Option<Array<string>>;
    colorsConfig: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      legalName: Option<boolean>;
      headquarters: Option<boolean>;
      phones: Option<boolean>;
      fax: Option<boolean>;
      email: Option<boolean>;
      website: Option<boolean>;
      taxId: Option<boolean>;
      referenceNumber: Option<boolean>;
      postalCodeLookup: Option<boolean>;
      timeZone: Option<boolean>;
      defaultTax: Option<boolean>;
      defaultTaxLocation: Option<boolean>;
      defaultAreaCode: Option<boolean>;
      defaultAccountType: Option<boolean>;
      lookupFormatting: Option<boolean>;
      accountNameFormat: Option<boolean>;
      merchantServiceProvider: Option<boolean>;
      dateDisplayStyle: Option<boolean>;
      hasAutoCommission: Option<boolean>;
      hasAutoDaylightSavings: Option<boolean>;
      hasAutoFmsTracking: Option<boolean>;
      hasNotifications: Option<boolean>;
      hasRequiredLeadSource: Option<boolean>;
      hasRequiredEmail: Option<boolean>;
      hasSortServiceItemsAlphabetically: Option<boolean>;
      hasAttachOrderToAppointmentEmails: Option<boolean>;
      scheduleInterval: Option<boolean>;
      colorsConfig: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly legalName: FieldController<string>;
    readonly headquarters: FieldController<string | Site>;
    readonly phones: ArrayFieldController<PhoneNumber>;
    readonly fax: FieldController<string>;
    readonly email: FieldController<string>;
    readonly website: FieldController<string>;
    readonly taxId: FieldController<string>;
    readonly referenceNumber: FieldController<number>;
    readonly postalCodeLookup: FieldController<string>;
    readonly timeZone: FieldController<string>;
    readonly defaultTax: FieldController<string | TaxRate>;
    readonly defaultTaxLocation: FieldController<string>;
    readonly defaultAreaCode: FieldController<number>;
    readonly defaultAccountType: FieldController<string>;
    readonly lookupFormatting: FieldController<string>;
    readonly accountNameFormat: FieldController<string>;
    readonly merchantServiceProvider: FieldController<string | null>;
    readonly dateDisplayStyle: FieldController<string>;
    readonly hasAutoCommission: FieldController<boolean>;
    readonly hasAutoDaylightSavings: FieldController<boolean>;
    readonly hasAutoFmsTracking: FieldController<boolean>;
    readonly hasNotifications: FieldController<boolean>;
    readonly hasRequiredLeadSource: FieldController<boolean>;
    readonly hasRequiredEmail: FieldController<boolean>;
    readonly hasSortServiceItemsAlphabetically: FieldController<boolean>;
    readonly hasAttachOrderToAppointmentEmails: FieldController<boolean>;
    readonly scheduleInterval: FieldController<number>;
    readonly colorsConfig: FieldController<ColorsConfig>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Company;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Company, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Company>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Company>,
  ): Gigaform {
    let data = $state({ ...Company.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      legalName: Option.none(),
      headquarters: Option.none(),
      phones: Option.none(),
      fax: Option.none(),
      email: Option.none(),
      website: Option.none(),
      taxId: Option.none(),
      referenceNumber: Option.none(),
      postalCodeLookup: Option.none(),
      timeZone: Option.none(),
      defaultTax: Option.none(),
      defaultTaxLocation: Option.none(),
      defaultAreaCode: Option.none(),
      defaultAccountType: Option.none(),
      lookupFormatting: Option.none(),
      accountNameFormat: Option.none(),
      merchantServiceProvider: Option.none(),
      dateDisplayStyle: Option.none(),
      hasAutoCommission: Option.none(),
      hasAutoDaylightSavings: Option.none(),
      hasAutoFmsTracking: Option.none(),
      hasNotifications: Option.none(),
      hasRequiredLeadSource: Option.none(),
      hasRequiredEmail: Option.none(),
      hasSortServiceItemsAlphabetically: Option.none(),
      hasAttachOrderToAppointmentEmails: Option.none(),
      scheduleInterval: Option.none(),
      colorsConfig: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      legalName: Option.none(),
      headquarters: Option.none(),
      phones: Option.none(),
      fax: Option.none(),
      email: Option.none(),
      website: Option.none(),
      taxId: Option.none(),
      referenceNumber: Option.none(),
      postalCodeLookup: Option.none(),
      timeZone: Option.none(),
      defaultTax: Option.none(),
      defaultTaxLocation: Option.none(),
      defaultAreaCode: Option.none(),
      defaultAccountType: Option.none(),
      lookupFormatting: Option.none(),
      accountNameFormat: Option.none(),
      merchantServiceProvider: Option.none(),
      dateDisplayStyle: Option.none(),
      hasAutoCommission: Option.none(),
      hasAutoDaylightSavings: Option.none(),
      hasAutoFmsTracking: Option.none(),
      hasNotifications: Option.none(),
      hasRequiredLeadSource: Option.none(),
      hasRequiredEmail: Option.none(),
      hasSortServiceItemsAlphabetically: Option.none(),
      hasAttachOrderToAppointmentEmails: Option.none(),
      scheduleInterval: Option.none(),
      colorsConfig: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      legalName: {
        path: ["legalName"] as const,
        name: "legalName",
        constraints: { required: true },

        get: () => data.legalName,
        set: (value: string) => {
          data.legalName = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.legalName,
        setError: (value: Option<Array<string>>) => {
          errors.legalName = value;
        },
        getTainted: () => tainted.legalName,
        setTainted: (value: Option<boolean>) => {
          tainted.legalName = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "legalName",
            data.legalName,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      headquarters: {
        path: ["headquarters"] as const,
        name: "headquarters",
        constraints: { required: true },

        get: () => data.headquarters,
        set: (value: string | Site) => {
          data.headquarters = value;
        },
        transform: (value: string | Site): string | Site => value,
        getError: () => errors.headquarters,
        setError: (value: Option<Array<string>>) => {
          errors.headquarters = value;
        },
        getTainted: () => tainted.headquarters,
        setTainted: (value: Option<boolean>) => {
          tainted.headquarters = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "headquarters",
            data.headquarters,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      phones: {
        path: ["phones"] as const,
        name: "phones",
        constraints: { required: true },

        get: () => data.phones,
        set: (value: PhoneNumber[]) => {
          data.phones = value;
        },
        transform: (value: PhoneNumber[]): PhoneNumber[] => value,
        getError: () => errors.phones,
        setError: (value: Option<Array<string>>) => {
          errors.phones = value;
        },
        getTainted: () => tainted.phones,
        setTainted: (value: Option<boolean>) => {
          tainted.phones = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField("phones", data.phones);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["phones", index] as const,
          name: `phones.${index}`,
          constraints: { required: true },
          get: () => data.phones[index]!,
          set: (value: PhoneNumber) => {
            data.phones[index] = value;
          },
          transform: (value: PhoneNumber): PhoneNumber => value,
          getError: () => errors.phones,
          setError: (value: Option<Array<string>>) => {
            errors.phones = value;
          },
          getTainted: () => tainted.phones,
          setTainted: (value: Option<boolean>) => {
            tainted.phones = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: PhoneNumber) => {
          data.phones.push(item);
        },
        remove: (index: number) => {
          data.phones.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.phones[a]!;
          data.phones[a] = data.phones[b]!;
          data.phones[b] = tmp;
        },
      },
      fax: {
        path: ["fax"] as const,
        name: "fax",
        constraints: { required: true },

        get: () => data.fax,
        set: (value: string) => {
          data.fax = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.fax,
        setError: (value: Option<Array<string>>) => {
          errors.fax = value;
        },
        getTainted: () => tainted.fax,
        setTainted: (value: Option<boolean>) => {
          tainted.fax = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField("fax", data.fax);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      email: {
        path: ["email"] as const,
        name: "email",
        constraints: { required: true },

        get: () => data.email,
        set: (value: string) => {
          data.email = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.email,
        setError: (value: Option<Array<string>>) => {
          errors.email = value;
        },
        getTainted: () => tainted.email,
        setTainted: (value: Option<boolean>) => {
          tainted.email = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField("email", data.email);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      website: {
        path: ["website"] as const,
        name: "website",
        constraints: { required: true },

        get: () => data.website,
        set: (value: string) => {
          data.website = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.website,
        setError: (value: Option<Array<string>>) => {
          errors.website = value;
        },
        getTainted: () => tainted.website,
        setTainted: (value: Option<boolean>) => {
          tainted.website = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField("website", data.website);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      taxId: {
        path: ["taxId"] as const,
        name: "taxId",
        constraints: { required: true },

        get: () => data.taxId,
        set: (value: string) => {
          data.taxId = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.taxId,
        setError: (value: Option<Array<string>>) => {
          errors.taxId = value;
        },
        getTainted: () => tainted.taxId,
        setTainted: (value: Option<boolean>) => {
          tainted.taxId = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField("taxId", data.taxId);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      referenceNumber: {
        path: ["referenceNumber"] as const,
        name: "referenceNumber",
        constraints: { required: true },

        get: () => data.referenceNumber,
        set: (value: number) => {
          data.referenceNumber = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.referenceNumber,
        setError: (value: Option<Array<string>>) => {
          errors.referenceNumber = value;
        },
        getTainted: () => tainted.referenceNumber,
        setTainted: (value: Option<boolean>) => {
          tainted.referenceNumber = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "referenceNumber",
            data.referenceNumber,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      postalCodeLookup: {
        path: ["postalCodeLookup"] as const,
        name: "postalCodeLookup",
        constraints: { required: true },

        get: () => data.postalCodeLookup,
        set: (value: string) => {
          data.postalCodeLookup = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.postalCodeLookup,
        setError: (value: Option<Array<string>>) => {
          errors.postalCodeLookup = value;
        },
        getTainted: () => tainted.postalCodeLookup,
        setTainted: (value: Option<boolean>) => {
          tainted.postalCodeLookup = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "postalCodeLookup",
            data.postalCodeLookup,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      timeZone: {
        path: ["timeZone"] as const,
        name: "timeZone",
        constraints: { required: true },

        get: () => data.timeZone,
        set: (value: string) => {
          data.timeZone = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.timeZone,
        setError: (value: Option<Array<string>>) => {
          errors.timeZone = value;
        },
        getTainted: () => tainted.timeZone,
        setTainted: (value: Option<boolean>) => {
          tainted.timeZone = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField("timeZone", data.timeZone);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      defaultTax: {
        path: ["defaultTax"] as const,
        name: "defaultTax",
        constraints: { required: true },

        get: () => data.defaultTax,
        set: (value: string | TaxRate) => {
          data.defaultTax = value;
        },
        transform: (value: string | TaxRate): string | TaxRate => value,
        getError: () => errors.defaultTax,
        setError: (value: Option<Array<string>>) => {
          errors.defaultTax = value;
        },
        getTainted: () => tainted.defaultTax,
        setTainted: (value: Option<boolean>) => {
          tainted.defaultTax = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "defaultTax",
            data.defaultTax,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      defaultTaxLocation: {
        path: ["defaultTaxLocation"] as const,
        name: "defaultTaxLocation",
        constraints: { required: true },

        get: () => data.defaultTaxLocation,
        set: (value: string) => {
          data.defaultTaxLocation = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.defaultTaxLocation,
        setError: (value: Option<Array<string>>) => {
          errors.defaultTaxLocation = value;
        },
        getTainted: () => tainted.defaultTaxLocation,
        setTainted: (value: Option<boolean>) => {
          tainted.defaultTaxLocation = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "defaultTaxLocation",
            data.defaultTaxLocation,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      defaultAreaCode: {
        path: ["defaultAreaCode"] as const,
        name: "defaultAreaCode",
        constraints: { required: true },

        get: () => data.defaultAreaCode,
        set: (value: number) => {
          data.defaultAreaCode = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.defaultAreaCode,
        setError: (value: Option<Array<string>>) => {
          errors.defaultAreaCode = value;
        },
        getTainted: () => tainted.defaultAreaCode,
        setTainted: (value: Option<boolean>) => {
          tainted.defaultAreaCode = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "defaultAreaCode",
            data.defaultAreaCode,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      defaultAccountType: {
        path: ["defaultAccountType"] as const,
        name: "defaultAccountType",
        constraints: { required: true },

        get: () => data.defaultAccountType,
        set: (value: string) => {
          data.defaultAccountType = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.defaultAccountType,
        setError: (value: Option<Array<string>>) => {
          errors.defaultAccountType = value;
        },
        getTainted: () => tainted.defaultAccountType,
        setTainted: (value: Option<boolean>) => {
          tainted.defaultAccountType = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "defaultAccountType",
            data.defaultAccountType,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      lookupFormatting: {
        path: ["lookupFormatting"] as const,
        name: "lookupFormatting",
        constraints: { required: true },

        get: () => data.lookupFormatting,
        set: (value: string) => {
          data.lookupFormatting = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.lookupFormatting,
        setError: (value: Option<Array<string>>) => {
          errors.lookupFormatting = value;
        },
        getTainted: () => tainted.lookupFormatting,
        setTainted: (value: Option<boolean>) => {
          tainted.lookupFormatting = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "lookupFormatting",
            data.lookupFormatting,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      accountNameFormat: {
        path: ["accountNameFormat"] as const,
        name: "accountNameFormat",
        constraints: { required: true },

        get: () => data.accountNameFormat,
        set: (value: string) => {
          data.accountNameFormat = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.accountNameFormat,
        setError: (value: Option<Array<string>>) => {
          errors.accountNameFormat = value;
        },
        getTainted: () => tainted.accountNameFormat,
        setTainted: (value: Option<boolean>) => {
          tainted.accountNameFormat = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "accountNameFormat",
            data.accountNameFormat,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      merchantServiceProvider: {
        path: ["merchantServiceProvider"] as const,
        name: "merchantServiceProvider",
        constraints: { required: true },

        get: () => data.merchantServiceProvider,
        set: (value: string | null) => {
          data.merchantServiceProvider = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.merchantServiceProvider,
        setError: (value: Option<Array<string>>) => {
          errors.merchantServiceProvider = value;
        },
        getTainted: () => tainted.merchantServiceProvider,
        setTainted: (value: Option<boolean>) => {
          tainted.merchantServiceProvider = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "merchantServiceProvider",
            data.merchantServiceProvider,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      dateDisplayStyle: {
        path: ["dateDisplayStyle"] as const,
        name: "dateDisplayStyle",
        constraints: { required: true },

        get: () => data.dateDisplayStyle,
        set: (value: string) => {
          data.dateDisplayStyle = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.dateDisplayStyle,
        setError: (value: Option<Array<string>>) => {
          errors.dateDisplayStyle = value;
        },
        getTainted: () => tainted.dateDisplayStyle,
        setTainted: (value: Option<boolean>) => {
          tainted.dateDisplayStyle = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "dateDisplayStyle",
            data.dateDisplayStyle,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      hasAutoCommission: {
        path: ["hasAutoCommission"] as const,
        name: "hasAutoCommission",
        constraints: { required: true },

        get: () => data.hasAutoCommission,
        set: (value: boolean) => {
          data.hasAutoCommission = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.hasAutoCommission,
        setError: (value: Option<Array<string>>) => {
          errors.hasAutoCommission = value;
        },
        getTainted: () => tainted.hasAutoCommission,
        setTainted: (value: Option<boolean>) => {
          tainted.hasAutoCommission = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "hasAutoCommission",
            data.hasAutoCommission,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      hasAutoDaylightSavings: {
        path: ["hasAutoDaylightSavings"] as const,
        name: "hasAutoDaylightSavings",
        constraints: { required: true },

        get: () => data.hasAutoDaylightSavings,
        set: (value: boolean) => {
          data.hasAutoDaylightSavings = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.hasAutoDaylightSavings,
        setError: (value: Option<Array<string>>) => {
          errors.hasAutoDaylightSavings = value;
        },
        getTainted: () => tainted.hasAutoDaylightSavings,
        setTainted: (value: Option<boolean>) => {
          tainted.hasAutoDaylightSavings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "hasAutoDaylightSavings",
            data.hasAutoDaylightSavings,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      hasAutoFmsTracking: {
        path: ["hasAutoFmsTracking"] as const,
        name: "hasAutoFmsTracking",
        constraints: { required: true },

        get: () => data.hasAutoFmsTracking,
        set: (value: boolean) => {
          data.hasAutoFmsTracking = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.hasAutoFmsTracking,
        setError: (value: Option<Array<string>>) => {
          errors.hasAutoFmsTracking = value;
        },
        getTainted: () => tainted.hasAutoFmsTracking,
        setTainted: (value: Option<boolean>) => {
          tainted.hasAutoFmsTracking = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "hasAutoFmsTracking",
            data.hasAutoFmsTracking,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      hasNotifications: {
        path: ["hasNotifications"] as const,
        name: "hasNotifications",
        constraints: { required: true },

        get: () => data.hasNotifications,
        set: (value: boolean) => {
          data.hasNotifications = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.hasNotifications,
        setError: (value: Option<Array<string>>) => {
          errors.hasNotifications = value;
        },
        getTainted: () => tainted.hasNotifications,
        setTainted: (value: Option<boolean>) => {
          tainted.hasNotifications = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "hasNotifications",
            data.hasNotifications,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      hasRequiredLeadSource: {
        path: ["hasRequiredLeadSource"] as const,
        name: "hasRequiredLeadSource",
        constraints: { required: true },

        get: () => data.hasRequiredLeadSource,
        set: (value: boolean) => {
          data.hasRequiredLeadSource = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.hasRequiredLeadSource,
        setError: (value: Option<Array<string>>) => {
          errors.hasRequiredLeadSource = value;
        },
        getTainted: () => tainted.hasRequiredLeadSource,
        setTainted: (value: Option<boolean>) => {
          tainted.hasRequiredLeadSource = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "hasRequiredLeadSource",
            data.hasRequiredLeadSource,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      hasRequiredEmail: {
        path: ["hasRequiredEmail"] as const,
        name: "hasRequiredEmail",
        constraints: { required: true },

        get: () => data.hasRequiredEmail,
        set: (value: boolean) => {
          data.hasRequiredEmail = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.hasRequiredEmail,
        setError: (value: Option<Array<string>>) => {
          errors.hasRequiredEmail = value;
        },
        getTainted: () => tainted.hasRequiredEmail,
        setTainted: (value: Option<boolean>) => {
          tainted.hasRequiredEmail = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "hasRequiredEmail",
            data.hasRequiredEmail,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      hasSortServiceItemsAlphabetically: {
        path: ["hasSortServiceItemsAlphabetically"] as const,
        name: "hasSortServiceItemsAlphabetically",
        constraints: { required: true },

        get: () => data.hasSortServiceItemsAlphabetically,
        set: (value: boolean) => {
          data.hasSortServiceItemsAlphabetically = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.hasSortServiceItemsAlphabetically,
        setError: (value: Option<Array<string>>) => {
          errors.hasSortServiceItemsAlphabetically = value;
        },
        getTainted: () => tainted.hasSortServiceItemsAlphabetically,
        setTainted: (value: Option<boolean>) => {
          tainted.hasSortServiceItemsAlphabetically = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "hasSortServiceItemsAlphabetically",
            data.hasSortServiceItemsAlphabetically,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      hasAttachOrderToAppointmentEmails: {
        path: ["hasAttachOrderToAppointmentEmails"] as const,
        name: "hasAttachOrderToAppointmentEmails",
        constraints: { required: true },

        get: () => data.hasAttachOrderToAppointmentEmails,
        set: (value: boolean) => {
          data.hasAttachOrderToAppointmentEmails = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.hasAttachOrderToAppointmentEmails,
        setError: (value: Option<Array<string>>) => {
          errors.hasAttachOrderToAppointmentEmails = value;
        },
        getTainted: () => tainted.hasAttachOrderToAppointmentEmails,
        setTainted: (value: Option<boolean>) => {
          tainted.hasAttachOrderToAppointmentEmails = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "hasAttachOrderToAppointmentEmails",
            data.hasAttachOrderToAppointmentEmails,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      scheduleInterval: {
        path: ["scheduleInterval"] as const,
        name: "scheduleInterval",
        constraints: { required: true },

        get: () => data.scheduleInterval,
        set: (value: number) => {
          data.scheduleInterval = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.scheduleInterval,
        setError: (value: Option<Array<string>>) => {
          errors.scheduleInterval = value;
        },
        getTainted: () => tainted.scheduleInterval,
        setTainted: (value: Option<boolean>) => {
          tainted.scheduleInterval = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "scheduleInterval",
            data.scheduleInterval,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      colorsConfig: {
        path: ["colorsConfig"] as const,
        name: "colorsConfig",
        constraints: { required: true },

        get: () => data.colorsConfig,
        set: (value: ColorsConfig) => {
          data.colorsConfig = value;
        },
        transform: (value: ColorsConfig): ColorsConfig => value,
        getError: () => errors.colorsConfig,
        setError: (value: Option<Array<string>>) => {
          errors.colorsConfig = value;
        },
        getTainted: () => tainted.colorsConfig,
        setTainted: (value: Option<boolean>) => {
          tainted.colorsConfig = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Company.validateField(
            "colorsConfig",
            data.colorsConfig,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Company,
      Array<{ field: string; message: string }>
    > {
      return Company.fromObject(data);
    }
    function reset(newOverrides?: Partial<Company>): void {
      data = { ...Company.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        legalName: Option.none(),
        headquarters: Option.none(),
        phones: Option.none(),
        fax: Option.none(),
        email: Option.none(),
        website: Option.none(),
        taxId: Option.none(),
        referenceNumber: Option.none(),
        postalCodeLookup: Option.none(),
        timeZone: Option.none(),
        defaultTax: Option.none(),
        defaultTaxLocation: Option.none(),
        defaultAreaCode: Option.none(),
        defaultAccountType: Option.none(),
        lookupFormatting: Option.none(),
        accountNameFormat: Option.none(),
        merchantServiceProvider: Option.none(),
        dateDisplayStyle: Option.none(),
        hasAutoCommission: Option.none(),
        hasAutoDaylightSavings: Option.none(),
        hasAutoFmsTracking: Option.none(),
        hasNotifications: Option.none(),
        hasRequiredLeadSource: Option.none(),
        hasRequiredEmail: Option.none(),
        hasSortServiceItemsAlphabetically: Option.none(),
        hasAttachOrderToAppointmentEmails: Option.none(),
        scheduleInterval: Option.none(),
        colorsConfig: Option.none(),
      };
      tainted = {
        id: Option.none(),
        legalName: Option.none(),
        headquarters: Option.none(),
        phones: Option.none(),
        fax: Option.none(),
        email: Option.none(),
        website: Option.none(),
        taxId: Option.none(),
        referenceNumber: Option.none(),
        postalCodeLookup: Option.none(),
        timeZone: Option.none(),
        defaultTax: Option.none(),
        defaultTaxLocation: Option.none(),
        defaultAreaCode: Option.none(),
        defaultAccountType: Option.none(),
        lookupFormatting: Option.none(),
        accountNameFormat: Option.none(),
        merchantServiceProvider: Option.none(),
        dateDisplayStyle: Option.none(),
        hasAutoCommission: Option.none(),
        hasAutoDaylightSavings: Option.none(),
        hasAutoFmsTracking: Option.none(),
        hasNotifications: Option.none(),
        hasRequiredLeadSource: Option.none(),
        hasRequiredEmail: Option.none(),
        hasSortServiceItemsAlphabetically: Option.none(),
        hasAttachOrderToAppointmentEmails: Option.none(),
        scheduleInterval: Option.none(),
        colorsConfig: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Company, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.legalName = formData.get("legalName") ?? "";
    obj.headquarters = formData.get("headquarters") ?? "";
    {
      // Collect array items from indexed form fields
      const phonesItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("phones." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("phones." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("phones." + idx + ".")) {
              const fieldName = key.slice(
                "phones.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          phonesItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.phones = phonesItems;
    }
    obj.fax = formData.get("fax") ?? "";
    obj.email = formData.get("email") ?? "";
    obj.website = formData.get("website") ?? "";
    obj.taxId = formData.get("taxId") ?? "";
    {
      const referenceNumberStr = formData.get("referenceNumber");
      obj.referenceNumber = referenceNumberStr
        ? parseFloat(referenceNumberStr as string)
        : 0;
      if (
        obj.referenceNumber !== undefined &&
        isNaN(obj.referenceNumber as number)
      )
        obj.referenceNumber = 0;
    }
    obj.postalCodeLookup = formData.get("postalCodeLookup") ?? "";
    obj.timeZone = formData.get("timeZone") ?? "";
    obj.defaultTax = formData.get("defaultTax") ?? "";
    obj.defaultTaxLocation = formData.get("defaultTaxLocation") ?? "";
    {
      const defaultAreaCodeStr = formData.get("defaultAreaCode");
      obj.defaultAreaCode = defaultAreaCodeStr
        ? parseFloat(defaultAreaCodeStr as string)
        : 0;
      if (
        obj.defaultAreaCode !== undefined &&
        isNaN(obj.defaultAreaCode as number)
      )
        obj.defaultAreaCode = 0;
    }
    obj.defaultAccountType = formData.get("defaultAccountType") ?? "";
    obj.lookupFormatting = formData.get("lookupFormatting") ?? "";
    obj.accountNameFormat = formData.get("accountNameFormat") ?? "";
    obj.merchantServiceProvider = formData.get("merchantServiceProvider") ?? "";
    obj.dateDisplayStyle = formData.get("dateDisplayStyle") ?? "";
    {
      const hasAutoCommissionVal = formData.get("hasAutoCommission");
      obj.hasAutoCommission =
        hasAutoCommissionVal === "true" ||
        hasAutoCommissionVal === "on" ||
        hasAutoCommissionVal === "1";
    }
    {
      const hasAutoDaylightSavingsVal = formData.get("hasAutoDaylightSavings");
      obj.hasAutoDaylightSavings =
        hasAutoDaylightSavingsVal === "true" ||
        hasAutoDaylightSavingsVal === "on" ||
        hasAutoDaylightSavingsVal === "1";
    }
    {
      const hasAutoFmsTrackingVal = formData.get("hasAutoFmsTracking");
      obj.hasAutoFmsTracking =
        hasAutoFmsTrackingVal === "true" ||
        hasAutoFmsTrackingVal === "on" ||
        hasAutoFmsTrackingVal === "1";
    }
    {
      const hasNotificationsVal = formData.get("hasNotifications");
      obj.hasNotifications =
        hasNotificationsVal === "true" ||
        hasNotificationsVal === "on" ||
        hasNotificationsVal === "1";
    }
    {
      const hasRequiredLeadSourceVal = formData.get("hasRequiredLeadSource");
      obj.hasRequiredLeadSource =
        hasRequiredLeadSourceVal === "true" ||
        hasRequiredLeadSourceVal === "on" ||
        hasRequiredLeadSourceVal === "1";
    }
    {
      const hasRequiredEmailVal = formData.get("hasRequiredEmail");
      obj.hasRequiredEmail =
        hasRequiredEmailVal === "true" ||
        hasRequiredEmailVal === "on" ||
        hasRequiredEmailVal === "1";
    }
    {
      const hasSortServiceItemsAlphabeticallyVal = formData.get(
        "hasSortServiceItemsAlphabetically",
      );
      obj.hasSortServiceItemsAlphabetically =
        hasSortServiceItemsAlphabeticallyVal === "true" ||
        hasSortServiceItemsAlphabeticallyVal === "on" ||
        hasSortServiceItemsAlphabeticallyVal === "1";
    }
    {
      const hasAttachOrderToAppointmentEmailsVal = formData.get(
        "hasAttachOrderToAppointmentEmails",
      );
      obj.hasAttachOrderToAppointmentEmails =
        hasAttachOrderToAppointmentEmailsVal === "true" ||
        hasAttachOrderToAppointmentEmailsVal === "on" ||
        hasAttachOrderToAppointmentEmailsVal === "1";
    }
    {
      const scheduleIntervalStr = formData.get("scheduleInterval");
      obj.scheduleInterval = scheduleIntervalStr
        ? parseFloat(scheduleIntervalStr as string)
        : 0;
      if (
        obj.scheduleInterval !== undefined &&
        isNaN(obj.scheduleInterval as number)
      )
        obj.scheduleInterval = 0;
    }
    {
      // Collect nested object fields with prefix "colorsConfig."
      const colorsConfigObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("colorsConfig.")) {
          const fieldName = key.slice("colorsConfig.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = colorsConfigObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.colorsConfig = colorsConfigObj;
    }
    return Company.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Ordinal {
  north: number;
  northeast: number;
  east: number;
  southeast: number;
  south: number;
  southwest: number;
  west: number;
  northwest: number;
}

export function defaultValueOrdinal(): Ordinal {
  return {
    north: 0,
    northeast: 0,
    east: 0,
    southeast: 0,
    south: 0,
    southwest: 0,
    west: 0,
    northwest: 0,
  } as Ordinal;
}

export function toStringifiedJSONOrdinal(value: Ordinal): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeOrdinal(value, ctx));
}
export function toObjectOrdinal(value: Ordinal): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeOrdinal(value, ctx);
}
export function __serializeOrdinal(
  value: Ordinal,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Ordinal", __id };
  result["north"] = value.north;
  result["northeast"] = value.northeast;
  result["east"] = value.east;
  result["southeast"] = value.southeast;
  result["south"] = value.south;
  result["southwest"] = value.southwest;
  result["west"] = value.west;
  result["northwest"] = value.northwest;
  return result;
}

export function fromStringifiedJSONOrdinal(
  json: string,
  opts?: DeserializeOptions,
): Result<Ordinal, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectOrdinal(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectOrdinal(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Ordinal, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeOrdinal(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Ordinal.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeOrdinal(
  value: any,
  ctx: DeserializeContext,
): Ordinal | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Ordinal.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("north" in obj)) {
    errors.push({ field: "north", message: "missing required field" });
  }
  if (!("northeast" in obj)) {
    errors.push({ field: "northeast", message: "missing required field" });
  }
  if (!("east" in obj)) {
    errors.push({ field: "east", message: "missing required field" });
  }
  if (!("southeast" in obj)) {
    errors.push({ field: "southeast", message: "missing required field" });
  }
  if (!("south" in obj)) {
    errors.push({ field: "south", message: "missing required field" });
  }
  if (!("southwest" in obj)) {
    errors.push({ field: "southwest", message: "missing required field" });
  }
  if (!("west" in obj)) {
    errors.push({ field: "west", message: "missing required field" });
  }
  if (!("northwest" in obj)) {
    errors.push({ field: "northwest", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_north = obj["north"] as number;
    instance.north = __raw_north;
  }
  {
    const __raw_northeast = obj["northeast"] as number;
    instance.northeast = __raw_northeast;
  }
  {
    const __raw_east = obj["east"] as number;
    instance.east = __raw_east;
  }
  {
    const __raw_southeast = obj["southeast"] as number;
    instance.southeast = __raw_southeast;
  }
  {
    const __raw_south = obj["south"] as number;
    instance.south = __raw_south;
  }
  {
    const __raw_southwest = obj["southwest"] as number;
    instance.southwest = __raw_southwest;
  }
  {
    const __raw_west = obj["west"] as number;
    instance.west = __raw_west;
  }
  {
    const __raw_northwest = obj["northwest"] as number;
    instance.northwest = __raw_northwest;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Ordinal;
}
export function validateFieldOrdinal<K extends keyof Ordinal>(
  field: K,
  value: Ordinal[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsOrdinal(
  partial: Partial<Ordinal>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isOrdinal(obj: unknown): obj is Ordinal {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "north" in o &&
    "northeast" in o &&
    "east" in o &&
    "southeast" in o &&
    "south" in o &&
    "southwest" in o &&
    "west" in o &&
    "northwest" in o
  );
}

export namespace Ordinal {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    north: Option<Array<string>>;
    northeast: Option<Array<string>>;
    east: Option<Array<string>>;
    southeast: Option<Array<string>>;
    south: Option<Array<string>>;
    southwest: Option<Array<string>>;
    west: Option<Array<string>>;
    northwest: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      north: Option<boolean>;
      northeast: Option<boolean>;
      east: Option<boolean>;
      southeast: Option<boolean>;
      south: Option<boolean>;
      southwest: Option<boolean>;
      west: Option<boolean>;
      northwest: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly north: FieldController<number>;
    readonly northeast: FieldController<number>;
    readonly east: FieldController<number>;
    readonly southeast: FieldController<number>;
    readonly south: FieldController<number>;
    readonly southwest: FieldController<number>;
    readonly west: FieldController<number>;
    readonly northwest: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Ordinal;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Ordinal, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Ordinal>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Ordinal>,
  ): Gigaform {
    let data = $state({ ...Ordinal.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      north: Option.none(),
      northeast: Option.none(),
      east: Option.none(),
      southeast: Option.none(),
      south: Option.none(),
      southwest: Option.none(),
      west: Option.none(),
      northwest: Option.none(),
    });
    let tainted = $state<Tainted>({
      north: Option.none(),
      northeast: Option.none(),
      east: Option.none(),
      southeast: Option.none(),
      south: Option.none(),
      southwest: Option.none(),
      west: Option.none(),
      northwest: Option.none(),
    });
    const fields: FieldControllers = {
      north: {
        path: ["north"] as const,
        name: "north",
        constraints: { required: true },

        get: () => data.north,
        set: (value: number) => {
          data.north = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.north,
        setError: (value: Option<Array<string>>) => {
          errors.north = value;
        },
        getTainted: () => tainted.north,
        setTainted: (value: Option<boolean>) => {
          tainted.north = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Ordinal.validateField("north", data.north);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      northeast: {
        path: ["northeast"] as const,
        name: "northeast",
        constraints: { required: true },

        get: () => data.northeast,
        set: (value: number) => {
          data.northeast = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.northeast,
        setError: (value: Option<Array<string>>) => {
          errors.northeast = value;
        },
        getTainted: () => tainted.northeast,
        setTainted: (value: Option<boolean>) => {
          tainted.northeast = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Ordinal.validateField(
            "northeast",
            data.northeast,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      east: {
        path: ["east"] as const,
        name: "east",
        constraints: { required: true },

        get: () => data.east,
        set: (value: number) => {
          data.east = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.east,
        setError: (value: Option<Array<string>>) => {
          errors.east = value;
        },
        getTainted: () => tainted.east,
        setTainted: (value: Option<boolean>) => {
          tainted.east = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Ordinal.validateField("east", data.east);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      southeast: {
        path: ["southeast"] as const,
        name: "southeast",
        constraints: { required: true },

        get: () => data.southeast,
        set: (value: number) => {
          data.southeast = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.southeast,
        setError: (value: Option<Array<string>>) => {
          errors.southeast = value;
        },
        getTainted: () => tainted.southeast,
        setTainted: (value: Option<boolean>) => {
          tainted.southeast = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Ordinal.validateField(
            "southeast",
            data.southeast,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      south: {
        path: ["south"] as const,
        name: "south",
        constraints: { required: true },

        get: () => data.south,
        set: (value: number) => {
          data.south = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.south,
        setError: (value: Option<Array<string>>) => {
          errors.south = value;
        },
        getTainted: () => tainted.south,
        setTainted: (value: Option<boolean>) => {
          tainted.south = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Ordinal.validateField("south", data.south);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      southwest: {
        path: ["southwest"] as const,
        name: "southwest",
        constraints: { required: true },

        get: () => data.southwest,
        set: (value: number) => {
          data.southwest = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.southwest,
        setError: (value: Option<Array<string>>) => {
          errors.southwest = value;
        },
        getTainted: () => tainted.southwest,
        setTainted: (value: Option<boolean>) => {
          tainted.southwest = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Ordinal.validateField(
            "southwest",
            data.southwest,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      west: {
        path: ["west"] as const,
        name: "west",
        constraints: { required: true },

        get: () => data.west,
        set: (value: number) => {
          data.west = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.west,
        setError: (value: Option<Array<string>>) => {
          errors.west = value;
        },
        getTainted: () => tainted.west,
        setTainted: (value: Option<boolean>) => {
          tainted.west = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Ordinal.validateField("west", data.west);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      northwest: {
        path: ["northwest"] as const,
        name: "northwest",
        constraints: { required: true },

        get: () => data.northwest,
        set: (value: number) => {
          data.northwest = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.northwest,
        setError: (value: Option<Array<string>>) => {
          errors.northwest = value;
        },
        getTainted: () => tainted.northwest,
        setTainted: (value: Option<boolean>) => {
          tainted.northwest = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Ordinal.validateField(
            "northwest",
            data.northwest,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Ordinal,
      Array<{ field: string; message: string }>
    > {
      return Ordinal.fromObject(data);
    }
    function reset(newOverrides?: Partial<Ordinal>): void {
      data = { ...Ordinal.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        north: Option.none(),
        northeast: Option.none(),
        east: Option.none(),
        southeast: Option.none(),
        south: Option.none(),
        southwest: Option.none(),
        west: Option.none(),
        northwest: Option.none(),
      };
      tainted = {
        north: Option.none(),
        northeast: Option.none(),
        east: Option.none(),
        southeast: Option.none(),
        south: Option.none(),
        southwest: Option.none(),
        west: Option.none(),
        northwest: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Ordinal, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const northStr = formData.get("north");
      obj.north = northStr ? parseFloat(northStr as string) : 0;
      if (obj.north !== undefined && isNaN(obj.north as number)) obj.north = 0;
    }
    {
      const northeastStr = formData.get("northeast");
      obj.northeast = northeastStr ? parseFloat(northeastStr as string) : 0;
      if (obj.northeast !== undefined && isNaN(obj.northeast as number))
        obj.northeast = 0;
    }
    {
      const eastStr = formData.get("east");
      obj.east = eastStr ? parseFloat(eastStr as string) : 0;
      if (obj.east !== undefined && isNaN(obj.east as number)) obj.east = 0;
    }
    {
      const southeastStr = formData.get("southeast");
      obj.southeast = southeastStr ? parseFloat(southeastStr as string) : 0;
      if (obj.southeast !== undefined && isNaN(obj.southeast as number))
        obj.southeast = 0;
    }
    {
      const southStr = formData.get("south");
      obj.south = southStr ? parseFloat(southStr as string) : 0;
      if (obj.south !== undefined && isNaN(obj.south as number)) obj.south = 0;
    }
    {
      const southwestStr = formData.get("southwest");
      obj.southwest = southwestStr ? parseFloat(southwestStr as string) : 0;
      if (obj.southwest !== undefined && isNaN(obj.southwest as number))
        obj.southwest = 0;
    }
    {
      const westStr = formData.get("west");
      obj.west = westStr ? parseFloat(westStr as string) : 0;
      if (obj.west !== undefined && isNaN(obj.west as number)) obj.west = 0;
    }
    {
      const northwestStr = formData.get("northwest");
      obj.northwest = northwestStr ? parseFloat(northwestStr as string) : 0;
      if (obj.northwest !== undefined && isNaN(obj.northwest as number))
        obj.northwest = 0;
    }
    return Ordinal.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Password {
  /** @serde({ validate: ["nonEmpty"] }) */
  password: string;
}

export function defaultValuePassword(): Password {
  return { password: "" } as Password;
}

export function toStringifiedJSONPassword(value: Password): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializePassword(value, ctx));
}
export function toObjectPassword(value: Password): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializePassword(value, ctx);
}
export function __serializePassword(
  value: Password,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Password", __id };
  result["password"] = value.password;
  return result;
}

export function fromStringifiedJSONPassword(
  json: string,
  opts?: DeserializeOptions,
): Result<Password, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectPassword(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectPassword(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Password, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializePassword(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Password.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializePassword(
  value: any,
  ctx: DeserializeContext,
): Password | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Password.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("password" in obj)) {
    errors.push({ field: "password", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_password = obj["password"] as string;
    if (__raw_password.length === 0) {
      errors.push({ field: "password", message: "must not be empty" });
    }
    instance.password = __raw_password;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Password;
}
export function validateFieldPassword<K extends keyof Password>(
  field: K,
  value: Password[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "password": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "password", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsPassword(
  partial: Partial<Password>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("password" in partial && partial.password !== undefined) {
    const __val = partial.password as string;
    if (__val.length === 0) {
      errors.push({ field: "password", message: "must not be empty" });
    }
  }
  return errors;
}
export function isPassword(obj: unknown): obj is Password {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "password" in o;
}

export namespace Password {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    password: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { password: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly password: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Password;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Password, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Password>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Password>,
  ): Gigaform {
    let data = $state({ ...Password.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      password: Option.none(),
    });
    let tainted = $state<Tainted>({ password: Option.none() });
    const fields: FieldControllers = {
      password: {
        path: ["password"] as const,
        name: "password",
        constraints: { required: true },

        get: () => data.password,
        set: (value: string) => {
          data.password = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.password,
        setError: (value: Option<Array<string>>) => {
          errors.password = value;
        },
        getTainted: () => tainted.password,
        setTainted: (value: Option<boolean>) => {
          tainted.password = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Password.validateField("password", data.password);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Password,
      Array<{ field: string; message: string }>
    > {
      return Password.fromObject(data);
    }
    function reset(newOverrides?: Partial<Password>): void {
      data = { ...Password.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), password: Option.none() };
      tainted = { password: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Password, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.password = formData.get("password") ?? "";
    return Password.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Created {
  initialData: string | null;
}

export function defaultValueCreated(): Created {
  return { initialData: null } as Created;
}

export function toStringifiedJSONCreated(value: Created): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeCreated(value, ctx));
}
export function toObjectCreated(value: Created): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeCreated(value, ctx);
}
export function __serializeCreated(
  value: Created,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Created", __id };
  if (value.initialData !== null) {
    result["initialData"] =
      typeof (value.initialData as any)?.__serialize === "function"
        ? (value.initialData as any).__serialize(ctx)
        : value.initialData;
  } else {
    result["initialData"] = null;
  }
  return result;
}

export function fromStringifiedJSONCreated(
  json: string,
  opts?: DeserializeOptions,
): Result<Created, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectCreated(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectCreated(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Created, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeCreated(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Created.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeCreated(
  value: any,
  ctx: DeserializeContext,
): Created | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Created.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("initialData" in obj)) {
    errors.push({ field: "initialData", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_initialData = obj["initialData"] as string | null;
    if (__raw_initialData === null) {
      instance.initialData = null;
    } else if (typeof (__raw_initialData as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_initialData as any).__ref);
      ctx.assignOrDefer(instance, "initialData", __result);
    } else {
      instance.initialData = __raw_initialData;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Created;
}
export function validateFieldCreated<K extends keyof Created>(
  field: K,
  value: Created[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsCreated(
  partial: Partial<Created>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isCreated(obj: unknown): obj is Created {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "initialData" in o;
}

export namespace Created {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    initialData: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { initialData: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly initialData: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Created;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Created, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Created>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Created>,
  ): Gigaform {
    let data = $state({ ...Created.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      initialData: Option.none(),
    });
    let tainted = $state<Tainted>({ initialData: Option.none() });
    const fields: FieldControllers = {
      initialData: {
        path: ["initialData"] as const,
        name: "initialData",
        constraints: { required: true },

        get: () => data.initialData,
        set: (value: string | null) => {
          data.initialData = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.initialData,
        setError: (value: Option<Array<string>>) => {
          errors.initialData = value;
        },
        getTainted: () => tainted.initialData,
        setTainted: (value: Option<boolean>) => {
          tainted.initialData = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Created.validateField(
            "initialData",
            data.initialData,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Created,
      Array<{ field: string; message: string }>
    > {
      return Created.fromObject(data);
    }
    function reset(newOverrides?: Partial<Created>): void {
      data = { ...Created.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), initialData: Option.none() };
      tainted = { initialData: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Created, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.initialData = formData.get("initialData") ?? "";
    return Created.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Employee {
  id: string;
  imageUrl: string | null;
  /** @serde({ validate: ["nonEmpty"] }) */
  name: string;
  phones: PhoneNumber[];
  /** @serde({ validate: ["nonEmpty"] }) */
  role: string;
  /** @default("Technician") */
  title: JobTitle;
  email: Email;
  /** @serde({ validate: ["nonEmpty"] }) */
  address: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  username: string;
  /** @default("") */
  route: string | Route;
  ratePerHour: number;
  active: boolean;
  isTechnician: boolean;
  isSalesRep: boolean;
  description: string | null;
  linkedinUrl: string | null;
  attendance: string[];
  settings: Settings;
}

export function defaultValueEmployee(): Employee {
  return {
    id: "",
    imageUrl: null,
    name: "",
    phones: [],
    role: "",
    title: "Technician",
    email: Email.defaultValue(),
    address: "",
    username: "",
    route: "",
    ratePerHour: 0,
    active: false,
    isTechnician: false,
    isSalesRep: false,
    description: null,
    linkedinUrl: null,
    attendance: [],
    settings: Settings.defaultValue(),
  } as Employee;
}

export function toStringifiedJSONEmployee(value: Employee): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeEmployee(value, ctx));
}
export function toObjectEmployee(value: Employee): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeEmployee(value, ctx);
}
export function __serializeEmployee(
  value: Employee,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Employee", __id };
  result["id"] = value.id;
  if (value.imageUrl !== null) {
    result["imageUrl"] =
      typeof (value.imageUrl as any)?.__serialize === "function"
        ? (value.imageUrl as any).__serialize(ctx)
        : value.imageUrl;
  } else {
    result["imageUrl"] = null;
  }
  result["name"] = value.name;
  result["phones"] = value.phones.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["role"] = value.role;
  result["title"] =
    typeof (value.title as any)?.__serialize === "function"
      ? (value.title as any).__serialize(ctx)
      : value.title;
  result["email"] =
    typeof (value.email as any)?.__serialize === "function"
      ? (value.email as any).__serialize(ctx)
      : value.email;
  result["address"] = value.address;
  result["username"] = value.username;
  result["route"] = value.route;
  result["ratePerHour"] = value.ratePerHour;
  result["active"] = value.active;
  result["isTechnician"] = value.isTechnician;
  result["isSalesRep"] = value.isSalesRep;
  if (value.description !== null) {
    result["description"] =
      typeof (value.description as any)?.__serialize === "function"
        ? (value.description as any).__serialize(ctx)
        : value.description;
  } else {
    result["description"] = null;
  }
  if (value.linkedinUrl !== null) {
    result["linkedinUrl"] =
      typeof (value.linkedinUrl as any)?.__serialize === "function"
        ? (value.linkedinUrl as any).__serialize(ctx)
        : value.linkedinUrl;
  } else {
    result["linkedinUrl"] = null;
  }
  result["attendance"] = value.attendance.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  result["settings"] =
    typeof (value.settings as any)?.__serialize === "function"
      ? (value.settings as any).__serialize(ctx)
      : value.settings;
  return result;
}

export function fromStringifiedJSONEmployee(
  json: string,
  opts?: DeserializeOptions,
): Result<Employee, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectEmployee(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectEmployee(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Employee, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeEmployee(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Employee.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeEmployee(
  value: any,
  ctx: DeserializeContext,
): Employee | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Employee.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("imageUrl" in obj)) {
    errors.push({ field: "imageUrl", message: "missing required field" });
  }
  if (!("name" in obj)) {
    errors.push({ field: "name", message: "missing required field" });
  }
  if (!("phones" in obj)) {
    errors.push({ field: "phones", message: "missing required field" });
  }
  if (!("role" in obj)) {
    errors.push({ field: "role", message: "missing required field" });
  }
  if (!("title" in obj)) {
    errors.push({ field: "title", message: "missing required field" });
  }
  if (!("email" in obj)) {
    errors.push({ field: "email", message: "missing required field" });
  }
  if (!("address" in obj)) {
    errors.push({ field: "address", message: "missing required field" });
  }
  if (!("username" in obj)) {
    errors.push({ field: "username", message: "missing required field" });
  }
  if (!("route" in obj)) {
    errors.push({ field: "route", message: "missing required field" });
  }
  if (!("ratePerHour" in obj)) {
    errors.push({ field: "ratePerHour", message: "missing required field" });
  }
  if (!("active" in obj)) {
    errors.push({ field: "active", message: "missing required field" });
  }
  if (!("isTechnician" in obj)) {
    errors.push({ field: "isTechnician", message: "missing required field" });
  }
  if (!("isSalesRep" in obj)) {
    errors.push({ field: "isSalesRep", message: "missing required field" });
  }
  if (!("description" in obj)) {
    errors.push({ field: "description", message: "missing required field" });
  }
  if (!("linkedinUrl" in obj)) {
    errors.push({ field: "linkedinUrl", message: "missing required field" });
  }
  if (!("attendance" in obj)) {
    errors.push({ field: "attendance", message: "missing required field" });
  }
  if (!("settings" in obj)) {
    errors.push({ field: "settings", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_imageUrl = obj["imageUrl"] as string | null;
    if (__raw_imageUrl === null) {
      instance.imageUrl = null;
    } else if (typeof (__raw_imageUrl as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_imageUrl as any).__ref);
      ctx.assignOrDefer(instance, "imageUrl", __result);
    } else {
      instance.imageUrl = __raw_imageUrl;
    }
  }
  {
    const __raw_name = obj["name"] as string;
    if (__raw_name.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
    instance.name = __raw_name;
  }
  {
    const __raw_phones = obj["phones"] as PhoneNumber[];
    if (Array.isArray(__raw_phones)) {
      instance.phones = __raw_phones as PhoneNumber[];
    }
  }
  {
    const __raw_role = obj["role"] as string;
    if (__raw_role.length === 0) {
      errors.push({ field: "role", message: "must not be empty" });
    }
    instance.role = __raw_role;
  }
  {
    const __raw_title = obj["title"] as JobTitle;
    if (typeof (JobTitle as any)?.__deserialize === "function") {
      const __result = (JobTitle as any).__deserialize(__raw_title, ctx);
      ctx.assignOrDefer(instance, "title", __result);
    } else {
      instance.title = __raw_title;
    }
  }
  {
    const __raw_email = obj["email"] as Email;
    if (typeof (Email as any)?.__deserialize === "function") {
      const __result = (Email as any).__deserialize(__raw_email, ctx);
      ctx.assignOrDefer(instance, "email", __result);
    } else {
      instance.email = __raw_email;
    }
  }
  {
    const __raw_address = obj["address"] as string;
    if (__raw_address.length === 0) {
      errors.push({ field: "address", message: "must not be empty" });
    }
    instance.address = __raw_address;
  }
  {
    const __raw_username = obj["username"] as string;
    if (__raw_username.length === 0) {
      errors.push({ field: "username", message: "must not be empty" });
    }
    instance.username = __raw_username;
  }
  {
    const __raw_route = obj["route"] as string | Route;
    instance.route = __raw_route;
  }
  {
    const __raw_ratePerHour = obj["ratePerHour"] as number;
    instance.ratePerHour = __raw_ratePerHour;
  }
  {
    const __raw_active = obj["active"] as boolean;
    instance.active = __raw_active;
  }
  {
    const __raw_isTechnician = obj["isTechnician"] as boolean;
    instance.isTechnician = __raw_isTechnician;
  }
  {
    const __raw_isSalesRep = obj["isSalesRep"] as boolean;
    instance.isSalesRep = __raw_isSalesRep;
  }
  {
    const __raw_description = obj["description"] as string | null;
    if (__raw_description === null) {
      instance.description = null;
    } else if (typeof (__raw_description as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_description as any).__ref);
      ctx.assignOrDefer(instance, "description", __result);
    } else {
      instance.description = __raw_description;
    }
  }
  {
    const __raw_linkedinUrl = obj["linkedinUrl"] as string | null;
    if (__raw_linkedinUrl === null) {
      instance.linkedinUrl = null;
    } else if (typeof (__raw_linkedinUrl as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_linkedinUrl as any).__ref);
      ctx.assignOrDefer(instance, "linkedinUrl", __result);
    } else {
      instance.linkedinUrl = __raw_linkedinUrl;
    }
  }
  {
    const __raw_attendance = obj["attendance"] as string[];
    if (Array.isArray(__raw_attendance)) {
      instance.attendance = __raw_attendance as string[];
    }
  }
  {
    const __raw_settings = obj["settings"] as Settings;
    if (typeof (Settings as any)?.__deserialize === "function") {
      const __result = (Settings as any).__deserialize(__raw_settings, ctx);
      ctx.assignOrDefer(instance, "settings", __result);
    } else {
      instance.settings = __raw_settings;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Employee;
}
export function validateFieldEmployee<K extends keyof Employee>(
  field: K,
  value: Employee[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "name": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
      break;
    }
    case "role": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "role", message: "must not be empty" });
      }
      break;
    }
    case "address": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "address", message: "must not be empty" });
      }
      break;
    }
    case "username": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "username", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsEmployee(
  partial: Partial<Employee>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("name" in partial && partial.name !== undefined) {
    const __val = partial.name as string;
    if (__val.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
  }
  if ("role" in partial && partial.role !== undefined) {
    const __val = partial.role as string;
    if (__val.length === 0) {
      errors.push({ field: "role", message: "must not be empty" });
    }
  }
  if ("address" in partial && partial.address !== undefined) {
    const __val = partial.address as string;
    if (__val.length === 0) {
      errors.push({ field: "address", message: "must not be empty" });
    }
  }
  if ("username" in partial && partial.username !== undefined) {
    const __val = partial.username as string;
    if (__val.length === 0) {
      errors.push({ field: "username", message: "must not be empty" });
    }
  }
  return errors;
}
export function isEmployee(obj: unknown): obj is Employee {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "id" in o &&
    "imageUrl" in o &&
    "name" in o &&
    "phones" in o &&
    "role" in o &&
    "title" in o &&
    "email" in o &&
    "address" in o &&
    "username" in o &&
    "route" in o &&
    "ratePerHour" in o &&
    "active" in o &&
    "isTechnician" in o &&
    "isSalesRep" in o &&
    "description" in o &&
    "linkedinUrl" in o &&
    "attendance" in o &&
    "settings" in o
  );
}

export namespace Employee {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    imageUrl: Option<Array<string>>;
    name: Option<Array<string>>;
    phones: Option<Array<string>>;
    role: Option<Array<string>>;
    title: Option<Array<string>>;
    email: Option<Array<string>>;
    address: Option<Array<string>>;
    username: Option<Array<string>>;
    route: Option<Array<string>>;
    ratePerHour: Option<Array<string>>;
    active: Option<Array<string>>;
    isTechnician: Option<Array<string>>;
    isSalesRep: Option<Array<string>>;
    description: Option<Array<string>>;
    linkedinUrl: Option<Array<string>>;
    attendance: Option<Array<string>>;
    settings: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      imageUrl: Option<boolean>;
      name: Option<boolean>;
      phones: Option<boolean>;
      role: Option<boolean>;
      title: Option<boolean>;
      email: Option<boolean>;
      address: Option<boolean>;
      username: Option<boolean>;
      route: Option<boolean>;
      ratePerHour: Option<boolean>;
      active: Option<boolean>;
      isTechnician: Option<boolean>;
      isSalesRep: Option<boolean>;
      description: Option<boolean>;
      linkedinUrl: Option<boolean>;
      attendance: Option<boolean>;
      settings: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly imageUrl: FieldController<string | null>;
    readonly name: FieldController<string>;
    readonly phones: ArrayFieldController<PhoneNumber>;
    readonly role: FieldController<string>;
    readonly title: FieldController<JobTitle>;
    readonly email: FieldController<Email>;
    readonly address: FieldController<string>;
    readonly username: FieldController<string>;
    readonly route: FieldController<string | Route>;
    readonly ratePerHour: FieldController<number>;
    readonly active: FieldController<boolean>;
    readonly isTechnician: FieldController<boolean>;
    readonly isSalesRep: FieldController<boolean>;
    readonly description: FieldController<string | null>;
    readonly linkedinUrl: FieldController<string | null>;
    readonly attendance: ArrayFieldController<string>;
    readonly settings: FieldController<Settings>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Employee;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Employee, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Employee>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Employee>,
  ): Gigaform {
    let data = $state({ ...Employee.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      imageUrl: Option.none(),
      name: Option.none(),
      phones: Option.none(),
      role: Option.none(),
      title: Option.none(),
      email: Option.none(),
      address: Option.none(),
      username: Option.none(),
      route: Option.none(),
      ratePerHour: Option.none(),
      active: Option.none(),
      isTechnician: Option.none(),
      isSalesRep: Option.none(),
      description: Option.none(),
      linkedinUrl: Option.none(),
      attendance: Option.none(),
      settings: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      imageUrl: Option.none(),
      name: Option.none(),
      phones: Option.none(),
      role: Option.none(),
      title: Option.none(),
      email: Option.none(),
      address: Option.none(),
      username: Option.none(),
      route: Option.none(),
      ratePerHour: Option.none(),
      active: Option.none(),
      isTechnician: Option.none(),
      isSalesRep: Option.none(),
      description: Option.none(),
      linkedinUrl: Option.none(),
      attendance: Option.none(),
      settings: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      imageUrl: {
        path: ["imageUrl"] as const,
        name: "imageUrl",
        constraints: { required: true },

        get: () => data.imageUrl,
        set: (value: string | null) => {
          data.imageUrl = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.imageUrl,
        setError: (value: Option<Array<string>>) => {
          errors.imageUrl = value;
        },
        getTainted: () => tainted.imageUrl,
        setTainted: (value: Option<boolean>) => {
          tainted.imageUrl = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("imageUrl", data.imageUrl);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },

        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("name", data.name);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      phones: {
        path: ["phones"] as const,
        name: "phones",
        constraints: { required: true },

        get: () => data.phones,
        set: (value: PhoneNumber[]) => {
          data.phones = value;
        },
        transform: (value: PhoneNumber[]): PhoneNumber[] => value,
        getError: () => errors.phones,
        setError: (value: Option<Array<string>>) => {
          errors.phones = value;
        },
        getTainted: () => tainted.phones,
        setTainted: (value: Option<boolean>) => {
          tainted.phones = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("phones", data.phones);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["phones", index] as const,
          name: `phones.${index}`,
          constraints: { required: true },
          get: () => data.phones[index]!,
          set: (value: PhoneNumber) => {
            data.phones[index] = value;
          },
          transform: (value: PhoneNumber): PhoneNumber => value,
          getError: () => errors.phones,
          setError: (value: Option<Array<string>>) => {
            errors.phones = value;
          },
          getTainted: () => tainted.phones,
          setTainted: (value: Option<boolean>) => {
            tainted.phones = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: PhoneNumber) => {
          data.phones.push(item);
        },
        remove: (index: number) => {
          data.phones.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.phones[a]!;
          data.phones[a] = data.phones[b]!;
          data.phones[b] = tmp;
        },
      },
      role: {
        path: ["role"] as const,
        name: "role",
        constraints: { required: true },

        get: () => data.role,
        set: (value: string) => {
          data.role = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.role,
        setError: (value: Option<Array<string>>) => {
          errors.role = value;
        },
        getTainted: () => tainted.role,
        setTainted: (value: Option<boolean>) => {
          tainted.role = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("role", data.role);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      title: {
        path: ["title"] as const,
        name: "title",
        constraints: { required: true },

        get: () => data.title,
        set: (value: JobTitle) => {
          data.title = value;
        },
        transform: (value: JobTitle): JobTitle => value,
        getError: () => errors.title,
        setError: (value: Option<Array<string>>) => {
          errors.title = value;
        },
        getTainted: () => tainted.title,
        setTainted: (value: Option<boolean>) => {
          tainted.title = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("title", data.title);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      email: {
        path: ["email"] as const,
        name: "email",
        constraints: { required: true },

        get: () => data.email,
        set: (value: Email) => {
          data.email = value;
        },
        transform: (value: Email): Email => value,
        getError: () => errors.email,
        setError: (value: Option<Array<string>>) => {
          errors.email = value;
        },
        getTainted: () => tainted.email,
        setTainted: (value: Option<boolean>) => {
          tainted.email = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("email", data.email);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      address: {
        path: ["address"] as const,
        name: "address",
        constraints: { required: true },

        get: () => data.address,
        set: (value: string) => {
          data.address = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.address,
        setError: (value: Option<Array<string>>) => {
          errors.address = value;
        },
        getTainted: () => tainted.address,
        setTainted: (value: Option<boolean>) => {
          tainted.address = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("address", data.address);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      username: {
        path: ["username"] as const,
        name: "username",
        constraints: { required: true },

        get: () => data.username,
        set: (value: string) => {
          data.username = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.username,
        setError: (value: Option<Array<string>>) => {
          errors.username = value;
        },
        getTainted: () => tainted.username,
        setTainted: (value: Option<boolean>) => {
          tainted.username = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("username", data.username);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      route: {
        path: ["route"] as const,
        name: "route",
        constraints: { required: true },

        get: () => data.route,
        set: (value: string | Route) => {
          data.route = value;
        },
        transform: (value: string | Route): string | Route => value,
        getError: () => errors.route,
        setError: (value: Option<Array<string>>) => {
          errors.route = value;
        },
        getTainted: () => tainted.route,
        setTainted: (value: Option<boolean>) => {
          tainted.route = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("route", data.route);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      ratePerHour: {
        path: ["ratePerHour"] as const,
        name: "ratePerHour",
        constraints: { required: true },

        get: () => data.ratePerHour,
        set: (value: number) => {
          data.ratePerHour = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.ratePerHour,
        setError: (value: Option<Array<string>>) => {
          errors.ratePerHour = value;
        },
        getTainted: () => tainted.ratePerHour,
        setTainted: (value: Option<boolean>) => {
          tainted.ratePerHour = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField(
            "ratePerHour",
            data.ratePerHour,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      active: {
        path: ["active"] as const,
        name: "active",
        constraints: { required: true },

        get: () => data.active,
        set: (value: boolean) => {
          data.active = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.active,
        setError: (value: Option<Array<string>>) => {
          errors.active = value;
        },
        getTainted: () => tainted.active,
        setTainted: (value: Option<boolean>) => {
          tainted.active = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("active", data.active);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      isTechnician: {
        path: ["isTechnician"] as const,
        name: "isTechnician",
        constraints: { required: true },

        get: () => data.isTechnician,
        set: (value: boolean) => {
          data.isTechnician = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.isTechnician,
        setError: (value: Option<Array<string>>) => {
          errors.isTechnician = value;
        },
        getTainted: () => tainted.isTechnician,
        setTainted: (value: Option<boolean>) => {
          tainted.isTechnician = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField(
            "isTechnician",
            data.isTechnician,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      isSalesRep: {
        path: ["isSalesRep"] as const,
        name: "isSalesRep",
        constraints: { required: true },

        get: () => data.isSalesRep,
        set: (value: boolean) => {
          data.isSalesRep = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.isSalesRep,
        setError: (value: Option<Array<string>>) => {
          errors.isSalesRep = value;
        },
        getTainted: () => tainted.isSalesRep,
        setTainted: (value: Option<boolean>) => {
          tainted.isSalesRep = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField(
            "isSalesRep",
            data.isSalesRep,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      description: {
        path: ["description"] as const,
        name: "description",
        constraints: { required: true },

        get: () => data.description,
        set: (value: string | null) => {
          data.description = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.description,
        setError: (value: Option<Array<string>>) => {
          errors.description = value;
        },
        getTainted: () => tainted.description,
        setTainted: (value: Option<boolean>) => {
          tainted.description = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField(
            "description",
            data.description,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      linkedinUrl: {
        path: ["linkedinUrl"] as const,
        name: "linkedinUrl",
        constraints: { required: true },

        get: () => data.linkedinUrl,
        set: (value: string | null) => {
          data.linkedinUrl = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.linkedinUrl,
        setError: (value: Option<Array<string>>) => {
          errors.linkedinUrl = value;
        },
        getTainted: () => tainted.linkedinUrl,
        setTainted: (value: Option<boolean>) => {
          tainted.linkedinUrl = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField(
            "linkedinUrl",
            data.linkedinUrl,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      attendance: {
        path: ["attendance"] as const,
        name: "attendance",
        constraints: { required: true },

        get: () => data.attendance,
        set: (value: string[]) => {
          data.attendance = value;
        },
        transform: (value: string[]): string[] => value,
        getError: () => errors.attendance,
        setError: (value: Option<Array<string>>) => {
          errors.attendance = value;
        },
        getTainted: () => tainted.attendance,
        setTainted: (value: Option<boolean>) => {
          tainted.attendance = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField(
            "attendance",
            data.attendance,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["attendance", index] as const,
          name: `attendance.${index}`,
          constraints: { required: true },
          get: () => data.attendance[index]!,
          set: (value: string) => {
            data.attendance[index] = value;
          },
          transform: (value: string): string => value,
          getError: () => errors.attendance,
          setError: (value: Option<Array<string>>) => {
            errors.attendance = value;
          },
          getTainted: () => tainted.attendance,
          setTainted: (value: Option<boolean>) => {
            tainted.attendance = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.attendance.push(item);
        },
        remove: (index: number) => {
          data.attendance.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.attendance[a]!;
          data.attendance[a] = data.attendance[b]!;
          data.attendance[b] = tmp;
        },
      },
      settings: {
        path: ["settings"] as const,
        name: "settings",
        constraints: { required: true },

        get: () => data.settings,
        set: (value: Settings) => {
          data.settings = value;
        },
        transform: (value: Settings): Settings => value,
        getError: () => errors.settings,
        setError: (value: Option<Array<string>>) => {
          errors.settings = value;
        },
        getTainted: () => tainted.settings,
        setTainted: (value: Option<boolean>) => {
          tainted.settings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("settings", data.settings);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Employee,
      Array<{ field: string; message: string }>
    > {
      return Employee.fromObject(data);
    }
    function reset(newOverrides?: Partial<Employee>): void {
      data = { ...Employee.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        imageUrl: Option.none(),
        name: Option.none(),
        phones: Option.none(),
        role: Option.none(),
        title: Option.none(),
        email: Option.none(),
        address: Option.none(),
        username: Option.none(),
        route: Option.none(),
        ratePerHour: Option.none(),
        active: Option.none(),
        isTechnician: Option.none(),
        isSalesRep: Option.none(),
        description: Option.none(),
        linkedinUrl: Option.none(),
        attendance: Option.none(),
        settings: Option.none(),
      };
      tainted = {
        id: Option.none(),
        imageUrl: Option.none(),
        name: Option.none(),
        phones: Option.none(),
        role: Option.none(),
        title: Option.none(),
        email: Option.none(),
        address: Option.none(),
        username: Option.none(),
        route: Option.none(),
        ratePerHour: Option.none(),
        active: Option.none(),
        isTechnician: Option.none(),
        isSalesRep: Option.none(),
        description: Option.none(),
        linkedinUrl: Option.none(),
        attendance: Option.none(),
        settings: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Employee, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.imageUrl = formData.get("imageUrl") ?? "";
    obj.name = formData.get("name") ?? "";
    {
      // Collect array items from indexed form fields
      const phonesItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("phones." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("phones." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of Array.from(formData.entries())) {
            if (key.startsWith("phones." + idx + ".")) {
              const fieldName = key.slice(
                "phones.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          phonesItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.phones = phonesItems;
    }
    obj.role = formData.get("role") ?? "";
    {
      // Collect nested object fields with prefix "title."
      const titleObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("title.")) {
          const fieldName = key.slice("title.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = titleObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.title = titleObj;
    }
    {
      // Collect nested object fields with prefix "email."
      const emailObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("email.")) {
          const fieldName = key.slice("email.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = emailObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.email = emailObj;
    }
    obj.address = formData.get("address") ?? "";
    obj.username = formData.get("username") ?? "";
    obj.route = formData.get("route") ?? "";
    {
      const ratePerHourStr = formData.get("ratePerHour");
      obj.ratePerHour = ratePerHourStr
        ? parseFloat(ratePerHourStr as string)
        : 0;
      if (obj.ratePerHour !== undefined && isNaN(obj.ratePerHour as number))
        obj.ratePerHour = 0;
    }
    {
      const activeVal = formData.get("active");
      obj.active =
        activeVal === "true" || activeVal === "on" || activeVal === "1";
    }
    {
      const isTechnicianVal = formData.get("isTechnician");
      obj.isTechnician =
        isTechnicianVal === "true" ||
        isTechnicianVal === "on" ||
        isTechnicianVal === "1";
    }
    {
      const isSalesRepVal = formData.get("isSalesRep");
      obj.isSalesRep =
        isSalesRepVal === "true" ||
        isSalesRepVal === "on" ||
        isSalesRepVal === "1";
    }
    obj.description = formData.get("description") ?? "";
    obj.linkedinUrl = formData.get("linkedinUrl") ?? "";
    obj.attendance = formData.getAll("attendance") as Array<string>;
    {
      // Collect nested object fields with prefix "settings."
      const settingsObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("settings.")) {
          const fieldName = key.slice("settings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = settingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.settings = settingsObj;
    }
    return Employee.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Commissions {
  /** @serde({ validate: ["nonEmpty"] }) */
  technician: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  salesRep: string;
}

export function defaultValueCommissions(): Commissions {
  return { technician: "", salesRep: "" } as Commissions;
}

export function toStringifiedJSONCommissions(value: Commissions): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeCommissions(value, ctx));
}
export function toObjectCommissions(
  value: Commissions,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeCommissions(value, ctx);
}
export function __serializeCommissions(
  value: Commissions,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Commissions", __id };
  result["technician"] = value.technician;
  result["salesRep"] = value.salesRep;
  return result;
}

export function fromStringifiedJSONCommissions(
  json: string,
  opts?: DeserializeOptions,
): Result<Commissions, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectCommissions(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectCommissions(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Commissions, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeCommissions(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Commissions.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeCommissions(
  value: any,
  ctx: DeserializeContext,
): Commissions | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "Commissions.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("technician" in obj)) {
    errors.push({ field: "technician", message: "missing required field" });
  }
  if (!("salesRep" in obj)) {
    errors.push({ field: "salesRep", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_technician = obj["technician"] as string;
    if (__raw_technician.length === 0) {
      errors.push({ field: "technician", message: "must not be empty" });
    }
    instance.technician = __raw_technician;
  }
  {
    const __raw_salesRep = obj["salesRep"] as string;
    if (__raw_salesRep.length === 0) {
      errors.push({ field: "salesRep", message: "must not be empty" });
    }
    instance.salesRep = __raw_salesRep;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Commissions;
}
export function validateFieldCommissions<K extends keyof Commissions>(
  field: K,
  value: Commissions[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "technician": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "technician", message: "must not be empty" });
      }
      break;
    }
    case "salesRep": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "salesRep", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsCommissions(
  partial: Partial<Commissions>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("technician" in partial && partial.technician !== undefined) {
    const __val = partial.technician as string;
    if (__val.length === 0) {
      errors.push({ field: "technician", message: "must not be empty" });
    }
  }
  if ("salesRep" in partial && partial.salesRep !== undefined) {
    const __val = partial.salesRep as string;
    if (__val.length === 0) {
      errors.push({ field: "salesRep", message: "must not be empty" });
    }
  }
  return errors;
}
export function isCommissions(obj: unknown): obj is Commissions {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "technician" in o && "salesRep" in o;
}

export namespace Commissions {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    technician: Option<Array<string>>;
    salesRep: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { technician: Option<boolean>; salesRep: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly technician: FieldController<string>;
    readonly salesRep: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Commissions;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Commissions, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Commissions>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Commissions>,
  ): Gigaform {
    let data = $state({ ...Commissions.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      technician: Option.none(),
      salesRep: Option.none(),
    });
    let tainted = $state<Tainted>({
      technician: Option.none(),
      salesRep: Option.none(),
    });
    const fields: FieldControllers = {
      technician: {
        path: ["technician"] as const,
        name: "technician",
        constraints: { required: true },

        get: () => data.technician,
        set: (value: string) => {
          data.technician = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.technician,
        setError: (value: Option<Array<string>>) => {
          errors.technician = value;
        },
        getTainted: () => tainted.technician,
        setTainted: (value: Option<boolean>) => {
          tainted.technician = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Commissions.validateField(
            "technician",
            data.technician,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      salesRep: {
        path: ["salesRep"] as const,
        name: "salesRep",
        constraints: { required: true },

        get: () => data.salesRep,
        set: (value: string) => {
          data.salesRep = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.salesRep,
        setError: (value: Option<Array<string>>) => {
          errors.salesRep = value;
        },
        getTainted: () => tainted.salesRep,
        setTainted: (value: Option<boolean>) => {
          tainted.salesRep = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Commissions.validateField(
            "salesRep",
            data.salesRep,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Commissions,
      Array<{ field: string; message: string }>
    > {
      return Commissions.fromObject(data);
    }
    function reset(newOverrides?: Partial<Commissions>): void {
      data = { ...Commissions.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        technician: Option.none(),
        salesRep: Option.none(),
      };
      tainted = { technician: Option.none(), salesRep: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Commissions, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.technician = formData.get("technician") ?? "";
    obj.salesRep = formData.get("salesRep") ?? "";
    return Commissions.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Number {
  /** @serde({ validate: ["nonEmpty"] }) */
  countryCode: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  areaCode: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  localNumber: string;
}

export function defaultValueNumber(): Number {
  return { countryCode: "", areaCode: "", localNumber: "" } as Number;
}

export function toStringifiedJSONNumber(value: Number): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeNumber(value, ctx));
}
export function toObjectNumber(value: Number): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeNumber(value, ctx);
}
export function __serializeNumber(
  value: Number,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Number", __id };
  result["countryCode"] = value.countryCode;
  result["areaCode"] = value.areaCode;
  result["localNumber"] = value.localNumber;
  return result;
}

export function fromStringifiedJSONNumber(
  json: string,
  opts?: DeserializeOptions,
): Result<Number, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectNumber(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectNumber(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Number, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeNumber(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Number.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeNumber(
  value: any,
  ctx: DeserializeContext,
): Number | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Number.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("countryCode" in obj)) {
    errors.push({ field: "countryCode", message: "missing required field" });
  }
  if (!("areaCode" in obj)) {
    errors.push({ field: "areaCode", message: "missing required field" });
  }
  if (!("localNumber" in obj)) {
    errors.push({ field: "localNumber", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_countryCode = obj["countryCode"] as string;
    if (__raw_countryCode.length === 0) {
      errors.push({ field: "countryCode", message: "must not be empty" });
    }
    instance.countryCode = __raw_countryCode;
  }
  {
    const __raw_areaCode = obj["areaCode"] as string;
    if (__raw_areaCode.length === 0) {
      errors.push({ field: "areaCode", message: "must not be empty" });
    }
    instance.areaCode = __raw_areaCode;
  }
  {
    const __raw_localNumber = obj["localNumber"] as string;
    if (__raw_localNumber.length === 0) {
      errors.push({ field: "localNumber", message: "must not be empty" });
    }
    instance.localNumber = __raw_localNumber;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Number;
}
export function validateFieldNumber<K extends keyof Number>(
  field: K,
  value: Number[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "countryCode": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "countryCode", message: "must not be empty" });
      }
      break;
    }
    case "areaCode": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "areaCode", message: "must not be empty" });
      }
      break;
    }
    case "localNumber": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "localNumber", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsNumber(
  partial: Partial<Number>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("countryCode" in partial && partial.countryCode !== undefined) {
    const __val = partial.countryCode as string;
    if (__val.length === 0) {
      errors.push({ field: "countryCode", message: "must not be empty" });
    }
  }
  if ("areaCode" in partial && partial.areaCode !== undefined) {
    const __val = partial.areaCode as string;
    if (__val.length === 0) {
      errors.push({ field: "areaCode", message: "must not be empty" });
    }
  }
  if ("localNumber" in partial && partial.localNumber !== undefined) {
    const __val = partial.localNumber as string;
    if (__val.length === 0) {
      errors.push({ field: "localNumber", message: "must not be empty" });
    }
  }
  return errors;
}
export function isNumber(obj: unknown): obj is Number {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "countryCode" in o && "areaCode" in o && "localNumber" in o;
}

export namespace Number {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    countryCode: Option<Array<string>>;
    areaCode: Option<Array<string>>;
    localNumber: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      countryCode: Option<boolean>;
      areaCode: Option<boolean>;
      localNumber: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly countryCode: FieldController<string>;
    readonly areaCode: FieldController<string>;
    readonly localNumber: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Number;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Number, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Number>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Number>,
  ): Gigaform {
    let data = $state({ ...Number.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      countryCode: Option.none(),
      areaCode: Option.none(),
      localNumber: Option.none(),
    });
    let tainted = $state<Tainted>({
      countryCode: Option.none(),
      areaCode: Option.none(),
      localNumber: Option.none(),
    });
    const fields: FieldControllers = {
      countryCode: {
        path: ["countryCode"] as const,
        name: "countryCode",
        constraints: { required: true },

        get: () => data.countryCode,
        set: (value: string) => {
          data.countryCode = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.countryCode,
        setError: (value: Option<Array<string>>) => {
          errors.countryCode = value;
        },
        getTainted: () => tainted.countryCode,
        setTainted: (value: Option<boolean>) => {
          tainted.countryCode = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Number.validateField(
            "countryCode",
            data.countryCode,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      areaCode: {
        path: ["areaCode"] as const,
        name: "areaCode",
        constraints: { required: true },

        get: () => data.areaCode,
        set: (value: string) => {
          data.areaCode = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.areaCode,
        setError: (value: Option<Array<string>>) => {
          errors.areaCode = value;
        },
        getTainted: () => tainted.areaCode,
        setTainted: (value: Option<boolean>) => {
          tainted.areaCode = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Number.validateField("areaCode", data.areaCode);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      localNumber: {
        path: ["localNumber"] as const,
        name: "localNumber",
        constraints: { required: true },

        get: () => data.localNumber,
        set: (value: string) => {
          data.localNumber = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.localNumber,
        setError: (value: Option<Array<string>>) => {
          errors.localNumber = value;
        },
        getTainted: () => tainted.localNumber,
        setTainted: (value: Option<boolean>) => {
          tainted.localNumber = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Number.validateField(
            "localNumber",
            data.localNumber,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Number,
      Array<{ field: string; message: string }>
    > {
      return Number.fromObject(data);
    }
    function reset(newOverrides?: Partial<Number>): void {
      data = { ...Number.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        countryCode: Option.none(),
        areaCode: Option.none(),
        localNumber: Option.none(),
      };
      tainted = {
        countryCode: Option.none(),
        areaCode: Option.none(),
        localNumber: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Number, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.countryCode = formData.get("countryCode") ?? "";
    obj.areaCode = formData.get("areaCode") ?? "";
    obj.localNumber = formData.get("localNumber") ?? "";
    return Number.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface DataPath {
  path: string[];
  formatter: string | null;
}

export function defaultValueDataPath(): DataPath {
  return { path: [], formatter: null } as DataPath;
}

export function toStringifiedJSONDataPath(value: DataPath): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeDataPath(value, ctx));
}
export function toObjectDataPath(value: DataPath): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeDataPath(value, ctx);
}
export function __serializeDataPath(
  value: DataPath,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "DataPath", __id };
  result["path"] = value.path.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  if (value.formatter !== null) {
    result["formatter"] =
      typeof (value.formatter as any)?.__serialize === "function"
        ? (value.formatter as any).__serialize(ctx)
        : value.formatter;
  } else {
    result["formatter"] = null;
  }
  return result;
}

export function fromStringifiedJSONDataPath(
  json: string,
  opts?: DeserializeOptions,
): Result<DataPath, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectDataPath(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectDataPath(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<DataPath, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeDataPath(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "DataPath.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeDataPath(
  value: any,
  ctx: DeserializeContext,
): DataPath | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "DataPath.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("path" in obj)) {
    errors.push({ field: "path", message: "missing required field" });
  }
  if (!("formatter" in obj)) {
    errors.push({ field: "formatter", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_path = obj["path"] as string[];
    if (Array.isArray(__raw_path)) {
      instance.path = __raw_path as string[];
    }
  }
  {
    const __raw_formatter = obj["formatter"] as string | null;
    if (__raw_formatter === null) {
      instance.formatter = null;
    } else if (typeof (__raw_formatter as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_formatter as any).__ref);
      ctx.assignOrDefer(instance, "formatter", __result);
    } else {
      instance.formatter = __raw_formatter;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as DataPath;
}
export function validateFieldDataPath<K extends keyof DataPath>(
  field: K,
  value: DataPath[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsDataPath(
  partial: Partial<DataPath>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isDataPath(obj: unknown): obj is DataPath {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "path" in o && "formatter" in o;
}

export namespace DataPath {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    path: Option<Array<string>>;
    formatter: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { path: Option<boolean>; formatter: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly path: ArrayFieldController<string>;
    readonly formatter: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: DataPath;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<DataPath, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<DataPath>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<DataPath>,
  ): Gigaform {
    let data = $state({ ...DataPath.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      path: Option.none(),
      formatter: Option.none(),
    });
    let tainted = $state<Tainted>({
      path: Option.none(),
      formatter: Option.none(),
    });
    const fields: FieldControllers = {
      path: {
        path: ["path"] as const,
        name: "path",
        constraints: { required: true },

        get: () => data.path,
        set: (value: string[]) => {
          data.path = value;
        },
        transform: (value: string[]): string[] => value,
        getError: () => errors.path,
        setError: (value: Option<Array<string>>) => {
          errors.path = value;
        },
        getTainted: () => tainted.path,
        setTainted: (value: Option<boolean>) => {
          tainted.path = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = DataPath.validateField("path", data.path);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["path", index] as const,
          name: `path.${index}`,
          constraints: { required: true },
          get: () => data.path[index]!,
          set: (value: string) => {
            data.path[index] = value;
          },
          transform: (value: string): string => value,
          getError: () => errors.path,
          setError: (value: Option<Array<string>>) => {
            errors.path = value;
          },
          getTainted: () => tainted.path,
          setTainted: (value: Option<boolean>) => {
            tainted.path = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.path.push(item);
        },
        remove: (index: number) => {
          data.path.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.path[a]!;
          data.path[a] = data.path[b]!;
          data.path[b] = tmp;
        },
      },
      formatter: {
        path: ["formatter"] as const,
        name: "formatter",
        constraints: { required: true },

        get: () => data.formatter,
        set: (value: string | null) => {
          data.formatter = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.formatter,
        setError: (value: Option<Array<string>>) => {
          errors.formatter = value;
        },
        getTainted: () => tainted.formatter,
        setTainted: (value: Option<boolean>) => {
          tainted.formatter = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = DataPath.validateField(
            "formatter",
            data.formatter,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      DataPath,
      Array<{ field: string; message: string }>
    > {
      return DataPath.fromObject(data);
    }
    function reset(newOverrides?: Partial<DataPath>): void {
      data = { ...DataPath.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        path: Option.none(),
        formatter: Option.none(),
      };
      tainted = { path: Option.none(), formatter: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<DataPath, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.path = formData.getAll("path") as Array<string>;
    obj.formatter = formData.get("formatter") ?? "";
    return DataPath.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Route {
  id: string;
  techs: (string | Employee)[] | null;
  active: boolean;
  /** @serde({ validate: ["nonEmpty"] }) */
  name: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  phone: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  position: string;
  serviceRoute: boolean;
  defaultDurationHours: number;
  tags: string[];
  icon: string | null;
  color: string | null;
}

export function defaultValueRoute(): Route {
  return {
    id: "",
    techs: null,
    active: false,
    name: "",
    phone: "",
    position: "",
    serviceRoute: false,
    defaultDurationHours: 0,
    tags: [],
    icon: null,
    color: null,
  } as Route;
}

export function toStringifiedJSONRoute(value: Route): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeRoute(value, ctx));
}
export function toObjectRoute(value: Route): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeRoute(value, ctx);
}
export function __serializeRoute(
  value: Route,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Route", __id };
  result["id"] = value.id;
  if (value.techs !== null) {
    result["techs"] =
      typeof (value.techs as any)?.__serialize === "function"
        ? (value.techs as any).__serialize(ctx)
        : value.techs;
  } else {
    result["techs"] = null;
  }
  result["active"] = value.active;
  result["name"] = value.name;
  result["phone"] = value.phone;
  result["position"] = value.position;
  result["serviceRoute"] = value.serviceRoute;
  result["defaultDurationHours"] = value.defaultDurationHours;
  result["tags"] = value.tags.map((item: any) =>
    typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
  );
  if (value.icon !== null) {
    result["icon"] =
      typeof (value.icon as any)?.__serialize === "function"
        ? (value.icon as any).__serialize(ctx)
        : value.icon;
  } else {
    result["icon"] = null;
  }
  if (value.color !== null) {
    result["color"] =
      typeof (value.color as any)?.__serialize === "function"
        ? (value.color as any).__serialize(ctx)
        : value.color;
  } else {
    result["color"] = null;
  }
  return result;
}

export function fromStringifiedJSONRoute(
  json: string,
  opts?: DeserializeOptions,
): Result<Route, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectRoute(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectRoute(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Route, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeRoute(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Route.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeRoute(
  value: any,
  ctx: DeserializeContext,
): Route | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Route.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("techs" in obj)) {
    errors.push({ field: "techs", message: "missing required field" });
  }
  if (!("active" in obj)) {
    errors.push({ field: "active", message: "missing required field" });
  }
  if (!("name" in obj)) {
    errors.push({ field: "name", message: "missing required field" });
  }
  if (!("phone" in obj)) {
    errors.push({ field: "phone", message: "missing required field" });
  }
  if (!("position" in obj)) {
    errors.push({ field: "position", message: "missing required field" });
  }
  if (!("serviceRoute" in obj)) {
    errors.push({ field: "serviceRoute", message: "missing required field" });
  }
  if (!("defaultDurationHours" in obj)) {
    errors.push({
      field: "defaultDurationHours",
      message: "missing required field",
    });
  }
  if (!("tags" in obj)) {
    errors.push({ field: "tags", message: "missing required field" });
  }
  if (!("icon" in obj)) {
    errors.push({ field: "icon", message: "missing required field" });
  }
  if (!("color" in obj)) {
    errors.push({ field: "color", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_techs = obj["techs"] as (string | Employee)[] | null;
    if (__raw_techs === null) {
      instance.techs = null;
    } else if (typeof (__raw_techs as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_techs as any).__ref);
      ctx.assignOrDefer(instance, "techs", __result);
    } else {
      instance.techs = __raw_techs;
    }
  }
  {
    const __raw_active = obj["active"] as boolean;
    instance.active = __raw_active;
  }
  {
    const __raw_name = obj["name"] as string;
    if (__raw_name.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
    instance.name = __raw_name;
  }
  {
    const __raw_phone = obj["phone"] as string;
    if (__raw_phone.length === 0) {
      errors.push({ field: "phone", message: "must not be empty" });
    }
    instance.phone = __raw_phone;
  }
  {
    const __raw_position = obj["position"] as string;
    if (__raw_position.length === 0) {
      errors.push({ field: "position", message: "must not be empty" });
    }
    instance.position = __raw_position;
  }
  {
    const __raw_serviceRoute = obj["serviceRoute"] as boolean;
    instance.serviceRoute = __raw_serviceRoute;
  }
  {
    const __raw_defaultDurationHours = obj["defaultDurationHours"] as number;
    instance.defaultDurationHours = __raw_defaultDurationHours;
  }
  {
    const __raw_tags = obj["tags"] as string[];
    if (Array.isArray(__raw_tags)) {
      instance.tags = __raw_tags as string[];
    }
  }
  {
    const __raw_icon = obj["icon"] as string | null;
    if (__raw_icon === null) {
      instance.icon = null;
    } else if (typeof (__raw_icon as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_icon as any).__ref);
      ctx.assignOrDefer(instance, "icon", __result);
    } else {
      instance.icon = __raw_icon;
    }
  }
  {
    const __raw_color = obj["color"] as string | null;
    if (__raw_color === null) {
      instance.color = null;
    } else if (typeof (__raw_color as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_color as any).__ref);
      ctx.assignOrDefer(instance, "color", __result);
    } else {
      instance.color = __raw_color;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Route;
}
export function validateFieldRoute<K extends keyof Route>(
  field: K,
  value: Route[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "name": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
      break;
    }
    case "phone": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "phone", message: "must not be empty" });
      }
      break;
    }
    case "position": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "position", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsRoute(
  partial: Partial<Route>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("name" in partial && partial.name !== undefined) {
    const __val = partial.name as string;
    if (__val.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
  }
  if ("phone" in partial && partial.phone !== undefined) {
    const __val = partial.phone as string;
    if (__val.length === 0) {
      errors.push({ field: "phone", message: "must not be empty" });
    }
  }
  if ("position" in partial && partial.position !== undefined) {
    const __val = partial.position as string;
    if (__val.length === 0) {
      errors.push({ field: "position", message: "must not be empty" });
    }
  }
  return errors;
}
export function isRoute(obj: unknown): obj is Route {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "id" in o &&
    "techs" in o &&
    "active" in o &&
    "name" in o &&
    "phone" in o &&
    "position" in o &&
    "serviceRoute" in o &&
    "defaultDurationHours" in o &&
    "tags" in o &&
    "icon" in o &&
    "color" in o
  );
}

export namespace Route {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    techs: Option<Array<string>>;
    active: Option<Array<string>>;
    name: Option<Array<string>>;
    phone: Option<Array<string>>;
    position: Option<Array<string>>;
    serviceRoute: Option<Array<string>>;
    defaultDurationHours: Option<Array<string>>;
    tags: Option<Array<string>>;
    icon: Option<Array<string>>;
    color: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      techs: Option<boolean>;
      active: Option<boolean>;
      name: Option<boolean>;
      phone: Option<boolean>;
      position: Option<boolean>;
      serviceRoute: Option<boolean>;
      defaultDurationHours: Option<boolean>;
      tags: Option<boolean>;
      icon: Option<boolean>;
      color: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly techs: FieldController<(string | Employee)[] | null>;
    readonly active: FieldController<boolean>;
    readonly name: FieldController<string>;
    readonly phone: FieldController<string>;
    readonly position: FieldController<string>;
    readonly serviceRoute: FieldController<boolean>;
    readonly defaultDurationHours: FieldController<number>;
    readonly tags: ArrayFieldController<string>;
    readonly icon: FieldController<string | null>;
    readonly color: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Route;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Route, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Route>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Route>,
  ): Gigaform {
    let data = $state({ ...Route.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      techs: Option.none(),
      active: Option.none(),
      name: Option.none(),
      phone: Option.none(),
      position: Option.none(),
      serviceRoute: Option.none(),
      defaultDurationHours: Option.none(),
      tags: Option.none(),
      icon: Option.none(),
      color: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      techs: Option.none(),
      active: Option.none(),
      name: Option.none(),
      phone: Option.none(),
      position: Option.none(),
      serviceRoute: Option.none(),
      defaultDurationHours: Option.none(),
      tags: Option.none(),
      icon: Option.none(),
      color: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Route.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      techs: {
        path: ["techs"] as const,
        name: "techs",
        constraints: { required: true },

        get: () => data.techs,
        set: (value: (string | Employee)[] | null) => {
          data.techs = value;
        },
        transform: (
          value: (string | Employee)[] | null,
        ): (string | Employee)[] | null => value,
        getError: () => errors.techs,
        setError: (value: Option<Array<string>>) => {
          errors.techs = value;
        },
        getTainted: () => tainted.techs,
        setTainted: (value: Option<boolean>) => {
          tainted.techs = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Route.validateField("techs", data.techs);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      active: {
        path: ["active"] as const,
        name: "active",
        constraints: { required: true },

        get: () => data.active,
        set: (value: boolean) => {
          data.active = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.active,
        setError: (value: Option<Array<string>>) => {
          errors.active = value;
        },
        getTainted: () => tainted.active,
        setTainted: (value: Option<boolean>) => {
          tainted.active = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Route.validateField("active", data.active);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },

        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Route.validateField("name", data.name);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      phone: {
        path: ["phone"] as const,
        name: "phone",
        constraints: { required: true },

        get: () => data.phone,
        set: (value: string) => {
          data.phone = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.phone,
        setError: (value: Option<Array<string>>) => {
          errors.phone = value;
        },
        getTainted: () => tainted.phone,
        setTainted: (value: Option<boolean>) => {
          tainted.phone = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Route.validateField("phone", data.phone);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      position: {
        path: ["position"] as const,
        name: "position",
        constraints: { required: true },

        get: () => data.position,
        set: (value: string) => {
          data.position = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.position,
        setError: (value: Option<Array<string>>) => {
          errors.position = value;
        },
        getTainted: () => tainted.position,
        setTainted: (value: Option<boolean>) => {
          tainted.position = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Route.validateField("position", data.position);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      serviceRoute: {
        path: ["serviceRoute"] as const,
        name: "serviceRoute",
        constraints: { required: true },

        get: () => data.serviceRoute,
        set: (value: boolean) => {
          data.serviceRoute = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.serviceRoute,
        setError: (value: Option<Array<string>>) => {
          errors.serviceRoute = value;
        },
        getTainted: () => tainted.serviceRoute,
        setTainted: (value: Option<boolean>) => {
          tainted.serviceRoute = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Route.validateField(
            "serviceRoute",
            data.serviceRoute,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      defaultDurationHours: {
        path: ["defaultDurationHours"] as const,
        name: "defaultDurationHours",
        constraints: { required: true },

        get: () => data.defaultDurationHours,
        set: (value: number) => {
          data.defaultDurationHours = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.defaultDurationHours,
        setError: (value: Option<Array<string>>) => {
          errors.defaultDurationHours = value;
        },
        getTainted: () => tainted.defaultDurationHours,
        setTainted: (value: Option<boolean>) => {
          tainted.defaultDurationHours = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Route.validateField(
            "defaultDurationHours",
            data.defaultDurationHours,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      tags: {
        path: ["tags"] as const,
        name: "tags",
        constraints: { required: true },

        get: () => data.tags,
        set: (value: string[]) => {
          data.tags = value;
        },
        transform: (value: string[]): string[] => value,
        getError: () => errors.tags,
        setError: (value: Option<Array<string>>) => {
          errors.tags = value;
        },
        getTainted: () => tainted.tags,
        setTainted: (value: Option<boolean>) => {
          tainted.tags = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Route.validateField("tags", data.tags);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
        at: (index: number) => ({
          path: ["tags", index] as const,
          name: `tags.${index}`,
          constraints: { required: true },
          get: () => data.tags[index]!,
          set: (value: string) => {
            data.tags[index] = value;
          },
          transform: (value: string): string => value,
          getError: () => errors.tags,
          setError: (value: Option<Array<string>>) => {
            errors.tags = value;
          },
          getTainted: () => tainted.tags,
          setTainted: (value: Option<boolean>) => {
            tainted.tags = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.tags.push(item);
        },
        remove: (index: number) => {
          data.tags.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          const tmp = data.tags[a]!;
          data.tags[a] = data.tags[b]!;
          data.tags[b] = tmp;
        },
      },
      icon: {
        path: ["icon"] as const,
        name: "icon",
        constraints: { required: true },

        get: () => data.icon,
        set: (value: string | null) => {
          data.icon = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.icon,
        setError: (value: Option<Array<string>>) => {
          errors.icon = value;
        },
        getTainted: () => tainted.icon,
        setTainted: (value: Option<boolean>) => {
          tainted.icon = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Route.validateField("icon", data.icon);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      color: {
        path: ["color"] as const,
        name: "color",
        constraints: { required: true },

        get: () => data.color,
        set: (value: string | null) => {
          data.color = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.color,
        setError: (value: Option<Array<string>>) => {
          errors.color = value;
        },
        getTainted: () => tainted.color,
        setTainted: (value: Option<boolean>) => {
          tainted.color = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Route.validateField("color", data.color);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Route,
      Array<{ field: string; message: string }>
    > {
      return Route.fromObject(data);
    }
    function reset(newOverrides?: Partial<Route>): void {
      data = { ...Route.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        techs: Option.none(),
        active: Option.none(),
        name: Option.none(),
        phone: Option.none(),
        position: Option.none(),
        serviceRoute: Option.none(),
        defaultDurationHours: Option.none(),
        tags: Option.none(),
        icon: Option.none(),
        color: Option.none(),
      };
      tainted = {
        id: Option.none(),
        techs: Option.none(),
        active: Option.none(),
        name: Option.none(),
        phone: Option.none(),
        position: Option.none(),
        serviceRoute: Option.none(),
        defaultDurationHours: Option.none(),
        tags: Option.none(),
        icon: Option.none(),
        color: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Route, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.techs = formData.get("techs") ?? "";
    {
      const activeVal = formData.get("active");
      obj.active =
        activeVal === "true" || activeVal === "on" || activeVal === "1";
    }
    obj.name = formData.get("name") ?? "";
    obj.phone = formData.get("phone") ?? "";
    obj.position = formData.get("position") ?? "";
    {
      const serviceRouteVal = formData.get("serviceRoute");
      obj.serviceRoute =
        serviceRouteVal === "true" ||
        serviceRouteVal === "on" ||
        serviceRouteVal === "1";
    }
    {
      const defaultDurationHoursStr = formData.get("defaultDurationHours");
      obj.defaultDurationHours = defaultDurationHoursStr
        ? parseFloat(defaultDurationHoursStr as string)
        : 0;
      if (
        obj.defaultDurationHours !== undefined &&
        isNaN(obj.defaultDurationHours as number)
      )
        obj.defaultDurationHours = 0;
    }
    obj.tags = formData.getAll("tags") as Array<string>;
    obj.icon = formData.get("icon") ?? "";
    obj.color = formData.get("color") ?? "";
    return Route.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface EmailParts {
  /** @serde({ validate: ["nonEmpty"] }) */
  local: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  domainName: string;
  /** @serde({ validate: ["nonEmpty"] }) */
  topLevelDomain: string;
}

export function defaultValueEmailParts(): EmailParts {
  return { local: "", domainName: "", topLevelDomain: "" } as EmailParts;
}

export function toStringifiedJSONEmailParts(value: EmailParts): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeEmailParts(value, ctx));
}
export function toObjectEmailParts(value: EmailParts): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeEmailParts(value, ctx);
}
export function __serializeEmailParts(
  value: EmailParts,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "EmailParts", __id };
  result["local"] = value.local;
  result["domainName"] = value.domainName;
  result["topLevelDomain"] = value.topLevelDomain;
  return result;
}

export function fromStringifiedJSONEmailParts(
  json: string,
  opts?: DeserializeOptions,
): Result<EmailParts, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectEmailParts(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectEmailParts(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<EmailParts, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeEmailParts(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "EmailParts.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeEmailParts(
  value: any,
  ctx: DeserializeContext,
): EmailParts | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "EmailParts.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("local" in obj)) {
    errors.push({ field: "local", message: "missing required field" });
  }
  if (!("domainName" in obj)) {
    errors.push({ field: "domainName", message: "missing required field" });
  }
  if (!("topLevelDomain" in obj)) {
    errors.push({ field: "topLevelDomain", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_local = obj["local"] as string;
    if (__raw_local.length === 0) {
      errors.push({ field: "local", message: "must not be empty" });
    }
    instance.local = __raw_local;
  }
  {
    const __raw_domainName = obj["domainName"] as string;
    if (__raw_domainName.length === 0) {
      errors.push({ field: "domainName", message: "must not be empty" });
    }
    instance.domainName = __raw_domainName;
  }
  {
    const __raw_topLevelDomain = obj["topLevelDomain"] as string;
    if (__raw_topLevelDomain.length === 0) {
      errors.push({ field: "topLevelDomain", message: "must not be empty" });
    }
    instance.topLevelDomain = __raw_topLevelDomain;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as EmailParts;
}
export function validateFieldEmailParts<K extends keyof EmailParts>(
  field: K,
  value: EmailParts[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "local": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "local", message: "must not be empty" });
      }
      break;
    }
    case "domainName": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "domainName", message: "must not be empty" });
      }
      break;
    }
    case "topLevelDomain": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "topLevelDomain", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsEmailParts(
  partial: Partial<EmailParts>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("local" in partial && partial.local !== undefined) {
    const __val = partial.local as string;
    if (__val.length === 0) {
      errors.push({ field: "local", message: "must not be empty" });
    }
  }
  if ("domainName" in partial && partial.domainName !== undefined) {
    const __val = partial.domainName as string;
    if (__val.length === 0) {
      errors.push({ field: "domainName", message: "must not be empty" });
    }
  }
  if ("topLevelDomain" in partial && partial.topLevelDomain !== undefined) {
    const __val = partial.topLevelDomain as string;
    if (__val.length === 0) {
      errors.push({ field: "topLevelDomain", message: "must not be empty" });
    }
  }
  return errors;
}
export function isEmailParts(obj: unknown): obj is EmailParts {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "local" in o && "domainName" in o && "topLevelDomain" in o;
}

export namespace EmailParts {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    local: Option<Array<string>>;
    domainName: Option<Array<string>>;
    topLevelDomain: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      local: Option<boolean>;
      domainName: Option<boolean>;
      topLevelDomain: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly local: FieldController<string>;
    readonly domainName: FieldController<string>;
    readonly topLevelDomain: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: EmailParts;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<EmailParts, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<EmailParts>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<EmailParts>,
  ): Gigaform {
    let data = $state({ ...EmailParts.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      local: Option.none(),
      domainName: Option.none(),
      topLevelDomain: Option.none(),
    });
    let tainted = $state<Tainted>({
      local: Option.none(),
      domainName: Option.none(),
      topLevelDomain: Option.none(),
    });
    const fields: FieldControllers = {
      local: {
        path: ["local"] as const,
        name: "local",
        constraints: { required: true },

        get: () => data.local,
        set: (value: string) => {
          data.local = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.local,
        setError: (value: Option<Array<string>>) => {
          errors.local = value;
        },
        getTainted: () => tainted.local,
        setTainted: (value: Option<boolean>) => {
          tainted.local = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = EmailParts.validateField("local", data.local);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      domainName: {
        path: ["domainName"] as const,
        name: "domainName",
        constraints: { required: true },

        get: () => data.domainName,
        set: (value: string) => {
          data.domainName = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.domainName,
        setError: (value: Option<Array<string>>) => {
          errors.domainName = value;
        },
        getTainted: () => tainted.domainName,
        setTainted: (value: Option<boolean>) => {
          tainted.domainName = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = EmailParts.validateField(
            "domainName",
            data.domainName,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      topLevelDomain: {
        path: ["topLevelDomain"] as const,
        name: "topLevelDomain",
        constraints: { required: true },

        get: () => data.topLevelDomain,
        set: (value: string) => {
          data.topLevelDomain = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.topLevelDomain,
        setError: (value: Option<Array<string>>) => {
          errors.topLevelDomain = value;
        },
        getTainted: () => tainted.topLevelDomain,
        setTainted: (value: Option<boolean>) => {
          tainted.topLevelDomain = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = EmailParts.validateField(
            "topLevelDomain",
            data.topLevelDomain,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      EmailParts,
      Array<{ field: string; message: string }>
    > {
      return EmailParts.fromObject(data);
    }
    function reset(newOverrides?: Partial<EmailParts>): void {
      data = { ...EmailParts.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        local: Option.none(),
        domainName: Option.none(),
        topLevelDomain: Option.none(),
      };
      tainted = {
        local: Option.none(),
        domainName: Option.none(),
        topLevelDomain: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<EmailParts, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.local = formData.get("local") ?? "";
    obj.domainName = formData.get("domainName") ?? "";
    obj.topLevelDomain = formData.get("topLevelDomain") ?? "";
    return EmailParts.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Sent {
  recipient: string | null;
  method: string | null;
}

export function defaultValueSent(): Sent {
  return { recipient: null, method: null } as Sent;
}

export function toStringifiedJSONSent(value: Sent): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeSent(value, ctx));
}
export function toObjectSent(value: Sent): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeSent(value, ctx);
}
export function __serializeSent(
  value: Sent,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Sent", __id };
  if (value.recipient !== null) {
    result["recipient"] =
      typeof (value.recipient as any)?.__serialize === "function"
        ? (value.recipient as any).__serialize(ctx)
        : value.recipient;
  } else {
    result["recipient"] = null;
  }
  if (value.method !== null) {
    result["method"] =
      typeof (value.method as any)?.__serialize === "function"
        ? (value.method as any).__serialize(ctx)
        : value.method;
  } else {
    result["method"] = null;
  }
  return result;
}

export function fromStringifiedJSONSent(
  json: string,
  opts?: DeserializeOptions,
): Result<Sent, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectSent(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectSent(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Sent, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeSent(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Sent.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeSent(
  value: any,
  ctx: DeserializeContext,
): Sent | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Sent.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("recipient" in obj)) {
    errors.push({ field: "recipient", message: "missing required field" });
  }
  if (!("method" in obj)) {
    errors.push({ field: "method", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_recipient = obj["recipient"] as string | null;
    if (__raw_recipient === null) {
      instance.recipient = null;
    } else if (typeof (__raw_recipient as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_recipient as any).__ref);
      ctx.assignOrDefer(instance, "recipient", __result);
    } else {
      instance.recipient = __raw_recipient;
    }
  }
  {
    const __raw_method = obj["method"] as string | null;
    if (__raw_method === null) {
      instance.method = null;
    } else if (typeof (__raw_method as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_method as any).__ref);
      ctx.assignOrDefer(instance, "method", __result);
    } else {
      instance.method = __raw_method;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Sent;
}
export function validateFieldSent<K extends keyof Sent>(
  field: K,
  value: Sent[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsSent(
  partial: Partial<Sent>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isSent(obj: unknown): obj is Sent {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "recipient" in o && "method" in o;
}

export namespace Sent {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    recipient: Option<Array<string>>;
    method: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { recipient: Option<boolean>; method: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly recipient: FieldController<string | null>;
    readonly method: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Sent;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Sent, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Sent>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Sent>,
  ): Gigaform {
    let data = $state({ ...Sent.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      recipient: Option.none(),
      method: Option.none(),
    });
    let tainted = $state<Tainted>({
      recipient: Option.none(),
      method: Option.none(),
    });
    const fields: FieldControllers = {
      recipient: {
        path: ["recipient"] as const,
        name: "recipient",
        constraints: { required: true },

        get: () => data.recipient,
        set: (value: string | null) => {
          data.recipient = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.recipient,
        setError: (value: Option<Array<string>>) => {
          errors.recipient = value;
        },
        getTainted: () => tainted.recipient,
        setTainted: (value: Option<boolean>) => {
          tainted.recipient = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Sent.validateField("recipient", data.recipient);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      method: {
        path: ["method"] as const,
        name: "method",
        constraints: { required: true },

        get: () => data.method,
        set: (value: string | null) => {
          data.method = value;
        },
        transform: (value: string | null): string | null => value,
        getError: () => errors.method,
        setError: (value: Option<Array<string>>) => {
          errors.method = value;
        },
        getTainted: () => tainted.method,
        setTainted: (value: Option<boolean>) => {
          tainted.method = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Sent.validateField("method", data.method);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Sent,
      Array<{ field: string; message: string }>
    > {
      return Sent.fromObject(data);
    }
    function reset(newOverrides?: Partial<Sent>): void {
      data = { ...Sent.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        recipient: Option.none(),
        method: Option.none(),
      };
      tainted = { recipient: Option.none(), method: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Sent, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.recipient = formData.get("recipient") ?? "";
    obj.method = formData.get("method") ?? "";
    return Sent.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface BilledItem {
  /** @comboboxController({ label: "Item", allowCustom: true, fetchUrls: ["/api/products", "/api/services"] }) */
  /** @default("") */
  item: Item;
  /** @numberController({ label: "Quantity", min: 0, step: 1 }) */
  quantity: number;
  /** @switchController({ label: "Taxed" }) */
  taxed: boolean;
  /** @switchController({ label: "Upsale" }) */
  upsale: boolean;
}

export function defaultValueBilledItem(): BilledItem {
  return { item: "", quantity: 0, taxed: false, upsale: false } as BilledItem;
}

export function toStringifiedJSONBilledItem(value: BilledItem): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeBilledItem(value, ctx));
}
export function toObjectBilledItem(value: BilledItem): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeBilledItem(value, ctx);
}
export function __serializeBilledItem(
  value: BilledItem,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "BilledItem", __id };
  result["item"] =
    typeof (value.item as any)?.__serialize === "function"
      ? (value.item as any).__serialize(ctx)
      : value.item;
  result["quantity"] = value.quantity;
  result["taxed"] = value.taxed;
  result["upsale"] = value.upsale;
  return result;
}

export function fromStringifiedJSONBilledItem(
  json: string,
  opts?: DeserializeOptions,
): Result<BilledItem, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectBilledItem(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectBilledItem(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<BilledItem, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeBilledItem(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "BilledItem.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeBilledItem(
  value: any,
  ctx: DeserializeContext,
): BilledItem | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "BilledItem.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("item" in obj)) {
    errors.push({ field: "item", message: "missing required field" });
  }
  if (!("quantity" in obj)) {
    errors.push({ field: "quantity", message: "missing required field" });
  }
  if (!("taxed" in obj)) {
    errors.push({ field: "taxed", message: "missing required field" });
  }
  if (!("upsale" in obj)) {
    errors.push({ field: "upsale", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_item = obj["item"] as Item;
    if (typeof (Item as any)?.__deserialize === "function") {
      const __result = (Item as any).__deserialize(__raw_item, ctx);
      ctx.assignOrDefer(instance, "item", __result);
    } else {
      instance.item = __raw_item;
    }
  }
  {
    const __raw_quantity = obj["quantity"] as number;
    instance.quantity = __raw_quantity;
  }
  {
    const __raw_taxed = obj["taxed"] as boolean;
    instance.taxed = __raw_taxed;
  }
  {
    const __raw_upsale = obj["upsale"] as boolean;
    instance.upsale = __raw_upsale;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as BilledItem;
}
export function validateFieldBilledItem<K extends keyof BilledItem>(
  field: K,
  value: BilledItem[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsBilledItem(
  partial: Partial<BilledItem>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isBilledItem(obj: unknown): obj is BilledItem {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "item" in o && "quantity" in o && "taxed" in o && "upsale" in o;
}

export namespace BilledItem {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    item: Option<Array<string>>;
    quantity: Option<Array<string>>;
    taxed: Option<Array<string>>;
    upsale: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      item: Option<boolean>;
      quantity: Option<boolean>;
      taxed: Option<boolean>;
      upsale: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly item: FieldController<Item>;
    readonly quantity: FieldController<number>;
    readonly taxed: FieldController<boolean>;
    readonly upsale: FieldController<boolean>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: BilledItem;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<BilledItem, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<BilledItem>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<BilledItem>,
  ): Gigaform {
    let data = $state({ ...BilledItem.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      item: Option.none(),
      quantity: Option.none(),
      taxed: Option.none(),
      upsale: Option.none(),
    });
    let tainted = $state<Tainted>({
      item: Option.none(),
      quantity: Option.none(),
      taxed: Option.none(),
      upsale: Option.none(),
    });
    const fields: FieldControllers = {
      item: {
        path: ["item"] as const,
        name: "item",
        constraints: { required: true },
        label: "Item",
        get: () => data.item,
        set: (value: Item) => {
          data.item = value;
        },
        transform: (value: Item): Item => value,
        getError: () => errors.item,
        setError: (value: Option<Array<string>>) => {
          errors.item = value;
        },
        getTainted: () => tainted.item,
        setTainted: (value: Option<boolean>) => {
          tainted.item = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = BilledItem.validateField("item", data.item);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      quantity: {
        path: ["quantity"] as const,
        name: "quantity",
        constraints: { required: true },
        label: "Quantity",
        get: () => data.quantity,
        set: (value: number) => {
          data.quantity = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.quantity,
        setError: (value: Option<Array<string>>) => {
          errors.quantity = value;
        },
        getTainted: () => tainted.quantity,
        setTainted: (value: Option<boolean>) => {
          tainted.quantity = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = BilledItem.validateField(
            "quantity",
            data.quantity,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      taxed: {
        path: ["taxed"] as const,
        name: "taxed",
        constraints: { required: true },
        label: "Taxed",
        get: () => data.taxed,
        set: (value: boolean) => {
          data.taxed = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.taxed,
        setError: (value: Option<Array<string>>) => {
          errors.taxed = value;
        },
        getTainted: () => tainted.taxed,
        setTainted: (value: Option<boolean>) => {
          tainted.taxed = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = BilledItem.validateField("taxed", data.taxed);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      upsale: {
        path: ["upsale"] as const,
        name: "upsale",
        constraints: { required: true },
        label: "Upsale",
        get: () => data.upsale,
        set: (value: boolean) => {
          data.upsale = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.upsale,
        setError: (value: Option<Array<string>>) => {
          errors.upsale = value;
        },
        getTainted: () => tainted.upsale,
        setTainted: (value: Option<boolean>) => {
          tainted.upsale = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = BilledItem.validateField("upsale", data.upsale);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      BilledItem,
      Array<{ field: string; message: string }>
    > {
      return BilledItem.fromObject(data);
    }
    function reset(newOverrides?: Partial<BilledItem>): void {
      data = { ...BilledItem.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        item: Option.none(),
        quantity: Option.none(),
        taxed: Option.none(),
        upsale: Option.none(),
      };
      tainted = {
        item: Option.none(),
        quantity: Option.none(),
        taxed: Option.none(),
        upsale: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<BilledItem, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect nested object fields with prefix "item."
      const itemObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("item.")) {
          const fieldName = key.slice("item.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = itemObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.item = itemObj;
    }
    {
      const quantityStr = formData.get("quantity");
      obj.quantity = quantityStr ? parseFloat(quantityStr as string) : 0;
      if (obj.quantity !== undefined && isNaN(obj.quantity as number))
        obj.quantity = 0;
    }
    {
      const taxedVal = formData.get("taxed");
      obj.taxed = taxedVal === "true" || taxedVal === "on" || taxedVal === "1";
    }
    {
      const upsaleVal = formData.get("upsale");
      obj.upsale =
        upsaleVal === "true" || upsaleVal === "on" || upsaleVal === "1";
    }
    return BilledItem.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Coordinates {
  lat: number;
  lng: number;
}

export function defaultValueCoordinates(): Coordinates {
  return { lat: 0, lng: 0 } as Coordinates;
}

export function toStringifiedJSONCoordinates(value: Coordinates): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeCoordinates(value, ctx));
}
export function toObjectCoordinates(
  value: Coordinates,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeCoordinates(value, ctx);
}
export function __serializeCoordinates(
  value: Coordinates,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Coordinates", __id };
  result["lat"] = value.lat;
  result["lng"] = value.lng;
  return result;
}

export function fromStringifiedJSONCoordinates(
  json: string,
  opts?: DeserializeOptions,
): Result<Coordinates, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectCoordinates(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectCoordinates(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Coordinates, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeCoordinates(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Coordinates.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeCoordinates(
  value: any,
  ctx: DeserializeContext,
): Coordinates | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "Coordinates.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("lat" in obj)) {
    errors.push({ field: "lat", message: "missing required field" });
  }
  if (!("lng" in obj)) {
    errors.push({ field: "lng", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_lat = obj["lat"] as number;
    instance.lat = __raw_lat;
  }
  {
    const __raw_lng = obj["lng"] as number;
    instance.lng = __raw_lng;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Coordinates;
}
export function validateFieldCoordinates<K extends keyof Coordinates>(
  field: K,
  value: Coordinates[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsCoordinates(
  partial: Partial<Coordinates>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isCoordinates(obj: unknown): obj is Coordinates {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "lat" in o && "lng" in o;
}

export namespace Coordinates {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    lat: Option<Array<string>>;
    lng: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { lat: Option<boolean>; lng: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly lat: FieldController<number>;
    readonly lng: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Coordinates;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Coordinates, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Coordinates>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Coordinates>,
  ): Gigaform {
    let data = $state({ ...Coordinates.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      lat: Option.none(),
      lng: Option.none(),
    });
    let tainted = $state<Tainted>({ lat: Option.none(), lng: Option.none() });
    const fields: FieldControllers = {
      lat: {
        path: ["lat"] as const,
        name: "lat",
        constraints: { required: true },

        get: () => data.lat,
        set: (value: number) => {
          data.lat = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.lat,
        setError: (value: Option<Array<string>>) => {
          errors.lat = value;
        },
        getTainted: () => tainted.lat,
        setTainted: (value: Option<boolean>) => {
          tainted.lat = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Coordinates.validateField("lat", data.lat);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      lng: {
        path: ["lng"] as const,
        name: "lng",
        constraints: { required: true },

        get: () => data.lng,
        set: (value: number) => {
          data.lng = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.lng,
        setError: (value: Option<Array<string>>) => {
          errors.lng = value;
        },
        getTainted: () => tainted.lng,
        setTainted: (value: Option<boolean>) => {
          tainted.lng = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Coordinates.validateField("lng", data.lng);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Coordinates,
      Array<{ field: string; message: string }>
    > {
      return Coordinates.fromObject(data);
    }
    function reset(newOverrides?: Partial<Coordinates>): void {
      data = { ...Coordinates.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        lat: Option.none(),
        lng: Option.none(),
      };
      tainted = { lat: Option.none(), lng: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Coordinates, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const latStr = formData.get("lat");
      obj.lat = latStr ? parseFloat(latStr as string) : 0;
      if (obj.lat !== undefined && isNaN(obj.lat as number)) obj.lat = 0;
    }
    {
      const lngStr = formData.get("lng");
      obj.lng = lngStr ? parseFloat(lngStr as string) : 0;
      if (obj.lng !== undefined && isNaN(obj.lng as number)) obj.lng = 0;
    }
    return Coordinates.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Ordered {
  id: string;
  /** @default("") */
  in: string | Account;
  /** @default("") */
  out: string | Order;
  date: string;
}

export function defaultValueOrdered(): Ordered {
  return { id: "", in: "", out: "", date: "" } as Ordered;
}

export function toStringifiedJSONOrdered(value: Ordered): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeOrdered(value, ctx));
}
export function toObjectOrdered(value: Ordered): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeOrdered(value, ctx);
}
export function __serializeOrdered(
  value: Ordered,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Ordered", __id };
  result["id"] = value.id;
  result["in"] = value.in;
  result["out"] = value.out;
  result["date"] = value.date;
  return result;
}

export function fromStringifiedJSONOrdered(
  json: string,
  opts?: DeserializeOptions,
): Result<Ordered, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectOrdered(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectOrdered(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Ordered, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeOrdered(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Ordered.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeOrdered(
  value: any,
  ctx: DeserializeContext,
): Ordered | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Ordered.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("id" in obj)) {
    errors.push({ field: "id", message: "missing required field" });
  }
  if (!("in" in obj)) {
    errors.push({ field: "in", message: "missing required field" });
  }
  if (!("out" in obj)) {
    errors.push({ field: "out", message: "missing required field" });
  }
  if (!("date" in obj)) {
    errors.push({ field: "date", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_id = obj["id"] as string;
    instance.id = __raw_id;
  }
  {
    const __raw_in = obj["in"] as string | Account;
    instance.in = __raw_in;
  }
  {
    const __raw_out = obj["out"] as string | Order;
    instance.out = __raw_out;
  }
  {
    const __raw_date = obj["date"] as string;
    instance.date = __raw_date;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Ordered;
}
export function validateFieldOrdered<K extends keyof Ordered>(
  field: K,
  value: Ordered[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsOrdered(
  partial: Partial<Ordered>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isOrdered(obj: unknown): obj is Ordered {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "id" in o && "in" in o && "out" in o && "date" in o;
}

export namespace Ordered {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    in: Option<Array<string>>;
    out: Option<Array<string>>;
    date: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      in: Option<boolean>;
      out: Option<boolean>;
      date: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly in: FieldController<string | Account>;
    readonly out: FieldController<string | Order>;
    readonly date: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Ordered;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Ordered, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Ordered>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Ordered>,
  ): Gigaform {
    let data = $state({ ...Ordered.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      in: Option.none(),
      out: Option.none(),
      date: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      in: Option.none(),
      out: Option.none(),
      date: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Ordered.validateField("id", data.id);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      in: {
        path: ["in"] as const,
        name: "in",
        constraints: { required: true },

        get: () => data.in,
        set: (value: string | Account) => {
          data.in = value;
        },
        transform: (value: string | Account): string | Account => value,
        getError: () => errors.in,
        setError: (value: Option<Array<string>>) => {
          errors.in = value;
        },
        getTainted: () => tainted.in,
        setTainted: (value: Option<boolean>) => {
          tainted.in = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Ordered.validateField("in", data.in);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      out: {
        path: ["out"] as const,
        name: "out",
        constraints: { required: true },

        get: () => data.out,
        set: (value: string | Order) => {
          data.out = value;
        },
        transform: (value: string | Order): string | Order => value,
        getError: () => errors.out,
        setError: (value: Option<Array<string>>) => {
          errors.out = value;
        },
        getTainted: () => tainted.out,
        setTainted: (value: Option<boolean>) => {
          tainted.out = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Ordered.validateField("out", data.out);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      date: {
        path: ["date"] as const,
        name: "date",
        constraints: { required: true },

        get: () => data.date,
        set: (value: string) => {
          data.date = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.date,
        setError: (value: Option<Array<string>>) => {
          errors.date = value;
        },
        getTainted: () => tainted.date,
        setTainted: (value: Option<boolean>) => {
          tainted.date = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Ordered.validateField("date", data.date);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Ordered,
      Array<{ field: string; message: string }>
    > {
      return Ordered.fromObject(data);
    }
    function reset(newOverrides?: Partial<Ordered>): void {
      data = { ...Ordered.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        in: Option.none(),
        out: Option.none(),
        date: Option.none(),
      };
      tainted = {
        id: Option.none(),
        in: Option.none(),
        out: Option.none(),
        date: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Ordered, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.in = formData.get("in") ?? "";
    obj.out = formData.get("out") ?? "";
    obj.date = formData.get("date") ?? "";
    return Ordered.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Email {
  /** @switchController({ label: "Can Email" }) */
  canEmail: boolean;
  /** @textController({ label: "Email" }) */
  /** @serde({ validate: ["nonEmpty", "email"] }) */
  emailString: string;
}

export function defaultValueEmail(): Email {
  return { canEmail: false, emailString: "" } as Email;
}

export function toStringifiedJSONEmail(value: Email): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeEmail(value, ctx));
}
export function toObjectEmail(value: Email): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeEmail(value, ctx);
}
export function __serializeEmail(
  value: Email,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Email", __id };
  result["canEmail"] = value.canEmail;
  result["emailString"] = value.emailString;
  return result;
}

export function fromStringifiedJSONEmail(
  json: string,
  opts?: DeserializeOptions,
): Result<Email, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectEmail(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectEmail(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Email, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeEmail(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Email.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeEmail(
  value: any,
  ctx: DeserializeContext,
): Email | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Email.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("canEmail" in obj)) {
    errors.push({ field: "canEmail", message: "missing required field" });
  }
  if (!("emailString" in obj)) {
    errors.push({ field: "emailString", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_canEmail = obj["canEmail"] as boolean;
    instance.canEmail = __raw_canEmail;
  }
  {
    const __raw_emailString = obj["emailString"] as string;
    if (__raw_emailString.length === 0) {
      errors.push({ field: "emailString", message: "must not be empty" });
    }

    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__raw_emailString)) {
      errors.push({ field: "emailString", message: "must be a valid email" });
    }
    instance.emailString = __raw_emailString;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Email;
}
export function validateFieldEmail<K extends keyof Email>(
  field: K,
  value: Email[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "emailString": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "emailString", message: "must not be empty" });
      }

      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__val)) {
        errors.push({ field: "emailString", message: "must be a valid email" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsEmail(
  partial: Partial<Email>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("emailString" in partial && partial.emailString !== undefined) {
    const __val = partial.emailString as string;
    if (__val.length === 0) {
      errors.push({ field: "emailString", message: "must not be empty" });
    }

    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__val)) {
      errors.push({ field: "emailString", message: "must be a valid email" });
    }
  }
  return errors;
}
export function isEmail(obj: unknown): obj is Email {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "canEmail" in o && "emailString" in o;
}

export namespace Email {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    canEmail: Option<Array<string>>;
    emailString: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { canEmail: Option<boolean>; emailString: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly canEmail: FieldController<boolean>;
    readonly emailString: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Email;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Email, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Email>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Email>,
  ): Gigaform {
    let data = $state({ ...Email.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      canEmail: Option.none(),
      emailString: Option.none(),
    });
    let tainted = $state<Tainted>({
      canEmail: Option.none(),
      emailString: Option.none(),
    });
    const fields: FieldControllers = {
      canEmail: {
        path: ["canEmail"] as const,
        name: "canEmail",
        constraints: { required: true },
        label: "Can Email",
        get: () => data.canEmail,
        set: (value: boolean) => {
          data.canEmail = value;
        },
        transform: (value: boolean): boolean => value,
        getError: () => errors.canEmail,
        setError: (value: Option<Array<string>>) => {
          errors.canEmail = value;
        },
        getTainted: () => tainted.canEmail,
        setTainted: (value: Option<boolean>) => {
          tainted.canEmail = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Email.validateField("canEmail", data.canEmail);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      emailString: {
        path: ["emailString"] as const,
        name: "emailString",
        constraints: { required: true, type: "email" },
        label: "Email",
        get: () => data.emailString,
        set: (value: string) => {
          data.emailString = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.emailString,
        setError: (value: Option<Array<string>>) => {
          errors.emailString = value;
        },
        getTainted: () => tainted.emailString,
        setTainted: (value: Option<boolean>) => {
          tainted.emailString = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Email.validateField(
            "emailString",
            data.emailString,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Email,
      Array<{ field: string; message: string }>
    > {
      return Email.fromObject(data);
    }
    function reset(newOverrides?: Partial<Email>): void {
      data = { ...Email.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        canEmail: Option.none(),
        emailString: Option.none(),
      };
      tainted = { canEmail: Option.none(), emailString: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Email, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const canEmailVal = formData.get("canEmail");
      obj.canEmail =
        canEmailVal === "true" || canEmailVal === "on" || canEmailVal === "1";
    }
    obj.emailString = formData.get("emailString") ?? "";
    return Email.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface RecurrenceRule {
  interval: Interval;
  recurrenceBegins: string;
  recurrenceEnds: RecurrenceEnd | null;
  cancelledInstances: string[] | null;
  additionalInstances: string[] | null;
}

export function defaultValueRecurrenceRule(): RecurrenceRule {
  return {
    interval: Interval.defaultValue(),
    recurrenceBegins: "",
    recurrenceEnds: null,
    cancelledInstances: null,
    additionalInstances: null,
  } as RecurrenceRule;
}

export function toStringifiedJSONRecurrenceRule(value: RecurrenceRule): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeRecurrenceRule(value, ctx));
}
export function toObjectRecurrenceRule(
  value: RecurrenceRule,
): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeRecurrenceRule(value, ctx);
}
export function __serializeRecurrenceRule(
  value: RecurrenceRule,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "RecurrenceRule", __id };
  result["interval"] =
    typeof (value.interval as any)?.__serialize === "function"
      ? (value.interval as any).__serialize(ctx)
      : value.interval;
  result["recurrenceBegins"] = value.recurrenceBegins;
  if (value.recurrenceEnds !== null) {
    result["recurrenceEnds"] =
      typeof (value.recurrenceEnds as any)?.__serialize === "function"
        ? (value.recurrenceEnds as any).__serialize(ctx)
        : value.recurrenceEnds;
  } else {
    result["recurrenceEnds"] = null;
  }
  if (value.cancelledInstances !== null) {
    result["cancelledInstances"] =
      typeof (value.cancelledInstances as any)?.__serialize === "function"
        ? (value.cancelledInstances as any).__serialize(ctx)
        : value.cancelledInstances;
  } else {
    result["cancelledInstances"] = null;
  }
  if (value.additionalInstances !== null) {
    result["additionalInstances"] =
      typeof (value.additionalInstances as any)?.__serialize === "function"
        ? (value.additionalInstances as any).__serialize(ctx)
        : value.additionalInstances;
  } else {
    result["additionalInstances"] = null;
  }
  return result;
}

export function fromStringifiedJSONRecurrenceRule(
  json: string,
  opts?: DeserializeOptions,
): Result<RecurrenceRule, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectRecurrenceRule(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectRecurrenceRule(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<RecurrenceRule, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeRecurrenceRule(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "RecurrenceRule.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeRecurrenceRule(
  value: any,
  ctx: DeserializeContext,
): RecurrenceRule | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "RecurrenceRule.__deserialize: expected an object",
      },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("interval" in obj)) {
    errors.push({ field: "interval", message: "missing required field" });
  }
  if (!("recurrenceBegins" in obj)) {
    errors.push({
      field: "recurrenceBegins",
      message: "missing required field",
    });
  }
  if (!("recurrenceEnds" in obj)) {
    errors.push({ field: "recurrenceEnds", message: "missing required field" });
  }
  if (!("cancelledInstances" in obj)) {
    errors.push({
      field: "cancelledInstances",
      message: "missing required field",
    });
  }
  if (!("additionalInstances" in obj)) {
    errors.push({
      field: "additionalInstances",
      message: "missing required field",
    });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_interval = obj["interval"] as Interval;
    if (typeof (Interval as any)?.__deserialize === "function") {
      const __result = (Interval as any).__deserialize(__raw_interval, ctx);
      ctx.assignOrDefer(instance, "interval", __result);
    } else {
      instance.interval = __raw_interval;
    }
  }
  {
    const __raw_recurrenceBegins = obj["recurrenceBegins"] as string;
    instance.recurrenceBegins = __raw_recurrenceBegins;
  }
  {
    const __raw_recurrenceEnds = obj["recurrenceEnds"] as RecurrenceEnd | null;
    if (__raw_recurrenceEnds === null) {
      instance.recurrenceEnds = null;
    } else if (typeof (__raw_recurrenceEnds as any)?.__ref !== "undefined") {
      const __result = ctx.getOrDefer((__raw_recurrenceEnds as any).__ref);
      ctx.assignOrDefer(instance, "recurrenceEnds", __result);
    } else {
      instance.recurrenceEnds = __raw_recurrenceEnds;
    }
  }
  {
    const __raw_cancelledInstances = obj["cancelledInstances"] as
      | string[]
      | null;
    if (__raw_cancelledInstances === null) {
      instance.cancelledInstances = null;
    } else if (
      typeof (__raw_cancelledInstances as any)?.__ref !== "undefined"
    ) {
      const __result = ctx.getOrDefer((__raw_cancelledInstances as any).__ref);
      ctx.assignOrDefer(instance, "cancelledInstances", __result);
    } else {
      instance.cancelledInstances = __raw_cancelledInstances;
    }
  }
  {
    const __raw_additionalInstances = obj["additionalInstances"] as
      | string[]
      | null;
    if (__raw_additionalInstances === null) {
      instance.additionalInstances = null;
    } else if (
      typeof (__raw_additionalInstances as any)?.__ref !== "undefined"
    ) {
      const __result = ctx.getOrDefer((__raw_additionalInstances as any).__ref);
      ctx.assignOrDefer(instance, "additionalInstances", __result);
    } else {
      instance.additionalInstances = __raw_additionalInstances;
    }
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as RecurrenceRule;
}
export function validateFieldRecurrenceRule<K extends keyof RecurrenceRule>(
  field: K,
  value: RecurrenceRule[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsRecurrenceRule(
  partial: Partial<RecurrenceRule>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isRecurrenceRule(obj: unknown): obj is RecurrenceRule {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return (
    "interval" in o &&
    "recurrenceBegins" in o &&
    "recurrenceEnds" in o &&
    "cancelledInstances" in o &&
    "additionalInstances" in o
  );
}

export namespace RecurrenceRule {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    interval: Option<Array<string>>;
    recurrenceBegins: Option<Array<string>>;
    recurrenceEnds: Option<Array<string>>;
    cancelledInstances: Option<Array<string>>;
    additionalInstances: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      interval: Option<boolean>;
      recurrenceBegins: Option<boolean>;
      recurrenceEnds: Option<boolean>;
      cancelledInstances: Option<boolean>;
      additionalInstances: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly interval: FieldController<Interval>;
    readonly recurrenceBegins: FieldController<string>;
    readonly recurrenceEnds: FieldController<RecurrenceEnd | null>;
    readonly cancelledInstances: FieldController<string[] | null>;
    readonly additionalInstances: FieldController<string[] | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: RecurrenceRule;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      RecurrenceRule,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<RecurrenceRule>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<RecurrenceRule>,
  ): Gigaform {
    let data = $state({ ...RecurrenceRule.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      interval: Option.none(),
      recurrenceBegins: Option.none(),
      recurrenceEnds: Option.none(),
      cancelledInstances: Option.none(),
      additionalInstances: Option.none(),
    });
    let tainted = $state<Tainted>({
      interval: Option.none(),
      recurrenceBegins: Option.none(),
      recurrenceEnds: Option.none(),
      cancelledInstances: Option.none(),
      additionalInstances: Option.none(),
    });
    const fields: FieldControllers = {
      interval: {
        path: ["interval"] as const,
        name: "interval",
        constraints: { required: true },

        get: () => data.interval,
        set: (value: Interval) => {
          data.interval = value;
        },
        transform: (value: Interval): Interval => value,
        getError: () => errors.interval,
        setError: (value: Option<Array<string>>) => {
          errors.interval = value;
        },
        getTainted: () => tainted.interval,
        setTainted: (value: Option<boolean>) => {
          tainted.interval = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = RecurrenceRule.validateField(
            "interval",
            data.interval,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      recurrenceBegins: {
        path: ["recurrenceBegins"] as const,
        name: "recurrenceBegins",
        constraints: { required: true },

        get: () => data.recurrenceBegins,
        set: (value: string) => {
          data.recurrenceBegins = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.recurrenceBegins,
        setError: (value: Option<Array<string>>) => {
          errors.recurrenceBegins = value;
        },
        getTainted: () => tainted.recurrenceBegins,
        setTainted: (value: Option<boolean>) => {
          tainted.recurrenceBegins = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = RecurrenceRule.validateField(
            "recurrenceBegins",
            data.recurrenceBegins,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      recurrenceEnds: {
        path: ["recurrenceEnds"] as const,
        name: "recurrenceEnds",
        constraints: { required: true },

        get: () => data.recurrenceEnds,
        set: (value: RecurrenceEnd | null) => {
          data.recurrenceEnds = value;
        },
        transform: (value: RecurrenceEnd | null): RecurrenceEnd | null => value,
        getError: () => errors.recurrenceEnds,
        setError: (value: Option<Array<string>>) => {
          errors.recurrenceEnds = value;
        },
        getTainted: () => tainted.recurrenceEnds,
        setTainted: (value: Option<boolean>) => {
          tainted.recurrenceEnds = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = RecurrenceRule.validateField(
            "recurrenceEnds",
            data.recurrenceEnds,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      cancelledInstances: {
        path: ["cancelledInstances"] as const,
        name: "cancelledInstances",
        constraints: { required: true },

        get: () => data.cancelledInstances,
        set: (value: string[] | null) => {
          data.cancelledInstances = value;
        },
        transform: (value: string[] | null): string[] | null => value,
        getError: () => errors.cancelledInstances,
        setError: (value: Option<Array<string>>) => {
          errors.cancelledInstances = value;
        },
        getTainted: () => tainted.cancelledInstances,
        setTainted: (value: Option<boolean>) => {
          tainted.cancelledInstances = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = RecurrenceRule.validateField(
            "cancelledInstances",
            data.cancelledInstances,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      additionalInstances: {
        path: ["additionalInstances"] as const,
        name: "additionalInstances",
        constraints: { required: true },

        get: () => data.additionalInstances,
        set: (value: string[] | null) => {
          data.additionalInstances = value;
        },
        transform: (value: string[] | null): string[] | null => value,
        getError: () => errors.additionalInstances,
        setError: (value: Option<Array<string>>) => {
          errors.additionalInstances = value;
        },
        getTainted: () => tainted.additionalInstances,
        setTainted: (value: Option<boolean>) => {
          tainted.additionalInstances = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = RecurrenceRule.validateField(
            "additionalInstances",
            data.additionalInstances,
          );
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      RecurrenceRule,
      Array<{ field: string; message: string }>
    > {
      return RecurrenceRule.fromObject(data);
    }
    function reset(newOverrides?: Partial<RecurrenceRule>): void {
      data = { ...RecurrenceRule.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        interval: Option.none(),
        recurrenceBegins: Option.none(),
        recurrenceEnds: Option.none(),
        cancelledInstances: Option.none(),
        additionalInstances: Option.none(),
      };
      tainted = {
        interval: Option.none(),
        recurrenceBegins: Option.none(),
        recurrenceEnds: Option.none(),
        cancelledInstances: Option.none(),
        additionalInstances: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<RecurrenceRule, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect nested object fields with prefix "interval."
      const intervalObj: Record<string, unknown> = {};
      for (const [key, value] of Array.from(formData.entries())) {
        if (key.startsWith("interval.")) {
          const fieldName = key.slice("interval.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = intervalObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i]!;
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]!] = value;
        }
      }
      obj.interval = intervalObj;
    }
    obj.recurrenceBegins = formData.get("recurrenceBegins") ?? "";
    obj.recurrenceEnds = formData.get("recurrenceEnds") ?? "";
    obj.cancelledInstances = formData.get("cancelledInstances") ?? "";
    obj.additionalInstances = formData.get("additionalInstances") ?? "";
    return RecurrenceRule.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface LastName {
  /** @serde({ validate: ["nonEmpty"] }) */
  name: string;
}

export function defaultValueLastName(): LastName {
  return { name: "" } as LastName;
}

export function toStringifiedJSONLastName(value: LastName): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeLastName(value, ctx));
}
export function toObjectLastName(value: LastName): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeLastName(value, ctx);
}
export function __serializeLastName(
  value: LastName,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "LastName", __id };
  result["name"] = value.name;
  return result;
}

export function fromStringifiedJSONLastName(
  json: string,
  opts?: DeserializeOptions,
): Result<LastName, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectLastName(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectLastName(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<LastName, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeLastName(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "LastName.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeLastName(
  value: any,
  ctx: DeserializeContext,
): LastName | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "LastName.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("name" in obj)) {
    errors.push({ field: "name", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_name = obj["name"] as string;
    if (__raw_name.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
    instance.name = __raw_name;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as LastName;
}
export function validateFieldLastName<K extends keyof LastName>(
  field: K,
  value: LastName[K],
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  switch (field) {
    case "name": {
      const __val = value as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
      break;
    }
  }
  return errors;
}
export function validateFieldsLastName(
  partial: Partial<LastName>,
): Array<{ field: string; message: string }> {
  const errors: Array<{ field: string; message: string }> = [];
  if ("name" in partial && partial.name !== undefined) {
    const __val = partial.name as string;
    if (__val.length === 0) {
      errors.push({ field: "name", message: "must not be empty" });
    }
  }
  return errors;
}
export function isLastName(obj: unknown): obj is LastName {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "name" in o;
}

export namespace LastName {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    name: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { name: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly name: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: LastName;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<LastName, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<LastName>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<LastName>,
  ): Gigaform {
    let data = $state({ ...LastName.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      name: Option.none(),
    });
    let tainted = $state<Tainted>({ name: Option.none() });
    const fields: FieldControllers = {
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },

        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        transform: (value: string): string => value,
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = LastName.validateField("name", data.name);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      LastName,
      Array<{ field: string; message: string }>
    > {
      return LastName.fromObject(data);
    }
    function reset(newOverrides?: Partial<LastName>): void {
      data = { ...LastName.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), name: Option.none() };
      tainted = { name: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<LastName, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.name = formData.get("name") ?? "";
    return LastName.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export interface Cardinal {
  north: number;
  east: number;
  south: number;
  west: number;
}

export function defaultValueCardinal(): Cardinal {
  return { north: 0, east: 0, south: 0, west: 0 } as Cardinal;
}

export function toStringifiedJSONCardinal(value: Cardinal): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeCardinal(value, ctx));
}
export function toObjectCardinal(value: Cardinal): Record<string, unknown> {
  const ctx = SerializeContext.create();
  return __serializeCardinal(value, ctx);
}
export function __serializeCardinal(
  value: Cardinal,
  ctx: SerializeContext,
): Record<string, unknown> {
  const existingId = ctx.getId(value);
  if (existingId !== undefined) {
    return { __ref: existingId };
  }
  const __id = ctx.register(value);
  const result: Record<string, unknown> = { __type: "Cardinal", __id };
  result["north"] = value.north;
  result["east"] = value.east;
  result["south"] = value.south;
  result["west"] = value.west;
  return result;
}

export function fromStringifiedJSONCardinal(
  json: string,
  opts?: DeserializeOptions,
): Result<Cardinal, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectCardinal(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectCardinal(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Cardinal, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeCardinal(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Cardinal.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeCardinal(
  value: any,
  ctx: DeserializeContext,
): Cardinal | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref);
  }
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new DeserializeError([
      { field: "_root", message: "Cardinal.__deserialize: expected an object" },
    ]);
  }
  const obj = value as Record<string, unknown>;
  const errors: Array<{ field: string; message: string }> = [];
  if (!("north" in obj)) {
    errors.push({ field: "north", message: "missing required field" });
  }
  if (!("east" in obj)) {
    errors.push({ field: "east", message: "missing required field" });
  }
  if (!("south" in obj)) {
    errors.push({ field: "south", message: "missing required field" });
  }
  if (!("west" in obj)) {
    errors.push({ field: "west", message: "missing required field" });
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  const instance: any = {};
  if (obj.__id !== undefined) {
    ctx.register(obj.__id as number, instance);
  }
  ctx.trackForFreeze(instance);
  {
    const __raw_north = obj["north"] as number;
    instance.north = __raw_north;
  }
  {
    const __raw_east = obj["east"] as number;
    instance.east = __raw_east;
  }
  {
    const __raw_south = obj["south"] as number;
    instance.south = __raw_south;
  }
  {
    const __raw_west = obj["west"] as number;
    instance.west = __raw_west;
  }
  if (errors.length > 0) {
    throw new DeserializeError(errors);
  }
  return instance as Cardinal;
}
export function validateFieldCardinal<K extends keyof Cardinal>(
  field: K,
  value: Cardinal[K],
): Array<{ field: string; message: string }> {
  return [];
}
export function validateFieldsCardinal(
  partial: Partial<Cardinal>,
): Array<{ field: string; message: string }> {
  return [];
}
export function isCardinal(obj: unknown): obj is Cardinal {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
    return false;
  }
  const o = obj as Record<string, unknown>;
  return "north" in o && "east" in o && "south" in o && "west" in o;
}

export namespace Cardinal {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    north: Option<Array<string>>;
    east: Option<Array<string>>;
    south: Option<Array<string>>;
    west: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      north: Option<boolean>;
      east: Option<boolean>;
      south: Option<boolean>;
      west: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly north: FieldController<number>;
    readonly east: FieldController<number>;
    readonly south: FieldController<number>;
    readonly west: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Cardinal;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Cardinal, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Cardinal>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Cardinal>,
  ): Gigaform {
    let data = $state({ ...Cardinal.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      north: Option.none(),
      east: Option.none(),
      south: Option.none(),
      west: Option.none(),
    });
    let tainted = $state<Tainted>({
      north: Option.none(),
      east: Option.none(),
      south: Option.none(),
      west: Option.none(),
    });
    const fields: FieldControllers = {
      north: {
        path: ["north"] as const,
        name: "north",
        constraints: { required: true },

        get: () => data.north,
        set: (value: number) => {
          data.north = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.north,
        setError: (value: Option<Array<string>>) => {
          errors.north = value;
        },
        getTainted: () => tainted.north,
        setTainted: (value: Option<boolean>) => {
          tainted.north = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Cardinal.validateField("north", data.north);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      east: {
        path: ["east"] as const,
        name: "east",
        constraints: { required: true },

        get: () => data.east,
        set: (value: number) => {
          data.east = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.east,
        setError: (value: Option<Array<string>>) => {
          errors.east = value;
        },
        getTainted: () => tainted.east,
        setTainted: (value: Option<boolean>) => {
          tainted.east = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Cardinal.validateField("east", data.east);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      south: {
        path: ["south"] as const,
        name: "south",
        constraints: { required: true },

        get: () => data.south,
        set: (value: number) => {
          data.south = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.south,
        setError: (value: Option<Array<string>>) => {
          errors.south = value;
        },
        getTainted: () => tainted.south,
        setTainted: (value: Option<boolean>) => {
          tainted.south = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Cardinal.validateField("south", data.south);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
      west: {
        path: ["west"] as const,
        name: "west",
        constraints: { required: true },

        get: () => data.west,
        set: (value: number) => {
          data.west = value;
        },
        transform: (value: number): number => value,
        getError: () => errors.west,
        setError: (value: Option<Array<string>>) => {
          errors.west = value;
        },
        getTainted: () => tainted.west,
        setTainted: (value: Option<boolean>) => {
          tainted.west = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Cardinal.validateField("west", data.west);
          return fieldErrors.map(
            (e: { field: string; message: string }) => e.message,
          );
        },
      },
    };
    function validate(): Result<
      Cardinal,
      Array<{ field: string; message: string }>
    > {
      return Cardinal.fromObject(data);
    }
    function reset(newOverrides?: Partial<Cardinal>): void {
      data = { ...Cardinal.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        north: Option.none(),
        east: Option.none(),
        south: Option.none(),
        west: Option.none(),
      };
      tainted = {
        north: Option.none(),
        east: Option.none(),
        south: Option.none(),
        west: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Cardinal, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const northStr = formData.get("north");
      obj.north = northStr ? parseFloat(northStr as string) : 0;
      if (obj.north !== undefined && isNaN(obj.north as number)) obj.north = 0;
    }
    {
      const eastStr = formData.get("east");
      obj.east = eastStr ? parseFloat(eastStr as string) : 0;
      if (obj.east !== undefined && isNaN(obj.east as number)) obj.east = 0;
    }
    {
      const southStr = formData.get("south");
      obj.south = southStr ? parseFloat(southStr as string) : 0;
      if (obj.south !== undefined && isNaN(obj.south as number)) obj.south = 0;
    }
    {
      const westStr = formData.get("west");
      obj.west = westStr ? parseFloat(westStr as string) : 0;
      if (obj.west !== undefined && isNaN(obj.west as number)) obj.west = 0;
    }
    return Cardinal.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type Interval =
  | /** @default */ DailyRecurrenceRule
  | WeeklyRecurrenceRule
  | MonthlyRecurrenceRule
  | YearlyRecurrenceRule;

export function defaultValueInterval(): Interval {
  return DailyRecurrenceRule.defaultValue();
}

export function toStringifiedJSONInterval(value: Interval): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeInterval(value, ctx));
}
export function toObjectInterval(value: Interval): unknown {
  const ctx = SerializeContext.create();
  return __serializeInterval(value, ctx);
}
export function __serializeInterval(
  value: Interval,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONInterval(
  json: string,
  opts?: DeserializeOptions,
): Result<Interval, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectInterval(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectInterval(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Interval, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeInterval(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Interval.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeInterval(
  value: any,
  ctx: DeserializeContext,
): Interval | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as Interval | PendingRef;
  }
  if (typeof value !== "object" || value === null) {
    throw new DeserializeError([
      { field: "_root", message: "Interval.__deserialize: expected an object" },
    ]);
  }
  const __typeName = (value as any).__type;
  if (typeof __typeName !== "string") {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Interval.__deserialize: missing __type field for union dispatch",
      },
    ]);
  }
  if (__typeName === "DailyRecurrenceRule") {
    if (typeof (DailyRecurrenceRule as any)?.__deserialize === "function") {
      return (DailyRecurrenceRule as any).__deserialize(value, ctx) as Interval;
    }
    return value as Interval;
  }
  if (__typeName === "WeeklyRecurrenceRule") {
    if (typeof (WeeklyRecurrenceRule as any)?.__deserialize === "function") {
      return (WeeklyRecurrenceRule as any).__deserialize(
        value,
        ctx,
      ) as Interval;
    }
    return value as Interval;
  }
  if (__typeName === "MonthlyRecurrenceRule") {
    if (typeof (MonthlyRecurrenceRule as any)?.__deserialize === "function") {
      return (MonthlyRecurrenceRule as any).__deserialize(
        value,
        ctx,
      ) as Interval;
    }
    return value as Interval;
  }
  if (__typeName === "YearlyRecurrenceRule") {
    if (typeof (YearlyRecurrenceRule as any)?.__deserialize === "function") {
      return (YearlyRecurrenceRule as any).__deserialize(
        value,
        ctx,
      ) as Interval;
    }
    return value as Interval;
  }
  throw new DeserializeError([
    {
      field: "_root",
      message:
        'Interval.__deserialize: unknown type "' +
        __typeName +
        '". Expected one of: DailyRecurrenceRule, WeeklyRecurrenceRule, MonthlyRecurrenceRule, YearlyRecurrenceRule',
    },
  ]);
}
export function isInterval(value: unknown): value is Interval {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const __typeName = (value as any).__type;
  return (
    __typeName === "DailyRecurrenceRule" ||
    __typeName === "WeeklyRecurrenceRule" ||
    __typeName === "MonthlyRecurrenceRule" ||
    __typeName === "YearlyRecurrenceRule"
  );
}

export namespace Interval {
  /** Per-variant error types */ export type DailyRecurrenceRuleErrors = {
    _errors: Option<Array<string>>;
  };
  export type WeeklyRecurrenceRuleErrors = { _errors: Option<Array<string>> };
  export type MonthlyRecurrenceRuleErrors = { _errors: Option<Array<string>> };
  export type YearlyRecurrenceRuleErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type DailyRecurrenceRuleTainted = {};
  export type WeeklyRecurrenceRuleTainted = {};
  export type MonthlyRecurrenceRuleTainted = {};
  export type YearlyRecurrenceRuleTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "DailyRecurrenceRule" } & DailyRecurrenceRuleErrors)
    | ({ _type: "WeeklyRecurrenceRule" } & WeeklyRecurrenceRuleErrors)
    | ({ _type: "MonthlyRecurrenceRule" } & MonthlyRecurrenceRuleErrors)
    | ({ _type: "YearlyRecurrenceRule" } & YearlyRecurrenceRuleErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "DailyRecurrenceRule" } & DailyRecurrenceRuleTainted)
    | ({ _type: "WeeklyRecurrenceRule" } & WeeklyRecurrenceRuleTainted)
    | ({ _type: "MonthlyRecurrenceRule" } & MonthlyRecurrenceRuleTainted)
    | ({ _type: "YearlyRecurrenceRule" } & YearlyRecurrenceRuleTainted);
  /** Per-variant field controller types */ export interface DailyRecurrenceRuleFieldControllers {}
  export interface WeeklyRecurrenceRuleFieldControllers {}
  export interface MonthlyRecurrenceRuleFieldControllers {}
  export interface YearlyRecurrenceRuleFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "DailyRecurrenceRule"
      | "WeeklyRecurrenceRule"
      | "MonthlyRecurrenceRule"
      | "YearlyRecurrenceRule";
    readonly data: Interval;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "DailyRecurrenceRule"
        | "WeeklyRecurrenceRule"
        | "MonthlyRecurrenceRule"
        | "YearlyRecurrenceRule",
    ): void;
    validate(): Result<Interval, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Interval>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly DailyRecurrenceRule: {
      readonly fields: DailyRecurrenceRuleFieldControllers;
    };
    readonly WeeklyRecurrenceRule: {
      readonly fields: WeeklyRecurrenceRuleFieldControllers;
    };
    readonly MonthlyRecurrenceRule: {
      readonly fields: MonthlyRecurrenceRuleFieldControllers;
    };
    readonly YearlyRecurrenceRule: {
      readonly fields: YearlyRecurrenceRuleFieldControllers;
    };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Interval {
    switch (variant) {
      case "DailyRecurrenceRule":
        return DailyRecurrenceRule.defaultValue() as Interval;
      case "WeeklyRecurrenceRule":
        return WeeklyRecurrenceRule.defaultValue() as Interval;
      case "MonthlyRecurrenceRule":
        return MonthlyRecurrenceRule.defaultValue() as Interval;
      case "YearlyRecurrenceRule":
        return YearlyRecurrenceRule.defaultValue() as Interval;
      default:
        return DailyRecurrenceRule.defaultValue() as Interval;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Interval,
  ): Gigaform {
    const initialVariant:
      | "DailyRecurrenceRule"
      | "WeeklyRecurrenceRule"
      | "MonthlyRecurrenceRule"
      | "YearlyRecurrenceRule" = "DailyRecurrenceRule";
    let currentVariant = $state<
      | "DailyRecurrenceRule"
      | "WeeklyRecurrenceRule"
      | "MonthlyRecurrenceRule"
      | "YearlyRecurrenceRule"
    >(initialVariant);
    let data = $state<Interval>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      DailyRecurrenceRule: {
        fields: {} as DailyRecurrenceRuleFieldControllers,
      },
      WeeklyRecurrenceRule: {
        fields: {} as WeeklyRecurrenceRuleFieldControllers,
      },
      MonthlyRecurrenceRule: {
        fields: {} as MonthlyRecurrenceRuleFieldControllers,
      },
      YearlyRecurrenceRule: {
        fields: {} as YearlyRecurrenceRuleFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "DailyRecurrenceRule"
        | "WeeklyRecurrenceRule"
        | "MonthlyRecurrenceRule"
        | "YearlyRecurrenceRule",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Interval,
      Array<{ field: string; message: string }>
    > {
      return Interval.fromObject(data);
    }
    function reset(overrides?: Partial<Interval>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Interval, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as
      | "DailyRecurrenceRule"
      | "WeeklyRecurrenceRule"
      | "MonthlyRecurrenceRule"
      | "YearlyRecurrenceRule"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "DailyRecurrenceRule") {
    } else if (discriminant === "WeeklyRecurrenceRule") {
    } else if (discriminant === "MonthlyRecurrenceRule") {
    } else if (discriminant === "YearlyRecurrenceRule") {
    }
    return Interval.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type Page =
  | /** @default */ "SalesHomeDashboard"
  | "SalesHomeProducts"
  | "SalesHomeServices"
  | "SalesHomePackages"
  | "SalesHomeTaxRates"
  | "SalesLeadsOverview"
  | "SalesLeadsActivities"
  | "SalesLeadsCampaigns"
  | "SalesLeadsDripCampaigns"
  | "SalesLeadsOpportunities"
  | "SalesLeadsPromotions"
  | "SalesAccountsOverview"
  | "SalesAccountsActivities"
  | "SalesAccountsBilling"
  | "SalesAccountsContracts"
  | "SalesOrdersOverview"
  | "SalesOrdersActivities"
  | "SalesOrdersPayments"
  | "SalesOrdersCommissions"
  | "SalesSchedulingSchedule"
  | "SalesSchedulingAppointments"
  | "SalesSchedulingRecurring"
  | "SalesSchedulingRoutes"
  | "SalesSchedulingReminders"
  | "UserHome";

export function defaultValuePage(): Page {
  return "SalesHomeDashboard";
}

export function toStringifiedJSONPage(value: Page): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializePage(value, ctx));
}
export function toObjectPage(value: Page): unknown {
  const ctx = SerializeContext.create();
  return __serializePage(value, ctx);
}
export function __serializePage(value: Page, ctx: SerializeContext): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONPage(
  json: string,
  opts?: DeserializeOptions,
): Result<Page, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectPage(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectPage(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Page, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializePage(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Page.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializePage(
  value: any,
  ctx: DeserializeContext,
): Page | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as Page | PendingRef;
  }
  const allowedValues = [
    "SalesHomeDashboard",
    "SalesHomeProducts",
    "SalesHomeServices",
    "SalesHomePackages",
    "SalesHomeTaxRates",
    "SalesLeadsOverview",
    "SalesLeadsActivities",
    "SalesLeadsCampaigns",
    "SalesLeadsDripCampaigns",
    "SalesLeadsOpportunities",
    "SalesLeadsPromotions",
    "SalesAccountsOverview",
    "SalesAccountsActivities",
    "SalesAccountsBilling",
    "SalesAccountsContracts",
    "SalesOrdersOverview",
    "SalesOrdersActivities",
    "SalesOrdersPayments",
    "SalesOrdersCommissions",
    "SalesSchedulingSchedule",
    "SalesSchedulingAppointments",
    "SalesSchedulingRecurring",
    "SalesSchedulingRoutes",
    "SalesSchedulingReminders",
    "UserHome",
  ] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for Page: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as Page;
}
export function isPage(value: unknown): value is Page {
  const allowedValues = [
    "SalesHomeDashboard",
    "SalesHomeProducts",
    "SalesHomeServices",
    "SalesHomePackages",
    "SalesHomeTaxRates",
    "SalesLeadsOverview",
    "SalesLeadsActivities",
    "SalesLeadsCampaigns",
    "SalesLeadsDripCampaigns",
    "SalesLeadsOpportunities",
    "SalesLeadsPromotions",
    "SalesAccountsOverview",
    "SalesAccountsActivities",
    "SalesAccountsBilling",
    "SalesAccountsContracts",
    "SalesOrdersOverview",
    "SalesOrdersActivities",
    "SalesOrdersPayments",
    "SalesOrdersCommissions",
    "SalesSchedulingSchedule",
    "SalesSchedulingAppointments",
    "SalesSchedulingRecurring",
    "SalesSchedulingRoutes",
    "SalesSchedulingReminders",
    "UserHome",
  ] as const;
  return allowedValues.includes(value as any);
}

export namespace Page {
  /** Per-variant error types */ export type SalesHomeDashboardErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesHomeProductsErrors = { _errors: Option<Array<string>> };
  export type SalesHomeServicesErrors = { _errors: Option<Array<string>> };
  export type SalesHomePackagesErrors = { _errors: Option<Array<string>> };
  export type SalesHomeTaxRatesErrors = { _errors: Option<Array<string>> };
  export type SalesLeadsOverviewErrors = { _errors: Option<Array<string>> };
  export type SalesLeadsActivitiesErrors = { _errors: Option<Array<string>> };
  export type SalesLeadsCampaignsErrors = { _errors: Option<Array<string>> };
  export type SalesLeadsDripCampaignsErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesLeadsOpportunitiesErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesLeadsPromotionsErrors = { _errors: Option<Array<string>> };
  export type SalesAccountsOverviewErrors = { _errors: Option<Array<string>> };
  export type SalesAccountsActivitiesErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesAccountsBillingErrors = { _errors: Option<Array<string>> };
  export type SalesAccountsContractsErrors = { _errors: Option<Array<string>> };
  export type SalesOrdersOverviewErrors = { _errors: Option<Array<string>> };
  export type SalesOrdersActivitiesErrors = { _errors: Option<Array<string>> };
  export type SalesOrdersPaymentsErrors = { _errors: Option<Array<string>> };
  export type SalesOrdersCommissionsErrors = { _errors: Option<Array<string>> };
  export type SalesSchedulingScheduleErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesSchedulingAppointmentsErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesSchedulingRecurringErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesSchedulingRoutesErrors = { _errors: Option<Array<string>> };
  export type SalesSchedulingRemindersErrors = {
    _errors: Option<Array<string>>;
  };
  export type UserHomeErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type SalesHomeDashboardTainted = {};
  export type SalesHomeProductsTainted = {};
  export type SalesHomeServicesTainted = {};
  export type SalesHomePackagesTainted = {};
  export type SalesHomeTaxRatesTainted = {};
  export type SalesLeadsOverviewTainted = {};
  export type SalesLeadsActivitiesTainted = {};
  export type SalesLeadsCampaignsTainted = {};
  export type SalesLeadsDripCampaignsTainted = {};
  export type SalesLeadsOpportunitiesTainted = {};
  export type SalesLeadsPromotionsTainted = {};
  export type SalesAccountsOverviewTainted = {};
  export type SalesAccountsActivitiesTainted = {};
  export type SalesAccountsBillingTainted = {};
  export type SalesAccountsContractsTainted = {};
  export type SalesOrdersOverviewTainted = {};
  export type SalesOrdersActivitiesTainted = {};
  export type SalesOrdersPaymentsTainted = {};
  export type SalesOrdersCommissionsTainted = {};
  export type SalesSchedulingScheduleTainted = {};
  export type SalesSchedulingAppointmentsTainted = {};
  export type SalesSchedulingRecurringTainted = {};
  export type SalesSchedulingRoutesTainted = {};
  export type SalesSchedulingRemindersTainted = {};
  export type UserHomeTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "SalesHomeDashboard" } & SalesHomeDashboardErrors)
    | ({ _value: "SalesHomeProducts" } & SalesHomeProductsErrors)
    | ({ _value: "SalesHomeServices" } & SalesHomeServicesErrors)
    | ({ _value: "SalesHomePackages" } & SalesHomePackagesErrors)
    | ({ _value: "SalesHomeTaxRates" } & SalesHomeTaxRatesErrors)
    | ({ _value: "SalesLeadsOverview" } & SalesLeadsOverviewErrors)
    | ({ _value: "SalesLeadsActivities" } & SalesLeadsActivitiesErrors)
    | ({ _value: "SalesLeadsCampaigns" } & SalesLeadsCampaignsErrors)
    | ({ _value: "SalesLeadsDripCampaigns" } & SalesLeadsDripCampaignsErrors)
    | ({ _value: "SalesLeadsOpportunities" } & SalesLeadsOpportunitiesErrors)
    | ({ _value: "SalesLeadsPromotions" } & SalesLeadsPromotionsErrors)
    | ({ _value: "SalesAccountsOverview" } & SalesAccountsOverviewErrors)
    | ({ _value: "SalesAccountsActivities" } & SalesAccountsActivitiesErrors)
    | ({ _value: "SalesAccountsBilling" } & SalesAccountsBillingErrors)
    | ({ _value: "SalesAccountsContracts" } & SalesAccountsContractsErrors)
    | ({ _value: "SalesOrdersOverview" } & SalesOrdersOverviewErrors)
    | ({ _value: "SalesOrdersActivities" } & SalesOrdersActivitiesErrors)
    | ({ _value: "SalesOrdersPayments" } & SalesOrdersPaymentsErrors)
    | ({ _value: "SalesOrdersCommissions" } & SalesOrdersCommissionsErrors)
    | ({ _value: "SalesSchedulingSchedule" } & SalesSchedulingScheduleErrors)
    | ({
        _value: "SalesSchedulingAppointments";
      } & SalesSchedulingAppointmentsErrors)
    | ({ _value: "SalesSchedulingRecurring" } & SalesSchedulingRecurringErrors)
    | ({ _value: "SalesSchedulingRoutes" } & SalesSchedulingRoutesErrors)
    | ({ _value: "SalesSchedulingReminders" } & SalesSchedulingRemindersErrors)
    | ({ _value: "UserHome" } & UserHomeErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "SalesHomeDashboard" } & SalesHomeDashboardTainted)
    | ({ _value: "SalesHomeProducts" } & SalesHomeProductsTainted)
    | ({ _value: "SalesHomeServices" } & SalesHomeServicesTainted)
    | ({ _value: "SalesHomePackages" } & SalesHomePackagesTainted)
    | ({ _value: "SalesHomeTaxRates" } & SalesHomeTaxRatesTainted)
    | ({ _value: "SalesLeadsOverview" } & SalesLeadsOverviewTainted)
    | ({ _value: "SalesLeadsActivities" } & SalesLeadsActivitiesTainted)
    | ({ _value: "SalesLeadsCampaigns" } & SalesLeadsCampaignsTainted)
    | ({ _value: "SalesLeadsDripCampaigns" } & SalesLeadsDripCampaignsTainted)
    | ({ _value: "SalesLeadsOpportunities" } & SalesLeadsOpportunitiesTainted)
    | ({ _value: "SalesLeadsPromotions" } & SalesLeadsPromotionsTainted)
    | ({ _value: "SalesAccountsOverview" } & SalesAccountsOverviewTainted)
    | ({ _value: "SalesAccountsActivities" } & SalesAccountsActivitiesTainted)
    | ({ _value: "SalesAccountsBilling" } & SalesAccountsBillingTainted)
    | ({ _value: "SalesAccountsContracts" } & SalesAccountsContractsTainted)
    | ({ _value: "SalesOrdersOverview" } & SalesOrdersOverviewTainted)
    | ({ _value: "SalesOrdersActivities" } & SalesOrdersActivitiesTainted)
    | ({ _value: "SalesOrdersPayments" } & SalesOrdersPaymentsTainted)
    | ({ _value: "SalesOrdersCommissions" } & SalesOrdersCommissionsTainted)
    | ({ _value: "SalesSchedulingSchedule" } & SalesSchedulingScheduleTainted)
    | ({
        _value: "SalesSchedulingAppointments";
      } & SalesSchedulingAppointmentsTainted)
    | ({ _value: "SalesSchedulingRecurring" } & SalesSchedulingRecurringTainted)
    | ({ _value: "SalesSchedulingRoutes" } & SalesSchedulingRoutesTainted)
    | ({ _value: "SalesSchedulingReminders" } & SalesSchedulingRemindersTainted)
    | ({ _value: "UserHome" } & UserHomeTainted);
  /** Per-variant field controller types */ export interface SalesHomeDashboardFieldControllers {}
  export interface SalesHomeProductsFieldControllers {}
  export interface SalesHomeServicesFieldControllers {}
  export interface SalesHomePackagesFieldControllers {}
  export interface SalesHomeTaxRatesFieldControllers {}
  export interface SalesLeadsOverviewFieldControllers {}
  export interface SalesLeadsActivitiesFieldControllers {}
  export interface SalesLeadsCampaignsFieldControllers {}
  export interface SalesLeadsDripCampaignsFieldControllers {}
  export interface SalesLeadsOpportunitiesFieldControllers {}
  export interface SalesLeadsPromotionsFieldControllers {}
  export interface SalesAccountsOverviewFieldControllers {}
  export interface SalesAccountsActivitiesFieldControllers {}
  export interface SalesAccountsBillingFieldControllers {}
  export interface SalesAccountsContractsFieldControllers {}
  export interface SalesOrdersOverviewFieldControllers {}
  export interface SalesOrdersActivitiesFieldControllers {}
  export interface SalesOrdersPaymentsFieldControllers {}
  export interface SalesOrdersCommissionsFieldControllers {}
  export interface SalesSchedulingScheduleFieldControllers {}
  export interface SalesSchedulingAppointmentsFieldControllers {}
  export interface SalesSchedulingRecurringFieldControllers {}
  export interface SalesSchedulingRoutesFieldControllers {}
  export interface SalesSchedulingRemindersFieldControllers {}
  export interface UserHomeFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "SalesHomeDashboard"
      | "SalesHomeProducts"
      | "SalesHomeServices"
      | "SalesHomePackages"
      | "SalesHomeTaxRates"
      | "SalesLeadsOverview"
      | "SalesLeadsActivities"
      | "SalesLeadsCampaigns"
      | "SalesLeadsDripCampaigns"
      | "SalesLeadsOpportunities"
      | "SalesLeadsPromotions"
      | "SalesAccountsOverview"
      | "SalesAccountsActivities"
      | "SalesAccountsBilling"
      | "SalesAccountsContracts"
      | "SalesOrdersOverview"
      | "SalesOrdersActivities"
      | "SalesOrdersPayments"
      | "SalesOrdersCommissions"
      | "SalesSchedulingSchedule"
      | "SalesSchedulingAppointments"
      | "SalesSchedulingRecurring"
      | "SalesSchedulingRoutes"
      | "SalesSchedulingReminders"
      | "UserHome";
    readonly data: Page;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "SalesHomeDashboard"
        | "SalesHomeProducts"
        | "SalesHomeServices"
        | "SalesHomePackages"
        | "SalesHomeTaxRates"
        | "SalesLeadsOverview"
        | "SalesLeadsActivities"
        | "SalesLeadsCampaigns"
        | "SalesLeadsDripCampaigns"
        | "SalesLeadsOpportunities"
        | "SalesLeadsPromotions"
        | "SalesAccountsOverview"
        | "SalesAccountsActivities"
        | "SalesAccountsBilling"
        | "SalesAccountsContracts"
        | "SalesOrdersOverview"
        | "SalesOrdersActivities"
        | "SalesOrdersPayments"
        | "SalesOrdersCommissions"
        | "SalesSchedulingSchedule"
        | "SalesSchedulingAppointments"
        | "SalesSchedulingRecurring"
        | "SalesSchedulingRoutes"
        | "SalesSchedulingReminders"
        | "UserHome",
    ): void;
    validate(): Result<Page, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Page>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly SalesHomeDashboard: {
      readonly fields: SalesHomeDashboardFieldControllers;
    };
    readonly SalesHomeProducts: {
      readonly fields: SalesHomeProductsFieldControllers;
    };
    readonly SalesHomeServices: {
      readonly fields: SalesHomeServicesFieldControllers;
    };
    readonly SalesHomePackages: {
      readonly fields: SalesHomePackagesFieldControllers;
    };
    readonly SalesHomeTaxRates: {
      readonly fields: SalesHomeTaxRatesFieldControllers;
    };
    readonly SalesLeadsOverview: {
      readonly fields: SalesLeadsOverviewFieldControllers;
    };
    readonly SalesLeadsActivities: {
      readonly fields: SalesLeadsActivitiesFieldControllers;
    };
    readonly SalesLeadsCampaigns: {
      readonly fields: SalesLeadsCampaignsFieldControllers;
    };
    readonly SalesLeadsDripCampaigns: {
      readonly fields: SalesLeadsDripCampaignsFieldControllers;
    };
    readonly SalesLeadsOpportunities: {
      readonly fields: SalesLeadsOpportunitiesFieldControllers;
    };
    readonly SalesLeadsPromotions: {
      readonly fields: SalesLeadsPromotionsFieldControllers;
    };
    readonly SalesAccountsOverview: {
      readonly fields: SalesAccountsOverviewFieldControllers;
    };
    readonly SalesAccountsActivities: {
      readonly fields: SalesAccountsActivitiesFieldControllers;
    };
    readonly SalesAccountsBilling: {
      readonly fields: SalesAccountsBillingFieldControllers;
    };
    readonly SalesAccountsContracts: {
      readonly fields: SalesAccountsContractsFieldControllers;
    };
    readonly SalesOrdersOverview: {
      readonly fields: SalesOrdersOverviewFieldControllers;
    };
    readonly SalesOrdersActivities: {
      readonly fields: SalesOrdersActivitiesFieldControllers;
    };
    readonly SalesOrdersPayments: {
      readonly fields: SalesOrdersPaymentsFieldControllers;
    };
    readonly SalesOrdersCommissions: {
      readonly fields: SalesOrdersCommissionsFieldControllers;
    };
    readonly SalesSchedulingSchedule: {
      readonly fields: SalesSchedulingScheduleFieldControllers;
    };
    readonly SalesSchedulingAppointments: {
      readonly fields: SalesSchedulingAppointmentsFieldControllers;
    };
    readonly SalesSchedulingRecurring: {
      readonly fields: SalesSchedulingRecurringFieldControllers;
    };
    readonly SalesSchedulingRoutes: {
      readonly fields: SalesSchedulingRoutesFieldControllers;
    };
    readonly SalesSchedulingReminders: {
      readonly fields: SalesSchedulingRemindersFieldControllers;
    };
    readonly UserHome: { readonly fields: UserHomeFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Page {
    switch (variant) {
      case "SalesHomeDashboard":
        return "SalesHomeDashboard" as Page;
      case "SalesHomeProducts":
        return "SalesHomeProducts" as Page;
      case "SalesHomeServices":
        return "SalesHomeServices" as Page;
      case "SalesHomePackages":
        return "SalesHomePackages" as Page;
      case "SalesHomeTaxRates":
        return "SalesHomeTaxRates" as Page;
      case "SalesLeadsOverview":
        return "SalesLeadsOverview" as Page;
      case "SalesLeadsActivities":
        return "SalesLeadsActivities" as Page;
      case "SalesLeadsCampaigns":
        return "SalesLeadsCampaigns" as Page;
      case "SalesLeadsDripCampaigns":
        return "SalesLeadsDripCampaigns" as Page;
      case "SalesLeadsOpportunities":
        return "SalesLeadsOpportunities" as Page;
      case "SalesLeadsPromotions":
        return "SalesLeadsPromotions" as Page;
      case "SalesAccountsOverview":
        return "SalesAccountsOverview" as Page;
      case "SalesAccountsActivities":
        return "SalesAccountsActivities" as Page;
      case "SalesAccountsBilling":
        return "SalesAccountsBilling" as Page;
      case "SalesAccountsContracts":
        return "SalesAccountsContracts" as Page;
      case "SalesOrdersOverview":
        return "SalesOrdersOverview" as Page;
      case "SalesOrdersActivities":
        return "SalesOrdersActivities" as Page;
      case "SalesOrdersPayments":
        return "SalesOrdersPayments" as Page;
      case "SalesOrdersCommissions":
        return "SalesOrdersCommissions" as Page;
      case "SalesSchedulingSchedule":
        return "SalesSchedulingSchedule" as Page;
      case "SalesSchedulingAppointments":
        return "SalesSchedulingAppointments" as Page;
      case "SalesSchedulingRecurring":
        return "SalesSchedulingRecurring" as Page;
      case "SalesSchedulingRoutes":
        return "SalesSchedulingRoutes" as Page;
      case "SalesSchedulingReminders":
        return "SalesSchedulingReminders" as Page;
      case "UserHome":
        return "UserHome" as Page;
      default:
        return "SalesHomeDashboard" as Page;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Page,
  ): Gigaform {
    const initialVariant:
      | "SalesHomeDashboard"
      | "SalesHomeProducts"
      | "SalesHomeServices"
      | "SalesHomePackages"
      | "SalesHomeTaxRates"
      | "SalesLeadsOverview"
      | "SalesLeadsActivities"
      | "SalesLeadsCampaigns"
      | "SalesLeadsDripCampaigns"
      | "SalesLeadsOpportunities"
      | "SalesLeadsPromotions"
      | "SalesAccountsOverview"
      | "SalesAccountsActivities"
      | "SalesAccountsBilling"
      | "SalesAccountsContracts"
      | "SalesOrdersOverview"
      | "SalesOrdersActivities"
      | "SalesOrdersPayments"
      | "SalesOrdersCommissions"
      | "SalesSchedulingSchedule"
      | "SalesSchedulingAppointments"
      | "SalesSchedulingRecurring"
      | "SalesSchedulingRoutes"
      | "SalesSchedulingReminders"
      | "UserHome" =
      (initial as
        | "SalesHomeDashboard"
        | "SalesHomeProducts"
        | "SalesHomeServices"
        | "SalesHomePackages"
        | "SalesHomeTaxRates"
        | "SalesLeadsOverview"
        | "SalesLeadsActivities"
        | "SalesLeadsCampaigns"
        | "SalesLeadsDripCampaigns"
        | "SalesLeadsOpportunities"
        | "SalesLeadsPromotions"
        | "SalesAccountsOverview"
        | "SalesAccountsActivities"
        | "SalesAccountsBilling"
        | "SalesAccountsContracts"
        | "SalesOrdersOverview"
        | "SalesOrdersActivities"
        | "SalesOrdersPayments"
        | "SalesOrdersCommissions"
        | "SalesSchedulingSchedule"
        | "SalesSchedulingAppointments"
        | "SalesSchedulingRecurring"
        | "SalesSchedulingRoutes"
        | "SalesSchedulingReminders"
        | "UserHome") ?? "SalesHomeDashboard";
    let currentVariant = $state<
      | "SalesHomeDashboard"
      | "SalesHomeProducts"
      | "SalesHomeServices"
      | "SalesHomePackages"
      | "SalesHomeTaxRates"
      | "SalesLeadsOverview"
      | "SalesLeadsActivities"
      | "SalesLeadsCampaigns"
      | "SalesLeadsDripCampaigns"
      | "SalesLeadsOpportunities"
      | "SalesLeadsPromotions"
      | "SalesAccountsOverview"
      | "SalesAccountsActivities"
      | "SalesAccountsBilling"
      | "SalesAccountsContracts"
      | "SalesOrdersOverview"
      | "SalesOrdersActivities"
      | "SalesOrdersPayments"
      | "SalesOrdersCommissions"
      | "SalesSchedulingSchedule"
      | "SalesSchedulingAppointments"
      | "SalesSchedulingRecurring"
      | "SalesSchedulingRoutes"
      | "SalesSchedulingReminders"
      | "UserHome"
    >(initialVariant);
    let data = $state<Page>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      SalesHomeDashboard: {
        fields: {} as SalesHomeDashboardFieldControllers,
      },
      SalesHomeProducts: {
        fields: {} as SalesHomeProductsFieldControllers,
      },
      SalesHomeServices: {
        fields: {} as SalesHomeServicesFieldControllers,
      },
      SalesHomePackages: {
        fields: {} as SalesHomePackagesFieldControllers,
      },
      SalesHomeTaxRates: {
        fields: {} as SalesHomeTaxRatesFieldControllers,
      },
      SalesLeadsOverview: {
        fields: {} as SalesLeadsOverviewFieldControllers,
      },
      SalesLeadsActivities: {
        fields: {} as SalesLeadsActivitiesFieldControllers,
      },
      SalesLeadsCampaigns: {
        fields: {} as SalesLeadsCampaignsFieldControllers,
      },
      SalesLeadsDripCampaigns: {
        fields: {} as SalesLeadsDripCampaignsFieldControllers,
      },
      SalesLeadsOpportunities: {
        fields: {} as SalesLeadsOpportunitiesFieldControllers,
      },
      SalesLeadsPromotions: {
        fields: {} as SalesLeadsPromotionsFieldControllers,
      },
      SalesAccountsOverview: {
        fields: {} as SalesAccountsOverviewFieldControllers,
      },
      SalesAccountsActivities: {
        fields: {} as SalesAccountsActivitiesFieldControllers,
      },
      SalesAccountsBilling: {
        fields: {} as SalesAccountsBillingFieldControllers,
      },
      SalesAccountsContracts: {
        fields: {} as SalesAccountsContractsFieldControllers,
      },
      SalesOrdersOverview: {
        fields: {} as SalesOrdersOverviewFieldControllers,
      },
      SalesOrdersActivities: {
        fields: {} as SalesOrdersActivitiesFieldControllers,
      },
      SalesOrdersPayments: {
        fields: {} as SalesOrdersPaymentsFieldControllers,
      },
      SalesOrdersCommissions: {
        fields: {} as SalesOrdersCommissionsFieldControllers,
      },
      SalesSchedulingSchedule: {
        fields: {} as SalesSchedulingScheduleFieldControllers,
      },
      SalesSchedulingAppointments: {
        fields: {} as SalesSchedulingAppointmentsFieldControllers,
      },
      SalesSchedulingRecurring: {
        fields: {} as SalesSchedulingRecurringFieldControllers,
      },
      SalesSchedulingRoutes: {
        fields: {} as SalesSchedulingRoutesFieldControllers,
      },
      SalesSchedulingReminders: {
        fields: {} as SalesSchedulingRemindersFieldControllers,
      },
      UserHome: {
        fields: {} as UserHomeFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "SalesHomeDashboard"
        | "SalesHomeProducts"
        | "SalesHomeServices"
        | "SalesHomePackages"
        | "SalesHomeTaxRates"
        | "SalesLeadsOverview"
        | "SalesLeadsActivities"
        | "SalesLeadsCampaigns"
        | "SalesLeadsDripCampaigns"
        | "SalesLeadsOpportunities"
        | "SalesLeadsPromotions"
        | "SalesAccountsOverview"
        | "SalesAccountsActivities"
        | "SalesAccountsBilling"
        | "SalesAccountsContracts"
        | "SalesOrdersOverview"
        | "SalesOrdersActivities"
        | "SalesOrdersPayments"
        | "SalesOrdersCommissions"
        | "SalesSchedulingSchedule"
        | "SalesSchedulingAppointments"
        | "SalesSchedulingRecurring"
        | "SalesSchedulingRoutes"
        | "SalesSchedulingReminders"
        | "UserHome",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Page,
      Array<{ field: string; message: string }>
    > {
      return Page.fromObject(data);
    }
    function reset(overrides?: Partial<Page>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Page, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "SalesHomeDashboard"
      | "SalesHomeProducts"
      | "SalesHomeServices"
      | "SalesHomePackages"
      | "SalesHomeTaxRates"
      | "SalesLeadsOverview"
      | "SalesLeadsActivities"
      | "SalesLeadsCampaigns"
      | "SalesLeadsDripCampaigns"
      | "SalesLeadsOpportunities"
      | "SalesLeadsPromotions"
      | "SalesAccountsOverview"
      | "SalesAccountsActivities"
      | "SalesAccountsBilling"
      | "SalesAccountsContracts"
      | "SalesOrdersOverview"
      | "SalesOrdersActivities"
      | "SalesOrdersPayments"
      | "SalesOrdersCommissions"
      | "SalesSchedulingSchedule"
      | "SalesSchedulingAppointments"
      | "SalesSchedulingRecurring"
      | "SalesSchedulingRoutes"
      | "SalesSchedulingReminders"
      | "UserHome"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "SalesHomeDashboard") {
    } else if (discriminant === "SalesHomeProducts") {
    } else if (discriminant === "SalesHomeServices") {
    } else if (discriminant === "SalesHomePackages") {
    } else if (discriminant === "SalesHomeTaxRates") {
    } else if (discriminant === "SalesLeadsOverview") {
    } else if (discriminant === "SalesLeadsActivities") {
    } else if (discriminant === "SalesLeadsCampaigns") {
    } else if (discriminant === "SalesLeadsDripCampaigns") {
    } else if (discriminant === "SalesLeadsOpportunities") {
    } else if (discriminant === "SalesLeadsPromotions") {
    } else if (discriminant === "SalesAccountsOverview") {
    } else if (discriminant === "SalesAccountsActivities") {
    } else if (discriminant === "SalesAccountsBilling") {
    } else if (discriminant === "SalesAccountsContracts") {
    } else if (discriminant === "SalesOrdersOverview") {
    } else if (discriminant === "SalesOrdersActivities") {
    } else if (discriminant === "SalesOrdersPayments") {
    } else if (discriminant === "SalesOrdersCommissions") {
    } else if (discriminant === "SalesSchedulingSchedule") {
    } else if (discriminant === "SalesSchedulingAppointments") {
    } else if (discriminant === "SalesSchedulingRecurring") {
    } else if (discriminant === "SalesSchedulingRoutes") {
    } else if (discriminant === "SalesSchedulingReminders") {
    } else if (discriminant === "UserHome") {
    }
    return Page.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type UserRole =
  | /** @default */ "Administrator"
  | "SalesRepresentative"
  | "Technician"
  | "HumanResources"
  | "InformationTechnology";

export function defaultValueUserRole(): UserRole {
  return "Administrator";
}

export function toStringifiedJSONUserRole(value: UserRole): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeUserRole(value, ctx));
}
export function toObjectUserRole(value: UserRole): unknown {
  const ctx = SerializeContext.create();
  return __serializeUserRole(value, ctx);
}
export function __serializeUserRole(
  value: UserRole,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONUserRole(
  json: string,
  opts?: DeserializeOptions,
): Result<UserRole, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectUserRole(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectUserRole(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<UserRole, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeUserRole(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "UserRole.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeUserRole(
  value: any,
  ctx: DeserializeContext,
): UserRole | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as UserRole | PendingRef;
  }
  const allowedValues = [
    "Administrator",
    "SalesRepresentative",
    "Technician",
    "HumanResources",
    "InformationTechnology",
  ] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for UserRole: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as UserRole;
}
export function isUserRole(value: unknown): value is UserRole {
  const allowedValues = [
    "Administrator",
    "SalesRepresentative",
    "Technician",
    "HumanResources",
    "InformationTechnology",
  ] as const;
  return allowedValues.includes(value as any);
}

export namespace UserRole {
  /** Per-variant error types */ export type AdministratorErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesRepresentativeErrors = { _errors: Option<Array<string>> };
  export type TechnicianErrors = { _errors: Option<Array<string>> };
  export type HumanResourcesErrors = { _errors: Option<Array<string>> };
  export type InformationTechnologyErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type AdministratorTainted = {};
  export type SalesRepresentativeTainted = {};
  export type TechnicianTainted = {};
  export type HumanResourcesTainted = {};
  export type InformationTechnologyTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Administrator" } & AdministratorErrors)
    | ({ _value: "SalesRepresentative" } & SalesRepresentativeErrors)
    | ({ _value: "Technician" } & TechnicianErrors)
    | ({ _value: "HumanResources" } & HumanResourcesErrors)
    | ({ _value: "InformationTechnology" } & InformationTechnologyErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Administrator" } & AdministratorTainted)
    | ({ _value: "SalesRepresentative" } & SalesRepresentativeTainted)
    | ({ _value: "Technician" } & TechnicianTainted)
    | ({ _value: "HumanResources" } & HumanResourcesTainted)
    | ({ _value: "InformationTechnology" } & InformationTechnologyTainted);
  /** Per-variant field controller types */ export interface AdministratorFieldControllers {}
  export interface SalesRepresentativeFieldControllers {}
  export interface TechnicianFieldControllers {}
  export interface HumanResourcesFieldControllers {}
  export interface InformationTechnologyFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Administrator"
      | "SalesRepresentative"
      | "Technician"
      | "HumanResources"
      | "InformationTechnology";
    readonly data: UserRole;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Administrator"
        | "SalesRepresentative"
        | "Technician"
        | "HumanResources"
        | "InformationTechnology",
    ): void;
    validate(): Result<UserRole, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<UserRole>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Administrator: { readonly fields: AdministratorFieldControllers };
    readonly SalesRepresentative: {
      readonly fields: SalesRepresentativeFieldControllers;
    };
    readonly Technician: { readonly fields: TechnicianFieldControllers };
    readonly HumanResources: {
      readonly fields: HumanResourcesFieldControllers;
    };
    readonly InformationTechnology: {
      readonly fields: InformationTechnologyFieldControllers;
    };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): UserRole {
    switch (variant) {
      case "Administrator":
        return "Administrator" as UserRole;
      case "SalesRepresentative":
        return "SalesRepresentative" as UserRole;
      case "Technician":
        return "Technician" as UserRole;
      case "HumanResources":
        return "HumanResources" as UserRole;
      case "InformationTechnology":
        return "InformationTechnology" as UserRole;
      default:
        return "Administrator" as UserRole;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: UserRole,
  ): Gigaform {
    const initialVariant:
      | "Administrator"
      | "SalesRepresentative"
      | "Technician"
      | "HumanResources"
      | "InformationTechnology" =
      (initial as
        | "Administrator"
        | "SalesRepresentative"
        | "Technician"
        | "HumanResources"
        | "InformationTechnology") ?? "Administrator";
    let currentVariant = $state<
      | "Administrator"
      | "SalesRepresentative"
      | "Technician"
      | "HumanResources"
      | "InformationTechnology"
    >(initialVariant);
    let data = $state<UserRole>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Administrator: {
        fields: {} as AdministratorFieldControllers,
      },
      SalesRepresentative: {
        fields: {} as SalesRepresentativeFieldControllers,
      },
      Technician: {
        fields: {} as TechnicianFieldControllers,
      },
      HumanResources: {
        fields: {} as HumanResourcesFieldControllers,
      },
      InformationTechnology: {
        fields: {} as InformationTechnologyFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Administrator"
        | "SalesRepresentative"
        | "Technician"
        | "HumanResources"
        | "InformationTechnology",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      UserRole,
      Array<{ field: string; message: string }>
    > {
      return UserRole.fromObject(data);
    }
    function reset(overrides?: Partial<UserRole>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<UserRole, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Administrator"
      | "SalesRepresentative"
      | "Technician"
      | "HumanResources"
      | "InformationTechnology"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Administrator") {
    } else if (discriminant === "SalesRepresentative") {
    } else if (discriminant === "Technician") {
    } else if (discriminant === "HumanResources") {
    } else if (discriminant === "InformationTechnology") {
    }
    return UserRole.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type Target =
  | /** @default */ Account
  | User
  | Employee
  | Appointment
  | Lead
  | TaxRate
  | Site
  | Route
  | Company
  | Product
  | Service
  | Order
  | Payment
  | Package
  | Promotion
  | Represents
  | Ordered;

export function defaultValueTarget(): Target {
  return Account.defaultValue();
}

export function toStringifiedJSONTarget(value: Target): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeTarget(value, ctx));
}
export function toObjectTarget(value: Target): unknown {
  const ctx = SerializeContext.create();
  return __serializeTarget(value, ctx);
}
export function __serializeTarget(
  value: Target,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONTarget(
  json: string,
  opts?: DeserializeOptions,
): Result<Target, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectTarget(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectTarget(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Target, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeTarget(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Target.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeTarget(
  value: any,
  ctx: DeserializeContext,
): Target | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as Target | PendingRef;
  }
  if (typeof value !== "object" || value === null) {
    throw new DeserializeError([
      { field: "_root", message: "Target.__deserialize: expected an object" },
    ]);
  }
  const __typeName = (value as any).__type;
  if (typeof __typeName !== "string") {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Target.__deserialize: missing __type field for union dispatch",
      },
    ]);
  }
  if (__typeName === "Account") {
    if (typeof (Account as any)?.__deserialize === "function") {
      return (Account as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "User") {
    if (typeof (User as any)?.__deserialize === "function") {
      return (User as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "Employee") {
    if (typeof (Employee as any)?.__deserialize === "function") {
      return (Employee as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "Appointment") {
    if (typeof (Appointment as any)?.__deserialize === "function") {
      return (Appointment as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "Lead") {
    if (typeof (Lead as any)?.__deserialize === "function") {
      return (Lead as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "TaxRate") {
    if (typeof (TaxRate as any)?.__deserialize === "function") {
      return (TaxRate as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "Site") {
    if (typeof (Site as any)?.__deserialize === "function") {
      return (Site as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "Route") {
    if (typeof (Route as any)?.__deserialize === "function") {
      return (Route as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "Company") {
    if (typeof (Company as any)?.__deserialize === "function") {
      return (Company as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "Product") {
    if (typeof (Product as any)?.__deserialize === "function") {
      return (Product as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "Service") {
    if (typeof (Service as any)?.__deserialize === "function") {
      return (Service as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "Order") {
    if (typeof (Order as any)?.__deserialize === "function") {
      return (Order as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "Payment") {
    if (typeof (Payment as any)?.__deserialize === "function") {
      return (Payment as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "Package") {
    if (typeof (Package as any)?.__deserialize === "function") {
      return (Package as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "Promotion") {
    if (typeof (Promotion as any)?.__deserialize === "function") {
      return (Promotion as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "Represents") {
    if (typeof (Represents as any)?.__deserialize === "function") {
      return (Represents as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  if (__typeName === "Ordered") {
    if (typeof (Ordered as any)?.__deserialize === "function") {
      return (Ordered as any).__deserialize(value, ctx) as Target;
    }
    return value as Target;
  }
  throw new DeserializeError([
    {
      field: "_root",
      message:
        'Target.__deserialize: unknown type "' +
        __typeName +
        '". Expected one of: Account, User, Employee, Appointment, Lead, TaxRate, Site, Route, Company, Product, Service, Order, Payment, Package, Promotion, Represents, Ordered',
    },
  ]);
}
export function isTarget(value: unknown): value is Target {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const __typeName = (value as any).__type;
  return (
    __typeName === "Account" ||
    __typeName === "User" ||
    __typeName === "Employee" ||
    __typeName === "Appointment" ||
    __typeName === "Lead" ||
    __typeName === "TaxRate" ||
    __typeName === "Site" ||
    __typeName === "Route" ||
    __typeName === "Company" ||
    __typeName === "Product" ||
    __typeName === "Service" ||
    __typeName === "Order" ||
    __typeName === "Payment" ||
    __typeName === "Package" ||
    __typeName === "Promotion" ||
    __typeName === "Represents" ||
    __typeName === "Ordered"
  );
}

export namespace Target {
  /** Per-variant error types */ export type AccountErrors = {
    _errors: Option<Array<string>>;
  };
  export type UserErrors = { _errors: Option<Array<string>> };
  export type EmployeeErrors = { _errors: Option<Array<string>> };
  export type AppointmentErrors = { _errors: Option<Array<string>> };
  export type LeadErrors = { _errors: Option<Array<string>> };
  export type TaxRateErrors = { _errors: Option<Array<string>> };
  export type SiteErrors = { _errors: Option<Array<string>> };
  export type RouteErrors = { _errors: Option<Array<string>> };
  export type CompanyErrors = { _errors: Option<Array<string>> };
  export type ProductErrors = { _errors: Option<Array<string>> };
  export type ServiceErrors = { _errors: Option<Array<string>> };
  export type OrderErrors = { _errors: Option<Array<string>> };
  export type PaymentErrors = { _errors: Option<Array<string>> };
  export type PackageErrors = { _errors: Option<Array<string>> };
  export type PromotionErrors = { _errors: Option<Array<string>> };
  export type RepresentsErrors = { _errors: Option<Array<string>> };
  export type OrderedErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type AccountTainted = {};
  export type UserTainted = {};
  export type EmployeeTainted = {};
  export type AppointmentTainted = {};
  export type LeadTainted = {};
  export type TaxRateTainted = {};
  export type SiteTainted = {};
  export type RouteTainted = {};
  export type CompanyTainted = {};
  export type ProductTainted = {};
  export type ServiceTainted = {};
  export type OrderTainted = {};
  export type PaymentTainted = {};
  export type PackageTainted = {};
  export type PromotionTainted = {};
  export type RepresentsTainted = {};
  export type OrderedTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "Account" } & AccountErrors)
    | ({ _type: "User" } & UserErrors)
    | ({ _type: "Employee" } & EmployeeErrors)
    | ({ _type: "Appointment" } & AppointmentErrors)
    | ({ _type: "Lead" } & LeadErrors)
    | ({ _type: "TaxRate" } & TaxRateErrors)
    | ({ _type: "Site" } & SiteErrors)
    | ({ _type: "Route" } & RouteErrors)
    | ({ _type: "Company" } & CompanyErrors)
    | ({ _type: "Product" } & ProductErrors)
    | ({ _type: "Service" } & ServiceErrors)
    | ({ _type: "Order" } & OrderErrors)
    | ({ _type: "Payment" } & PaymentErrors)
    | ({ _type: "Package" } & PackageErrors)
    | ({ _type: "Promotion" } & PromotionErrors)
    | ({ _type: "Represents" } & RepresentsErrors)
    | ({ _type: "Ordered" } & OrderedErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "Account" } & AccountTainted)
    | ({ _type: "User" } & UserTainted)
    | ({ _type: "Employee" } & EmployeeTainted)
    | ({ _type: "Appointment" } & AppointmentTainted)
    | ({ _type: "Lead" } & LeadTainted)
    | ({ _type: "TaxRate" } & TaxRateTainted)
    | ({ _type: "Site" } & SiteTainted)
    | ({ _type: "Route" } & RouteTainted)
    | ({ _type: "Company" } & CompanyTainted)
    | ({ _type: "Product" } & ProductTainted)
    | ({ _type: "Service" } & ServiceTainted)
    | ({ _type: "Order" } & OrderTainted)
    | ({ _type: "Payment" } & PaymentTainted)
    | ({ _type: "Package" } & PackageTainted)
    | ({ _type: "Promotion" } & PromotionTainted)
    | ({ _type: "Represents" } & RepresentsTainted)
    | ({ _type: "Ordered" } & OrderedTainted);
  /** Per-variant field controller types */ export interface AccountFieldControllers {}
  export interface UserFieldControllers {}
  export interface EmployeeFieldControllers {}
  export interface AppointmentFieldControllers {}
  export interface LeadFieldControllers {}
  export interface TaxRateFieldControllers {}
  export interface SiteFieldControllers {}
  export interface RouteFieldControllers {}
  export interface CompanyFieldControllers {}
  export interface ProductFieldControllers {}
  export interface ServiceFieldControllers {}
  export interface OrderFieldControllers {}
  export interface PaymentFieldControllers {}
  export interface PackageFieldControllers {}
  export interface PromotionFieldControllers {}
  export interface RepresentsFieldControllers {}
  export interface OrderedFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Account"
      | "User"
      | "Employee"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered";
    readonly data: Target;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Account"
        | "User"
        | "Employee"
        | "Appointment"
        | "Lead"
        | "TaxRate"
        | "Site"
        | "Route"
        | "Company"
        | "Product"
        | "Service"
        | "Order"
        | "Payment"
        | "Package"
        | "Promotion"
        | "Represents"
        | "Ordered",
    ): void;
    validate(): Result<Target, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Target>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Account: { readonly fields: AccountFieldControllers };
    readonly User: { readonly fields: UserFieldControllers };
    readonly Employee: { readonly fields: EmployeeFieldControllers };
    readonly Appointment: { readonly fields: AppointmentFieldControllers };
    readonly Lead: { readonly fields: LeadFieldControllers };
    readonly TaxRate: { readonly fields: TaxRateFieldControllers };
    readonly Site: { readonly fields: SiteFieldControllers };
    readonly Route: { readonly fields: RouteFieldControllers };
    readonly Company: { readonly fields: CompanyFieldControllers };
    readonly Product: { readonly fields: ProductFieldControllers };
    readonly Service: { readonly fields: ServiceFieldControllers };
    readonly Order: { readonly fields: OrderFieldControllers };
    readonly Payment: { readonly fields: PaymentFieldControllers };
    readonly Package: { readonly fields: PackageFieldControllers };
    readonly Promotion: { readonly fields: PromotionFieldControllers };
    readonly Represents: { readonly fields: RepresentsFieldControllers };
    readonly Ordered: { readonly fields: OrderedFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Target {
    switch (variant) {
      case "Account":
        return Account.defaultValue() as Target;
      case "User":
        return User.defaultValue() as Target;
      case "Employee":
        return Employee.defaultValue() as Target;
      case "Appointment":
        return Appointment.defaultValue() as Target;
      case "Lead":
        return Lead.defaultValue() as Target;
      case "TaxRate":
        return TaxRate.defaultValue() as Target;
      case "Site":
        return Site.defaultValue() as Target;
      case "Route":
        return Route.defaultValue() as Target;
      case "Company":
        return Company.defaultValue() as Target;
      case "Product":
        return Product.defaultValue() as Target;
      case "Service":
        return Service.defaultValue() as Target;
      case "Order":
        return Order.defaultValue() as Target;
      case "Payment":
        return Payment.defaultValue() as Target;
      case "Package":
        return Package.defaultValue() as Target;
      case "Promotion":
        return Promotion.defaultValue() as Target;
      case "Represents":
        return Represents.defaultValue() as Target;
      case "Ordered":
        return Ordered.defaultValue() as Target;
      default:
        return Account.defaultValue() as Target;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Target,
  ): Gigaform {
    const initialVariant:
      | "Account"
      | "User"
      | "Employee"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered" = "Account";
    let currentVariant = $state<
      | "Account"
      | "User"
      | "Employee"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered"
    >(initialVariant);
    let data = $state<Target>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Account: {
        fields: {} as AccountFieldControllers,
      },
      User: {
        fields: {} as UserFieldControllers,
      },
      Employee: {
        fields: {} as EmployeeFieldControllers,
      },
      Appointment: {
        fields: {} as AppointmentFieldControllers,
      },
      Lead: {
        fields: {} as LeadFieldControllers,
      },
      TaxRate: {
        fields: {} as TaxRateFieldControllers,
      },
      Site: {
        fields: {} as SiteFieldControllers,
      },
      Route: {
        fields: {} as RouteFieldControllers,
      },
      Company: {
        fields: {} as CompanyFieldControllers,
      },
      Product: {
        fields: {} as ProductFieldControllers,
      },
      Service: {
        fields: {} as ServiceFieldControllers,
      },
      Order: {
        fields: {} as OrderFieldControllers,
      },
      Payment: {
        fields: {} as PaymentFieldControllers,
      },
      Package: {
        fields: {} as PackageFieldControllers,
      },
      Promotion: {
        fields: {} as PromotionFieldControllers,
      },
      Represents: {
        fields: {} as RepresentsFieldControllers,
      },
      Ordered: {
        fields: {} as OrderedFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Account"
        | "User"
        | "Employee"
        | "Appointment"
        | "Lead"
        | "TaxRate"
        | "Site"
        | "Route"
        | "Company"
        | "Product"
        | "Service"
        | "Order"
        | "Payment"
        | "Package"
        | "Promotion"
        | "Represents"
        | "Ordered",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Target,
      Array<{ field: string; message: string }>
    > {
      return Target.fromObject(data);
    }
    function reset(overrides?: Partial<Target>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Target, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as
      | "Account"
      | "User"
      | "Employee"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "Account") {
    } else if (discriminant === "User") {
    } else if (discriminant === "Employee") {
    } else if (discriminant === "Appointment") {
    } else if (discriminant === "Lead") {
    } else if (discriminant === "TaxRate") {
    } else if (discriminant === "Site") {
    } else if (discriminant === "Route") {
    } else if (discriminant === "Company") {
    } else if (discriminant === "Product") {
    } else if (discriminant === "Service") {
    } else if (discriminant === "Order") {
    } else if (discriminant === "Payment") {
    } else if (discriminant === "Package") {
    } else if (discriminant === "Promotion") {
    } else if (discriminant === "Represents") {
    } else if (discriminant === "Ordered") {
    }
    return Target.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type RecurrenceEnd = /** @default(0) */ number | string;

export function defaultValueRecurrenceEnd(): RecurrenceEnd {
  return 0;
}

export function toStringifiedJSONRecurrenceEnd(value: RecurrenceEnd): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeRecurrenceEnd(value, ctx));
}
export function toObjectRecurrenceEnd(value: RecurrenceEnd): unknown {
  const ctx = SerializeContext.create();
  return __serializeRecurrenceEnd(value, ctx);
}
export function __serializeRecurrenceEnd(
  value: RecurrenceEnd,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONRecurrenceEnd(
  json: string,
  opts?: DeserializeOptions,
): Result<RecurrenceEnd, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectRecurrenceEnd(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectRecurrenceEnd(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<RecurrenceEnd, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeRecurrenceEnd(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "RecurrenceEnd.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeRecurrenceEnd(
  value: any,
  ctx: DeserializeContext,
): RecurrenceEnd | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as RecurrenceEnd | PendingRef;
  }
  if (typeof value === "number") {
    return value as RecurrenceEnd;
  }
  if (typeof value === "string") {
    return value as RecurrenceEnd;
  }
  throw new DeserializeError([
    {
      field: "_root",
      message:
        "RecurrenceEnd.__deserialize: expected number, string, got " +
        typeof value,
    },
  ]);
}
export function isRecurrenceEnd(value: unknown): value is RecurrenceEnd {
  return typeof value === "number" || typeof value === "string";
}

export namespace RecurrenceEnd {
  /** Per-variant error types */ export type NumberErrors = {
    _errors: Option<Array<string>>;
  };
  export type StringErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type NumberTainted = {};
  export type StringTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "number" } & NumberErrors)
    | ({ _type: "string" } & StringErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "number" } & NumberTainted)
    | ({ _type: "string" } & StringTainted);
  /** Per-variant field controller types */ export interface NumberFieldControllers {}
  export interface StringFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "number" | "string";
    readonly data: RecurrenceEnd;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "number" | "string"): void;
    validate(): Result<
      RecurrenceEnd,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<RecurrenceEnd>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly number: { readonly fields: NumberFieldControllers };
    readonly string: { readonly fields: StringFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): RecurrenceEnd {
    switch (variant) {
      case "number":
        return 0 as RecurrenceEnd;
      case "string":
        return "" as RecurrenceEnd;
      default:
        return 0 as RecurrenceEnd;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: RecurrenceEnd,
  ): Gigaform {
    const initialVariant: "number" | "string" = "number";
    let currentVariant = $state<"number" | "string">(initialVariant);
    let data = $state<RecurrenceEnd>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      number: {
        fields: {} as NumberFieldControllers,
      },
      string: {
        fields: {} as StringFieldControllers,
      },
    };
    function switchVariant(variant: "number" | "string"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      RecurrenceEnd,
      Array<{ field: string; message: string }>
    > {
      return RecurrenceEnd.fromObject(data);
    }
    function reset(overrides?: Partial<RecurrenceEnd>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<RecurrenceEnd, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as "number" | "string" | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "number") {
    } else if (discriminant === "string") {
    }
    return RecurrenceEnd.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type OverviewDisplay = /** @default */ "Card" | "Table";

export function defaultValueOverviewDisplay(): OverviewDisplay {
  return "Card";
}

export function toStringifiedJSONOverviewDisplay(
  value: OverviewDisplay,
): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeOverviewDisplay(value, ctx));
}
export function toObjectOverviewDisplay(value: OverviewDisplay): unknown {
  const ctx = SerializeContext.create();
  return __serializeOverviewDisplay(value, ctx);
}
export function __serializeOverviewDisplay(
  value: OverviewDisplay,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONOverviewDisplay(
  json: string,
  opts?: DeserializeOptions,
): Result<OverviewDisplay, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectOverviewDisplay(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectOverviewDisplay(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<OverviewDisplay, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeOverviewDisplay(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "OverviewDisplay.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeOverviewDisplay(
  value: any,
  ctx: DeserializeContext,
): OverviewDisplay | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as OverviewDisplay | PendingRef;
  }
  const allowedValues = ["Card", "Table"] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for OverviewDisplay: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as OverviewDisplay;
}
export function isOverviewDisplay(value: unknown): value is OverviewDisplay {
  const allowedValues = ["Card", "Table"] as const;
  return allowedValues.includes(value as any);
}

export namespace OverviewDisplay {
  /** Per-variant error types */ export type CardErrors = {
    _errors: Option<Array<string>>;
  };
  export type TableErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type CardTainted = {};
  export type TableTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Card" } & CardErrors)
    | ({ _value: "Table" } & TableErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Card" } & CardTainted)
    | ({ _value: "Table" } & TableTainted);
  /** Per-variant field controller types */ export interface CardFieldControllers {}
  export interface TableFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Card" | "Table";
    readonly data: OverviewDisplay;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "Card" | "Table"): void;
    validate(): Result<
      OverviewDisplay,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<OverviewDisplay>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Card: { readonly fields: CardFieldControllers };
    readonly Table: { readonly fields: TableFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): OverviewDisplay {
    switch (variant) {
      case "Card":
        return "Card" as OverviewDisplay;
      case "Table":
        return "Table" as OverviewDisplay;
      default:
        return "Card" as OverviewDisplay;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: OverviewDisplay,
  ): Gigaform {
    const initialVariant: "Card" | "Table" =
      (initial as "Card" | "Table") ?? "Card";
    let currentVariant = $state<"Card" | "Table">(initialVariant);
    let data = $state<OverviewDisplay>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Card: {
        fields: {} as CardFieldControllers,
      },
      Table: {
        fields: {} as TableFieldControllers,
      },
    };
    function switchVariant(variant: "Card" | "Table"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      OverviewDisplay,
      Array<{ field: string; message: string }>
    > {
      return OverviewDisplay.fromObject(data);
    }
    function reset(overrides?: Partial<OverviewDisplay>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<OverviewDisplay, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as "Card" | "Table" | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Card") {
    } else if (discriminant === "Table") {
    }
    return OverviewDisplay.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type IntervalUnit = /** @default */ "Day" | "Week" | "Month" | "Year";

export function defaultValueIntervalUnit(): IntervalUnit {
  return "Day";
}

export function toStringifiedJSONIntervalUnit(value: IntervalUnit): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeIntervalUnit(value, ctx));
}
export function toObjectIntervalUnit(value: IntervalUnit): unknown {
  const ctx = SerializeContext.create();
  return __serializeIntervalUnit(value, ctx);
}
export function __serializeIntervalUnit(
  value: IntervalUnit,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONIntervalUnit(
  json: string,
  opts?: DeserializeOptions,
): Result<IntervalUnit, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectIntervalUnit(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectIntervalUnit(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<IntervalUnit, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeIntervalUnit(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "IntervalUnit.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeIntervalUnit(
  value: any,
  ctx: DeserializeContext,
): IntervalUnit | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as IntervalUnit | PendingRef;
  }
  const allowedValues = ["Day", "Week", "Month", "Year"] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for IntervalUnit: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as IntervalUnit;
}
export function isIntervalUnit(value: unknown): value is IntervalUnit {
  const allowedValues = ["Day", "Week", "Month", "Year"] as const;
  return allowedValues.includes(value as any);
}

export namespace IntervalUnit {
  /** Per-variant error types */ export type DayErrors = {
    _errors: Option<Array<string>>;
  };
  export type WeekErrors = { _errors: Option<Array<string>> };
  export type MonthErrors = { _errors: Option<Array<string>> };
  export type YearErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type DayTainted = {};
  export type WeekTainted = {};
  export type MonthTainted = {};
  export type YearTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Day" } & DayErrors)
    | ({ _value: "Week" } & WeekErrors)
    | ({ _value: "Month" } & MonthErrors)
    | ({ _value: "Year" } & YearErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Day" } & DayTainted)
    | ({ _value: "Week" } & WeekTainted)
    | ({ _value: "Month" } & MonthTainted)
    | ({ _value: "Year" } & YearTainted);
  /** Per-variant field controller types */ export interface DayFieldControllers {}
  export interface WeekFieldControllers {}
  export interface MonthFieldControllers {}
  export interface YearFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Day" | "Week" | "Month" | "Year";
    readonly data: IntervalUnit;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "Day" | "Week" | "Month" | "Year"): void;
    validate(): Result<IntervalUnit, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<IntervalUnit>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Day: { readonly fields: DayFieldControllers };
    readonly Week: { readonly fields: WeekFieldControllers };
    readonly Month: { readonly fields: MonthFieldControllers };
    readonly Year: { readonly fields: YearFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): IntervalUnit {
    switch (variant) {
      case "Day":
        return "Day" as IntervalUnit;
      case "Week":
        return "Week" as IntervalUnit;
      case "Month":
        return "Month" as IntervalUnit;
      case "Year":
        return "Year" as IntervalUnit;
      default:
        return "Day" as IntervalUnit;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: IntervalUnit,
  ): Gigaform {
    const initialVariant: "Day" | "Week" | "Month" | "Year" =
      (initial as "Day" | "Week" | "Month" | "Year") ?? "Day";
    let currentVariant = $state<"Day" | "Week" | "Month" | "Year">(
      initialVariant,
    );
    let data = $state<IntervalUnit>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Day: {
        fields: {} as DayFieldControllers,
      },
      Week: {
        fields: {} as WeekFieldControllers,
      },
      Month: {
        fields: {} as MonthFieldControllers,
      },
      Year: {
        fields: {} as YearFieldControllers,
      },
    };
    function switchVariant(variant: "Day" | "Week" | "Month" | "Year"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      IntervalUnit,
      Array<{ field: string; message: string }>
    > {
      return IntervalUnit.fromObject(data);
    }
    function reset(overrides?: Partial<IntervalUnit>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<IntervalUnit, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Day"
      | "Week"
      | "Month"
      | "Year"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Day") {
    } else if (discriminant === "Week") {
    } else if (discriminant === "Month") {
    } else if (discriminant === "Year") {
    }
    return IntervalUnit.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type Sector = /** @default */ "Residential" | "Commercial";

export function defaultValueSector(): Sector {
  return "Residential";
}

export function toStringifiedJSONSector(value: Sector): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeSector(value, ctx));
}
export function toObjectSector(value: Sector): unknown {
  const ctx = SerializeContext.create();
  return __serializeSector(value, ctx);
}
export function __serializeSector(
  value: Sector,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONSector(
  json: string,
  opts?: DeserializeOptions,
): Result<Sector, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectSector(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectSector(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Sector, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeSector(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Sector.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeSector(
  value: any,
  ctx: DeserializeContext,
): Sector | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as Sector | PendingRef;
  }
  const allowedValues = ["Residential", "Commercial"] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for Sector: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as Sector;
}
export function isSector(value: unknown): value is Sector {
  const allowedValues = ["Residential", "Commercial"] as const;
  return allowedValues.includes(value as any);
}

export namespace Sector {
  /** Per-variant error types */ export type ResidentialErrors = {
    _errors: Option<Array<string>>;
  };
  export type CommercialErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type ResidentialTainted = {};
  export type CommercialTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Residential" } & ResidentialErrors)
    | ({ _value: "Commercial" } & CommercialErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Residential" } & ResidentialTainted)
    | ({ _value: "Commercial" } & CommercialTainted);
  /** Per-variant field controller types */ export interface ResidentialFieldControllers {}
  export interface CommercialFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Residential" | "Commercial";
    readonly data: Sector;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "Residential" | "Commercial"): void;
    validate(): Result<Sector, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Sector>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Residential: { readonly fields: ResidentialFieldControllers };
    readonly Commercial: { readonly fields: CommercialFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Sector {
    switch (variant) {
      case "Residential":
        return "Residential" as Sector;
      case "Commercial":
        return "Commercial" as Sector;
      default:
        return "Residential" as Sector;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Sector,
  ): Gigaform {
    const initialVariant: "Residential" | "Commercial" =
      (initial as "Residential" | "Commercial") ?? "Residential";
    let currentVariant = $state<"Residential" | "Commercial">(initialVariant);
    let data = $state<Sector>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Residential: {
        fields: {} as ResidentialFieldControllers,
      },
      Commercial: {
        fields: {} as CommercialFieldControllers,
      },
    };
    function switchVariant(variant: "Residential" | "Commercial"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Sector,
      Array<{ field: string; message: string }>
    > {
      return Sector.fromObject(data);
    }
    function reset(overrides?: Partial<Sector>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Sector, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Residential"
      | "Commercial"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Residential") {
    } else if (discriminant === "Commercial") {
    }
    return Sector.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type Weekday =
  | /** @default */ "Monday"
  | "Tuesday"
  | "Wednesday"
  | "Thursday"
  | "Friday"
  | "Saturday"
  | "Sunday";

export function defaultValueWeekday(): Weekday {
  return "Monday";
}

export function toStringifiedJSONWeekday(value: Weekday): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeWeekday(value, ctx));
}
export function toObjectWeekday(value: Weekday): unknown {
  const ctx = SerializeContext.create();
  return __serializeWeekday(value, ctx);
}
export function __serializeWeekday(
  value: Weekday,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONWeekday(
  json: string,
  opts?: DeserializeOptions,
): Result<Weekday, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectWeekday(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectWeekday(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Weekday, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeWeekday(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Weekday.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeWeekday(
  value: any,
  ctx: DeserializeContext,
): Weekday | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as Weekday | PendingRef;
  }
  const allowedValues = [
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Sunday",
  ] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for Weekday: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as Weekday;
}
export function isWeekday(value: unknown): value is Weekday {
  const allowedValues = [
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Sunday",
  ] as const;
  return allowedValues.includes(value as any);
}

export namespace Weekday {
  /** Per-variant error types */ export type MondayErrors = {
    _errors: Option<Array<string>>;
  };
  export type TuesdayErrors = { _errors: Option<Array<string>> };
  export type WednesdayErrors = { _errors: Option<Array<string>> };
  export type ThursdayErrors = { _errors: Option<Array<string>> };
  export type FridayErrors = { _errors: Option<Array<string>> };
  export type SaturdayErrors = { _errors: Option<Array<string>> };
  export type SundayErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type MondayTainted = {};
  export type TuesdayTainted = {};
  export type WednesdayTainted = {};
  export type ThursdayTainted = {};
  export type FridayTainted = {};
  export type SaturdayTainted = {};
  export type SundayTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Monday" } & MondayErrors)
    | ({ _value: "Tuesday" } & TuesdayErrors)
    | ({ _value: "Wednesday" } & WednesdayErrors)
    | ({ _value: "Thursday" } & ThursdayErrors)
    | ({ _value: "Friday" } & FridayErrors)
    | ({ _value: "Saturday" } & SaturdayErrors)
    | ({ _value: "Sunday" } & SundayErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Monday" } & MondayTainted)
    | ({ _value: "Tuesday" } & TuesdayTainted)
    | ({ _value: "Wednesday" } & WednesdayTainted)
    | ({ _value: "Thursday" } & ThursdayTainted)
    | ({ _value: "Friday" } & FridayTainted)
    | ({ _value: "Saturday" } & SaturdayTainted)
    | ({ _value: "Sunday" } & SundayTainted);
  /** Per-variant field controller types */ export interface MondayFieldControllers {}
  export interface TuesdayFieldControllers {}
  export interface WednesdayFieldControllers {}
  export interface ThursdayFieldControllers {}
  export interface FridayFieldControllers {}
  export interface SaturdayFieldControllers {}
  export interface SundayFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Monday"
      | "Tuesday"
      | "Wednesday"
      | "Thursday"
      | "Friday"
      | "Saturday"
      | "Sunday";
    readonly data: Weekday;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Monday"
        | "Tuesday"
        | "Wednesday"
        | "Thursday"
        | "Friday"
        | "Saturday"
        | "Sunday",
    ): void;
    validate(): Result<Weekday, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Weekday>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Monday: { readonly fields: MondayFieldControllers };
    readonly Tuesday: { readonly fields: TuesdayFieldControllers };
    readonly Wednesday: { readonly fields: WednesdayFieldControllers };
    readonly Thursday: { readonly fields: ThursdayFieldControllers };
    readonly Friday: { readonly fields: FridayFieldControllers };
    readonly Saturday: { readonly fields: SaturdayFieldControllers };
    readonly Sunday: { readonly fields: SundayFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Weekday {
    switch (variant) {
      case "Monday":
        return "Monday" as Weekday;
      case "Tuesday":
        return "Tuesday" as Weekday;
      case "Wednesday":
        return "Wednesday" as Weekday;
      case "Thursday":
        return "Thursday" as Weekday;
      case "Friday":
        return "Friday" as Weekday;
      case "Saturday":
        return "Saturday" as Weekday;
      case "Sunday":
        return "Sunday" as Weekday;
      default:
        return "Monday" as Weekday;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Weekday,
  ): Gigaform {
    const initialVariant:
      | "Monday"
      | "Tuesday"
      | "Wednesday"
      | "Thursday"
      | "Friday"
      | "Saturday"
      | "Sunday" =
      (initial as
        | "Monday"
        | "Tuesday"
        | "Wednesday"
        | "Thursday"
        | "Friday"
        | "Saturday"
        | "Sunday") ?? "Monday";
    let currentVariant = $state<
      | "Monday"
      | "Tuesday"
      | "Wednesday"
      | "Thursday"
      | "Friday"
      | "Saturday"
      | "Sunday"
    >(initialVariant);
    let data = $state<Weekday>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Monday: {
        fields: {} as MondayFieldControllers,
      },
      Tuesday: {
        fields: {} as TuesdayFieldControllers,
      },
      Wednesday: {
        fields: {} as WednesdayFieldControllers,
      },
      Thursday: {
        fields: {} as ThursdayFieldControllers,
      },
      Friday: {
        fields: {} as FridayFieldControllers,
      },
      Saturday: {
        fields: {} as SaturdayFieldControllers,
      },
      Sunday: {
        fields: {} as SundayFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Monday"
        | "Tuesday"
        | "Wednesday"
        | "Thursday"
        | "Friday"
        | "Saturday"
        | "Sunday",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Weekday,
      Array<{ field: string; message: string }>
    > {
      return Weekday.fromObject(data);
    }
    function reset(overrides?: Partial<Weekday>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Weekday, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Monday"
      | "Tuesday"
      | "Wednesday"
      | "Thursday"
      | "Friday"
      | "Saturday"
      | "Sunday"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Monday") {
    } else if (discriminant === "Tuesday") {
    } else if (discriminant === "Wednesday") {
    } else if (discriminant === "Thursday") {
    } else if (discriminant === "Friday") {
    } else if (discriminant === "Saturday") {
    } else if (discriminant === "Sunday") {
    }
    return Weekday.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type Status = /** @default */ "Scheduled" | "OnDeck" | "Waiting";

export function defaultValueStatus(): Status {
  return "Scheduled";
}

export function toStringifiedJSONStatus(value: Status): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeStatus(value, ctx));
}
export function toObjectStatus(value: Status): unknown {
  const ctx = SerializeContext.create();
  return __serializeStatus(value, ctx);
}
export function __serializeStatus(
  value: Status,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONStatus(
  json: string,
  opts?: DeserializeOptions,
): Result<Status, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectStatus(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectStatus(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Status, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeStatus(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Status.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeStatus(
  value: any,
  ctx: DeserializeContext,
): Status | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as Status | PendingRef;
  }
  const allowedValues = ["Scheduled", "OnDeck", "Waiting"] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for Status: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as Status;
}
export function isStatus(value: unknown): value is Status {
  const allowedValues = ["Scheduled", "OnDeck", "Waiting"] as const;
  return allowedValues.includes(value as any);
}

export namespace Status {
  /** Per-variant error types */ export type ScheduledErrors = {
    _errors: Option<Array<string>>;
  };
  export type OnDeckErrors = { _errors: Option<Array<string>> };
  export type WaitingErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type ScheduledTainted = {};
  export type OnDeckTainted = {};
  export type WaitingTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Scheduled" } & ScheduledErrors)
    | ({ _value: "OnDeck" } & OnDeckErrors)
    | ({ _value: "Waiting" } & WaitingErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Scheduled" } & ScheduledTainted)
    | ({ _value: "OnDeck" } & OnDeckTainted)
    | ({ _value: "Waiting" } & WaitingTainted);
  /** Per-variant field controller types */ export interface ScheduledFieldControllers {}
  export interface OnDeckFieldControllers {}
  export interface WaitingFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Scheduled" | "OnDeck" | "Waiting";
    readonly data: Status;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "Scheduled" | "OnDeck" | "Waiting"): void;
    validate(): Result<Status, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Status>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Scheduled: { readonly fields: ScheduledFieldControllers };
    readonly OnDeck: { readonly fields: OnDeckFieldControllers };
    readonly Waiting: { readonly fields: WaitingFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Status {
    switch (variant) {
      case "Scheduled":
        return "Scheduled" as Status;
      case "OnDeck":
        return "OnDeck" as Status;
      case "Waiting":
        return "Waiting" as Status;
      default:
        return "Scheduled" as Status;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Status,
  ): Gigaform {
    const initialVariant: "Scheduled" | "OnDeck" | "Waiting" =
      (initial as "Scheduled" | "OnDeck" | "Waiting") ?? "Scheduled";
    let currentVariant = $state<"Scheduled" | "OnDeck" | "Waiting">(
      initialVariant,
    );
    let data = $state<Status>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Scheduled: {
        fields: {} as ScheduledFieldControllers,
      },
      OnDeck: {
        fields: {} as OnDeckFieldControllers,
      },
      Waiting: {
        fields: {} as WaitingFieldControllers,
      },
    };
    function switchVariant(variant: "Scheduled" | "OnDeck" | "Waiting"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Status,
      Array<{ field: string; message: string }>
    > {
      return Status.fromObject(data);
    }
    function reset(overrides?: Partial<Status>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Status, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Scheduled"
      | "OnDeck"
      | "Waiting"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Scheduled") {
    } else if (discriminant === "OnDeck") {
    } else if (discriminant === "Waiting") {
    }
    return Status.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type NextStep = /** @default */
  | "InitialContact"
  | "Qualified"
  | "Estimate"
  | "Negotiation";

export function defaultValueNextStep(): NextStep {
  return "InitialContact";
}

export function toStringifiedJSONNextStep(value: NextStep): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeNextStep(value, ctx));
}
export function toObjectNextStep(value: NextStep): unknown {
  const ctx = SerializeContext.create();
  return __serializeNextStep(value, ctx);
}
export function __serializeNextStep(
  value: NextStep,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONNextStep(
  json: string,
  opts?: DeserializeOptions,
): Result<NextStep, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectNextStep(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectNextStep(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<NextStep, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeNextStep(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "NextStep.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeNextStep(
  value: any,
  ctx: DeserializeContext,
): NextStep | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as NextStep | PendingRef;
  }
  const allowedValues = [
    "InitialContact",
    "Qualified",
    "Estimate",
    "Negotiation",
  ] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for NextStep: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as NextStep;
}
export function isNextStep(value: unknown): value is NextStep {
  const allowedValues = [
    "InitialContact",
    "Qualified",
    "Estimate",
    "Negotiation",
  ] as const;
  return allowedValues.includes(value as any);
}

export namespace NextStep {
  /** Per-variant error types */ export type InitialContactErrors = {
    _errors: Option<Array<string>>;
  };
  export type QualifiedErrors = { _errors: Option<Array<string>> };
  export type EstimateErrors = { _errors: Option<Array<string>> };
  export type NegotiationErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type InitialContactTainted = {};
  export type QualifiedTainted = {};
  export type EstimateTainted = {};
  export type NegotiationTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "InitialContact" } & InitialContactErrors)
    | ({ _value: "Qualified" } & QualifiedErrors)
    | ({ _value: "Estimate" } & EstimateErrors)
    | ({ _value: "Negotiation" } & NegotiationErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "InitialContact" } & InitialContactTainted)
    | ({ _value: "Qualified" } & QualifiedTainted)
    | ({ _value: "Estimate" } & EstimateTainted)
    | ({ _value: "Negotiation" } & NegotiationTainted);
  /** Per-variant field controller types */ export interface InitialContactFieldControllers {}
  export interface QualifiedFieldControllers {}
  export interface EstimateFieldControllers {}
  export interface NegotiationFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "InitialContact"
      | "Qualified"
      | "Estimate"
      | "Negotiation";
    readonly data: NextStep;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation",
    ): void;
    validate(): Result<NextStep, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<NextStep>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly InitialContact: {
      readonly fields: InitialContactFieldControllers;
    };
    readonly Qualified: { readonly fields: QualifiedFieldControllers };
    readonly Estimate: { readonly fields: EstimateFieldControllers };
    readonly Negotiation: { readonly fields: NegotiationFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): NextStep {
    switch (variant) {
      case "InitialContact":
        return "InitialContact" as NextStep;
      case "Qualified":
        return "Qualified" as NextStep;
      case "Estimate":
        return "Estimate" as NextStep;
      case "Negotiation":
        return "Negotiation" as NextStep;
      default:
        return "InitialContact" as NextStep;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: NextStep,
  ): Gigaform {
    const initialVariant:
      | "InitialContact"
      | "Qualified"
      | "Estimate"
      | "Negotiation" =
      (initial as
        | "InitialContact"
        | "Qualified"
        | "Estimate"
        | "Negotiation") ?? "InitialContact";
    let currentVariant = $state<
      "InitialContact" | "Qualified" | "Estimate" | "Negotiation"
    >(initialVariant);
    let data = $state<NextStep>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      InitialContact: {
        fields: {} as InitialContactFieldControllers,
      },
      Qualified: {
        fields: {} as QualifiedFieldControllers,
      },
      Estimate: {
        fields: {} as EstimateFieldControllers,
      },
      Negotiation: {
        fields: {} as NegotiationFieldControllers,
      },
    };
    function switchVariant(
      variant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      NextStep,
      Array<{ field: string; message: string }>
    > {
      return NextStep.fromObject(data);
    }
    function reset(overrides?: Partial<NextStep>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<NextStep, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "InitialContact"
      | "Qualified"
      | "Estimate"
      | "Negotiation"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "InitialContact") {
    } else if (discriminant === "Qualified") {
    } else if (discriminant === "Estimate") {
    } else if (discriminant === "Negotiation") {
    }
    return NextStep.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type LeadStage =
  | /** @default */ "Open"
  | "InitialContact"
  | "Qualified"
  | "Estimate"
  | "Negotiation";

export function defaultValueLeadStage(): LeadStage {
  return "Open";
}

export function toStringifiedJSONLeadStage(value: LeadStage): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeLeadStage(value, ctx));
}
export function toObjectLeadStage(value: LeadStage): unknown {
  const ctx = SerializeContext.create();
  return __serializeLeadStage(value, ctx);
}
export function __serializeLeadStage(
  value: LeadStage,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONLeadStage(
  json: string,
  opts?: DeserializeOptions,
): Result<LeadStage, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectLeadStage(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectLeadStage(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<LeadStage, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeLeadStage(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "LeadStage.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeLeadStage(
  value: any,
  ctx: DeserializeContext,
): LeadStage | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as LeadStage | PendingRef;
  }
  const allowedValues = [
    "Open",
    "InitialContact",
    "Qualified",
    "Estimate",
    "Negotiation",
  ] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for LeadStage: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as LeadStage;
}
export function isLeadStage(value: unknown): value is LeadStage {
  const allowedValues = [
    "Open",
    "InitialContact",
    "Qualified",
    "Estimate",
    "Negotiation",
  ] as const;
  return allowedValues.includes(value as any);
}

export namespace LeadStage {
  /** Per-variant error types */ export type OpenErrors = {
    _errors: Option<Array<string>>;
  };
  export type InitialContactErrors = { _errors: Option<Array<string>> };
  export type QualifiedErrors = { _errors: Option<Array<string>> };
  export type EstimateErrors = { _errors: Option<Array<string>> };
  export type NegotiationErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type OpenTainted = {};
  export type InitialContactTainted = {};
  export type QualifiedTainted = {};
  export type EstimateTainted = {};
  export type NegotiationTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Open" } & OpenErrors)
    | ({ _value: "InitialContact" } & InitialContactErrors)
    | ({ _value: "Qualified" } & QualifiedErrors)
    | ({ _value: "Estimate" } & EstimateErrors)
    | ({ _value: "Negotiation" } & NegotiationErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Open" } & OpenTainted)
    | ({ _value: "InitialContact" } & InitialContactTainted)
    | ({ _value: "Qualified" } & QualifiedTainted)
    | ({ _value: "Estimate" } & EstimateTainted)
    | ({ _value: "Negotiation" } & NegotiationTainted);
  /** Per-variant field controller types */ export interface OpenFieldControllers {}
  export interface InitialContactFieldControllers {}
  export interface QualifiedFieldControllers {}
  export interface EstimateFieldControllers {}
  export interface NegotiationFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Open"
      | "InitialContact"
      | "Qualified"
      | "Estimate"
      | "Negotiation";
    readonly data: LeadStage;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Open"
        | "InitialContact"
        | "Qualified"
        | "Estimate"
        | "Negotiation",
    ): void;
    validate(): Result<LeadStage, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<LeadStage>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Open: { readonly fields: OpenFieldControllers };
    readonly InitialContact: {
      readonly fields: InitialContactFieldControllers;
    };
    readonly Qualified: { readonly fields: QualifiedFieldControllers };
    readonly Estimate: { readonly fields: EstimateFieldControllers };
    readonly Negotiation: { readonly fields: NegotiationFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): LeadStage {
    switch (variant) {
      case "Open":
        return "Open" as LeadStage;
      case "InitialContact":
        return "InitialContact" as LeadStage;
      case "Qualified":
        return "Qualified" as LeadStage;
      case "Estimate":
        return "Estimate" as LeadStage;
      case "Negotiation":
        return "Negotiation" as LeadStage;
      default:
        return "Open" as LeadStage;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: LeadStage,
  ): Gigaform {
    const initialVariant:
      | "Open"
      | "InitialContact"
      | "Qualified"
      | "Estimate"
      | "Negotiation" =
      (initial as
        | "Open"
        | "InitialContact"
        | "Qualified"
        | "Estimate"
        | "Negotiation") ?? "Open";
    let currentVariant = $state<
      "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation"
    >(initialVariant);
    let data = $state<LeadStage>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Open: {
        fields: {} as OpenFieldControllers,
      },
      InitialContact: {
        fields: {} as InitialContactFieldControllers,
      },
      Qualified: {
        fields: {} as QualifiedFieldControllers,
      },
      Estimate: {
        fields: {} as EstimateFieldControllers,
      },
      Negotiation: {
        fields: {} as NegotiationFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Open"
        | "InitialContact"
        | "Qualified"
        | "Estimate"
        | "Negotiation",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      LeadStage,
      Array<{ field: string; message: string }>
    > {
      return LeadStage.fromObject(data);
    }
    function reset(overrides?: Partial<LeadStage>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<LeadStage, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Open"
      | "InitialContact"
      | "Qualified"
      | "Estimate"
      | "Negotiation"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Open") {
    } else if (discriminant === "InitialContact") {
    } else if (discriminant === "Qualified") {
    } else if (discriminant === "Estimate") {
    } else if (discriminant === "Negotiation") {
    }
    return LeadStage.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
/** @enumFieldsetController({ legend: "Name", variants: { CompanyName: { label: "Company" }, PersonName: { label: "Person" } } }) */
export type AccountName = /** @default */ CompanyName | PersonName;

export function defaultValueAccountName(): AccountName {
  return CompanyName.defaultValue();
}

export function toStringifiedJSONAccountName(value: AccountName): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeAccountName(value, ctx));
}
export function toObjectAccountName(value: AccountName): unknown {
  const ctx = SerializeContext.create();
  return __serializeAccountName(value, ctx);
}
export function __serializeAccountName(
  value: AccountName,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONAccountName(
  json: string,
  opts?: DeserializeOptions,
): Result<AccountName, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectAccountName(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectAccountName(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<AccountName, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeAccountName(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "AccountName.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeAccountName(
  value: any,
  ctx: DeserializeContext,
): AccountName | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as AccountName | PendingRef;
  }
  if (typeof value !== "object" || value === null) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "AccountName.__deserialize: expected an object",
      },
    ]);
  }
  const __typeName = (value as any).__type;
  if (typeof __typeName !== "string") {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "AccountName.__deserialize: missing __type field for union dispatch",
      },
    ]);
  }
  if (__typeName === "CompanyName") {
    if (typeof (CompanyName as any)?.__deserialize === "function") {
      return (CompanyName as any).__deserialize(value, ctx) as AccountName;
    }
    return value as AccountName;
  }
  if (__typeName === "PersonName") {
    if (typeof (PersonName as any)?.__deserialize === "function") {
      return (PersonName as any).__deserialize(value, ctx) as AccountName;
    }
    return value as AccountName;
  }
  throw new DeserializeError([
    {
      field: "_root",
      message:
        'AccountName.__deserialize: unknown type "' +
        __typeName +
        '". Expected one of: CompanyName, PersonName',
    },
  ]);
}
export function isAccountName(value: unknown): value is AccountName {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const __typeName = (value as any).__type;
  return __typeName === "CompanyName" || __typeName === "PersonName";
}

export namespace AccountName {
  /** Per-variant error types */ export type CompanyNameErrors = {
    _errors: Option<Array<string>>;
  };
  export type PersonNameErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type CompanyNameTainted = {};
  export type PersonNameTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "CompanyName" } & CompanyNameErrors)
    | ({ _type: "PersonName" } & PersonNameErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "CompanyName" } & CompanyNameTainted)
    | ({ _type: "PersonName" } & PersonNameTainted);
  /** Per-variant field controller types */ export interface CompanyNameFieldControllers {}
  export interface PersonNameFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "CompanyName" | "PersonName";
    readonly data: AccountName;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "CompanyName" | "PersonName"): void;
    validate(): Result<AccountName, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<AccountName>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly CompanyName: { readonly fields: CompanyNameFieldControllers };
    readonly PersonName: { readonly fields: PersonNameFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): AccountName {
    switch (variant) {
      case "CompanyName":
        return CompanyName.defaultValue() as AccountName;
      case "PersonName":
        return PersonName.defaultValue() as AccountName;
      default:
        return CompanyName.defaultValue() as AccountName;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: AccountName,
  ): Gigaform {
    const initialVariant: "CompanyName" | "PersonName" = "CompanyName";
    let currentVariant = $state<"CompanyName" | "PersonName">(initialVariant);
    let data = $state<AccountName>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      CompanyName: {
        fields: {} as CompanyNameFieldControllers,
      },
      PersonName: {
        fields: {} as PersonNameFieldControllers,
      },
    };
    function switchVariant(variant: "CompanyName" | "PersonName"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      AccountName,
      Array<{ field: string; message: string }>
    > {
      return AccountName.fromObject(data);
    }
    function reset(overrides?: Partial<AccountName>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<AccountName, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as
      | "CompanyName"
      | "PersonName"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "CompanyName") {
    } else if (discriminant === "PersonName") {
    }
    return AccountName.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type Priority = /** @default */ "Medium" | "High" | "Low";

export function defaultValuePriority(): Priority {
  return "Medium";
}

export function toStringifiedJSONPriority(value: Priority): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializePriority(value, ctx));
}
export function toObjectPriority(value: Priority): unknown {
  const ctx = SerializeContext.create();
  return __serializePriority(value, ctx);
}
export function __serializePriority(
  value: Priority,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONPriority(
  json: string,
  opts?: DeserializeOptions,
): Result<Priority, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectPriority(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectPriority(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Priority, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializePriority(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Priority.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializePriority(
  value: any,
  ctx: DeserializeContext,
): Priority | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as Priority | PendingRef;
  }
  const allowedValues = ["Medium", "High", "Low"] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for Priority: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as Priority;
}
export function isPriority(value: unknown): value is Priority {
  const allowedValues = ["Medium", "High", "Low"] as const;
  return allowedValues.includes(value as any);
}

export namespace Priority {
  /** Per-variant error types */ export type MediumErrors = {
    _errors: Option<Array<string>>;
  };
  export type HighErrors = { _errors: Option<Array<string>> };
  export type LowErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type MediumTainted = {};
  export type HighTainted = {};
  export type LowTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Medium" } & MediumErrors)
    | ({ _value: "High" } & HighErrors)
    | ({ _value: "Low" } & LowErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Medium" } & MediumTainted)
    | ({ _value: "High" } & HighTainted)
    | ({ _value: "Low" } & LowTainted);
  /** Per-variant field controller types */ export interface MediumFieldControllers {}
  export interface HighFieldControllers {}
  export interface LowFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Medium" | "High" | "Low";
    readonly data: Priority;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "Medium" | "High" | "Low"): void;
    validate(): Result<Priority, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Priority>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Medium: { readonly fields: MediumFieldControllers };
    readonly High: { readonly fields: HighFieldControllers };
    readonly Low: { readonly fields: LowFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Priority {
    switch (variant) {
      case "Medium":
        return "Medium" as Priority;
      case "High":
        return "High" as Priority;
      case "Low":
        return "Low" as Priority;
      default:
        return "Medium" as Priority;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Priority,
  ): Gigaform {
    const initialVariant: "Medium" | "High" | "Low" =
      (initial as "Medium" | "High" | "Low") ?? "Medium";
    let currentVariant = $state<"Medium" | "High" | "Low">(initialVariant);
    let data = $state<Priority>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Medium: {
        fields: {} as MediumFieldControllers,
      },
      High: {
        fields: {} as HighFieldControllers,
      },
      Low: {
        fields: {} as LowFieldControllers,
      },
    };
    function switchVariant(variant: "Medium" | "High" | "Low"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Priority,
      Array<{ field: string; message: string }>
    > {
      return Priority.fromObject(data);
    }
    function reset(overrides?: Partial<Priority>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Priority, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Medium"
      | "High"
      | "Low"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Medium") {
    } else if (discriminant === "High") {
    } else if (discriminant === "Low") {
    }
    return Priority.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type Applications =
  | /** @default */ "Sales"
  | "Accounting"
  | "Errand"
  | "HumanResources"
  | "Logistics"
  | "Marketing"
  | "Website";

export function defaultValueApplications(): Applications {
  return "Sales";
}

export function toStringifiedJSONApplications(value: Applications): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeApplications(value, ctx));
}
export function toObjectApplications(value: Applications): unknown {
  const ctx = SerializeContext.create();
  return __serializeApplications(value, ctx);
}
export function __serializeApplications(
  value: Applications,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONApplications(
  json: string,
  opts?: DeserializeOptions,
): Result<Applications, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectApplications(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectApplications(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Applications, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeApplications(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "Applications.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeApplications(
  value: any,
  ctx: DeserializeContext,
): Applications | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as Applications | PendingRef;
  }
  const allowedValues = [
    "Sales",
    "Accounting",
    "Errand",
    "HumanResources",
    "Logistics",
    "Marketing",
    "Website",
  ] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for Applications: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as Applications;
}
export function isApplications(value: unknown): value is Applications {
  const allowedValues = [
    "Sales",
    "Accounting",
    "Errand",
    "HumanResources",
    "Logistics",
    "Marketing",
    "Website",
  ] as const;
  return allowedValues.includes(value as any);
}

export namespace Applications {
  /** Per-variant error types */ export type SalesErrors = {
    _errors: Option<Array<string>>;
  };
  export type AccountingErrors = { _errors: Option<Array<string>> };
  export type ErrandErrors = { _errors: Option<Array<string>> };
  export type HumanResourcesErrors = { _errors: Option<Array<string>> };
  export type LogisticsErrors = { _errors: Option<Array<string>> };
  export type MarketingErrors = { _errors: Option<Array<string>> };
  export type WebsiteErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type SalesTainted = {};
  export type AccountingTainted = {};
  export type ErrandTainted = {};
  export type HumanResourcesTainted = {};
  export type LogisticsTainted = {};
  export type MarketingTainted = {};
  export type WebsiteTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Sales" } & SalesErrors)
    | ({ _value: "Accounting" } & AccountingErrors)
    | ({ _value: "Errand" } & ErrandErrors)
    | ({ _value: "HumanResources" } & HumanResourcesErrors)
    | ({ _value: "Logistics" } & LogisticsErrors)
    | ({ _value: "Marketing" } & MarketingErrors)
    | ({ _value: "Website" } & WebsiteErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Sales" } & SalesTainted)
    | ({ _value: "Accounting" } & AccountingTainted)
    | ({ _value: "Errand" } & ErrandTainted)
    | ({ _value: "HumanResources" } & HumanResourcesTainted)
    | ({ _value: "Logistics" } & LogisticsTainted)
    | ({ _value: "Marketing" } & MarketingTainted)
    | ({ _value: "Website" } & WebsiteTainted);
  /** Per-variant field controller types */ export interface SalesFieldControllers {}
  export interface AccountingFieldControllers {}
  export interface ErrandFieldControllers {}
  export interface HumanResourcesFieldControllers {}
  export interface LogisticsFieldControllers {}
  export interface MarketingFieldControllers {}
  export interface WebsiteFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Sales"
      | "Accounting"
      | "Errand"
      | "HumanResources"
      | "Logistics"
      | "Marketing"
      | "Website";
    readonly data: Applications;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Sales"
        | "Accounting"
        | "Errand"
        | "HumanResources"
        | "Logistics"
        | "Marketing"
        | "Website",
    ): void;
    validate(): Result<Applications, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Applications>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Sales: { readonly fields: SalesFieldControllers };
    readonly Accounting: { readonly fields: AccountingFieldControllers };
    readonly Errand: { readonly fields: ErrandFieldControllers };
    readonly HumanResources: {
      readonly fields: HumanResourcesFieldControllers;
    };
    readonly Logistics: { readonly fields: LogisticsFieldControllers };
    readonly Marketing: { readonly fields: MarketingFieldControllers };
    readonly Website: { readonly fields: WebsiteFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Applications {
    switch (variant) {
      case "Sales":
        return "Sales" as Applications;
      case "Accounting":
        return "Accounting" as Applications;
      case "Errand":
        return "Errand" as Applications;
      case "HumanResources":
        return "HumanResources" as Applications;
      case "Logistics":
        return "Logistics" as Applications;
      case "Marketing":
        return "Marketing" as Applications;
      case "Website":
        return "Website" as Applications;
      default:
        return "Sales" as Applications;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Applications,
  ): Gigaform {
    const initialVariant:
      | "Sales"
      | "Accounting"
      | "Errand"
      | "HumanResources"
      | "Logistics"
      | "Marketing"
      | "Website" =
      (initial as
        | "Sales"
        | "Accounting"
        | "Errand"
        | "HumanResources"
        | "Logistics"
        | "Marketing"
        | "Website") ?? "Sales";
    let currentVariant = $state<
      | "Sales"
      | "Accounting"
      | "Errand"
      | "HumanResources"
      | "Logistics"
      | "Marketing"
      | "Website"
    >(initialVariant);
    let data = $state<Applications>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Sales: {
        fields: {} as SalesFieldControllers,
      },
      Accounting: {
        fields: {} as AccountingFieldControllers,
      },
      Errand: {
        fields: {} as ErrandFieldControllers,
      },
      HumanResources: {
        fields: {} as HumanResourcesFieldControllers,
      },
      Logistics: {
        fields: {} as LogisticsFieldControllers,
      },
      Marketing: {
        fields: {} as MarketingFieldControllers,
      },
      Website: {
        fields: {} as WebsiteFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Sales"
        | "Accounting"
        | "Errand"
        | "HumanResources"
        | "Logistics"
        | "Marketing"
        | "Website",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Applications,
      Array<{ field: string; message: string }>
    > {
      return Applications.fromObject(data);
    }
    function reset(overrides?: Partial<Applications>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Applications, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Sales"
      | "Accounting"
      | "Errand"
      | "HumanResources"
      | "Logistics"
      | "Marketing"
      | "Website"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Sales") {
    } else if (discriminant === "Accounting") {
    } else if (discriminant === "Errand") {
    } else if (discriminant === "HumanResources") {
    } else if (discriminant === "Logistics") {
    } else if (discriminant === "Marketing") {
    } else if (discriminant === "Website") {
    }
    return Applications.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type JobTitle =
  | /** @default */ "Technician"
  | "SalesRepresentative"
  | "HumanResources"
  | "InformationTechnology";

export function defaultValueJobTitle(): JobTitle {
  return "Technician";
}

export function toStringifiedJSONJobTitle(value: JobTitle): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeJobTitle(value, ctx));
}
export function toObjectJobTitle(value: JobTitle): unknown {
  const ctx = SerializeContext.create();
  return __serializeJobTitle(value, ctx);
}
export function __serializeJobTitle(
  value: JobTitle,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONJobTitle(
  json: string,
  opts?: DeserializeOptions,
): Result<JobTitle, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectJobTitle(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectJobTitle(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<JobTitle, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeJobTitle(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "JobTitle.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeJobTitle(
  value: any,
  ctx: DeserializeContext,
): JobTitle | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as JobTitle | PendingRef;
  }
  const allowedValues = [
    "Technician",
    "SalesRepresentative",
    "HumanResources",
    "InformationTechnology",
  ] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for JobTitle: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as JobTitle;
}
export function isJobTitle(value: unknown): value is JobTitle {
  const allowedValues = [
    "Technician",
    "SalesRepresentative",
    "HumanResources",
    "InformationTechnology",
  ] as const;
  return allowedValues.includes(value as any);
}

export namespace JobTitle {
  /** Per-variant error types */ export type TechnicianErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesRepresentativeErrors = { _errors: Option<Array<string>> };
  export type HumanResourcesErrors = { _errors: Option<Array<string>> };
  export type InformationTechnologyErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type TechnicianTainted = {};
  export type SalesRepresentativeTainted = {};
  export type HumanResourcesTainted = {};
  export type InformationTechnologyTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Technician" } & TechnicianErrors)
    | ({ _value: "SalesRepresentative" } & SalesRepresentativeErrors)
    | ({ _value: "HumanResources" } & HumanResourcesErrors)
    | ({ _value: "InformationTechnology" } & InformationTechnologyErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Technician" } & TechnicianTainted)
    | ({ _value: "SalesRepresentative" } & SalesRepresentativeTainted)
    | ({ _value: "HumanResources" } & HumanResourcesTainted)
    | ({ _value: "InformationTechnology" } & InformationTechnologyTainted);
  /** Per-variant field controller types */ export interface TechnicianFieldControllers {}
  export interface SalesRepresentativeFieldControllers {}
  export interface HumanResourcesFieldControllers {}
  export interface InformationTechnologyFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Technician"
      | "SalesRepresentative"
      | "HumanResources"
      | "InformationTechnology";
    readonly data: JobTitle;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Technician"
        | "SalesRepresentative"
        | "HumanResources"
        | "InformationTechnology",
    ): void;
    validate(): Result<JobTitle, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<JobTitle>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Technician: { readonly fields: TechnicianFieldControllers };
    readonly SalesRepresentative: {
      readonly fields: SalesRepresentativeFieldControllers;
    };
    readonly HumanResources: {
      readonly fields: HumanResourcesFieldControllers;
    };
    readonly InformationTechnology: {
      readonly fields: InformationTechnologyFieldControllers;
    };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): JobTitle {
    switch (variant) {
      case "Technician":
        return "Technician" as JobTitle;
      case "SalesRepresentative":
        return "SalesRepresentative" as JobTitle;
      case "HumanResources":
        return "HumanResources" as JobTitle;
      case "InformationTechnology":
        return "InformationTechnology" as JobTitle;
      default:
        return "Technician" as JobTitle;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: JobTitle,
  ): Gigaform {
    const initialVariant:
      | "Technician"
      | "SalesRepresentative"
      | "HumanResources"
      | "InformationTechnology" =
      (initial as
        | "Technician"
        | "SalesRepresentative"
        | "HumanResources"
        | "InformationTechnology") ?? "Technician";
    let currentVariant = $state<
      | "Technician"
      | "SalesRepresentative"
      | "HumanResources"
      | "InformationTechnology"
    >(initialVariant);
    let data = $state<JobTitle>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Technician: {
        fields: {} as TechnicianFieldControllers,
      },
      SalesRepresentative: {
        fields: {} as SalesRepresentativeFieldControllers,
      },
      HumanResources: {
        fields: {} as HumanResourcesFieldControllers,
      },
      InformationTechnology: {
        fields: {} as InformationTechnologyFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Technician"
        | "SalesRepresentative"
        | "HumanResources"
        | "InformationTechnology",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      JobTitle,
      Array<{ field: string; message: string }>
    > {
      return JobTitle.fromObject(data);
    }
    function reset(overrides?: Partial<JobTitle>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<JobTitle, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Technician"
      | "SalesRepresentative"
      | "HumanResources"
      | "InformationTechnology"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Technician") {
    } else if (discriminant === "SalesRepresentative") {
    } else if (discriminant === "HumanResources") {
    } else if (discriminant === "InformationTechnology") {
    }
    return JobTitle.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type ColorsConfig =
  | Cardinal
  | Ordinal
  | Custom
  | /** @default */ Gradient;

export function defaultValueColorsConfig(): ColorsConfig {
  return Gradient.defaultValue();
}

export function toStringifiedJSONColorsConfig(value: ColorsConfig): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeColorsConfig(value, ctx));
}
export function toObjectColorsConfig(value: ColorsConfig): unknown {
  const ctx = SerializeContext.create();
  return __serializeColorsConfig(value, ctx);
}
export function __serializeColorsConfig(
  value: ColorsConfig,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONColorsConfig(
  json: string,
  opts?: DeserializeOptions,
): Result<ColorsConfig, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectColorsConfig(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectColorsConfig(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<ColorsConfig, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeColorsConfig(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "ColorsConfig.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeColorsConfig(
  value: any,
  ctx: DeserializeContext,
): ColorsConfig | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as ColorsConfig | PendingRef;
  }
  if (typeof value !== "object" || value === null) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "ColorsConfig.__deserialize: expected an object",
      },
    ]);
  }
  const __typeName = (value as any).__type;
  if (typeof __typeName !== "string") {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "ColorsConfig.__deserialize: missing __type field for union dispatch",
      },
    ]);
  }
  if (__typeName === "Cardinal") {
    if (typeof (Cardinal as any)?.__deserialize === "function") {
      return (Cardinal as any).__deserialize(value, ctx) as ColorsConfig;
    }
    return value as ColorsConfig;
  }
  if (__typeName === "Ordinal") {
    if (typeof (Ordinal as any)?.__deserialize === "function") {
      return (Ordinal as any).__deserialize(value, ctx) as ColorsConfig;
    }
    return value as ColorsConfig;
  }
  if (__typeName === "Custom") {
    if (typeof (Custom as any)?.__deserialize === "function") {
      return (Custom as any).__deserialize(value, ctx) as ColorsConfig;
    }
    return value as ColorsConfig;
  }
  if (__typeName === "Gradient") {
    if (typeof (Gradient as any)?.__deserialize === "function") {
      return (Gradient as any).__deserialize(value, ctx) as ColorsConfig;
    }
    return value as ColorsConfig;
  }
  throw new DeserializeError([
    {
      field: "_root",
      message:
        'ColorsConfig.__deserialize: unknown type "' +
        __typeName +
        '". Expected one of: Cardinal, Ordinal, Custom, Gradient',
    },
  ]);
}
export function isColorsConfig(value: unknown): value is ColorsConfig {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const __typeName = (value as any).__type;
  return (
    __typeName === "Cardinal" ||
    __typeName === "Ordinal" ||
    __typeName === "Custom" ||
    __typeName === "Gradient"
  );
}

export namespace ColorsConfig {
  /** Per-variant error types */ export type CardinalErrors = {
    _errors: Option<Array<string>>;
  };
  export type OrdinalErrors = { _errors: Option<Array<string>> };
  export type CustomErrors = { _errors: Option<Array<string>> };
  export type GradientErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type CardinalTainted = {};
  export type OrdinalTainted = {};
  export type CustomTainted = {};
  export type GradientTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "Cardinal" } & CardinalErrors)
    | ({ _type: "Ordinal" } & OrdinalErrors)
    | ({ _type: "Custom" } & CustomErrors)
    | ({ _type: "Gradient" } & GradientErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "Cardinal" } & CardinalTainted)
    | ({ _type: "Ordinal" } & OrdinalTainted)
    | ({ _type: "Custom" } & CustomTainted)
    | ({ _type: "Gradient" } & GradientTainted);
  /** Per-variant field controller types */ export interface CardinalFieldControllers {}
  export interface OrdinalFieldControllers {}
  export interface CustomFieldControllers {}
  export interface GradientFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Cardinal" | "Ordinal" | "Custom" | "Gradient";
    readonly data: ColorsConfig;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant: "Cardinal" | "Ordinal" | "Custom" | "Gradient",
    ): void;
    validate(): Result<ColorsConfig, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<ColorsConfig>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Cardinal: { readonly fields: CardinalFieldControllers };
    readonly Ordinal: { readonly fields: OrdinalFieldControllers };
    readonly Custom: { readonly fields: CustomFieldControllers };
    readonly Gradient: { readonly fields: GradientFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): ColorsConfig {
    switch (variant) {
      case "Cardinal":
        return Cardinal.defaultValue() as ColorsConfig;
      case "Ordinal":
        return Ordinal.defaultValue() as ColorsConfig;
      case "Custom":
        return Custom.defaultValue() as ColorsConfig;
      case "Gradient":
        return Gradient.defaultValue() as ColorsConfig;
      default:
        return Cardinal.defaultValue() as ColorsConfig;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: ColorsConfig,
  ): Gigaform {
    const initialVariant: "Cardinal" | "Ordinal" | "Custom" | "Gradient" =
      "Cardinal";
    let currentVariant = $state<"Cardinal" | "Ordinal" | "Custom" | "Gradient">(
      initialVariant,
    );
    let data = $state<ColorsConfig>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Cardinal: {
        fields: {} as CardinalFieldControllers,
      },
      Ordinal: {
        fields: {} as OrdinalFieldControllers,
      },
      Custom: {
        fields: {} as CustomFieldControllers,
      },
      Gradient: {
        fields: {} as GradientFieldControllers,
      },
    };
    function switchVariant(
      variant: "Cardinal" | "Ordinal" | "Custom" | "Gradient",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      ColorsConfig,
      Array<{ field: string; message: string }>
    > {
      return ColorsConfig.fromObject(data);
    }
    function reset(overrides?: Partial<ColorsConfig>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<ColorsConfig, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as
      | "Cardinal"
      | "Ordinal"
      | "Custom"
      | "Gradient"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "Cardinal") {
    } else if (discriminant === "Ordinal") {
    } else if (discriminant === "Custom") {
    } else if (discriminant === "Gradient") {
    }
    return ColorsConfig.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type WeekOfMonth = /** @default */
  | "First"
  | "Second"
  | "Third"
  | "Fourth"
  | "Last";

export function defaultValueWeekOfMonth(): WeekOfMonth {
  return "First";
}

export function toStringifiedJSONWeekOfMonth(value: WeekOfMonth): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeWeekOfMonth(value, ctx));
}
export function toObjectWeekOfMonth(value: WeekOfMonth): unknown {
  const ctx = SerializeContext.create();
  return __serializeWeekOfMonth(value, ctx);
}
export function __serializeWeekOfMonth(
  value: WeekOfMonth,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONWeekOfMonth(
  json: string,
  opts?: DeserializeOptions,
): Result<WeekOfMonth, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectWeekOfMonth(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectWeekOfMonth(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<WeekOfMonth, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeWeekOfMonth(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "WeekOfMonth.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeWeekOfMonth(
  value: any,
  ctx: DeserializeContext,
): WeekOfMonth | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as WeekOfMonth | PendingRef;
  }
  const allowedValues = ["First", "Second", "Third", "Fourth", "Last"] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for WeekOfMonth: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as WeekOfMonth;
}
export function isWeekOfMonth(value: unknown): value is WeekOfMonth {
  const allowedValues = ["First", "Second", "Third", "Fourth", "Last"] as const;
  return allowedValues.includes(value as any);
}

export namespace WeekOfMonth {
  /** Per-variant error types */ export type FirstErrors = {
    _errors: Option<Array<string>>;
  };
  export type SecondErrors = { _errors: Option<Array<string>> };
  export type ThirdErrors = { _errors: Option<Array<string>> };
  export type FourthErrors = { _errors: Option<Array<string>> };
  export type LastErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type FirstTainted = {};
  export type SecondTainted = {};
  export type ThirdTainted = {};
  export type FourthTainted = {};
  export type LastTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "First" } & FirstErrors)
    | ({ _value: "Second" } & SecondErrors)
    | ({ _value: "Third" } & ThirdErrors)
    | ({ _value: "Fourth" } & FourthErrors)
    | ({ _value: "Last" } & LastErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "First" } & FirstTainted)
    | ({ _value: "Second" } & SecondTainted)
    | ({ _value: "Third" } & ThirdTainted)
    | ({ _value: "Fourth" } & FourthTainted)
    | ({ _value: "Last" } & LastTainted);
  /** Per-variant field controller types */ export interface FirstFieldControllers {}
  export interface SecondFieldControllers {}
  export interface ThirdFieldControllers {}
  export interface FourthFieldControllers {}
  export interface LastFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "First" | "Second" | "Third" | "Fourth" | "Last";
    readonly data: WeekOfMonth;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant: "First" | "Second" | "Third" | "Fourth" | "Last",
    ): void;
    validate(): Result<WeekOfMonth, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<WeekOfMonth>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly First: { readonly fields: FirstFieldControllers };
    readonly Second: { readonly fields: SecondFieldControllers };
    readonly Third: { readonly fields: ThirdFieldControllers };
    readonly Fourth: { readonly fields: FourthFieldControllers };
    readonly Last: { readonly fields: LastFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): WeekOfMonth {
    switch (variant) {
      case "First":
        return "First" as WeekOfMonth;
      case "Second":
        return "Second" as WeekOfMonth;
      case "Third":
        return "Third" as WeekOfMonth;
      case "Fourth":
        return "Fourth" as WeekOfMonth;
      case "Last":
        return "Last" as WeekOfMonth;
      default:
        return "First" as WeekOfMonth;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: WeekOfMonth,
  ): Gigaform {
    const initialVariant: "First" | "Second" | "Third" | "Fourth" | "Last" =
      (initial as "First" | "Second" | "Third" | "Fourth" | "Last") ?? "First";
    let currentVariant = $state<
      "First" | "Second" | "Third" | "Fourth" | "Last"
    >(initialVariant);
    let data = $state<WeekOfMonth>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      First: {
        fields: {} as FirstFieldControllers,
      },
      Second: {
        fields: {} as SecondFieldControllers,
      },
      Third: {
        fields: {} as ThirdFieldControllers,
      },
      Fourth: {
        fields: {} as FourthFieldControllers,
      },
      Last: {
        fields: {} as LastFieldControllers,
      },
    };
    function switchVariant(
      variant: "First" | "Second" | "Third" | "Fourth" | "Last",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      WeekOfMonth,
      Array<{ field: string; message: string }>
    > {
      return WeekOfMonth.fromObject(data);
    }
    function reset(overrides?: Partial<WeekOfMonth>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<WeekOfMonth, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "First"
      | "Second"
      | "Third"
      | "Fourth"
      | "Last"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "First") {
    } else if (discriminant === "Second") {
    } else if (discriminant === "Third") {
    } else if (discriminant === "Fourth") {
    } else if (discriminant === "Last") {
    }
    return WeekOfMonth.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type ActivityType = /** @default */
  | Created
  | Edited
  | Sent
  | Viewed
  | Commented
  | Paid;

export function defaultValueActivityType(): ActivityType {
  return Created.defaultValue();
}

export function toStringifiedJSONActivityType(value: ActivityType): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeActivityType(value, ctx));
}
export function toObjectActivityType(value: ActivityType): unknown {
  const ctx = SerializeContext.create();
  return __serializeActivityType(value, ctx);
}
export function __serializeActivityType(
  value: ActivityType,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONActivityType(
  json: string,
  opts?: DeserializeOptions,
): Result<ActivityType, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectActivityType(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectActivityType(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<ActivityType, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeActivityType(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message:
            "ActivityType.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeActivityType(
  value: any,
  ctx: DeserializeContext,
): ActivityType | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as ActivityType | PendingRef;
  }
  if (typeof value !== "object" || value === null) {
    throw new DeserializeError([
      {
        field: "_root",
        message: "ActivityType.__deserialize: expected an object",
      },
    ]);
  }
  const __typeName = (value as any).__type;
  if (typeof __typeName !== "string") {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "ActivityType.__deserialize: missing __type field for union dispatch",
      },
    ]);
  }
  if (__typeName === "Created") {
    if (typeof (Created as any)?.__deserialize === "function") {
      return (Created as any).__deserialize(value, ctx) as ActivityType;
    }
    return value as ActivityType;
  }
  if (__typeName === "Edited") {
    if (typeof (Edited as any)?.__deserialize === "function") {
      return (Edited as any).__deserialize(value, ctx) as ActivityType;
    }
    return value as ActivityType;
  }
  if (__typeName === "Sent") {
    if (typeof (Sent as any)?.__deserialize === "function") {
      return (Sent as any).__deserialize(value, ctx) as ActivityType;
    }
    return value as ActivityType;
  }
  if (__typeName === "Viewed") {
    if (typeof (Viewed as any)?.__deserialize === "function") {
      return (Viewed as any).__deserialize(value, ctx) as ActivityType;
    }
    return value as ActivityType;
  }
  if (__typeName === "Commented") {
    if (typeof (Commented as any)?.__deserialize === "function") {
      return (Commented as any).__deserialize(value, ctx) as ActivityType;
    }
    return value as ActivityType;
  }
  if (__typeName === "Paid") {
    if (typeof (Paid as any)?.__deserialize === "function") {
      return (Paid as any).__deserialize(value, ctx) as ActivityType;
    }
    return value as ActivityType;
  }
  throw new DeserializeError([
    {
      field: "_root",
      message:
        'ActivityType.__deserialize: unknown type "' +
        __typeName +
        '". Expected one of: Created, Edited, Sent, Viewed, Commented, Paid',
    },
  ]);
}
export function isActivityType(value: unknown): value is ActivityType {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const __typeName = (value as any).__type;
  return (
    __typeName === "Created" ||
    __typeName === "Edited" ||
    __typeName === "Sent" ||
    __typeName === "Viewed" ||
    __typeName === "Commented" ||
    __typeName === "Paid"
  );
}

export namespace ActivityType {
  /** Per-variant error types */ export type CreatedErrors = {
    _errors: Option<Array<string>>;
  };
  export type EditedErrors = { _errors: Option<Array<string>> };
  export type SentErrors = { _errors: Option<Array<string>> };
  export type ViewedErrors = { _errors: Option<Array<string>> };
  export type CommentedErrors = { _errors: Option<Array<string>> };
  export type PaidErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type CreatedTainted = {};
  export type EditedTainted = {};
  export type SentTainted = {};
  export type ViewedTainted = {};
  export type CommentedTainted = {};
  export type PaidTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "Created" } & CreatedErrors)
    | ({ _type: "Edited" } & EditedErrors)
    | ({ _type: "Sent" } & SentErrors)
    | ({ _type: "Viewed" } & ViewedErrors)
    | ({ _type: "Commented" } & CommentedErrors)
    | ({ _type: "Paid" } & PaidErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "Created" } & CreatedTainted)
    | ({ _type: "Edited" } & EditedTainted)
    | ({ _type: "Sent" } & SentTainted)
    | ({ _type: "Viewed" } & ViewedTainted)
    | ({ _type: "Commented" } & CommentedTainted)
    | ({ _type: "Paid" } & PaidTainted);
  /** Per-variant field controller types */ export interface CreatedFieldControllers {}
  export interface EditedFieldControllers {}
  export interface SentFieldControllers {}
  export interface ViewedFieldControllers {}
  export interface CommentedFieldControllers {}
  export interface PaidFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Created"
      | "Edited"
      | "Sent"
      | "Viewed"
      | "Commented"
      | "Paid";
    readonly data: ActivityType;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid",
    ): void;
    validate(): Result<ActivityType, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<ActivityType>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Created: { readonly fields: CreatedFieldControllers };
    readonly Edited: { readonly fields: EditedFieldControllers };
    readonly Sent: { readonly fields: SentFieldControllers };
    readonly Viewed: { readonly fields: ViewedFieldControllers };
    readonly Commented: { readonly fields: CommentedFieldControllers };
    readonly Paid: { readonly fields: PaidFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): ActivityType {
    switch (variant) {
      case "Created":
        return Created.defaultValue() as ActivityType;
      case "Edited":
        return Edited.defaultValue() as ActivityType;
      case "Sent":
        return Sent.defaultValue() as ActivityType;
      case "Viewed":
        return Viewed.defaultValue() as ActivityType;
      case "Commented":
        return Commented.defaultValue() as ActivityType;
      case "Paid":
        return Paid.defaultValue() as ActivityType;
      default:
        return Created.defaultValue() as ActivityType;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: ActivityType,
  ): Gigaform {
    const initialVariant:
      | "Created"
      | "Edited"
      | "Sent"
      | "Viewed"
      | "Commented"
      | "Paid" = "Created";
    let currentVariant = $state<
      "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid"
    >(initialVariant);
    let data = $state<ActivityType>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Created: {
        fields: {} as CreatedFieldControllers,
      },
      Edited: {
        fields: {} as EditedFieldControllers,
      },
      Sent: {
        fields: {} as SentFieldControllers,
      },
      Viewed: {
        fields: {} as ViewedFieldControllers,
      },
      Commented: {
        fields: {} as CommentedFieldControllers,
      },
      Paid: {
        fields: {} as PaidFieldControllers,
      },
    };
    function switchVariant(
      variant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      ActivityType,
      Array<{ field: string; message: string }>
    > {
      return ActivityType.fromObject(data);
    }
    function reset(overrides?: Partial<ActivityType>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<ActivityType, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as
      | "Created"
      | "Edited"
      | "Sent"
      | "Viewed"
      | "Commented"
      | "Paid"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "Created") {
    } else if (discriminant === "Edited") {
    } else if (discriminant === "Sent") {
    } else if (discriminant === "Viewed") {
    } else if (discriminant === "Commented") {
    } else if (discriminant === "Paid") {
    }
    return ActivityType.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type RowHeight =
  | "ExtraSmall"
  | "Small"
  | /** @default */ "Medium"
  | "Large";

export function defaultValueRowHeight(): RowHeight {
  return "Medium";
}

export function toStringifiedJSONRowHeight(value: RowHeight): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeRowHeight(value, ctx));
}
export function toObjectRowHeight(value: RowHeight): unknown {
  const ctx = SerializeContext.create();
  return __serializeRowHeight(value, ctx);
}
export function __serializeRowHeight(
  value: RowHeight,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONRowHeight(
  json: string,
  opts?: DeserializeOptions,
): Result<RowHeight, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectRowHeight(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectRowHeight(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<RowHeight, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeRowHeight(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "RowHeight.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeRowHeight(
  value: any,
  ctx: DeserializeContext,
): RowHeight | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as RowHeight | PendingRef;
  }
  const allowedValues = ["ExtraSmall", "Small", "Medium", "Large"] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for RowHeight: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as RowHeight;
}
export function isRowHeight(value: unknown): value is RowHeight {
  const allowedValues = ["ExtraSmall", "Small", "Medium", "Large"] as const;
  return allowedValues.includes(value as any);
}

export namespace RowHeight {
  /** Per-variant error types */ export type ExtraSmallErrors = {
    _errors: Option<Array<string>>;
  };
  export type SmallErrors = { _errors: Option<Array<string>> };
  export type MediumErrors = { _errors: Option<Array<string>> };
  export type LargeErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type ExtraSmallTainted = {};
  export type SmallTainted = {};
  export type MediumTainted = {};
  export type LargeTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "ExtraSmall" } & ExtraSmallErrors)
    | ({ _value: "Small" } & SmallErrors)
    | ({ _value: "Medium" } & MediumErrors)
    | ({ _value: "Large" } & LargeErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "ExtraSmall" } & ExtraSmallTainted)
    | ({ _value: "Small" } & SmallTainted)
    | ({ _value: "Medium" } & MediumTainted)
    | ({ _value: "Large" } & LargeTainted);
  /** Per-variant field controller types */ export interface ExtraSmallFieldControllers {}
  export interface SmallFieldControllers {}
  export interface MediumFieldControllers {}
  export interface LargeFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "ExtraSmall" | "Small" | "Medium" | "Large";
    readonly data: RowHeight;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "ExtraSmall" | "Small" | "Medium" | "Large"): void;
    validate(): Result<RowHeight, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<RowHeight>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly ExtraSmall: { readonly fields: ExtraSmallFieldControllers };
    readonly Small: { readonly fields: SmallFieldControllers };
    readonly Medium: { readonly fields: MediumFieldControllers };
    readonly Large: { readonly fields: LargeFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): RowHeight {
    switch (variant) {
      case "ExtraSmall":
        return "ExtraSmall" as RowHeight;
      case "Small":
        return "Small" as RowHeight;
      case "Medium":
        return "Medium" as RowHeight;
      case "Large":
        return "Large" as RowHeight;
      default:
        return "ExtraSmall" as RowHeight;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: RowHeight,
  ): Gigaform {
    const initialVariant: "ExtraSmall" | "Small" | "Medium" | "Large" =
      (initial as "ExtraSmall" | "Small" | "Medium" | "Large") ?? "ExtraSmall";
    let currentVariant = $state<"ExtraSmall" | "Small" | "Medium" | "Large">(
      initialVariant,
    );
    let data = $state<RowHeight>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      ExtraSmall: {
        fields: {} as ExtraSmallFieldControllers,
      },
      Small: {
        fields: {} as SmallFieldControllers,
      },
      Medium: {
        fields: {} as MediumFieldControllers,
      },
      Large: {
        fields: {} as LargeFieldControllers,
      },
    };
    function switchVariant(
      variant: "ExtraSmall" | "Small" | "Medium" | "Large",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      RowHeight,
      Array<{ field: string; message: string }>
    > {
      return RowHeight.fromObject(data);
    }
    function reset(overrides?: Partial<RowHeight>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<RowHeight, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "ExtraSmall"
      | "Small"
      | "Medium"
      | "Large"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "ExtraSmall") {
    } else if (discriminant === "Small") {
    } else if (discriminant === "Medium") {
    } else if (discriminant === "Large") {
    }
    return RowHeight.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type OrderStage = /** @default */ "Estimate" | "Active" | "Invoice";

export function defaultValueOrderStage(): OrderStage {
  return "Estimate";
}

export function toStringifiedJSONOrderStage(value: OrderStage): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeOrderStage(value, ctx));
}
export function toObjectOrderStage(value: OrderStage): unknown {
  const ctx = SerializeContext.create();
  return __serializeOrderStage(value, ctx);
}
export function __serializeOrderStage(
  value: OrderStage,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONOrderStage(
  json: string,
  opts?: DeserializeOptions,
): Result<OrderStage, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectOrderStage(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectOrderStage(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<OrderStage, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeOrderStage(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "OrderStage.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeOrderStage(
  value: any,
  ctx: DeserializeContext,
): OrderStage | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as OrderStage | PendingRef;
  }
  const allowedValues = ["Estimate", "Active", "Invoice"] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for OrderStage: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as OrderStage;
}
export function isOrderStage(value: unknown): value is OrderStage {
  const allowedValues = ["Estimate", "Active", "Invoice"] as const;
  return allowedValues.includes(value as any);
}

export namespace OrderStage {
  /** Per-variant error types */ export type EstimateErrors = {
    _errors: Option<Array<string>>;
  };
  export type ActiveErrors = { _errors: Option<Array<string>> };
  export type InvoiceErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type EstimateTainted = {};
  export type ActiveTainted = {};
  export type InvoiceTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Estimate" } & EstimateErrors)
    | ({ _value: "Active" } & ActiveErrors)
    | ({ _value: "Invoice" } & InvoiceErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Estimate" } & EstimateTainted)
    | ({ _value: "Active" } & ActiveTainted)
    | ({ _value: "Invoice" } & InvoiceTainted);
  /** Per-variant field controller types */ export interface EstimateFieldControllers {}
  export interface ActiveFieldControllers {}
  export interface InvoiceFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Estimate" | "Active" | "Invoice";
    readonly data: OrderStage;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "Estimate" | "Active" | "Invoice"): void;
    validate(): Result<OrderStage, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<OrderStage>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Estimate: { readonly fields: EstimateFieldControllers };
    readonly Active: { readonly fields: ActiveFieldControllers };
    readonly Invoice: { readonly fields: InvoiceFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): OrderStage {
    switch (variant) {
      case "Estimate":
        return "Estimate" as OrderStage;
      case "Active":
        return "Active" as OrderStage;
      case "Invoice":
        return "Invoice" as OrderStage;
      default:
        return "Estimate" as OrderStage;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: OrderStage,
  ): Gigaform {
    const initialVariant: "Estimate" | "Active" | "Invoice" =
      (initial as "Estimate" | "Active" | "Invoice") ?? "Estimate";
    let currentVariant = $state<"Estimate" | "Active" | "Invoice">(
      initialVariant,
    );
    let data = $state<OrderStage>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Estimate: {
        fields: {} as EstimateFieldControllers,
      },
      Active: {
        fields: {} as ActiveFieldControllers,
      },
      Invoice: {
        fields: {} as InvoiceFieldControllers,
      },
    };
    function switchVariant(variant: "Estimate" | "Active" | "Invoice"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      OrderStage,
      Array<{ field: string; message: string }>
    > {
      return OrderStage.fromObject(data);
    }
    function reset(overrides?: Partial<OrderStage>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<OrderStage, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Estimate"
      | "Active"
      | "Invoice"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Estimate") {
    } else if (discriminant === "Active") {
    } else if (discriminant === "Invoice") {
    }
    return OrderStage.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type Table =
  | /** @default */ "Account"
  | "Did"
  | "Appointment"
  | "Lead"
  | "TaxRate"
  | "Site"
  | "Employee"
  | "Route"
  | "Company"
  | "Product"
  | "Service"
  | "User"
  | "Order"
  | "Payment"
  | "Package"
  | "Promotion"
  | "Represents"
  | "Ordered";

export function defaultValueTable(): Table {
  return "Account";
}

export function toStringifiedJSONTable(value: Table): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeTable(value, ctx));
}
export function toObjectTable(value: Table): unknown {
  const ctx = SerializeContext.create();
  return __serializeTable(value, ctx);
}
export function __serializeTable(value: Table, ctx: SerializeContext): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONTable(
  json: string,
  opts?: DeserializeOptions,
): Result<Table, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectTable(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectTable(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Table, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeTable(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Table.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeTable(
  value: any,
  ctx: DeserializeContext,
): Table | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as Table | PendingRef;
  }
  const allowedValues = [
    "Account",
    "Did",
    "Appointment",
    "Lead",
    "TaxRate",
    "Site",
    "Employee",
    "Route",
    "Company",
    "Product",
    "Service",
    "User",
    "Order",
    "Payment",
    "Package",
    "Promotion",
    "Represents",
    "Ordered",
  ] as const;
  if (!allowedValues.includes(value)) {
    throw new DeserializeError([
      {
        field: "_root",
        message:
          "Invalid value for Table: expected one of " +
          allowedValues.map((v) => JSON.stringify(v)).join(", ") +
          ", got " +
          JSON.stringify(value),
      },
    ]);
  }
  return value as Table;
}
export function isTable(value: unknown): value is Table {
  const allowedValues = [
    "Account",
    "Did",
    "Appointment",
    "Lead",
    "TaxRate",
    "Site",
    "Employee",
    "Route",
    "Company",
    "Product",
    "Service",
    "User",
    "Order",
    "Payment",
    "Package",
    "Promotion",
    "Represents",
    "Ordered",
  ] as const;
  return allowedValues.includes(value as any);
}

export namespace Table {
  /** Per-variant error types */ export type AccountErrors = {
    _errors: Option<Array<string>>;
  };
  export type DidErrors = { _errors: Option<Array<string>> };
  export type AppointmentErrors = { _errors: Option<Array<string>> };
  export type LeadErrors = { _errors: Option<Array<string>> };
  export type TaxRateErrors = { _errors: Option<Array<string>> };
  export type SiteErrors = { _errors: Option<Array<string>> };
  export type EmployeeErrors = { _errors: Option<Array<string>> };
  export type RouteErrors = { _errors: Option<Array<string>> };
  export type CompanyErrors = { _errors: Option<Array<string>> };
  export type ProductErrors = { _errors: Option<Array<string>> };
  export type ServiceErrors = { _errors: Option<Array<string>> };
  export type UserErrors = { _errors: Option<Array<string>> };
  export type OrderErrors = { _errors: Option<Array<string>> };
  export type PaymentErrors = { _errors: Option<Array<string>> };
  export type PackageErrors = { _errors: Option<Array<string>> };
  export type PromotionErrors = { _errors: Option<Array<string>> };
  export type RepresentsErrors = { _errors: Option<Array<string>> };
  export type OrderedErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type AccountTainted = {};
  export type DidTainted = {};
  export type AppointmentTainted = {};
  export type LeadTainted = {};
  export type TaxRateTainted = {};
  export type SiteTainted = {};
  export type EmployeeTainted = {};
  export type RouteTainted = {};
  export type CompanyTainted = {};
  export type ProductTainted = {};
  export type ServiceTainted = {};
  export type UserTainted = {};
  export type OrderTainted = {};
  export type PaymentTainted = {};
  export type PackageTainted = {};
  export type PromotionTainted = {};
  export type RepresentsTainted = {};
  export type OrderedTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Account" } & AccountErrors)
    | ({ _value: "Did" } & DidErrors)
    | ({ _value: "Appointment" } & AppointmentErrors)
    | ({ _value: "Lead" } & LeadErrors)
    | ({ _value: "TaxRate" } & TaxRateErrors)
    | ({ _value: "Site" } & SiteErrors)
    | ({ _value: "Employee" } & EmployeeErrors)
    | ({ _value: "Route" } & RouteErrors)
    | ({ _value: "Company" } & CompanyErrors)
    | ({ _value: "Product" } & ProductErrors)
    | ({ _value: "Service" } & ServiceErrors)
    | ({ _value: "User" } & UserErrors)
    | ({ _value: "Order" } & OrderErrors)
    | ({ _value: "Payment" } & PaymentErrors)
    | ({ _value: "Package" } & PackageErrors)
    | ({ _value: "Promotion" } & PromotionErrors)
    | ({ _value: "Represents" } & RepresentsErrors)
    | ({ _value: "Ordered" } & OrderedErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Account" } & AccountTainted)
    | ({ _value: "Did" } & DidTainted)
    | ({ _value: "Appointment" } & AppointmentTainted)
    | ({ _value: "Lead" } & LeadTainted)
    | ({ _value: "TaxRate" } & TaxRateTainted)
    | ({ _value: "Site" } & SiteTainted)
    | ({ _value: "Employee" } & EmployeeTainted)
    | ({ _value: "Route" } & RouteTainted)
    | ({ _value: "Company" } & CompanyTainted)
    | ({ _value: "Product" } & ProductTainted)
    | ({ _value: "Service" } & ServiceTainted)
    | ({ _value: "User" } & UserTainted)
    | ({ _value: "Order" } & OrderTainted)
    | ({ _value: "Payment" } & PaymentTainted)
    | ({ _value: "Package" } & PackageTainted)
    | ({ _value: "Promotion" } & PromotionTainted)
    | ({ _value: "Represents" } & RepresentsTainted)
    | ({ _value: "Ordered" } & OrderedTainted);
  /** Per-variant field controller types */ export interface AccountFieldControllers {}
  export interface DidFieldControllers {}
  export interface AppointmentFieldControllers {}
  export interface LeadFieldControllers {}
  export interface TaxRateFieldControllers {}
  export interface SiteFieldControllers {}
  export interface EmployeeFieldControllers {}
  export interface RouteFieldControllers {}
  export interface CompanyFieldControllers {}
  export interface ProductFieldControllers {}
  export interface ServiceFieldControllers {}
  export interface UserFieldControllers {}
  export interface OrderFieldControllers {}
  export interface PaymentFieldControllers {}
  export interface PackageFieldControllers {}
  export interface PromotionFieldControllers {}
  export interface RepresentsFieldControllers {}
  export interface OrderedFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Account"
      | "Did"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Employee"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "User"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered";
    readonly data: Table;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Account"
        | "Did"
        | "Appointment"
        | "Lead"
        | "TaxRate"
        | "Site"
        | "Employee"
        | "Route"
        | "Company"
        | "Product"
        | "Service"
        | "User"
        | "Order"
        | "Payment"
        | "Package"
        | "Promotion"
        | "Represents"
        | "Ordered",
    ): void;
    validate(): Result<Table, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Table>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Account: { readonly fields: AccountFieldControllers };
    readonly Did: { readonly fields: DidFieldControllers };
    readonly Appointment: { readonly fields: AppointmentFieldControllers };
    readonly Lead: { readonly fields: LeadFieldControllers };
    readonly TaxRate: { readonly fields: TaxRateFieldControllers };
    readonly Site: { readonly fields: SiteFieldControllers };
    readonly Employee: { readonly fields: EmployeeFieldControllers };
    readonly Route: { readonly fields: RouteFieldControllers };
    readonly Company: { readonly fields: CompanyFieldControllers };
    readonly Product: { readonly fields: ProductFieldControllers };
    readonly Service: { readonly fields: ServiceFieldControllers };
    readonly User: { readonly fields: UserFieldControllers };
    readonly Order: { readonly fields: OrderFieldControllers };
    readonly Payment: { readonly fields: PaymentFieldControllers };
    readonly Package: { readonly fields: PackageFieldControllers };
    readonly Promotion: { readonly fields: PromotionFieldControllers };
    readonly Represents: { readonly fields: RepresentsFieldControllers };
    readonly Ordered: { readonly fields: OrderedFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Table {
    switch (variant) {
      case "Account":
        return "Account" as Table;
      case "Did":
        return "Did" as Table;
      case "Appointment":
        return "Appointment" as Table;
      case "Lead":
        return "Lead" as Table;
      case "TaxRate":
        return "TaxRate" as Table;
      case "Site":
        return "Site" as Table;
      case "Employee":
        return "Employee" as Table;
      case "Route":
        return "Route" as Table;
      case "Company":
        return "Company" as Table;
      case "Product":
        return "Product" as Table;
      case "Service":
        return "Service" as Table;
      case "User":
        return "User" as Table;
      case "Order":
        return "Order" as Table;
      case "Payment":
        return "Payment" as Table;
      case "Package":
        return "Package" as Table;
      case "Promotion":
        return "Promotion" as Table;
      case "Represents":
        return "Represents" as Table;
      case "Ordered":
        return "Ordered" as Table;
      default:
        return "Account" as Table;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Table,
  ): Gigaform {
    const initialVariant:
      | "Account"
      | "Did"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Employee"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "User"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered" =
      (initial as
        | "Account"
        | "Did"
        | "Appointment"
        | "Lead"
        | "TaxRate"
        | "Site"
        | "Employee"
        | "Route"
        | "Company"
        | "Product"
        | "Service"
        | "User"
        | "Order"
        | "Payment"
        | "Package"
        | "Promotion"
        | "Represents"
        | "Ordered") ?? "Account";
    let currentVariant = $state<
      | "Account"
      | "Did"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Employee"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "User"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered"
    >(initialVariant);
    let data = $state<Table>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Account: {
        fields: {} as AccountFieldControllers,
      },
      Did: {
        fields: {} as DidFieldControllers,
      },
      Appointment: {
        fields: {} as AppointmentFieldControllers,
      },
      Lead: {
        fields: {} as LeadFieldControllers,
      },
      TaxRate: {
        fields: {} as TaxRateFieldControllers,
      },
      Site: {
        fields: {} as SiteFieldControllers,
      },
      Employee: {
        fields: {} as EmployeeFieldControllers,
      },
      Route: {
        fields: {} as RouteFieldControllers,
      },
      Company: {
        fields: {} as CompanyFieldControllers,
      },
      Product: {
        fields: {} as ProductFieldControllers,
      },
      Service: {
        fields: {} as ServiceFieldControllers,
      },
      User: {
        fields: {} as UserFieldControllers,
      },
      Order: {
        fields: {} as OrderFieldControllers,
      },
      Payment: {
        fields: {} as PaymentFieldControllers,
      },
      Package: {
        fields: {} as PackageFieldControllers,
      },
      Promotion: {
        fields: {} as PromotionFieldControllers,
      },
      Represents: {
        fields: {} as RepresentsFieldControllers,
      },
      Ordered: {
        fields: {} as OrderedFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Account"
        | "Did"
        | "Appointment"
        | "Lead"
        | "TaxRate"
        | "Site"
        | "Employee"
        | "Route"
        | "Company"
        | "Product"
        | "Service"
        | "User"
        | "Order"
        | "Payment"
        | "Package"
        | "Promotion"
        | "Represents"
        | "Ordered",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Table,
      Array<{ field: string; message: string }>
    > {
      return Table.fromObject(data);
    }
    function reset(overrides?: Partial<Table>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Table, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Account"
      | "Did"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Employee"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "User"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Account") {
    } else if (discriminant === "Did") {
    } else if (discriminant === "Appointment") {
    } else if (discriminant === "Lead") {
    } else if (discriminant === "TaxRate") {
    } else if (discriminant === "Site") {
    } else if (discriminant === "Employee") {
    } else if (discriminant === "Route") {
    } else if (discriminant === "Company") {
    } else if (discriminant === "Product") {
    } else if (discriminant === "Service") {
    } else if (discriminant === "User") {
    } else if (discriminant === "Order") {
    } else if (discriminant === "Payment") {
    } else if (discriminant === "Package") {
    } else if (discriminant === "Promotion") {
    } else if (discriminant === "Represents") {
    } else if (discriminant === "Ordered") {
    }
    return Table.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type Item = RecordLink<Product> | /** @default */ RecordLink<Service>;

export function defaultValueItem(): Item {
  return RecordLink.defaultValue<Service>();
}

export function toStringifiedJSONItem(value: Item): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeItem(value, ctx));
}
export function toObjectItem(value: Item): unknown {
  const ctx = SerializeContext.create();
  return __serializeItem(value, ctx);
}
export function __serializeItem(value: Item, ctx: SerializeContext): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONItem(
  json: string,
  opts?: DeserializeOptions,
): Result<Item, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectItem(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectItem(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Item, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeItem(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Item.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeItem(
  value: any,
  ctx: DeserializeContext,
): Item | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as Item | PendingRef;
  }
  if (typeof value !== "object" || value === null) {
    throw new DeserializeError([
      { field: "_root", message: "Item.__deserialize: expected an object" },
    ]);
  }
  const __typeName = (value as any).__type;
  if (typeof __typeName !== "string") {
    throw new DeserializeError([
      {
        field: "_root",
        message: "Item.__deserialize: missing __type field for union dispatch",
      },
    ]);
  }
  if (__typeName === "RecordLink<Product>") {
    if (typeof (RecordLink as any)?.__deserialize === "function") {
      return (RecordLink as any).__deserialize(value, ctx) as Item;
    }
    return value as Item;
  }
  if (__typeName === "RecordLink<Service>") {
    if (typeof (RecordLink as any)?.__deserialize === "function") {
      return (RecordLink as any).__deserialize(value, ctx) as Item;
    }
    return value as Item;
  }
  throw new DeserializeError([
    {
      field: "_root",
      message:
        'Item.__deserialize: unknown type "' +
        __typeName +
        '". Expected one of: RecordLink<Product>, RecordLink<Service>',
    },
  ]);
}
export function isItem(value: unknown): value is Item {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const __typeName = (value as any).__type;
  return (
    __typeName === "RecordLink<Product>" || __typeName === "RecordLink<Service>"
  );
}

export namespace Item {
  /** Per-variant error types */ export type RecordLinkProductErrors = {
    _errors: Option<Array<string>>;
  };
  export type RecordLinkServiceErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type RecordLinkProductTainted = {};
  export type RecordLinkServiceTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "RecordLink<Product>" } & RecordLinkProductErrors)
    | ({ _type: "RecordLink<Service>" } & RecordLinkServiceErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "RecordLink<Product>" } & RecordLinkProductTainted)
    | ({ _type: "RecordLink<Service>" } & RecordLinkServiceTainted);
  /** Per-variant field controller types */ export interface RecordLinkProductFieldControllers {}
  export interface RecordLinkServiceFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "RecordLink<Product>" | "RecordLink<Service>";
    readonly data: Item;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "RecordLink<Product>" | "RecordLink<Service>"): void;
    validate(): Result<Item, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Item>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly "RecordLink<Product>": {
      readonly fields: RecordLinkProductFieldControllers;
    };
    readonly "RecordLink<Service>": {
      readonly fields: RecordLinkServiceFieldControllers;
    };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Item {
    switch (variant) {
      case "RecordLink<Product>":
        return RecordLink.defaultValue<Product>() as Item;
      case "RecordLink<Service>":
        return RecordLink.defaultValue<Service>() as Item;
      default:
        return RecordLink.defaultValue<Product>() as Item;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Item,
  ): Gigaform {
    const initialVariant: "RecordLink<Product>" | "RecordLink<Service>" =
      "RecordLink<Product>";
    let currentVariant = $state<"RecordLink<Product>" | "RecordLink<Service>">(
      initialVariant,
    );
    let data = $state<Item>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      "RecordLink<Product>": {
        fields: {} as RecordLinkProductFieldControllers,
      },
      "RecordLink<Service>": {
        fields: {} as RecordLinkServiceFieldControllers,
      },
    };
    function switchVariant(
      variant: "RecordLink<Product>" | "RecordLink<Service>",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Item,
      Array<{ field: string; message: string }>
    > {
      return Item.fromObject(data);
    }
    function reset(overrides?: Partial<Item>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Item, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as
      | "RecordLink<Product>"
      | "RecordLink<Service>"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "RecordLink<Product>") {
    } else if (discriminant === "RecordLink<Service>") {
    }
    return Item.fromStringifiedJSON(JSON.stringify(obj));
  }
}

/** @derive(Default, Serialize, Deserialize) */
export type RecordLink<T> = /** @default */ string | T;

export function defaultValueRecordLink<T>(): RecordLink<T> {
  return "";
}

export function toStringifiedJSONRecordLink<T>(value: RecordLink<T>): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeRecordLink<T>(value, ctx));
}
export function toObjectRecordLink<T>(value: RecordLink<T>): unknown {
  const ctx = SerializeContext.create();
  return __serializeRecordLink<T>(value, ctx);
}
export function __serializeRecordLink<T>(
  value: RecordLink<T>,
  ctx: SerializeContext,
): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONRecordLink<T>(
  json: string,
  opts?: DeserializeOptions,
): Result<RecordLink<T>, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectRecordLink<T>(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectRecordLink<T>(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<RecordLink<T>, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeRecordLink<T>(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "RecordLink.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeRecordLink<T>(
  value: any,
  ctx: DeserializeContext,
): RecordLink<T> | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as RecordLink<T> | PendingRef;
  }
  if (typeof value === "string") {
    return value as RecordLink<T>;
  }
  return value as RecordLink<T>;
  throw new DeserializeError([
    {
      field: "_root",
      message:
        "RecordLink.__deserialize: value does not match any union member",
    },
  ]);
}
export function isRecordLink<T>(value: unknown): value is RecordLink<T> {
  if (typeof value === "string") return true;
  return true;
}

/** @derive(Default, Serialize, Deserialize, Gigaform) */
export type Actor = /** @default */ User | Employee | Account;

export function defaultValueActor(): Actor {
  return User.defaultValue();
}

export function toStringifiedJSONActor(value: Actor): string {
  const ctx = SerializeContext.create();
  return JSON.stringify(__serializeActor(value, ctx));
}
export function toObjectActor(value: Actor): unknown {
  const ctx = SerializeContext.create();
  return __serializeActor(value, ctx);
}
export function __serializeActor(value: Actor, ctx: SerializeContext): unknown {
  if (typeof (value as any)?.__serialize === "function") {
    return (value as any).__serialize(ctx);
  }
  return value;
}

export function fromStringifiedJSONActor(
  json: string,
  opts?: DeserializeOptions,
): Result<Actor, Array<{ field: string; message: string }>> {
  try {
    const raw = JSON.parse(json);
    return fromObjectActor(raw, opts);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function fromObjectActor(
  obj: unknown,
  opts?: DeserializeOptions,
): Result<Actor, Array<{ field: string; message: string }>> {
  try {
    const ctx = DeserializeContext.create();
    const resultOrRef = __deserializeActor(obj, ctx);
    if (PendingRef.is(resultOrRef)) {
      return Result.err([
        {
          field: "_root",
          message: "Actor.fromObject: root cannot be a forward reference",
        },
      ]);
    }
    ctx.applyPatches();
    if (opts?.freeze) {
      ctx.freezeAll();
    }
    return Result.ok(resultOrRef);
  } catch (e) {
    if (e instanceof DeserializeError) {
      return Result.err(e.errors);
    }
    const message = e instanceof Error ? e.message : String(e);
    return Result.err([{ field: "_root", message }]);
  }
}
export function __deserializeActor(
  value: any,
  ctx: DeserializeContext,
): Actor | PendingRef {
  if (value?.__ref !== undefined) {
    return ctx.getOrDefer(value.__ref) as Actor | PendingRef;
  }
  if (typeof value !== "object" || value === null) {
    throw new DeserializeError([
      { field: "_root", message: "Actor.__deserialize: expected an object" },
    ]);
  }
  const __typeName = (value as any).__type;
  if (typeof __typeName !== "string") {
    throw new DeserializeError([
      {
        field: "_root",
        message: "Actor.__deserialize: missing __type field for union dispatch",
      },
    ]);
  }
  if (__typeName === "User") {
    if (typeof (User as any)?.__deserialize === "function") {
      return (User as any).__deserialize(value, ctx) as Actor;
    }
    return value as Actor;
  }
  if (__typeName === "Employee") {
    if (typeof (Employee as any)?.__deserialize === "function") {
      return (Employee as any).__deserialize(value, ctx) as Actor;
    }
    return value as Actor;
  }
  if (__typeName === "Account") {
    if (typeof (Account as any)?.__deserialize === "function") {
      return (Account as any).__deserialize(value, ctx) as Actor;
    }
    return value as Actor;
  }
  throw new DeserializeError([
    {
      field: "_root",
      message:
        'Actor.__deserialize: unknown type "' +
        __typeName +
        '". Expected one of: User, Employee, Account',
    },
  ]);
}
export function isActor(value: unknown): value is Actor {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const __typeName = (value as any).__type;
  return (
    __typeName === "User" ||
    __typeName === "Employee" ||
    __typeName === "Account"
  );
}

export namespace Actor {
  /** Per-variant error types */ export type UserErrors = {
    _errors: Option<Array<string>>;
  };
  export type EmployeeErrors = { _errors: Option<Array<string>> };
  export type AccountErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type UserTainted = {};
  export type EmployeeTainted = {};
  export type AccountTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "User" } & UserErrors)
    | ({ _type: "Employee" } & EmployeeErrors)
    | ({ _type: "Account" } & AccountErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "User" } & UserTainted)
    | ({ _type: "Employee" } & EmployeeTainted)
    | ({ _type: "Account" } & AccountTainted);
  /** Per-variant field controller types */ export interface UserFieldControllers {}
  export interface EmployeeFieldControllers {}
  export interface AccountFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "User" | "Employee" | "Account";
    readonly data: Actor;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "User" | "Employee" | "Account"): void;
    validate(): Result<Actor, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Actor>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly User: { readonly fields: UserFieldControllers };
    readonly Employee: { readonly fields: EmployeeFieldControllers };
    readonly Account: { readonly fields: AccountFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Actor {
    switch (variant) {
      case "User":
        return User.defaultValue() as Actor;
      case "Employee":
        return Employee.defaultValue() as Actor;
      case "Account":
        return Account.defaultValue() as Actor;
      default:
        return User.defaultValue() as Actor;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Actor,
  ): Gigaform {
    const initialVariant: "User" | "Employee" | "Account" = "User";
    let currentVariant = $state<"User" | "Employee" | "Account">(
      initialVariant,
    );
    let data = $state<Actor>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      User: {
        fields: {} as UserFieldControllers,
      },
      Employee: {
        fields: {} as EmployeeFieldControllers,
      },
      Account: {
        fields: {} as AccountFieldControllers,
      },
    };
    function switchVariant(variant: "User" | "Employee" | "Account"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Actor,
      Array<{ field: string; message: string }>
    > {
      return Actor.fromObject(data);
    }
    function reset(overrides?: Partial<Actor>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Actor, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as
      | "User"
      | "Employee"
      | "Account"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "User") {
    } else if (discriminant === "Employee") {
    } else if (discriminant === "Account") {
    }
    return Actor.fromStringifiedJSON(JSON.stringify(obj));
  }
}
