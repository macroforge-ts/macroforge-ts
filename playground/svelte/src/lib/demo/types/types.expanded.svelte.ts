import { SerializeContext } from "macroforge/serde";
import { Result } from "macroforge/utils";
import { DeserializeContext } from "macroforge/serde";
import { DeserializeError } from "macroforge/serde";
import type { DeserializeOptions } from "macroforge/serde";
import { PendingRef } from "macroforge/serde";
import { Option } from "macroforge/utils";
import type { FieldController } from "@playground/macro/gigaform";
import type { ArrayFieldController } from "@playground/macro/gigaform";
/** import macro {Gigaform} from "@playground/macro"; */


export interface User {
    id: string;
    email: string | null;
    
    firstName: string;
    
    lastName: string;
    password: string | null;
    metadata: Metadata | null;
    settings: Settings;
    
    role: UserRole;
    emailVerified: boolean;
    verificationToken: string | null;
    verificationExpires: string | null;
    passwordResetToken: string | null;
    passwordResetExpires: string | null;
    permissions: AppPermissions;
}

export function defaultValueUser(): User {return {id: "",
                            email: null,
                            firstName: "",
                            lastName: "",
                            password: null,
                            metadata: null,
                            settings: defaultValueSettings(),
                            role: "Administrator",
                            emailVerified: false,
                            verificationToken: null,
                            verificationExpires: null,
                            passwordResetToken: null,
                            passwordResetExpires: null,
                            permissions: defaultValueAppPermissions(), }as User;}

export function toStringifiedJSONUser(value: User): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeUser(value, ctx));}export function toObjectUser(value: User): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeUser(value, ctx);}export function __serializeUser(value: User, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "User" , __id,}; result["id" ]= value.id; result["email" ]= value.email; result["firstName" ]= value.firstName; result["lastName" ]= value.lastName; result["password" ]= value.password; if(value.metadata!== null){result["metadata" ]= __serializeMetadata(value.metadata, ctx); }else {result["metadata" ]= null;}result["settings" ]= __serializeSettings(value.settings, ctx); result["role" ]= __serializeUserRole(value.role, ctx); result["emailVerified" ]= value.emailVerified; result["verificationToken" ]= value.verificationToken; result["verificationExpires" ]= value.verificationExpires; result["passwordResetToken" ]= value.passwordResetToken; result["passwordResetExpires" ]= value.passwordResetExpires; result["permissions" ]= __serializeAppPermissions(value.permissions, ctx); return result;}

export function fromStringifiedJSONUser(json: string, opts?: DeserializeOptions): Result<User, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectUser(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectUser(obj: unknown, opts?: DeserializeOptions): Result<User, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeUser(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "User.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeUser(value: any, ctx: DeserializeContext): User | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "User.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("firstName" in obj)){errors.push({field: "firstName" , message: "missing required field" });}if(!("lastName" in obj)){errors.push({field: "lastName" , message: "missing required field" });}if(!("password" in obj)){errors.push({field: "password" , message: "missing required field" });}if(!("metadata" in obj)){errors.push({field: "metadata" , message: "missing required field" });}if(!("settings" in obj)){errors.push({field: "settings" , message: "missing required field" });}if(!("role" in obj)){errors.push({field: "role" , message: "missing required field" });}if(!("emailVerified" in obj)){errors.push({field: "emailVerified" , message: "missing required field" });}if(!("verificationToken" in obj)){errors.push({field: "verificationToken" , message: "missing required field" });}if(!("verificationExpires" in obj)){errors.push({field: "verificationExpires" , message: "missing required field" });}if(!("passwordResetToken" in obj)){errors.push({field: "passwordResetToken" , message: "missing required field" });}if(!("passwordResetExpires" in obj)){errors.push({field: "passwordResetExpires" , message: "missing required field" });}if(!("permissions" in obj)){errors.push({field: "permissions" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_email = obj["email" ]as string | null; instance.email = __raw_email; }{const __raw_firstName = obj["firstName" ]as string; 
                if (__raw_firstName.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
 instance.firstName = __raw_firstName; }{const __raw_lastName = obj["lastName" ]as string; 
                if (__raw_lastName.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
 instance.lastName = __raw_lastName; }{const __raw_password = obj["password" ]as string | null; instance.password = __raw_password; }{const __raw_metadata = obj["metadata" ]as Metadata | null; if(__raw_metadata === null){instance.metadata = null;}else {const __result = __deserializeMetadata(__raw_metadata, ctx); ctx.assignOrDefer(instance, "metadata" , __result); }}{const __raw_settings = obj["settings" ]as Settings; {const __result = __deserializeSettings(__raw_settings, ctx); ctx.assignOrDefer(instance, "settings" , __result);}}{const __raw_role = obj["role" ]as UserRole; {const __result = __deserializeUserRole(__raw_role, ctx); ctx.assignOrDefer(instance, "role" , __result);}}{const __raw_emailVerified = obj["emailVerified" ]as boolean; instance.emailVerified = __raw_emailVerified; }{const __raw_verificationToken = obj["verificationToken" ]as string | null; instance.verificationToken = __raw_verificationToken; }{const __raw_verificationExpires = obj["verificationExpires" ]as string | null; instance.verificationExpires = __raw_verificationExpires; }{const __raw_passwordResetToken = obj["passwordResetToken" ]as string | null; instance.passwordResetToken = __raw_passwordResetToken; }{const __raw_passwordResetExpires = obj["passwordResetExpires" ]as string | null; instance.passwordResetExpires = __raw_passwordResetExpires; }{const __raw_permissions = obj["permissions" ]as AppPermissions; {const __result = __deserializeAppPermissions(__raw_permissions, ctx); ctx.assignOrDefer(instance, "permissions" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as User;}export function validateFieldUser<K extends keyof User>(field: K, value: User[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "firstName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
 break;}case "lastName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsUser(partial: Partial<User>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("firstName" in partial && partial.firstName!== undefined){const __val = partial.firstName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
}if("lastName" in partial && partial.lastName!== undefined){const __val = partial.lastName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
}return errors; }export function hasShapeUser(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "email" in o && "firstName" in o && "lastName" in o && "password" in o && "metadata" in o && "settings" in o && "role" in o && "emailVerified" in o && "verificationToken" in o && "verificationExpires" in o && "passwordResetToken" in o && "passwordResetExpires" in o && "permissions" in o;}export function isUser(obj: unknown): obj is User {if(!hasShapeUser(obj)){return false;}const result = fromObjectUser(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsUser = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            email: Option<Array<string>>;
            firstName: Option<Array<string>>;
            lastName: Option<Array<string>>;
            password: Option<Array<string>>;
            metadata: Option<Array<string>>;
            settings: Option<Array<string>>;
            role: Option<Array<string>>;
            emailVerified: Option<Array<string>>;
            verificationToken: Option<Array<string>>;
            verificationExpires: Option<Array<string>>;
            passwordResetToken: Option<Array<string>>;
            passwordResetExpires: Option<Array<string>>;
            permissions: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedUser = {id: Option<boolean>;
            email: Option<boolean>;
            firstName: Option<boolean>;
            lastName: Option<boolean>;
            password: Option<boolean>;
            metadata: Option<boolean>;
            settings: Option<boolean>;
            role: Option<boolean>;
            emailVerified: Option<boolean>;
            verificationToken: Option<boolean>;
            verificationExpires: Option<boolean>;
            passwordResetToken: Option<boolean>;
            passwordResetExpires: Option<boolean>;
            permissions: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersUser {readonly id: FieldController<string>;
            readonly email: FieldController<string | null>;
            readonly firstName: FieldController<string>;
            readonly lastName: FieldController<string>;
            readonly password: FieldController<string | null>;
            readonly metadata: FieldController<Metadata | null>;
            readonly settings: FieldController<Settings>;
            readonly role: FieldController<UserRole>;
            readonly emailVerified: FieldController<boolean>;
            readonly verificationToken: FieldController<string | null>;
            readonly verificationExpires: FieldController<string | null>;
            readonly passwordResetToken: FieldController<string | null>;
            readonly passwordResetExpires: FieldController<string | null>;
            readonly permissions: FieldController<AppPermissions>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformUser {readonly data: User; readonly errors: ErrorsUser; readonly tainted: TaintedUser; readonly fields: FieldControllersUser; validate(): Result<User, Array<{field: string; message: string}>>; reset(overrides?: Partial<User>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormUser(overrides?: Partial<User>): GigaformUser {let data = $state({...defaultValueUser(),...overrides}); let errors = $state<ErrorsUser>({ _errors: Option.none(), id: Option.none(), email: Option.none(), firstName: Option.none(), lastName: Option.none(), password: Option.none(), metadata: Option.none(), settings: Option.none(), role: Option.none(), emailVerified: Option.none(), verificationToken: Option.none(), verificationExpires: Option.none(), passwordResetToken: Option.none(), passwordResetExpires: Option.none(), permissions: Option.none() }); let tainted = $state<TaintedUser>({ id: Option.none(), email: Option.none(), firstName: Option.none(), lastName: Option.none(), password: Option.none(), metadata: Option.none(), settings: Option.none(), role: Option.none(), emailVerified: Option.none(), verificationToken: Option.none(), verificationExpires: Option.none(), passwordResetToken: Option.none(), passwordResetExpires: Option.none(), permissions: Option.none() }); const fields: FieldControllersUser = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldUser("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                email: {
                    path: ["email"] as const,
                    name: "email",
                    constraints: { required: true },
                    
                    get: () => data.email,
                    set: (value: string | null) => { data.email = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.email,
                    setError: (value: Option<Array<string>>) => { errors.email = value; },
                    getTainted: () => tainted.email,
                    setTainted: (value: Option<boolean>) => { tainted.email = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldUser("email", data.email);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                firstName: {
                    path: ["firstName"] as const,
                    name: "firstName",
                    constraints: { required: true },
                    
                    get: () => data.firstName,
                    set: (value: string) => { data.firstName = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.firstName,
                    setError: (value: Option<Array<string>>) => { errors.firstName = value; },
                    getTainted: () => tainted.firstName,
                    setTainted: (value: Option<boolean>) => { tainted.firstName = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldUser("firstName", data.firstName);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                lastName: {
                    path: ["lastName"] as const,
                    name: "lastName",
                    constraints: { required: true },
                    
                    get: () => data.lastName,
                    set: (value: string) => { data.lastName = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.lastName,
                    setError: (value: Option<Array<string>>) => { errors.lastName = value; },
                    getTainted: () => tainted.lastName,
                    setTainted: (value: Option<boolean>) => { tainted.lastName = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldUser("lastName", data.lastName);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                password: {
                    path: ["password"] as const,
                    name: "password",
                    constraints: { required: true },
                    
                    get: () => data.password,
                    set: (value: string | null) => { data.password = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.password,
                    setError: (value: Option<Array<string>>) => { errors.password = value; },
                    getTainted: () => tainted.password,
                    setTainted: (value: Option<boolean>) => { tainted.password = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldUser("password", data.password);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                metadata: {
                    path: ["metadata"] as const,
                    name: "metadata",
                    constraints: { required: true },
                    
                    get: () => data.metadata,
                    set: (value: Metadata | null) => { data.metadata = value; },
                    transform: (value: Metadata | null): Metadata | null => value,
                    getError: () => errors.metadata,
                    setError: (value: Option<Array<string>>) => { errors.metadata = value; },
                    getTainted: () => tainted.metadata,
                    setTainted: (value: Option<boolean>) => { tainted.metadata = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldUser("metadata", data.metadata);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                settings: {
                    path: ["settings"] as const,
                    name: "settings",
                    constraints: { required: true },
                    
                    get: () => data.settings,
                    set: (value: Settings) => { data.settings = value; },
                    transform: (value: Settings): Settings => value,
                    getError: () => errors.settings,
                    setError: (value: Option<Array<string>>) => { errors.settings = value; },
                    getTainted: () => tainted.settings,
                    setTainted: (value: Option<boolean>) => { tainted.settings = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldUser("settings", data.settings);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                role: {
                    path: ["role"] as const,
                    name: "role",
                    constraints: { required: true },
                    
                    get: () => data.role,
                    set: (value: UserRole) => { data.role = value; },
                    transform: (value: UserRole): UserRole => value,
                    getError: () => errors.role,
                    setError: (value: Option<Array<string>>) => { errors.role = value; },
                    getTainted: () => tainted.role,
                    setTainted: (value: Option<boolean>) => { tainted.role = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldUser("role", data.role);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                emailVerified: {
                    path: ["emailVerified"] as const,
                    name: "emailVerified",
                    constraints: { required: true },
                    
                    get: () => data.emailVerified,
                    set: (value: boolean) => { data.emailVerified = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.emailVerified,
                    setError: (value: Option<Array<string>>) => { errors.emailVerified = value; },
                    getTainted: () => tainted.emailVerified,
                    setTainted: (value: Option<boolean>) => { tainted.emailVerified = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldUser("emailVerified", data.emailVerified);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                verificationToken: {
                    path: ["verificationToken"] as const,
                    name: "verificationToken",
                    constraints: { required: true },
                    
                    get: () => data.verificationToken,
                    set: (value: string | null) => { data.verificationToken = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.verificationToken,
                    setError: (value: Option<Array<string>>) => { errors.verificationToken = value; },
                    getTainted: () => tainted.verificationToken,
                    setTainted: (value: Option<boolean>) => { tainted.verificationToken = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldUser("verificationToken", data.verificationToken);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                verificationExpires: {
                    path: ["verificationExpires"] as const,
                    name: "verificationExpires",
                    constraints: { required: true },
                    
                    get: () => data.verificationExpires,
                    set: (value: string | null) => { data.verificationExpires = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.verificationExpires,
                    setError: (value: Option<Array<string>>) => { errors.verificationExpires = value; },
                    getTainted: () => tainted.verificationExpires,
                    setTainted: (value: Option<boolean>) => { tainted.verificationExpires = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldUser("verificationExpires", data.verificationExpires);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                passwordResetToken: {
                    path: ["passwordResetToken"] as const,
                    name: "passwordResetToken",
                    constraints: { required: true },
                    
                    get: () => data.passwordResetToken,
                    set: (value: string | null) => { data.passwordResetToken = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.passwordResetToken,
                    setError: (value: Option<Array<string>>) => { errors.passwordResetToken = value; },
                    getTainted: () => tainted.passwordResetToken,
                    setTainted: (value: Option<boolean>) => { tainted.passwordResetToken = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldUser("passwordResetToken", data.passwordResetToken);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                passwordResetExpires: {
                    path: ["passwordResetExpires"] as const,
                    name: "passwordResetExpires",
                    constraints: { required: true },
                    
                    get: () => data.passwordResetExpires,
                    set: (value: string | null) => { data.passwordResetExpires = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.passwordResetExpires,
                    setError: (value: Option<Array<string>>) => { errors.passwordResetExpires = value; },
                    getTainted: () => tainted.passwordResetExpires,
                    setTainted: (value: Option<boolean>) => { tainted.passwordResetExpires = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldUser("passwordResetExpires", data.passwordResetExpires);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                permissions: {
                    path: ["permissions"] as const,
                    name: "permissions",
                    constraints: { required: true },
                    
                    get: () => data.permissions,
                    set: (value: AppPermissions) => { data.permissions = value; },
                    transform: (value: AppPermissions): AppPermissions => value,
                    getError: () => errors.permissions,
                    setError: (value: Option<Array<string>>) => { errors.permissions = value; },
                    getTainted: () => tainted.permissions,
                    setTainted: (value: Option<boolean>) => { tainted.permissions = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldUser("permissions", data.permissions);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<User, Array<{field: string; message: string}>>{return fromObjectUser(data);}function reset(newOverrides?: Partial<User>): void {data = {...defaultValueUser(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), email: Option.none(), firstName: Option.none(), lastName: Option.none(), password: Option.none(), metadata: Option.none(), settings: Option.none(), role: Option.none(), emailVerified: Option.none(), verificationToken: Option.none(), verificationExpires: Option.none(), passwordResetToken: Option.none(), passwordResetExpires: Option.none(), permissions: Option.none() }; tainted = { id: Option.none(), email: Option.none(), firstName: Option.none(), lastName: Option.none(), password: Option.none(), metadata: Option.none(), settings: Option.none(), role: Option.none(), emailVerified: Option.none(), verificationToken: Option.none(), verificationExpires: Option.none(), passwordResetToken: Option.none(), passwordResetExpires: Option.none(), permissions: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataUser(formData: FormData): Result<User, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.email = formData.get("email") ?? "";
            obj.firstName = formData.get("firstName") ?? "";
            obj.lastName = formData.get("lastName") ?? "";
            obj.password = formData.get("password") ?? "";
            obj.metadata = formData.get("metadata") ?? "";
            {
            // Collect nested object fields with prefix "settings."
            const settingsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("settings.")) {
                    const fieldName = key.slice("settings.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = settingsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.settings = settingsObj;
        }
            {
            // Collect nested object fields with prefix "role."
            const roleObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("role.")) {
                    const fieldName = key.slice("role.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = roleObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.role = roleObj;
        }
            {
                const emailVerifiedVal = formData.get("emailVerified");
                obj.emailVerified = emailVerifiedVal === "true" || emailVerifiedVal === "on" || emailVerifiedVal === "1";
            }
            obj.verificationToken = formData.get("verificationToken") ?? "";
            obj.verificationExpires = formData.get("verificationExpires") ?? "";
            obj.passwordResetToken = formData.get("passwordResetToken") ?? "";
            obj.passwordResetExpires = formData.get("passwordResetExpires") ?? "";
            {
            // Collect nested object fields with prefix "permissions."
            const permissionsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("permissions.")) {
                    const fieldName = key.slice("permissions.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = permissionsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.permissions = permissionsObj;
        } return fromStringifiedJSONUser(JSON.stringify(obj));}


export interface Service {
    
    id: string;
    
    
    name: string;
    
    
    quickCode: string;
    
    group: string | null;
    
    subgroup: string | null;
    
    unit: string | null;
    
    active: boolean;
    
    commission: boolean;
    
    favorite: boolean;
    
    averageTime: string | null;
    defaults: ServiceDefaults;
}

export function defaultValueService(): Service {return {id: "",
                            name: "",
                            quickCode: "",
                            group: null,
                            subgroup: null,
                            unit: null,
                            active: false,
                            commission: false,
                            favorite: false,
                            averageTime: null,
                            defaults: defaultValueServiceDefaults(), }as Service;}

export function toStringifiedJSONService(value: Service): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeService(value, ctx));}export function toObjectService(value: Service): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeService(value, ctx);}export function __serializeService(value: Service, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Service" , __id,}; result["id" ]= value.id; result["name" ]= value.name; result["quickCode" ]= value.quickCode; result["group" ]= value.group; result["subgroup" ]= value.subgroup; result["unit" ]= value.unit; result["active" ]= value.active; result["commission" ]= value.commission; result["favorite" ]= value.favorite; result["averageTime" ]= value.averageTime; result["defaults" ]= __serializeServiceDefaults(value.defaults, ctx); return result;}

export function fromStringifiedJSONService(json: string, opts?: DeserializeOptions): Result<Service, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectService(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectService(obj: unknown, opts?: DeserializeOptions): Result<Service, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeService(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Service.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeService(value: any, ctx: DeserializeContext): Service | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Service.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("quickCode" in obj)){errors.push({field: "quickCode" , message: "missing required field" });}if(!("group" in obj)){errors.push({field: "group" , message: "missing required field" });}if(!("subgroup" in obj)){errors.push({field: "subgroup" , message: "missing required field" });}if(!("unit" in obj)){errors.push({field: "unit" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(!("commission" in obj)){errors.push({field: "commission" , message: "missing required field" });}if(!("favorite" in obj)){errors.push({field: "favorite" , message: "missing required field" });}if(!("averageTime" in obj)){errors.push({field: "averageTime" , message: "missing required field" });}if(!("defaults" in obj)){errors.push({field: "defaults" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_quickCode = obj["quickCode" ]as string; 
                if (__raw_quickCode.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
 instance.quickCode = __raw_quickCode; }{const __raw_group = obj["group" ]as string | null; instance.group = __raw_group; }{const __raw_subgroup = obj["subgroup" ]as string | null; instance.subgroup = __raw_subgroup; }{const __raw_unit = obj["unit" ]as string | null; instance.unit = __raw_unit; }{const __raw_active = obj["active" ]as boolean; instance.active = __raw_active; }{const __raw_commission = obj["commission" ]as boolean; instance.commission = __raw_commission; }{const __raw_favorite = obj["favorite" ]as boolean; instance.favorite = __raw_favorite; }{const __raw_averageTime = obj["averageTime" ]as string | null; instance.averageTime = __raw_averageTime; }{const __raw_defaults = obj["defaults" ]as ServiceDefaults; {const __result = __deserializeServiceDefaults(__raw_defaults, ctx); ctx.assignOrDefer(instance, "defaults" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Service;}export function validateFieldService<K extends keyof Service>(field: K, value: Service[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "quickCode" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsService(partial: Partial<Service>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("quickCode" in partial && partial.quickCode!== undefined){const __val = partial.quickCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
}return errors; }export function hasShapeService(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "name" in o && "quickCode" in o && "group" in o && "subgroup" in o && "unit" in o && "active" in o && "commission" in o && "favorite" in o && "averageTime" in o && "defaults" in o;}export function isService(obj: unknown): obj is Service {if(!hasShapeService(obj)){return false;}const result = fromObjectService(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsService = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            name: Option<Array<string>>;
            quickCode: Option<Array<string>>;
            group: Option<Array<string>>;
            subgroup: Option<Array<string>>;
            unit: Option<Array<string>>;
            active: Option<Array<string>>;
            commission: Option<Array<string>>;
            favorite: Option<Array<string>>;
            averageTime: Option<Array<string>>;
            defaults: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedService = {id: Option<boolean>;
            name: Option<boolean>;
            quickCode: Option<boolean>;
            group: Option<boolean>;
            subgroup: Option<boolean>;
            unit: Option<boolean>;
            active: Option<boolean>;
            commission: Option<boolean>;
            favorite: Option<boolean>;
            averageTime: Option<boolean>;
            defaults: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersService {readonly id: FieldController<string>;
            readonly name: FieldController<string>;
            readonly quickCode: FieldController<string>;
            readonly group: FieldController<string | null>;
            readonly subgroup: FieldController<string | null>;
            readonly unit: FieldController<string | null>;
            readonly active: FieldController<boolean>;
            readonly commission: FieldController<boolean>;
            readonly favorite: FieldController<boolean>;
            readonly averageTime: FieldController<string | null>;
            readonly defaults: FieldController<ServiceDefaults>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformService {readonly data: Service; readonly errors: ErrorsService; readonly tainted: TaintedService; readonly fields: FieldControllersService; validate(): Result<Service, Array<{field: string; message: string}>>; reset(overrides?: Partial<Service>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormService(overrides?: Partial<Service>): GigaformService {let data = $state({...defaultValueService(),...overrides}); let errors = $state<ErrorsService>({ _errors: Option.none(), id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), averageTime: Option.none(), defaults: Option.none() }); let tainted = $state<TaintedService>({ id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), averageTime: Option.none(), defaults: Option.none() }); const fields: FieldControllersService = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldService("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                name: {
                    path: ["name"] as const,
                    name: "name",
                    constraints: { required: true },
                    label: "Name",
                    get: () => data.name,
                    set: (value: string) => { data.name = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.name,
                    setError: (value: Option<Array<string>>) => { errors.name = value; },
                    getTainted: () => tainted.name,
                    setTainted: (value: Option<boolean>) => { tainted.name = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldService("name", data.name);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                quickCode: {
                    path: ["quickCode"] as const,
                    name: "quickCode",
                    constraints: { required: true },
                    label: "Quick Code",
                    get: () => data.quickCode,
                    set: (value: string) => { data.quickCode = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.quickCode,
                    setError: (value: Option<Array<string>>) => { errors.quickCode = value; },
                    getTainted: () => tainted.quickCode,
                    setTainted: (value: Option<boolean>) => { tainted.quickCode = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldService("quickCode", data.quickCode);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                group: {
                    path: ["group"] as const,
                    name: "group",
                    constraints: { required: true },
                    label: "Group",
                    get: () => data.group,
                    set: (value: string | null) => { data.group = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.group,
                    setError: (value: Option<Array<string>>) => { errors.group = value; },
                    getTainted: () => tainted.group,
                    setTainted: (value: Option<boolean>) => { tainted.group = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldService("group", data.group);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                subgroup: {
                    path: ["subgroup"] as const,
                    name: "subgroup",
                    constraints: { required: true },
                    label: "Subgroup",
                    get: () => data.subgroup,
                    set: (value: string | null) => { data.subgroup = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.subgroup,
                    setError: (value: Option<Array<string>>) => { errors.subgroup = value; },
                    getTainted: () => tainted.subgroup,
                    setTainted: (value: Option<boolean>) => { tainted.subgroup = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldService("subgroup", data.subgroup);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                unit: {
                    path: ["unit"] as const,
                    name: "unit",
                    constraints: { required: true },
                    label: "Unit",
                    get: () => data.unit,
                    set: (value: string | null) => { data.unit = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.unit,
                    setError: (value: Option<Array<string>>) => { errors.unit = value; },
                    getTainted: () => tainted.unit,
                    setTainted: (value: Option<boolean>) => { tainted.unit = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldService("unit", data.unit);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                active: {
                    path: ["active"] as const,
                    name: "active",
                    constraints: { required: true },
                    label: "Active",
                    get: () => data.active,
                    set: (value: boolean) => { data.active = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.active,
                    setError: (value: Option<Array<string>>) => { errors.active = value; },
                    getTainted: () => tainted.active,
                    setTainted: (value: Option<boolean>) => { tainted.active = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldService("active", data.active);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                commission: {
                    path: ["commission"] as const,
                    name: "commission",
                    constraints: { required: true },
                    label: "Commission",
                    get: () => data.commission,
                    set: (value: boolean) => { data.commission = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.commission,
                    setError: (value: Option<Array<string>>) => { errors.commission = value; },
                    getTainted: () => tainted.commission,
                    setTainted: (value: Option<boolean>) => { tainted.commission = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldService("commission", data.commission);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                favorite: {
                    path: ["favorite"] as const,
                    name: "favorite",
                    constraints: { required: true },
                    label: "Favorite",
                    get: () => data.favorite,
                    set: (value: boolean) => { data.favorite = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.favorite,
                    setError: (value: Option<Array<string>>) => { errors.favorite = value; },
                    getTainted: () => tainted.favorite,
                    setTainted: (value: Option<boolean>) => { tainted.favorite = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldService("favorite", data.favorite);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                averageTime: {
                    path: ["averageTime"] as const,
                    name: "averageTime",
                    constraints: { required: true },
                    label: "Average Time",
                    get: () => data.averageTime,
                    set: (value: string | null) => { data.averageTime = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.averageTime,
                    setError: (value: Option<Array<string>>) => { errors.averageTime = value; },
                    getTainted: () => tainted.averageTime,
                    setTainted: (value: Option<boolean>) => { tainted.averageTime = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldService("averageTime", data.averageTime);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                defaults: {
                    path: ["defaults"] as const,
                    name: "defaults",
                    constraints: { required: true },
                    
                    get: () => data.defaults,
                    set: (value: ServiceDefaults) => { data.defaults = value; },
                    transform: (value: ServiceDefaults): ServiceDefaults => value,
                    getError: () => errors.defaults,
                    setError: (value: Option<Array<string>>) => { errors.defaults = value; },
                    getTainted: () => tainted.defaults,
                    setTainted: (value: Option<boolean>) => { tainted.defaults = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldService("defaults", data.defaults);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Service, Array<{field: string; message: string}>>{return fromObjectService(data);}function reset(newOverrides?: Partial<Service>): void {data = {...defaultValueService(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), averageTime: Option.none(), defaults: Option.none() }; tainted = { id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), averageTime: Option.none(), defaults: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataService(formData: FormData): Result<Service, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.name = formData.get("name") ?? "";
            obj.quickCode = formData.get("quickCode") ?? "";
            obj.group = formData.get("group") ?? "";
            obj.subgroup = formData.get("subgroup") ?? "";
            obj.unit = formData.get("unit") ?? "";
            {
                const activeVal = formData.get("active");
                obj.active = activeVal === "true" || activeVal === "on" || activeVal === "1";
            }
            {
                const commissionVal = formData.get("commission");
                obj.commission = commissionVal === "true" || commissionVal === "on" || commissionVal === "1";
            }
            {
                const favoriteVal = formData.get("favorite");
                obj.favorite = favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1";
            }
            obj.averageTime = formData.get("averageTime") ?? "";
            {
            // Collect nested object fields with prefix "defaults."
            const defaultsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("defaults.")) {
                    const fieldName = key.slice("defaults.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = defaultsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.defaults = defaultsObj;
        } return fromStringifiedJSONService(JSON.stringify(obj));}


export interface ServiceDefaults {
    
    price: number;
    
    
    description: string;
}

export function defaultValueServiceDefaults(): ServiceDefaults {return {price: 0,
                            description: "", }as ServiceDefaults;}

export function toStringifiedJSONServiceDefaults(value: ServiceDefaults): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeServiceDefaults(value, ctx));}export function toObjectServiceDefaults(value: ServiceDefaults): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeServiceDefaults(value, ctx);}export function __serializeServiceDefaults(value: ServiceDefaults, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "ServiceDefaults" , __id,}; result["price" ]= value.price; result["description" ]= value.description; return result;}

export function fromStringifiedJSONServiceDefaults(json: string, opts?: DeserializeOptions): Result<ServiceDefaults, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectServiceDefaults(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectServiceDefaults(obj: unknown, opts?: DeserializeOptions): Result<ServiceDefaults, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeServiceDefaults(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "ServiceDefaults.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeServiceDefaults(value: any, ctx: DeserializeContext): ServiceDefaults | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "ServiceDefaults.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("price" in obj)){errors.push({field: "price" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_price = obj["price" ]as number; instance.price = __raw_price; }{const __raw_description = obj["description" ]as string; 
                if (__raw_description.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 instance.description = __raw_description; }if(errors.length>0){throw new DeserializeError(errors);}return instance as ServiceDefaults;}export function validateFieldServiceDefaults<K extends keyof ServiceDefaults>(field: K, value: ServiceDefaults[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "description" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsServiceDefaults(partial: Partial<ServiceDefaults>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("description" in partial && partial.description!== undefined){const __val = partial.description as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
}return errors; }export function hasShapeServiceDefaults(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "price" in o && "description" in o;}export function isServiceDefaults(obj: unknown): obj is ServiceDefaults {if(!hasShapeServiceDefaults(obj)){return false;}const result = fromObjectServiceDefaults(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsServiceDefaults = {_errors: Option<Array<string>>; price: Option<Array<string>>;
            description: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedServiceDefaults = {price: Option<boolean>;
            description: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersServiceDefaults {readonly price: FieldController<number>;
            readonly description: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformServiceDefaults {readonly data: ServiceDefaults; readonly errors: ErrorsServiceDefaults; readonly tainted: TaintedServiceDefaults; readonly fields: FieldControllersServiceDefaults; validate(): Result<ServiceDefaults, Array<{field: string; message: string}>>; reset(overrides?: Partial<ServiceDefaults>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormServiceDefaults(overrides?: Partial<ServiceDefaults>): GigaformServiceDefaults {let data = $state({...defaultValueServiceDefaults(),...overrides}); let errors = $state<ErrorsServiceDefaults>({ _errors: Option.none(), price: Option.none(), description: Option.none() }); let tainted = $state<TaintedServiceDefaults>({ price: Option.none(), description: Option.none() }); const fields: FieldControllersServiceDefaults = {price: {
                    path: ["price"] as const,
                    name: "price",
                    constraints: { required: true },
                    label: "Price",
                    get: () => data.price,
                    set: (value: number) => { data.price = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.price,
                    setError: (value: Option<Array<string>>) => { errors.price = value; },
                    getTainted: () => tainted.price,
                    setTainted: (value: Option<boolean>) => { tainted.price = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldServiceDefaults("price", data.price);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                description: {
                    path: ["description"] as const,
                    name: "description",
                    constraints: { required: true },
                    label: "Description",
                    get: () => data.description,
                    set: (value: string) => { data.description = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.description,
                    setError: (value: Option<Array<string>>) => { errors.description = value; },
                    getTainted: () => tainted.description,
                    setTainted: (value: Option<boolean>) => { tainted.description = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldServiceDefaults("description", data.description);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<ServiceDefaults, Array<{field: string; message: string}>>{return fromObjectServiceDefaults(data);}function reset(newOverrides?: Partial<ServiceDefaults>): void {data = {...defaultValueServiceDefaults(),...newOverrides}; errors = { _errors: Option.none(), price: Option.none(), description: Option.none() }; tainted = { price: Option.none(), description: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataServiceDefaults(formData: FormData): Result<ServiceDefaults, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const priceStr = formData.get("price");
                obj.price = priceStr ? parseFloat(priceStr as string) : 0;
                if (obj.price !== undefined && isNaN(obj.price as number)) obj.price = 0;
            }
            obj.description = formData.get("description") ?? ""; return fromStringifiedJSONServiceDefaults(JSON.stringify(obj));}


export interface Did {
    
    in: string | Actor;
    
    out: string | Target;
    id: string;
    activityType: ActivityType;
    createdAt: string;
    metadata: string | null;
}

export function defaultValueDid(): Did {return {in: "",
                            out: "",
                            id: "",
                            activityType: defaultValueActivityType(),
                            createdAt: "",
                            metadata: null, }as Did;}

export function toStringifiedJSONDid(value: Did): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeDid(value, ctx));}export function toObjectDid(value: Did): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeDid(value, ctx);}export function __serializeDid(value: Did, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Did" , __id,}; result["in" ]= value.in; result["out" ]= value.out; result["id" ]= value.id; result["activityType" ]= __serializeActivityType(value.activityType, ctx); result["createdAt" ]= value.createdAt; result["metadata" ]= value.metadata; return result;}

export function fromStringifiedJSONDid(json: string, opts?: DeserializeOptions): Result<Did, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectDid(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectDid(obj: unknown, opts?: DeserializeOptions): Result<Did, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeDid(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Did.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeDid(value: any, ctx: DeserializeContext): Did | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Did.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("in" in obj)){errors.push({field: "in" , message: "missing required field" });}if(!("out" in obj)){errors.push({field: "out" , message: "missing required field" });}if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("activityType" in obj)){errors.push({field: "activityType" , message: "missing required field" });}if(!("createdAt" in obj)){errors.push({field: "createdAt" , message: "missing required field" });}if(!("metadata" in obj)){errors.push({field: "metadata" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_in = obj["in" ]as string | Actor; instance.in = __raw_in; }{const __raw_out = obj["out" ]as string | Target; instance.out = __raw_out; }{const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_activityType = obj["activityType" ]as ActivityType; {const __result = __deserializeActivityType(__raw_activityType, ctx); ctx.assignOrDefer(instance, "activityType" , __result);}}{const __raw_createdAt = obj["createdAt" ]as string; instance.createdAt = __raw_createdAt; }{const __raw_metadata = obj["metadata" ]as string | null; instance.metadata = __raw_metadata; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Did;}export function validateFieldDid<K extends keyof Did>(field: K, value: Did[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsDid(partial: Partial<Did>): Array<{field: string; message: string}>{return[]; }export function hasShapeDid(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "in" in o && "out" in o && "id" in o && "activityType" in o && "createdAt" in o && "metadata" in o;}export function isDid(obj: unknown): obj is Did {if(!hasShapeDid(obj)){return false;}const result = fromObjectDid(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsDid = {_errors: Option<Array<string>>; in: Option<Array<string>>;
            out: Option<Array<string>>;
            id: Option<Array<string>>;
            activityType: Option<Array<string>>;
            createdAt: Option<Array<string>>;
            metadata: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedDid = {in: Option<boolean>;
            out: Option<boolean>;
            id: Option<boolean>;
            activityType: Option<boolean>;
            createdAt: Option<boolean>;
            metadata: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersDid {readonly in: FieldController<string | Actor>;
            readonly out: FieldController<string | Target>;
            readonly id: FieldController<string>;
            readonly activityType: FieldController<ActivityType>;
            readonly createdAt: FieldController<string>;
            readonly metadata: FieldController<string | null>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformDid {readonly data: Did; readonly errors: ErrorsDid; readonly tainted: TaintedDid; readonly fields: FieldControllersDid; validate(): Result<Did, Array<{field: string; message: string}>>; reset(overrides?: Partial<Did>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormDid(overrides?: Partial<Did>): GigaformDid {let data = $state({...defaultValueDid(),...overrides}); let errors = $state<ErrorsDid>({ _errors: Option.none(), in: Option.none(), out: Option.none(), id: Option.none(), activityType: Option.none(), createdAt: Option.none(), metadata: Option.none() }); let tainted = $state<TaintedDid>({ in: Option.none(), out: Option.none(), id: Option.none(), activityType: Option.none(), createdAt: Option.none(), metadata: Option.none() }); const fields: FieldControllersDid = {in: {
                    path: ["in"] as const,
                    name: "in",
                    constraints: { required: true },
                    
                    get: () => data.in,
                    set: (value: string | Actor) => { data.in = value; },
                    transform: (value: string | Actor): string | Actor => value,
                    getError: () => errors.in,
                    setError: (value: Option<Array<string>>) => { errors.in = value; },
                    getTainted: () => tainted.in,
                    setTainted: (value: Option<boolean>) => { tainted.in = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldDid("in", data.in);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                out: {
                    path: ["out"] as const,
                    name: "out",
                    constraints: { required: true },
                    
                    get: () => data.out,
                    set: (value: string | Target) => { data.out = value; },
                    transform: (value: string | Target): string | Target => value,
                    getError: () => errors.out,
                    setError: (value: Option<Array<string>>) => { errors.out = value; },
                    getTainted: () => tainted.out,
                    setTainted: (value: Option<boolean>) => { tainted.out = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldDid("out", data.out);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldDid("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                activityType: {
                    path: ["activityType"] as const,
                    name: "activityType",
                    constraints: { required: true },
                    
                    get: () => data.activityType,
                    set: (value: ActivityType) => { data.activityType = value; },
                    transform: (value: ActivityType): ActivityType => value,
                    getError: () => errors.activityType,
                    setError: (value: Option<Array<string>>) => { errors.activityType = value; },
                    getTainted: () => tainted.activityType,
                    setTainted: (value: Option<boolean>) => { tainted.activityType = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldDid("activityType", data.activityType);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                createdAt: {
                    path: ["createdAt"] as const,
                    name: "createdAt",
                    constraints: { required: true },
                    
                    get: () => data.createdAt,
                    set: (value: string) => { data.createdAt = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.createdAt,
                    setError: (value: Option<Array<string>>) => { errors.createdAt = value; },
                    getTainted: () => tainted.createdAt,
                    setTainted: (value: Option<boolean>) => { tainted.createdAt = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldDid("createdAt", data.createdAt);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                metadata: {
                    path: ["metadata"] as const,
                    name: "metadata",
                    constraints: { required: true },
                    
                    get: () => data.metadata,
                    set: (value: string | null) => { data.metadata = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.metadata,
                    setError: (value: Option<Array<string>>) => { errors.metadata = value; },
                    getTainted: () => tainted.metadata,
                    setTainted: (value: Option<boolean>) => { tainted.metadata = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldDid("metadata", data.metadata);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Did, Array<{field: string; message: string}>>{return fromObjectDid(data);}function reset(newOverrides?: Partial<Did>): void {data = {...defaultValueDid(),...newOverrides}; errors = { _errors: Option.none(), in: Option.none(), out: Option.none(), id: Option.none(), activityType: Option.none(), createdAt: Option.none(), metadata: Option.none() }; tainted = { in: Option.none(), out: Option.none(), id: Option.none(), activityType: Option.none(), createdAt: Option.none(), metadata: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataDid(formData: FormData): Result<Did, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.in = formData.get("in") ?? "";
            obj.out = formData.get("out") ?? "";
            obj.id = formData.get("id") ?? "";
            {
            // Collect nested object fields with prefix "activityType."
            const activityTypeObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("activityType.")) {
                    const fieldName = key.slice("activityType.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = activityTypeObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.activityType = activityTypeObj;
        }
            obj.createdAt = formData.get("createdAt") ?? "";
            obj.metadata = formData.get("metadata") ?? ""; return fromStringifiedJSONDid(JSON.stringify(obj));}


export interface PersonName {
    
    
    firstName: string;
    
    
    lastName: string;
}

export function defaultValuePersonName(): PersonName {return {firstName: "",
                            lastName: "", }as PersonName;}

export function toStringifiedJSONPersonName(value: PersonName): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializePersonName(value, ctx));}export function toObjectPersonName(value: PersonName): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializePersonName(value, ctx);}export function __serializePersonName(value: PersonName, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "PersonName" , __id,}; result["firstName" ]= value.firstName; result["lastName" ]= value.lastName; return result;}

export function fromStringifiedJSONPersonName(json: string, opts?: DeserializeOptions): Result<PersonName, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectPersonName(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectPersonName(obj: unknown, opts?: DeserializeOptions): Result<PersonName, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializePersonName(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "PersonName.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializePersonName(value: any, ctx: DeserializeContext): PersonName | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "PersonName.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("firstName" in obj)){errors.push({field: "firstName" , message: "missing required field" });}if(!("lastName" in obj)){errors.push({field: "lastName" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_firstName = obj["firstName" ]as string; 
                if (__raw_firstName.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
 instance.firstName = __raw_firstName; }{const __raw_lastName = obj["lastName" ]as string; 
                if (__raw_lastName.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
 instance.lastName = __raw_lastName; }if(errors.length>0){throw new DeserializeError(errors);}return instance as PersonName;}export function validateFieldPersonName<K extends keyof PersonName>(field: K, value: PersonName[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "firstName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
 break;}case "lastName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsPersonName(partial: Partial<PersonName>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("firstName" in partial && partial.firstName!== undefined){const __val = partial.firstName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
}if("lastName" in partial && partial.lastName!== undefined){const __val = partial.lastName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
}return errors; }export function hasShapePersonName(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "firstName" in o && "lastName" in o;}export function isPersonName(obj: unknown): obj is PersonName {if(!hasShapePersonName(obj)){return false;}const result = fromObjectPersonName(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsPersonName = {_errors: Option<Array<string>>; firstName: Option<Array<string>>;
            lastName: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedPersonName = {firstName: Option<boolean>;
            lastName: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersPersonName {readonly firstName: FieldController<string>;
            readonly lastName: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformPersonName {readonly data: PersonName; readonly errors: ErrorsPersonName; readonly tainted: TaintedPersonName; readonly fields: FieldControllersPersonName; validate(): Result<PersonName, Array<{field: string; message: string}>>; reset(overrides?: Partial<PersonName>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormPersonName(overrides?: Partial<PersonName>): GigaformPersonName {let data = $state({...defaultValuePersonName(),...overrides}); let errors = $state<ErrorsPersonName>({ _errors: Option.none(), firstName: Option.none(), lastName: Option.none() }); let tainted = $state<TaintedPersonName>({ firstName: Option.none(), lastName: Option.none() }); const fields: FieldControllersPersonName = {firstName: {
                    path: ["firstName"] as const,
                    name: "firstName",
                    constraints: { required: true },
                    label: "First Name",
                    get: () => data.firstName,
                    set: (value: string) => { data.firstName = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.firstName,
                    setError: (value: Option<Array<string>>) => { errors.firstName = value; },
                    getTainted: () => tainted.firstName,
                    setTainted: (value: Option<boolean>) => { tainted.firstName = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPersonName("firstName", data.firstName);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                lastName: {
                    path: ["lastName"] as const,
                    name: "lastName",
                    constraints: { required: true },
                    label: "Last Name",
                    get: () => data.lastName,
                    set: (value: string) => { data.lastName = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.lastName,
                    setError: (value: Option<Array<string>>) => { errors.lastName = value; },
                    getTainted: () => tainted.lastName,
                    setTainted: (value: Option<boolean>) => { tainted.lastName = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPersonName("lastName", data.lastName);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<PersonName, Array<{field: string; message: string}>>{return fromObjectPersonName(data);}function reset(newOverrides?: Partial<PersonName>): void {data = {...defaultValuePersonName(),...newOverrides}; errors = { _errors: Option.none(), firstName: Option.none(), lastName: Option.none() }; tainted = { firstName: Option.none(), lastName: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataPersonName(formData: FormData): Result<PersonName, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.firstName = formData.get("firstName") ?? "";
            obj.lastName = formData.get("lastName") ?? ""; return fromStringifiedJSONPersonName(JSON.stringify(obj));}


export interface Promotion {
    id: string;
    date: string;
}

export function defaultValuePromotion(): Promotion {return {id: "",
                            date: "", }as Promotion;}

export function toStringifiedJSONPromotion(value: Promotion): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializePromotion(value, ctx));}export function toObjectPromotion(value: Promotion): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializePromotion(value, ctx);}export function __serializePromotion(value: Promotion, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Promotion" , __id,}; result["id" ]= value.id; result["date" ]= value.date; return result;}

export function fromStringifiedJSONPromotion(json: string, opts?: DeserializeOptions): Result<Promotion, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectPromotion(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectPromotion(obj: unknown, opts?: DeserializeOptions): Result<Promotion, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializePromotion(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Promotion.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializePromotion(value: any, ctx: DeserializeContext): Promotion | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Promotion.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("date" in obj)){errors.push({field: "date" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_date = obj["date" ]as string; instance.date = __raw_date; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Promotion;}export function validateFieldPromotion<K extends keyof Promotion>(field: K, value: Promotion[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsPromotion(partial: Partial<Promotion>): Array<{field: string; message: string}>{return[]; }export function hasShapePromotion(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "date" in o;}export function isPromotion(obj: unknown): obj is Promotion {if(!hasShapePromotion(obj)){return false;}const result = fromObjectPromotion(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsPromotion = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            date: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedPromotion = {id: Option<boolean>;
            date: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersPromotion {readonly id: FieldController<string>;
            readonly date: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformPromotion {readonly data: Promotion; readonly errors: ErrorsPromotion; readonly tainted: TaintedPromotion; readonly fields: FieldControllersPromotion; validate(): Result<Promotion, Array<{field: string; message: string}>>; reset(overrides?: Partial<Promotion>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormPromotion(overrides?: Partial<Promotion>): GigaformPromotion {let data = $state({...defaultValuePromotion(),...overrides}); let errors = $state<ErrorsPromotion>({ _errors: Option.none(), id: Option.none(), date: Option.none() }); let tainted = $state<TaintedPromotion>({ id: Option.none(), date: Option.none() }); const fields: FieldControllersPromotion = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPromotion("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                date: {
                    path: ["date"] as const,
                    name: "date",
                    constraints: { required: true },
                    
                    get: () => data.date,
                    set: (value: string) => { data.date = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.date,
                    setError: (value: Option<Array<string>>) => { errors.date = value; },
                    getTainted: () => tainted.date,
                    setTainted: (value: Option<boolean>) => { tainted.date = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPromotion("date", data.date);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Promotion, Array<{field: string; message: string}>>{return fromObjectPromotion(data);}function reset(newOverrides?: Partial<Promotion>): void {data = {...defaultValuePromotion(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), date: Option.none() }; tainted = { id: Option.none(), date: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataPromotion(formData: FormData): Result<Promotion, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.date = formData.get("date") ?? ""; return fromStringifiedJSONPromotion(JSON.stringify(obj));}


export interface Site {
    id: string;
    
    addressLine1: string;
    addressLine2: string | null;
    sublocalityLevel1: string | null;
    
    locality: string;
    administrativeAreaLevel3: string | null;
    administrativeAreaLevel2: string | null;
    
    administrativeAreaLevel1: string;
    
    country: string;
    
    postalCode: string;
    postalCodeSuffix: string | null;
    coordinates: Coordinates;
}

export function defaultValueSite(): Site {return {id: "",
                            addressLine1: "",
                            addressLine2: null,
                            sublocalityLevel1: null,
                            locality: "",
                            administrativeAreaLevel3: null,
                            administrativeAreaLevel2: null,
                            administrativeAreaLevel1: "",
                            country: "",
                            postalCode: "",
                            postalCodeSuffix: null,
                            coordinates: defaultValueCoordinates(), }as Site;}

export function toStringifiedJSONSite(value: Site): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeSite(value, ctx));}export function toObjectSite(value: Site): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeSite(value, ctx);}export function __serializeSite(value: Site, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Site" , __id,}; result["id" ]= value.id; result["addressLine1" ]= value.addressLine1; result["addressLine2" ]= value.addressLine2; result["sublocalityLevel1" ]= value.sublocalityLevel1; result["locality" ]= value.locality; result["administrativeAreaLevel3" ]= value.administrativeAreaLevel3; result["administrativeAreaLevel2" ]= value.administrativeAreaLevel2; result["administrativeAreaLevel1" ]= value.administrativeAreaLevel1; result["country" ]= value.country; result["postalCode" ]= value.postalCode; result["postalCodeSuffix" ]= value.postalCodeSuffix; result["coordinates" ]= __serializeCoordinates(value.coordinates, ctx); return result;}

export function fromStringifiedJSONSite(json: string, opts?: DeserializeOptions): Result<Site, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectSite(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectSite(obj: unknown, opts?: DeserializeOptions): Result<Site, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeSite(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Site.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeSite(value: any, ctx: DeserializeContext): Site | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Site.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("addressLine1" in obj)){errors.push({field: "addressLine1" , message: "missing required field" });}if(!("addressLine2" in obj)){errors.push({field: "addressLine2" , message: "missing required field" });}if(!("sublocalityLevel1" in obj)){errors.push({field: "sublocalityLevel1" , message: "missing required field" });}if(!("locality" in obj)){errors.push({field: "locality" , message: "missing required field" });}if(!("administrativeAreaLevel3" in obj)){errors.push({field: "administrativeAreaLevel3" , message: "missing required field" });}if(!("administrativeAreaLevel2" in obj)){errors.push({field: "administrativeAreaLevel2" , message: "missing required field" });}if(!("administrativeAreaLevel1" in obj)){errors.push({field: "administrativeAreaLevel1" , message: "missing required field" });}if(!("country" in obj)){errors.push({field: "country" , message: "missing required field" });}if(!("postalCode" in obj)){errors.push({field: "postalCode" , message: "missing required field" });}if(!("postalCodeSuffix" in obj)){errors.push({field: "postalCodeSuffix" , message: "missing required field" });}if(!("coordinates" in obj)){errors.push({field: "coordinates" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_addressLine1 = obj["addressLine1" ]as string; 
                if (__raw_addressLine1.length === 0) {
                    errors.push({ field: "addressLine1", message: "must not be empty" });
                }
 instance.addressLine1 = __raw_addressLine1; }{const __raw_addressLine2 = obj["addressLine2" ]as string | null; instance.addressLine2 = __raw_addressLine2; }{const __raw_sublocalityLevel1 = obj["sublocalityLevel1" ]as string | null; instance.sublocalityLevel1 = __raw_sublocalityLevel1; }{const __raw_locality = obj["locality" ]as string; 
                if (__raw_locality.length === 0) {
                    errors.push({ field: "locality", message: "must not be empty" });
                }
 instance.locality = __raw_locality; }{const __raw_administrativeAreaLevel3 = obj["administrativeAreaLevel3" ]as string | null; instance.administrativeAreaLevel3 = __raw_administrativeAreaLevel3; }{const __raw_administrativeAreaLevel2 = obj["administrativeAreaLevel2" ]as string | null; instance.administrativeAreaLevel2 = __raw_administrativeAreaLevel2; }{const __raw_administrativeAreaLevel1 = obj["administrativeAreaLevel1" ]as string; 
                if (__raw_administrativeAreaLevel1.length === 0) {
                    errors.push({ field: "administrativeAreaLevel1", message: "must not be empty" });
                }
 instance.administrativeAreaLevel1 = __raw_administrativeAreaLevel1; }{const __raw_country = obj["country" ]as string; 
                if (__raw_country.length === 0) {
                    errors.push({ field: "country", message: "must not be empty" });
                }
 instance.country = __raw_country; }{const __raw_postalCode = obj["postalCode" ]as string; 
                if (__raw_postalCode.length === 0) {
                    errors.push({ field: "postalCode", message: "must not be empty" });
                }
 instance.postalCode = __raw_postalCode; }{const __raw_postalCodeSuffix = obj["postalCodeSuffix" ]as string | null; instance.postalCodeSuffix = __raw_postalCodeSuffix; }{const __raw_coordinates = obj["coordinates" ]as Coordinates; {const __result = __deserializeCoordinates(__raw_coordinates, ctx); ctx.assignOrDefer(instance, "coordinates" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Site;}export function validateFieldSite<K extends keyof Site>(field: K, value: Site[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "addressLine1" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "addressLine1", message: "must not be empty" });
                }
 break;}case "locality" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "locality", message: "must not be empty" });
                }
 break;}case "administrativeAreaLevel1" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "administrativeAreaLevel1", message: "must not be empty" });
                }
 break;}case "country" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "country", message: "must not be empty" });
                }
 break;}case "postalCode" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "postalCode", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsSite(partial: Partial<Site>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("addressLine1" in partial && partial.addressLine1!== undefined){const __val = partial.addressLine1 as string; 
                if (__val.length === 0) {
                    errors.push({ field: "addressLine1", message: "must not be empty" });
                }
}if("locality" in partial && partial.locality!== undefined){const __val = partial.locality as string; 
                if (__val.length === 0) {
                    errors.push({ field: "locality", message: "must not be empty" });
                }
}if("administrativeAreaLevel1" in partial && partial.administrativeAreaLevel1!== undefined){const __val = partial.administrativeAreaLevel1 as string; 
                if (__val.length === 0) {
                    errors.push({ field: "administrativeAreaLevel1", message: "must not be empty" });
                }
}if("country" in partial && partial.country!== undefined){const __val = partial.country as string; 
                if (__val.length === 0) {
                    errors.push({ field: "country", message: "must not be empty" });
                }
}if("postalCode" in partial && partial.postalCode!== undefined){const __val = partial.postalCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "postalCode", message: "must not be empty" });
                }
}return errors; }export function hasShapeSite(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "addressLine1" in o && "addressLine2" in o && "sublocalityLevel1" in o && "locality" in o && "administrativeAreaLevel3" in o && "administrativeAreaLevel2" in o && "administrativeAreaLevel1" in o && "country" in o && "postalCode" in o && "postalCodeSuffix" in o && "coordinates" in o;}export function isSite(obj: unknown): obj is Site {if(!hasShapeSite(obj)){return false;}const result = fromObjectSite(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsSite = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            addressLine1: Option<Array<string>>;
            addressLine2: Option<Array<string>>;
            sublocalityLevel1: Option<Array<string>>;
            locality: Option<Array<string>>;
            administrativeAreaLevel3: Option<Array<string>>;
            administrativeAreaLevel2: Option<Array<string>>;
            administrativeAreaLevel1: Option<Array<string>>;
            country: Option<Array<string>>;
            postalCode: Option<Array<string>>;
            postalCodeSuffix: Option<Array<string>>;
            coordinates: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedSite = {id: Option<boolean>;
            addressLine1: Option<boolean>;
            addressLine2: Option<boolean>;
            sublocalityLevel1: Option<boolean>;
            locality: Option<boolean>;
            administrativeAreaLevel3: Option<boolean>;
            administrativeAreaLevel2: Option<boolean>;
            administrativeAreaLevel1: Option<boolean>;
            country: Option<boolean>;
            postalCode: Option<boolean>;
            postalCodeSuffix: Option<boolean>;
            coordinates: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersSite {readonly id: FieldController<string>;
            readonly addressLine1: FieldController<string>;
            readonly addressLine2: FieldController<string | null>;
            readonly sublocalityLevel1: FieldController<string | null>;
            readonly locality: FieldController<string>;
            readonly administrativeAreaLevel3: FieldController<string | null>;
            readonly administrativeAreaLevel2: FieldController<string | null>;
            readonly administrativeAreaLevel1: FieldController<string>;
            readonly country: FieldController<string>;
            readonly postalCode: FieldController<string>;
            readonly postalCodeSuffix: FieldController<string | null>;
            readonly coordinates: FieldController<Coordinates>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformSite {readonly data: Site; readonly errors: ErrorsSite; readonly tainted: TaintedSite; readonly fields: FieldControllersSite; validate(): Result<Site, Array<{field: string; message: string}>>; reset(overrides?: Partial<Site>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormSite(overrides?: Partial<Site>): GigaformSite {let data = $state({...defaultValueSite(),...overrides}); let errors = $state<ErrorsSite>({ _errors: Option.none(), id: Option.none(), addressLine1: Option.none(), addressLine2: Option.none(), sublocalityLevel1: Option.none(), locality: Option.none(), administrativeAreaLevel3: Option.none(), administrativeAreaLevel2: Option.none(), administrativeAreaLevel1: Option.none(), country: Option.none(), postalCode: Option.none(), postalCodeSuffix: Option.none(), coordinates: Option.none() }); let tainted = $state<TaintedSite>({ id: Option.none(), addressLine1: Option.none(), addressLine2: Option.none(), sublocalityLevel1: Option.none(), locality: Option.none(), administrativeAreaLevel3: Option.none(), administrativeAreaLevel2: Option.none(), administrativeAreaLevel1: Option.none(), country: Option.none(), postalCode: Option.none(), postalCodeSuffix: Option.none(), coordinates: Option.none() }); const fields: FieldControllersSite = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSite("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                addressLine1: {
                    path: ["addressLine1"] as const,
                    name: "addressLine1",
                    constraints: { required: true },
                    
                    get: () => data.addressLine1,
                    set: (value: string) => { data.addressLine1 = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.addressLine1,
                    setError: (value: Option<Array<string>>) => { errors.addressLine1 = value; },
                    getTainted: () => tainted.addressLine1,
                    setTainted: (value: Option<boolean>) => { tainted.addressLine1 = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSite("addressLine1", data.addressLine1);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                addressLine2: {
                    path: ["addressLine2"] as const,
                    name: "addressLine2",
                    constraints: { required: true },
                    
                    get: () => data.addressLine2,
                    set: (value: string | null) => { data.addressLine2 = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.addressLine2,
                    setError: (value: Option<Array<string>>) => { errors.addressLine2 = value; },
                    getTainted: () => tainted.addressLine2,
                    setTainted: (value: Option<boolean>) => { tainted.addressLine2 = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSite("addressLine2", data.addressLine2);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                sublocalityLevel1: {
                    path: ["sublocalityLevel1"] as const,
                    name: "sublocalityLevel1",
                    constraints: { required: true },
                    
                    get: () => data.sublocalityLevel1,
                    set: (value: string | null) => { data.sublocalityLevel1 = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.sublocalityLevel1,
                    setError: (value: Option<Array<string>>) => { errors.sublocalityLevel1 = value; },
                    getTainted: () => tainted.sublocalityLevel1,
                    setTainted: (value: Option<boolean>) => { tainted.sublocalityLevel1 = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSite("sublocalityLevel1", data.sublocalityLevel1);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                locality: {
                    path: ["locality"] as const,
                    name: "locality",
                    constraints: { required: true },
                    
                    get: () => data.locality,
                    set: (value: string) => { data.locality = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.locality,
                    setError: (value: Option<Array<string>>) => { errors.locality = value; },
                    getTainted: () => tainted.locality,
                    setTainted: (value: Option<boolean>) => { tainted.locality = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSite("locality", data.locality);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                administrativeAreaLevel3: {
                    path: ["administrativeAreaLevel3"] as const,
                    name: "administrativeAreaLevel3",
                    constraints: { required: true },
                    
                    get: () => data.administrativeAreaLevel3,
                    set: (value: string | null) => { data.administrativeAreaLevel3 = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.administrativeAreaLevel3,
                    setError: (value: Option<Array<string>>) => { errors.administrativeAreaLevel3 = value; },
                    getTainted: () => tainted.administrativeAreaLevel3,
                    setTainted: (value: Option<boolean>) => { tainted.administrativeAreaLevel3 = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSite("administrativeAreaLevel3", data.administrativeAreaLevel3);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                administrativeAreaLevel2: {
                    path: ["administrativeAreaLevel2"] as const,
                    name: "administrativeAreaLevel2",
                    constraints: { required: true },
                    
                    get: () => data.administrativeAreaLevel2,
                    set: (value: string | null) => { data.administrativeAreaLevel2 = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.administrativeAreaLevel2,
                    setError: (value: Option<Array<string>>) => { errors.administrativeAreaLevel2 = value; },
                    getTainted: () => tainted.administrativeAreaLevel2,
                    setTainted: (value: Option<boolean>) => { tainted.administrativeAreaLevel2 = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSite("administrativeAreaLevel2", data.administrativeAreaLevel2);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                administrativeAreaLevel1: {
                    path: ["administrativeAreaLevel1"] as const,
                    name: "administrativeAreaLevel1",
                    constraints: { required: true },
                    
                    get: () => data.administrativeAreaLevel1,
                    set: (value: string) => { data.administrativeAreaLevel1 = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.administrativeAreaLevel1,
                    setError: (value: Option<Array<string>>) => { errors.administrativeAreaLevel1 = value; },
                    getTainted: () => tainted.administrativeAreaLevel1,
                    setTainted: (value: Option<boolean>) => { tainted.administrativeAreaLevel1 = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSite("administrativeAreaLevel1", data.administrativeAreaLevel1);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                country: {
                    path: ["country"] as const,
                    name: "country",
                    constraints: { required: true },
                    
                    get: () => data.country,
                    set: (value: string) => { data.country = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.country,
                    setError: (value: Option<Array<string>>) => { errors.country = value; },
                    getTainted: () => tainted.country,
                    setTainted: (value: Option<boolean>) => { tainted.country = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSite("country", data.country);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                postalCode: {
                    path: ["postalCode"] as const,
                    name: "postalCode",
                    constraints: { required: true },
                    
                    get: () => data.postalCode,
                    set: (value: string) => { data.postalCode = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.postalCode,
                    setError: (value: Option<Array<string>>) => { errors.postalCode = value; },
                    getTainted: () => tainted.postalCode,
                    setTainted: (value: Option<boolean>) => { tainted.postalCode = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSite("postalCode", data.postalCode);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                postalCodeSuffix: {
                    path: ["postalCodeSuffix"] as const,
                    name: "postalCodeSuffix",
                    constraints: { required: true },
                    
                    get: () => data.postalCodeSuffix,
                    set: (value: string | null) => { data.postalCodeSuffix = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.postalCodeSuffix,
                    setError: (value: Option<Array<string>>) => { errors.postalCodeSuffix = value; },
                    getTainted: () => tainted.postalCodeSuffix,
                    setTainted: (value: Option<boolean>) => { tainted.postalCodeSuffix = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSite("postalCodeSuffix", data.postalCodeSuffix);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                coordinates: {
                    path: ["coordinates"] as const,
                    name: "coordinates",
                    constraints: { required: true },
                    
                    get: () => data.coordinates,
                    set: (value: Coordinates) => { data.coordinates = value; },
                    transform: (value: Coordinates): Coordinates => value,
                    getError: () => errors.coordinates,
                    setError: (value: Option<Array<string>>) => { errors.coordinates = value; },
                    getTainted: () => tainted.coordinates,
                    setTainted: (value: Option<boolean>) => { tainted.coordinates = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSite("coordinates", data.coordinates);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Site, Array<{field: string; message: string}>>{return fromObjectSite(data);}function reset(newOverrides?: Partial<Site>): void {data = {...defaultValueSite(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), addressLine1: Option.none(), addressLine2: Option.none(), sublocalityLevel1: Option.none(), locality: Option.none(), administrativeAreaLevel3: Option.none(), administrativeAreaLevel2: Option.none(), administrativeAreaLevel1: Option.none(), country: Option.none(), postalCode: Option.none(), postalCodeSuffix: Option.none(), coordinates: Option.none() }; tainted = { id: Option.none(), addressLine1: Option.none(), addressLine2: Option.none(), sublocalityLevel1: Option.none(), locality: Option.none(), administrativeAreaLevel3: Option.none(), administrativeAreaLevel2: Option.none(), administrativeAreaLevel1: Option.none(), country: Option.none(), postalCode: Option.none(), postalCodeSuffix: Option.none(), coordinates: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataSite(formData: FormData): Result<Site, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.addressLine1 = formData.get("addressLine1") ?? "";
            obj.addressLine2 = formData.get("addressLine2") ?? "";
            obj.sublocalityLevel1 = formData.get("sublocalityLevel1") ?? "";
            obj.locality = formData.get("locality") ?? "";
            obj.administrativeAreaLevel3 = formData.get("administrativeAreaLevel3") ?? "";
            obj.administrativeAreaLevel2 = formData.get("administrativeAreaLevel2") ?? "";
            obj.administrativeAreaLevel1 = formData.get("administrativeAreaLevel1") ?? "";
            obj.country = formData.get("country") ?? "";
            obj.postalCode = formData.get("postalCode") ?? "";
            obj.postalCodeSuffix = formData.get("postalCodeSuffix") ?? "";
            {
            // Collect nested object fields with prefix "coordinates."
            const coordinatesObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("coordinates.")) {
                    const fieldName = key.slice("coordinates.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = coordinatesObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.coordinates = coordinatesObj;
        } return fromStringifiedJSONSite(JSON.stringify(obj));}


export interface Metadata {
    createdAt: string;
    lastLogin: string | null;
    isActive: boolean;
    roles: string[];
}

export function defaultValueMetadata(): Metadata {return {createdAt: "",
                            lastLogin: null,
                            isActive: false,
                            roles: [], }as Metadata;}

export function toStringifiedJSONMetadata(value: Metadata): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeMetadata(value, ctx));}export function toObjectMetadata(value: Metadata): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeMetadata(value, ctx);}export function __serializeMetadata(value: Metadata, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Metadata" , __id,}; result["createdAt" ]= value.createdAt; result["lastLogin" ]= value.lastLogin; result["isActive" ]= value.isActive; result["roles" ]= value.roles; return result;}

export function fromStringifiedJSONMetadata(json: string, opts?: DeserializeOptions): Result<Metadata, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectMetadata(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectMetadata(obj: unknown, opts?: DeserializeOptions): Result<Metadata, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeMetadata(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Metadata.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeMetadata(value: any, ctx: DeserializeContext): Metadata | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Metadata.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("createdAt" in obj)){errors.push({field: "createdAt" , message: "missing required field" });}if(!("lastLogin" in obj)){errors.push({field: "lastLogin" , message: "missing required field" });}if(!("isActive" in obj)){errors.push({field: "isActive" , message: "missing required field" });}if(!("roles" in obj)){errors.push({field: "roles" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_createdAt = obj["createdAt" ]as string; instance.createdAt = __raw_createdAt; }{const __raw_lastLogin = obj["lastLogin" ]as string | null; instance.lastLogin = __raw_lastLogin; }{const __raw_isActive = obj["isActive" ]as boolean; instance.isActive = __raw_isActive; }{const __raw_roles = obj["roles" ]as string[]; if(Array.isArray(__raw_roles)){instance.roles = __raw_roles as string[];}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Metadata;}export function validateFieldMetadata<K extends keyof Metadata>(field: K, value: Metadata[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsMetadata(partial: Partial<Metadata>): Array<{field: string; message: string}>{return[]; }export function hasShapeMetadata(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "createdAt" in o && "lastLogin" in o && "isActive" in o && "roles" in o;}export function isMetadata(obj: unknown): obj is Metadata {if(!hasShapeMetadata(obj)){return false;}const result = fromObjectMetadata(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsMetadata = {_errors: Option<Array<string>>; createdAt: Option<Array<string>>;
            lastLogin: Option<Array<string>>;
            isActive: Option<Array<string>>;
            roles: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedMetadata = {createdAt: Option<boolean>;
            lastLogin: Option<boolean>;
            isActive: Option<boolean>;
            roles: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersMetadata {readonly createdAt: FieldController<string>;
            readonly lastLogin: FieldController<string | null>;
            readonly isActive: FieldController<boolean>;
            readonly roles: ArrayFieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformMetadata {readonly data: Metadata; readonly errors: ErrorsMetadata; readonly tainted: TaintedMetadata; readonly fields: FieldControllersMetadata; validate(): Result<Metadata, Array<{field: string; message: string}>>; reset(overrides?: Partial<Metadata>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormMetadata(overrides?: Partial<Metadata>): GigaformMetadata {let data = $state({...defaultValueMetadata(),...overrides}); let errors = $state<ErrorsMetadata>({ _errors: Option.none(), createdAt: Option.none(), lastLogin: Option.none(), isActive: Option.none(), roles: Option.none() }); let tainted = $state<TaintedMetadata>({ createdAt: Option.none(), lastLogin: Option.none(), isActive: Option.none(), roles: Option.none() }); const fields: FieldControllersMetadata = {createdAt: {
                    path: ["createdAt"] as const,
                    name: "createdAt",
                    constraints: { required: true },
                    
                    get: () => data.createdAt,
                    set: (value: string) => { data.createdAt = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.createdAt,
                    setError: (value: Option<Array<string>>) => { errors.createdAt = value; },
                    getTainted: () => tainted.createdAt,
                    setTainted: (value: Option<boolean>) => { tainted.createdAt = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldMetadata("createdAt", data.createdAt);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                lastLogin: {
                    path: ["lastLogin"] as const,
                    name: "lastLogin",
                    constraints: { required: true },
                    
                    get: () => data.lastLogin,
                    set: (value: string | null) => { data.lastLogin = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.lastLogin,
                    setError: (value: Option<Array<string>>) => { errors.lastLogin = value; },
                    getTainted: () => tainted.lastLogin,
                    setTainted: (value: Option<boolean>) => { tainted.lastLogin = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldMetadata("lastLogin", data.lastLogin);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                isActive: {
                    path: ["isActive"] as const,
                    name: "isActive",
                    constraints: { required: true },
                    
                    get: () => data.isActive,
                    set: (value: boolean) => { data.isActive = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.isActive,
                    setError: (value: Option<Array<string>>) => { errors.isActive = value; },
                    getTainted: () => tainted.isActive,
                    setTainted: (value: Option<boolean>) => { tainted.isActive = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldMetadata("isActive", data.isActive);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                roles: {
                    path: ["roles"] as const,
                    name: "roles",
                    constraints: { required: true },
                    
                    get: () => data.roles,
                    set: (value: string[]) => { data.roles = value; },
                    transform: (value: string[]): string[] => value,
                    getError: () => errors.roles,
                    setError: (value: Option<Array<string>>) => { errors.roles = value; },
                    getTainted: () => tainted.roles,
                    setTainted: (value: Option<boolean>) => { tainted.roles = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldMetadata("roles", data.roles);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["roles", index] as const,
                        name: `roles.${index}`,
                        constraints: { required: true },
                        get: () => data.roles[index]!,
                        set: (value: string) => { data.roles[index] = value; },
                        transform: (value: string): string => value,
                        getError: () => errors.roles,
                        setError: (value: Option<Array<string>>) => { errors.roles = value; },
                        getTainted: () => tainted.roles,
                        setTainted: (value: Option<boolean>) => { tainted.roles = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: string) => { data.roles.push(item); },
                    remove: (index: number) => { data.roles.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.roles[a]!;
                        data.roles[a] = data.roles[b]!;
                        data.roles[b] = tmp;
                    },
                }}; function validate(): Result<Metadata, Array<{field: string; message: string}>>{return fromObjectMetadata(data);}function reset(newOverrides?: Partial<Metadata>): void {data = {...defaultValueMetadata(),...newOverrides}; errors = { _errors: Option.none(), createdAt: Option.none(), lastLogin: Option.none(), isActive: Option.none(), roles: Option.none() }; tainted = { createdAt: Option.none(), lastLogin: Option.none(), isActive: Option.none(), roles: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataMetadata(formData: FormData): Result<Metadata, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.createdAt = formData.get("createdAt") ?? "";
            obj.lastLogin = formData.get("lastLogin") ?? "";
            {
                const isActiveVal = formData.get("isActive");
                obj.isActive = isActiveVal === "true" || isActiveVal === "on" || isActiveVal === "1";
            }
            obj.roles = formData.getAll("roles") as Array<string>; return fromStringifiedJSONMetadata(JSON.stringify(obj));}


export interface ColumnConfig {
    
    heading: string;
    dataPath: DataPath;
}

export function defaultValueColumnConfig(): ColumnConfig {return {heading: "",
                            dataPath: defaultValueDataPath(), }as ColumnConfig;}

export function toStringifiedJSONColumnConfig(value: ColumnConfig): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeColumnConfig(value, ctx));}export function toObjectColumnConfig(value: ColumnConfig): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeColumnConfig(value, ctx);}export function __serializeColumnConfig(value: ColumnConfig, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "ColumnConfig" , __id,}; result["heading" ]= value.heading; result["dataPath" ]= __serializeDataPath(value.dataPath, ctx); return result;}

export function fromStringifiedJSONColumnConfig(json: string, opts?: DeserializeOptions): Result<ColumnConfig, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectColumnConfig(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectColumnConfig(obj: unknown, opts?: DeserializeOptions): Result<ColumnConfig, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeColumnConfig(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "ColumnConfig.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeColumnConfig(value: any, ctx: DeserializeContext): ColumnConfig | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "ColumnConfig.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("heading" in obj)){errors.push({field: "heading" , message: "missing required field" });}if(!("dataPath" in obj)){errors.push({field: "dataPath" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_heading = obj["heading" ]as string; 
                if (__raw_heading.length === 0) {
                    errors.push({ field: "heading", message: "must not be empty" });
                }
 instance.heading = __raw_heading; }{const __raw_dataPath = obj["dataPath" ]as DataPath; {const __result = __deserializeDataPath(__raw_dataPath, ctx); ctx.assignOrDefer(instance, "dataPath" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as ColumnConfig;}export function validateFieldColumnConfig<K extends keyof ColumnConfig>(field: K, value: ColumnConfig[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "heading" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "heading", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsColumnConfig(partial: Partial<ColumnConfig>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("heading" in partial && partial.heading!== undefined){const __val = partial.heading as string; 
                if (__val.length === 0) {
                    errors.push({ field: "heading", message: "must not be empty" });
                }
}return errors; }export function hasShapeColumnConfig(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "heading" in o && "dataPath" in o;}export function isColumnConfig(obj: unknown): obj is ColumnConfig {if(!hasShapeColumnConfig(obj)){return false;}const result = fromObjectColumnConfig(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsColumnConfig = {_errors: Option<Array<string>>; heading: Option<Array<string>>;
            dataPath: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedColumnConfig = {heading: Option<boolean>;
            dataPath: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersColumnConfig {readonly heading: FieldController<string>;
            readonly dataPath: FieldController<DataPath>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformColumnConfig {readonly data: ColumnConfig; readonly errors: ErrorsColumnConfig; readonly tainted: TaintedColumnConfig; readonly fields: FieldControllersColumnConfig; validate(): Result<ColumnConfig, Array<{field: string; message: string}>>; reset(overrides?: Partial<ColumnConfig>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormColumnConfig(overrides?: Partial<ColumnConfig>): GigaformColumnConfig {let data = $state({...defaultValueColumnConfig(),...overrides}); let errors = $state<ErrorsColumnConfig>({ _errors: Option.none(), heading: Option.none(), dataPath: Option.none() }); let tainted = $state<TaintedColumnConfig>({ heading: Option.none(), dataPath: Option.none() }); const fields: FieldControllersColumnConfig = {heading: {
                    path: ["heading"] as const,
                    name: "heading",
                    constraints: { required: true },
                    
                    get: () => data.heading,
                    set: (value: string) => { data.heading = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.heading,
                    setError: (value: Option<Array<string>>) => { errors.heading = value; },
                    getTainted: () => tainted.heading,
                    setTainted: (value: Option<boolean>) => { tainted.heading = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldColumnConfig("heading", data.heading);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                dataPath: {
                    path: ["dataPath"] as const,
                    name: "dataPath",
                    constraints: { required: true },
                    
                    get: () => data.dataPath,
                    set: (value: DataPath) => { data.dataPath = value; },
                    transform: (value: DataPath): DataPath => value,
                    getError: () => errors.dataPath,
                    setError: (value: Option<Array<string>>) => { errors.dataPath = value; },
                    getTainted: () => tainted.dataPath,
                    setTainted: (value: Option<boolean>) => { tainted.dataPath = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldColumnConfig("dataPath", data.dataPath);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<ColumnConfig, Array<{field: string; message: string}>>{return fromObjectColumnConfig(data);}function reset(newOverrides?: Partial<ColumnConfig>): void {data = {...defaultValueColumnConfig(),...newOverrides}; errors = { _errors: Option.none(), heading: Option.none(), dataPath: Option.none() }; tainted = { heading: Option.none(), dataPath: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataColumnConfig(formData: FormData): Result<ColumnConfig, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.heading = formData.get("heading") ?? "";
            {
            // Collect nested object fields with prefix "dataPath."
            const dataPathObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("dataPath.")) {
                    const fieldName = key.slice("dataPath.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = dataPathObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.dataPath = dataPathObj;
        } return fromStringifiedJSONColumnConfig(JSON.stringify(obj));}


export interface PhoneNumber {
    
    main: boolean;
    
    
    phoneType: string;
    
    
    number: string;
    
    canText: boolean;
    
    canCall: boolean;
}

export function defaultValuePhoneNumber(): PhoneNumber {return {main: false,
                            phoneType: "",
                            number: "",
                            canText: false,
                            canCall: false, }as PhoneNumber;}

export function toStringifiedJSONPhoneNumber(value: PhoneNumber): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializePhoneNumber(value, ctx));}export function toObjectPhoneNumber(value: PhoneNumber): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializePhoneNumber(value, ctx);}export function __serializePhoneNumber(value: PhoneNumber, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "PhoneNumber" , __id,}; result["main" ]= value.main; result["phoneType" ]= value.phoneType; result["number" ]= value.number; result["canText" ]= value.canText; result["canCall" ]= value.canCall; return result;}

export function fromStringifiedJSONPhoneNumber(json: string, opts?: DeserializeOptions): Result<PhoneNumber, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectPhoneNumber(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectPhoneNumber(obj: unknown, opts?: DeserializeOptions): Result<PhoneNumber, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializePhoneNumber(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "PhoneNumber.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializePhoneNumber(value: any, ctx: DeserializeContext): PhoneNumber | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "PhoneNumber.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("main" in obj)){errors.push({field: "main" , message: "missing required field" });}if(!("phoneType" in obj)){errors.push({field: "phoneType" , message: "missing required field" });}if(!("number" in obj)){errors.push({field: "number" , message: "missing required field" });}if(!("canText" in obj)){errors.push({field: "canText" , message: "missing required field" });}if(!("canCall" in obj)){errors.push({field: "canCall" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_main = obj["main" ]as boolean; instance.main = __raw_main; }{const __raw_phoneType = obj["phoneType" ]as string; 
                if (__raw_phoneType.length === 0) {
                    errors.push({ field: "phoneType", message: "must not be empty" });
                }
 instance.phoneType = __raw_phoneType; }{const __raw_number = obj["number" ]as string; 
                if (__raw_number.length === 0) {
                    errors.push({ field: "number", message: "must not be empty" });
                }
 instance.number = __raw_number; }{const __raw_canText = obj["canText" ]as boolean; instance.canText = __raw_canText; }{const __raw_canCall = obj["canCall" ]as boolean; instance.canCall = __raw_canCall; }if(errors.length>0){throw new DeserializeError(errors);}return instance as PhoneNumber;}export function validateFieldPhoneNumber<K extends keyof PhoneNumber>(field: K, value: PhoneNumber[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "phoneType" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "phoneType", message: "must not be empty" });
                }
 break;}case "number" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "number", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsPhoneNumber(partial: Partial<PhoneNumber>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("phoneType" in partial && partial.phoneType!== undefined){const __val = partial.phoneType as string; 
                if (__val.length === 0) {
                    errors.push({ field: "phoneType", message: "must not be empty" });
                }
}if("number" in partial && partial.number!== undefined){const __val = partial.number as string; 
                if (__val.length === 0) {
                    errors.push({ field: "number", message: "must not be empty" });
                }
}return errors; }export function hasShapePhoneNumber(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "main" in o && "phoneType" in o && "number" in o && "canText" in o && "canCall" in o;}export function isPhoneNumber(obj: unknown): obj is PhoneNumber {if(!hasShapePhoneNumber(obj)){return false;}const result = fromObjectPhoneNumber(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsPhoneNumber = {_errors: Option<Array<string>>; main: Option<Array<string>>;
            phoneType: Option<Array<string>>;
            number: Option<Array<string>>;
            canText: Option<Array<string>>;
            canCall: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedPhoneNumber = {main: Option<boolean>;
            phoneType: Option<boolean>;
            number: Option<boolean>;
            canText: Option<boolean>;
            canCall: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersPhoneNumber {readonly main: FieldController<boolean>;
            readonly phoneType: FieldController<string>;
            readonly number: FieldController<string>;
            readonly canText: FieldController<boolean>;
            readonly canCall: FieldController<boolean>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformPhoneNumber {readonly data: PhoneNumber; readonly errors: ErrorsPhoneNumber; readonly tainted: TaintedPhoneNumber; readonly fields: FieldControllersPhoneNumber; validate(): Result<PhoneNumber, Array<{field: string; message: string}>>; reset(overrides?: Partial<PhoneNumber>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormPhoneNumber(overrides?: Partial<PhoneNumber>): GigaformPhoneNumber {let data = $state({...defaultValuePhoneNumber(),...overrides}); let errors = $state<ErrorsPhoneNumber>({ _errors: Option.none(), main: Option.none(), phoneType: Option.none(), number: Option.none(), canText: Option.none(), canCall: Option.none() }); let tainted = $state<TaintedPhoneNumber>({ main: Option.none(), phoneType: Option.none(), number: Option.none(), canText: Option.none(), canCall: Option.none() }); const fields: FieldControllersPhoneNumber = {main: {
                    path: ["main"] as const,
                    name: "main",
                    constraints: { required: true },
                    label: "Main",
                    get: () => data.main,
                    set: (value: boolean) => { data.main = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.main,
                    setError: (value: Option<Array<string>>) => { errors.main = value; },
                    getTainted: () => tainted.main,
                    setTainted: (value: Option<boolean>) => { tainted.main = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPhoneNumber("main", data.main);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                phoneType: {
                    path: ["phoneType"] as const,
                    name: "phoneType",
                    constraints: { required: true },
                    label: "Phone Type",
                    get: () => data.phoneType,
                    set: (value: string) => { data.phoneType = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.phoneType,
                    setError: (value: Option<Array<string>>) => { errors.phoneType = value; },
                    getTainted: () => tainted.phoneType,
                    setTainted: (value: Option<boolean>) => { tainted.phoneType = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPhoneNumber("phoneType", data.phoneType);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                number: {
                    path: ["number"] as const,
                    name: "number",
                    constraints: { required: true },
                    label: "Number",
                    get: () => data.number,
                    set: (value: string) => { data.number = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.number,
                    setError: (value: Option<Array<string>>) => { errors.number = value; },
                    getTainted: () => tainted.number,
                    setTainted: (value: Option<boolean>) => { tainted.number = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPhoneNumber("number", data.number);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                canText: {
                    path: ["canText"] as const,
                    name: "canText",
                    constraints: { required: true },
                    label: "Can Text",
                    get: () => data.canText,
                    set: (value: boolean) => { data.canText = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.canText,
                    setError: (value: Option<Array<string>>) => { errors.canText = value; },
                    getTainted: () => tainted.canText,
                    setTainted: (value: Option<boolean>) => { tainted.canText = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPhoneNumber("canText", data.canText);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                canCall: {
                    path: ["canCall"] as const,
                    name: "canCall",
                    constraints: { required: true },
                    label: "Can Call",
                    get: () => data.canCall,
                    set: (value: boolean) => { data.canCall = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.canCall,
                    setError: (value: Option<Array<string>>) => { errors.canCall = value; },
                    getTainted: () => tainted.canCall,
                    setTainted: (value: Option<boolean>) => { tainted.canCall = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPhoneNumber("canCall", data.canCall);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<PhoneNumber, Array<{field: string; message: string}>>{return fromObjectPhoneNumber(data);}function reset(newOverrides?: Partial<PhoneNumber>): void {data = {...defaultValuePhoneNumber(),...newOverrides}; errors = { _errors: Option.none(), main: Option.none(), phoneType: Option.none(), number: Option.none(), canText: Option.none(), canCall: Option.none() }; tainted = { main: Option.none(), phoneType: Option.none(), number: Option.none(), canText: Option.none(), canCall: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataPhoneNumber(formData: FormData): Result<PhoneNumber, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const mainVal = formData.get("main");
                obj.main = mainVal === "true" || mainVal === "on" || mainVal === "1";
            }
            obj.phoneType = formData.get("phoneType") ?? "";
            obj.number = formData.get("number") ?? "";
            {
                const canTextVal = formData.get("canText");
                obj.canText = canTextVal === "true" || canTextVal === "on" || canTextVal === "1";
            }
            {
                const canCallVal = formData.get("canCall");
                obj.canCall = canCallVal === "true" || canCallVal === "on" || canCallVal === "1";
            } return fromStringifiedJSONPhoneNumber(JSON.stringify(obj));}


export interface Gradient {
    startHue: number;
}

export function defaultValueGradient(): Gradient {return {startHue: 0, }as Gradient;}

export function toStringifiedJSONGradient(value: Gradient): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeGradient(value, ctx));}export function toObjectGradient(value: Gradient): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeGradient(value, ctx);}export function __serializeGradient(value: Gradient, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Gradient" , __id,}; result["startHue" ]= value.startHue; return result;}

export function fromStringifiedJSONGradient(json: string, opts?: DeserializeOptions): Result<Gradient, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectGradient(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectGradient(obj: unknown, opts?: DeserializeOptions): Result<Gradient, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeGradient(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Gradient.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeGradient(value: any, ctx: DeserializeContext): Gradient | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Gradient.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("startHue" in obj)){errors.push({field: "startHue" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_startHue = obj["startHue" ]as number; instance.startHue = __raw_startHue; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Gradient;}export function validateFieldGradient<K extends keyof Gradient>(field: K, value: Gradient[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsGradient(partial: Partial<Gradient>): Array<{field: string; message: string}>{return[]; }export function hasShapeGradient(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "startHue" in o;}export function isGradient(obj: unknown): obj is Gradient {if(!hasShapeGradient(obj)){return false;}const result = fromObjectGradient(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsGradient = {_errors: Option<Array<string>>; startHue: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedGradient = {startHue: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersGradient {readonly startHue: FieldController<number>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformGradient {readonly data: Gradient; readonly errors: ErrorsGradient; readonly tainted: TaintedGradient; readonly fields: FieldControllersGradient; validate(): Result<Gradient, Array<{field: string; message: string}>>; reset(overrides?: Partial<Gradient>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormGradient(overrides?: Partial<Gradient>): GigaformGradient {let data = $state({...defaultValueGradient(),...overrides}); let errors = $state<ErrorsGradient>({ _errors: Option.none(), startHue: Option.none() }); let tainted = $state<TaintedGradient>({ startHue: Option.none() }); const fields: FieldControllersGradient = {startHue: {
                    path: ["startHue"] as const,
                    name: "startHue",
                    constraints: { required: true },
                    
                    get: () => data.startHue,
                    set: (value: number) => { data.startHue = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.startHue,
                    setError: (value: Option<Array<string>>) => { errors.startHue = value; },
                    getTainted: () => tainted.startHue,
                    setTainted: (value: Option<boolean>) => { tainted.startHue = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldGradient("startHue", data.startHue);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Gradient, Array<{field: string; message: string}>>{return fromObjectGradient(data);}function reset(newOverrides?: Partial<Gradient>): void {data = {...defaultValueGradient(),...newOverrides}; errors = { _errors: Option.none(), startHue: Option.none() }; tainted = { startHue: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataGradient(formData: FormData): Result<Gradient, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const startHueStr = formData.get("startHue");
                obj.startHue = startHueStr ? parseFloat(startHueStr as string) : 0;
                if (obj.startHue !== undefined && isNaN(obj.startHue as number)) obj.startHue = 0;
            } return fromStringifiedJSONGradient(JSON.stringify(obj));}


export interface Product {
    
    id: string;
    
    
    name: string;
    
    
    quickCode: string;
    
    group: string | null;
    
    subgroup: string | null;
    
    unit: string | null;
    
    active: boolean;
    
    commission: boolean;
    
    favorite: boolean;
    defaults: ProductDefaults;
}

export function defaultValueProduct(): Product {return {id: "",
                            name: "",
                            quickCode: "",
                            group: null,
                            subgroup: null,
                            unit: null,
                            active: false,
                            commission: false,
                            favorite: false,
                            defaults: defaultValueProductDefaults(), }as Product;}

export function toStringifiedJSONProduct(value: Product): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeProduct(value, ctx));}export function toObjectProduct(value: Product): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeProduct(value, ctx);}export function __serializeProduct(value: Product, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Product" , __id,}; result["id" ]= value.id; result["name" ]= value.name; result["quickCode" ]= value.quickCode; result["group" ]= value.group; result["subgroup" ]= value.subgroup; result["unit" ]= value.unit; result["active" ]= value.active; result["commission" ]= value.commission; result["favorite" ]= value.favorite; result["defaults" ]= __serializeProductDefaults(value.defaults, ctx); return result;}

export function fromStringifiedJSONProduct(json: string, opts?: DeserializeOptions): Result<Product, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectProduct(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectProduct(obj: unknown, opts?: DeserializeOptions): Result<Product, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeProduct(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Product.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeProduct(value: any, ctx: DeserializeContext): Product | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Product.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("quickCode" in obj)){errors.push({field: "quickCode" , message: "missing required field" });}if(!("group" in obj)){errors.push({field: "group" , message: "missing required field" });}if(!("subgroup" in obj)){errors.push({field: "subgroup" , message: "missing required field" });}if(!("unit" in obj)){errors.push({field: "unit" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(!("commission" in obj)){errors.push({field: "commission" , message: "missing required field" });}if(!("favorite" in obj)){errors.push({field: "favorite" , message: "missing required field" });}if(!("defaults" in obj)){errors.push({field: "defaults" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_quickCode = obj["quickCode" ]as string; 
                if (__raw_quickCode.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
 instance.quickCode = __raw_quickCode; }{const __raw_group = obj["group" ]as string | null; instance.group = __raw_group; }{const __raw_subgroup = obj["subgroup" ]as string | null; instance.subgroup = __raw_subgroup; }{const __raw_unit = obj["unit" ]as string | null; instance.unit = __raw_unit; }{const __raw_active = obj["active" ]as boolean; instance.active = __raw_active; }{const __raw_commission = obj["commission" ]as boolean; instance.commission = __raw_commission; }{const __raw_favorite = obj["favorite" ]as boolean; instance.favorite = __raw_favorite; }{const __raw_defaults = obj["defaults" ]as ProductDefaults; {const __result = __deserializeProductDefaults(__raw_defaults, ctx); ctx.assignOrDefer(instance, "defaults" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Product;}export function validateFieldProduct<K extends keyof Product>(field: K, value: Product[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "quickCode" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsProduct(partial: Partial<Product>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("quickCode" in partial && partial.quickCode!== undefined){const __val = partial.quickCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
}return errors; }export function hasShapeProduct(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "name" in o && "quickCode" in o && "group" in o && "subgroup" in o && "unit" in o && "active" in o && "commission" in o && "favorite" in o && "defaults" in o;}export function isProduct(obj: unknown): obj is Product {if(!hasShapeProduct(obj)){return false;}const result = fromObjectProduct(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsProduct = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            name: Option<Array<string>>;
            quickCode: Option<Array<string>>;
            group: Option<Array<string>>;
            subgroup: Option<Array<string>>;
            unit: Option<Array<string>>;
            active: Option<Array<string>>;
            commission: Option<Array<string>>;
            favorite: Option<Array<string>>;
            defaults: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedProduct = {id: Option<boolean>;
            name: Option<boolean>;
            quickCode: Option<boolean>;
            group: Option<boolean>;
            subgroup: Option<boolean>;
            unit: Option<boolean>;
            active: Option<boolean>;
            commission: Option<boolean>;
            favorite: Option<boolean>;
            defaults: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersProduct {readonly id: FieldController<string>;
            readonly name: FieldController<string>;
            readonly quickCode: FieldController<string>;
            readonly group: FieldController<string | null>;
            readonly subgroup: FieldController<string | null>;
            readonly unit: FieldController<string | null>;
            readonly active: FieldController<boolean>;
            readonly commission: FieldController<boolean>;
            readonly favorite: FieldController<boolean>;
            readonly defaults: FieldController<ProductDefaults>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformProduct {readonly data: Product; readonly errors: ErrorsProduct; readonly tainted: TaintedProduct; readonly fields: FieldControllersProduct; validate(): Result<Product, Array<{field: string; message: string}>>; reset(overrides?: Partial<Product>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormProduct(overrides?: Partial<Product>): GigaformProduct {let data = $state({...defaultValueProduct(),...overrides}); let errors = $state<ErrorsProduct>({ _errors: Option.none(), id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), defaults: Option.none() }); let tainted = $state<TaintedProduct>({ id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), defaults: Option.none() }); const fields: FieldControllersProduct = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldProduct("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                name: {
                    path: ["name"] as const,
                    name: "name",
                    constraints: { required: true },
                    label: "Name",
                    get: () => data.name,
                    set: (value: string) => { data.name = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.name,
                    setError: (value: Option<Array<string>>) => { errors.name = value; },
                    getTainted: () => tainted.name,
                    setTainted: (value: Option<boolean>) => { tainted.name = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldProduct("name", data.name);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                quickCode: {
                    path: ["quickCode"] as const,
                    name: "quickCode",
                    constraints: { required: true },
                    label: "Quick Code",
                    get: () => data.quickCode,
                    set: (value: string) => { data.quickCode = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.quickCode,
                    setError: (value: Option<Array<string>>) => { errors.quickCode = value; },
                    getTainted: () => tainted.quickCode,
                    setTainted: (value: Option<boolean>) => { tainted.quickCode = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldProduct("quickCode", data.quickCode);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                group: {
                    path: ["group"] as const,
                    name: "group",
                    constraints: { required: true },
                    label: "Group",
                    get: () => data.group,
                    set: (value: string | null) => { data.group = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.group,
                    setError: (value: Option<Array<string>>) => { errors.group = value; },
                    getTainted: () => tainted.group,
                    setTainted: (value: Option<boolean>) => { tainted.group = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldProduct("group", data.group);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                subgroup: {
                    path: ["subgroup"] as const,
                    name: "subgroup",
                    constraints: { required: true },
                    label: "Subgroup",
                    get: () => data.subgroup,
                    set: (value: string | null) => { data.subgroup = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.subgroup,
                    setError: (value: Option<Array<string>>) => { errors.subgroup = value; },
                    getTainted: () => tainted.subgroup,
                    setTainted: (value: Option<boolean>) => { tainted.subgroup = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldProduct("subgroup", data.subgroup);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                unit: {
                    path: ["unit"] as const,
                    name: "unit",
                    constraints: { required: true },
                    label: "Unit",
                    get: () => data.unit,
                    set: (value: string | null) => { data.unit = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.unit,
                    setError: (value: Option<Array<string>>) => { errors.unit = value; },
                    getTainted: () => tainted.unit,
                    setTainted: (value: Option<boolean>) => { tainted.unit = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldProduct("unit", data.unit);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                active: {
                    path: ["active"] as const,
                    name: "active",
                    constraints: { required: true },
                    label: "Active",
                    get: () => data.active,
                    set: (value: boolean) => { data.active = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.active,
                    setError: (value: Option<Array<string>>) => { errors.active = value; },
                    getTainted: () => tainted.active,
                    setTainted: (value: Option<boolean>) => { tainted.active = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldProduct("active", data.active);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                commission: {
                    path: ["commission"] as const,
                    name: "commission",
                    constraints: { required: true },
                    label: "Commission",
                    get: () => data.commission,
                    set: (value: boolean) => { data.commission = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.commission,
                    setError: (value: Option<Array<string>>) => { errors.commission = value; },
                    getTainted: () => tainted.commission,
                    setTainted: (value: Option<boolean>) => { tainted.commission = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldProduct("commission", data.commission);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                favorite: {
                    path: ["favorite"] as const,
                    name: "favorite",
                    constraints: { required: true },
                    label: "Favorite",
                    get: () => data.favorite,
                    set: (value: boolean) => { data.favorite = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.favorite,
                    setError: (value: Option<Array<string>>) => { errors.favorite = value; },
                    getTainted: () => tainted.favorite,
                    setTainted: (value: Option<boolean>) => { tainted.favorite = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldProduct("favorite", data.favorite);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                defaults: {
                    path: ["defaults"] as const,
                    name: "defaults",
                    constraints: { required: true },
                    
                    get: () => data.defaults,
                    set: (value: ProductDefaults) => { data.defaults = value; },
                    transform: (value: ProductDefaults): ProductDefaults => value,
                    getError: () => errors.defaults,
                    setError: (value: Option<Array<string>>) => { errors.defaults = value; },
                    getTainted: () => tainted.defaults,
                    setTainted: (value: Option<boolean>) => { tainted.defaults = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldProduct("defaults", data.defaults);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Product, Array<{field: string; message: string}>>{return fromObjectProduct(data);}function reset(newOverrides?: Partial<Product>): void {data = {...defaultValueProduct(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), defaults: Option.none() }; tainted = { id: Option.none(), name: Option.none(), quickCode: Option.none(), group: Option.none(), subgroup: Option.none(), unit: Option.none(), active: Option.none(), commission: Option.none(), favorite: Option.none(), defaults: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataProduct(formData: FormData): Result<Product, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.name = formData.get("name") ?? "";
            obj.quickCode = formData.get("quickCode") ?? "";
            obj.group = formData.get("group") ?? "";
            obj.subgroup = formData.get("subgroup") ?? "";
            obj.unit = formData.get("unit") ?? "";
            {
                const activeVal = formData.get("active");
                obj.active = activeVal === "true" || activeVal === "on" || activeVal === "1";
            }
            {
                const commissionVal = formData.get("commission");
                obj.commission = commissionVal === "true" || commissionVal === "on" || commissionVal === "1";
            }
            {
                const favoriteVal = formData.get("favorite");
                obj.favorite = favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1";
            }
            {
            // Collect nested object fields with prefix "defaults."
            const defaultsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("defaults.")) {
                    const fieldName = key.slice("defaults.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = defaultsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.defaults = defaultsObj;
        } return fromStringifiedJSONProduct(JSON.stringify(obj));}


export interface YearlyRecurrenceRule {
    quantityOfYears: number;
}

export function defaultValueYearlyRecurrenceRule(): YearlyRecurrenceRule {return {quantityOfYears: 0, }as YearlyRecurrenceRule;}

export function toStringifiedJSONYearlyRecurrenceRule(value: YearlyRecurrenceRule): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeYearlyRecurrenceRule(value, ctx));}export function toObjectYearlyRecurrenceRule(value: YearlyRecurrenceRule): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeYearlyRecurrenceRule(value, ctx);}export function __serializeYearlyRecurrenceRule(value: YearlyRecurrenceRule, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "YearlyRecurrenceRule" , __id,}; result["quantityOfYears" ]= value.quantityOfYears; return result;}

export function fromStringifiedJSONYearlyRecurrenceRule(json: string, opts?: DeserializeOptions): Result<YearlyRecurrenceRule, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectYearlyRecurrenceRule(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectYearlyRecurrenceRule(obj: unknown, opts?: DeserializeOptions): Result<YearlyRecurrenceRule, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeYearlyRecurrenceRule(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "YearlyRecurrenceRule.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeYearlyRecurrenceRule(value: any, ctx: DeserializeContext): YearlyRecurrenceRule | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "YearlyRecurrenceRule.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("quantityOfYears" in obj)){errors.push({field: "quantityOfYears" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_quantityOfYears = obj["quantityOfYears" ]as number; instance.quantityOfYears = __raw_quantityOfYears; }if(errors.length>0){throw new DeserializeError(errors);}return instance as YearlyRecurrenceRule;}export function validateFieldYearlyRecurrenceRule<K extends keyof YearlyRecurrenceRule>(field: K, value: YearlyRecurrenceRule[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsYearlyRecurrenceRule(partial: Partial<YearlyRecurrenceRule>): Array<{field: string; message: string}>{return[]; }export function hasShapeYearlyRecurrenceRule(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "quantityOfYears" in o;}export function isYearlyRecurrenceRule(obj: unknown): obj is YearlyRecurrenceRule {if(!hasShapeYearlyRecurrenceRule(obj)){return false;}const result = fromObjectYearlyRecurrenceRule(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsYearlyRecurrenceRule = {_errors: Option<Array<string>>; quantityOfYears: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedYearlyRecurrenceRule = {quantityOfYears: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersYearlyRecurrenceRule {readonly quantityOfYears: FieldController<number>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformYearlyRecurrenceRule {readonly data: YearlyRecurrenceRule; readonly errors: ErrorsYearlyRecurrenceRule; readonly tainted: TaintedYearlyRecurrenceRule; readonly fields: FieldControllersYearlyRecurrenceRule; validate(): Result<YearlyRecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<YearlyRecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormYearlyRecurrenceRule(overrides?: Partial<YearlyRecurrenceRule>): GigaformYearlyRecurrenceRule {let data = $state({...defaultValueYearlyRecurrenceRule(),...overrides}); let errors = $state<ErrorsYearlyRecurrenceRule>({ _errors: Option.none(), quantityOfYears: Option.none() }); let tainted = $state<TaintedYearlyRecurrenceRule>({ quantityOfYears: Option.none() }); const fields: FieldControllersYearlyRecurrenceRule = {quantityOfYears: {
                    path: ["quantityOfYears"] as const,
                    name: "quantityOfYears",
                    constraints: { required: true },
                    
                    get: () => data.quantityOfYears,
                    set: (value: number) => { data.quantityOfYears = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.quantityOfYears,
                    setError: (value: Option<Array<string>>) => { errors.quantityOfYears = value; },
                    getTainted: () => tainted.quantityOfYears,
                    setTainted: (value: Option<boolean>) => { tainted.quantityOfYears = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldYearlyRecurrenceRule("quantityOfYears", data.quantityOfYears);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<YearlyRecurrenceRule, Array<{field: string; message: string}>>{return fromObjectYearlyRecurrenceRule(data);}function reset(newOverrides?: Partial<YearlyRecurrenceRule>): void {data = {...defaultValueYearlyRecurrenceRule(),...newOverrides}; errors = { _errors: Option.none(), quantityOfYears: Option.none() }; tainted = { quantityOfYears: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataYearlyRecurrenceRule(formData: FormData): Result<YearlyRecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const quantityOfYearsStr = formData.get("quantityOfYears");
                obj.quantityOfYears = quantityOfYearsStr ? parseFloat(quantityOfYearsStr as string) : 0;
                if (obj.quantityOfYears !== undefined && isNaN(obj.quantityOfYears as number)) obj.quantityOfYears = 0;
            } return fromStringifiedJSONYearlyRecurrenceRule(JSON.stringify(obj));}


export interface AppointmentNotifications {
    
    personalScheduleChangeNotifications: string;
    
    allScheduleChangeNotifications: string;
}

export function defaultValueAppointmentNotifications(): AppointmentNotifications {return {personalScheduleChangeNotifications: "",
                            allScheduleChangeNotifications: "", }as AppointmentNotifications;}

export function toStringifiedJSONAppointmentNotifications(value: AppointmentNotifications): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeAppointmentNotifications(value, ctx));}export function toObjectAppointmentNotifications(value: AppointmentNotifications): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeAppointmentNotifications(value, ctx);}export function __serializeAppointmentNotifications(value: AppointmentNotifications, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "AppointmentNotifications" , __id,}; result["personalScheduleChangeNotifications" ]= value.personalScheduleChangeNotifications; result["allScheduleChangeNotifications" ]= value.allScheduleChangeNotifications; return result;}

export function fromStringifiedJSONAppointmentNotifications(json: string, opts?: DeserializeOptions): Result<AppointmentNotifications, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectAppointmentNotifications(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectAppointmentNotifications(obj: unknown, opts?: DeserializeOptions): Result<AppointmentNotifications, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeAppointmentNotifications(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "AppointmentNotifications.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeAppointmentNotifications(value: any, ctx: DeserializeContext): AppointmentNotifications | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "AppointmentNotifications.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("personalScheduleChangeNotifications" in obj)){errors.push({field: "personalScheduleChangeNotifications" , message: "missing required field" });}if(!("allScheduleChangeNotifications" in obj)){errors.push({field: "allScheduleChangeNotifications" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_personalScheduleChangeNotifications = obj["personalScheduleChangeNotifications" ]as string; 
                if (__raw_personalScheduleChangeNotifications.length === 0) {
                    errors.push({ field: "personalScheduleChangeNotifications", message: "must not be empty" });
                }
 instance.personalScheduleChangeNotifications = __raw_personalScheduleChangeNotifications; }{const __raw_allScheduleChangeNotifications = obj["allScheduleChangeNotifications" ]as string; 
                if (__raw_allScheduleChangeNotifications.length === 0) {
                    errors.push({ field: "allScheduleChangeNotifications", message: "must not be empty" });
                }
 instance.allScheduleChangeNotifications = __raw_allScheduleChangeNotifications; }if(errors.length>0){throw new DeserializeError(errors);}return instance as AppointmentNotifications;}export function validateFieldAppointmentNotifications<K extends keyof AppointmentNotifications>(field: K, value: AppointmentNotifications[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "personalScheduleChangeNotifications" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "personalScheduleChangeNotifications", message: "must not be empty" });
                }
 break;}case "allScheduleChangeNotifications" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "allScheduleChangeNotifications", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsAppointmentNotifications(partial: Partial<AppointmentNotifications>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("personalScheduleChangeNotifications" in partial && partial.personalScheduleChangeNotifications!== undefined){const __val = partial.personalScheduleChangeNotifications as string; 
                if (__val.length === 0) {
                    errors.push({ field: "personalScheduleChangeNotifications", message: "must not be empty" });
                }
}if("allScheduleChangeNotifications" in partial && partial.allScheduleChangeNotifications!== undefined){const __val = partial.allScheduleChangeNotifications as string; 
                if (__val.length === 0) {
                    errors.push({ field: "allScheduleChangeNotifications", message: "must not be empty" });
                }
}return errors; }export function hasShapeAppointmentNotifications(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "personalScheduleChangeNotifications" in o && "allScheduleChangeNotifications" in o;}export function isAppointmentNotifications(obj: unknown): obj is AppointmentNotifications {if(!hasShapeAppointmentNotifications(obj)){return false;}const result = fromObjectAppointmentNotifications(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsAppointmentNotifications = {_errors: Option<Array<string>>; personalScheduleChangeNotifications: Option<Array<string>>;
            allScheduleChangeNotifications: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedAppointmentNotifications = {personalScheduleChangeNotifications: Option<boolean>;
            allScheduleChangeNotifications: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersAppointmentNotifications {readonly personalScheduleChangeNotifications: FieldController<string>;
            readonly allScheduleChangeNotifications: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformAppointmentNotifications {readonly data: AppointmentNotifications; readonly errors: ErrorsAppointmentNotifications; readonly tainted: TaintedAppointmentNotifications; readonly fields: FieldControllersAppointmentNotifications; validate(): Result<AppointmentNotifications, Array<{field: string; message: string}>>; reset(overrides?: Partial<AppointmentNotifications>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormAppointmentNotifications(overrides?: Partial<AppointmentNotifications>): GigaformAppointmentNotifications {let data = $state({...defaultValueAppointmentNotifications(),...overrides}); let errors = $state<ErrorsAppointmentNotifications>({ _errors: Option.none(), personalScheduleChangeNotifications: Option.none(), allScheduleChangeNotifications: Option.none() }); let tainted = $state<TaintedAppointmentNotifications>({ personalScheduleChangeNotifications: Option.none(), allScheduleChangeNotifications: Option.none() }); const fields: FieldControllersAppointmentNotifications = {personalScheduleChangeNotifications: {
                    path: ["personalScheduleChangeNotifications"] as const,
                    name: "personalScheduleChangeNotifications",
                    constraints: { required: true },
                    
                    get: () => data.personalScheduleChangeNotifications,
                    set: (value: string) => { data.personalScheduleChangeNotifications = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.personalScheduleChangeNotifications,
                    setError: (value: Option<Array<string>>) => { errors.personalScheduleChangeNotifications = value; },
                    getTainted: () => tainted.personalScheduleChangeNotifications,
                    setTainted: (value: Option<boolean>) => { tainted.personalScheduleChangeNotifications = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointmentNotifications("personalScheduleChangeNotifications", data.personalScheduleChangeNotifications);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                allScheduleChangeNotifications: {
                    path: ["allScheduleChangeNotifications"] as const,
                    name: "allScheduleChangeNotifications",
                    constraints: { required: true },
                    
                    get: () => data.allScheduleChangeNotifications,
                    set: (value: string) => { data.allScheduleChangeNotifications = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.allScheduleChangeNotifications,
                    setError: (value: Option<Array<string>>) => { errors.allScheduleChangeNotifications = value; },
                    getTainted: () => tainted.allScheduleChangeNotifications,
                    setTainted: (value: Option<boolean>) => { tainted.allScheduleChangeNotifications = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointmentNotifications("allScheduleChangeNotifications", data.allScheduleChangeNotifications);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<AppointmentNotifications, Array<{field: string; message: string}>>{return fromObjectAppointmentNotifications(data);}function reset(newOverrides?: Partial<AppointmentNotifications>): void {data = {...defaultValueAppointmentNotifications(),...newOverrides}; errors = { _errors: Option.none(), personalScheduleChangeNotifications: Option.none(), allScheduleChangeNotifications: Option.none() }; tainted = { personalScheduleChangeNotifications: Option.none(), allScheduleChangeNotifications: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataAppointmentNotifications(formData: FormData): Result<AppointmentNotifications, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.personalScheduleChangeNotifications = formData.get("personalScheduleChangeNotifications") ?? "";
            obj.allScheduleChangeNotifications = formData.get("allScheduleChangeNotifications") ?? ""; return fromStringifiedJSONAppointmentNotifications(JSON.stringify(obj));}


export interface DirectionHue {
    bearing: number;
    hue: number;
}

export function defaultValueDirectionHue(): DirectionHue {return {bearing: 0,
                            hue: 0, }as DirectionHue;}

export function toStringifiedJSONDirectionHue(value: DirectionHue): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeDirectionHue(value, ctx));}export function toObjectDirectionHue(value: DirectionHue): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeDirectionHue(value, ctx);}export function __serializeDirectionHue(value: DirectionHue, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "DirectionHue" , __id,}; result["bearing" ]= value.bearing; result["hue" ]= value.hue; return result;}

export function fromStringifiedJSONDirectionHue(json: string, opts?: DeserializeOptions): Result<DirectionHue, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectDirectionHue(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectDirectionHue(obj: unknown, opts?: DeserializeOptions): Result<DirectionHue, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeDirectionHue(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "DirectionHue.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeDirectionHue(value: any, ctx: DeserializeContext): DirectionHue | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "DirectionHue.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("bearing" in obj)){errors.push({field: "bearing" , message: "missing required field" });}if(!("hue" in obj)){errors.push({field: "hue" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_bearing = obj["bearing" ]as number; instance.bearing = __raw_bearing; }{const __raw_hue = obj["hue" ]as number; instance.hue = __raw_hue; }if(errors.length>0){throw new DeserializeError(errors);}return instance as DirectionHue;}export function validateFieldDirectionHue<K extends keyof DirectionHue>(field: K, value: DirectionHue[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsDirectionHue(partial: Partial<DirectionHue>): Array<{field: string; message: string}>{return[]; }export function hasShapeDirectionHue(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "bearing" in o && "hue" in o;}export function isDirectionHue(obj: unknown): obj is DirectionHue {if(!hasShapeDirectionHue(obj)){return false;}const result = fromObjectDirectionHue(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsDirectionHue = {_errors: Option<Array<string>>; bearing: Option<Array<string>>;
            hue: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedDirectionHue = {bearing: Option<boolean>;
            hue: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersDirectionHue {readonly bearing: FieldController<number>;
            readonly hue: FieldController<number>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformDirectionHue {readonly data: DirectionHue; readonly errors: ErrorsDirectionHue; readonly tainted: TaintedDirectionHue; readonly fields: FieldControllersDirectionHue; validate(): Result<DirectionHue, Array<{field: string; message: string}>>; reset(overrides?: Partial<DirectionHue>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormDirectionHue(overrides?: Partial<DirectionHue>): GigaformDirectionHue {let data = $state({...defaultValueDirectionHue(),...overrides}); let errors = $state<ErrorsDirectionHue>({ _errors: Option.none(), bearing: Option.none(), hue: Option.none() }); let tainted = $state<TaintedDirectionHue>({ bearing: Option.none(), hue: Option.none() }); const fields: FieldControllersDirectionHue = {bearing: {
                    path: ["bearing"] as const,
                    name: "bearing",
                    constraints: { required: true },
                    
                    get: () => data.bearing,
                    set: (value: number) => { data.bearing = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.bearing,
                    setError: (value: Option<Array<string>>) => { errors.bearing = value; },
                    getTainted: () => tainted.bearing,
                    setTainted: (value: Option<boolean>) => { tainted.bearing = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldDirectionHue("bearing", data.bearing);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                hue: {
                    path: ["hue"] as const,
                    name: "hue",
                    constraints: { required: true },
                    
                    get: () => data.hue,
                    set: (value: number) => { data.hue = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.hue,
                    setError: (value: Option<Array<string>>) => { errors.hue = value; },
                    getTainted: () => tainted.hue,
                    setTainted: (value: Option<boolean>) => { tainted.hue = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldDirectionHue("hue", data.hue);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<DirectionHue, Array<{field: string; message: string}>>{return fromObjectDirectionHue(data);}function reset(newOverrides?: Partial<DirectionHue>): void {data = {...defaultValueDirectionHue(),...newOverrides}; errors = { _errors: Option.none(), bearing: Option.none(), hue: Option.none() }; tainted = { bearing: Option.none(), hue: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataDirectionHue(formData: FormData): Result<DirectionHue, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const bearingStr = formData.get("bearing");
                obj.bearing = bearingStr ? parseFloat(bearingStr as string) : 0;
                if (obj.bearing !== undefined && isNaN(obj.bearing as number)) obj.bearing = 0;
            }
            {
                const hueStr = formData.get("hue");
                obj.hue = hueStr ? parseFloat(hueStr as string) : 0;
                if (obj.hue !== undefined && isNaN(obj.hue as number)) obj.hue = 0;
            } return fromStringifiedJSONDirectionHue(JSON.stringify(obj));}


export interface MonthlyRecurrenceRule {
    quantityOfMonths: number;
    day: number;
    
    name: string;
}

export function defaultValueMonthlyRecurrenceRule(): MonthlyRecurrenceRule {return {quantityOfMonths: 0,
                            day: 0,
                            name: "", }as MonthlyRecurrenceRule;}

export function toStringifiedJSONMonthlyRecurrenceRule(value: MonthlyRecurrenceRule): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeMonthlyRecurrenceRule(value, ctx));}export function toObjectMonthlyRecurrenceRule(value: MonthlyRecurrenceRule): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeMonthlyRecurrenceRule(value, ctx);}export function __serializeMonthlyRecurrenceRule(value: MonthlyRecurrenceRule, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "MonthlyRecurrenceRule" , __id,}; result["quantityOfMonths" ]= value.quantityOfMonths; result["day" ]= value.day; result["name" ]= value.name; return result;}

export function fromStringifiedJSONMonthlyRecurrenceRule(json: string, opts?: DeserializeOptions): Result<MonthlyRecurrenceRule, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectMonthlyRecurrenceRule(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectMonthlyRecurrenceRule(obj: unknown, opts?: DeserializeOptions): Result<MonthlyRecurrenceRule, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeMonthlyRecurrenceRule(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "MonthlyRecurrenceRule.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeMonthlyRecurrenceRule(value: any, ctx: DeserializeContext): MonthlyRecurrenceRule | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "MonthlyRecurrenceRule.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("quantityOfMonths" in obj)){errors.push({field: "quantityOfMonths" , message: "missing required field" });}if(!("day" in obj)){errors.push({field: "day" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_quantityOfMonths = obj["quantityOfMonths" ]as number; instance.quantityOfMonths = __raw_quantityOfMonths; }{const __raw_day = obj["day" ]as number; instance.day = __raw_day; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }if(errors.length>0){throw new DeserializeError(errors);}return instance as MonthlyRecurrenceRule;}export function validateFieldMonthlyRecurrenceRule<K extends keyof MonthlyRecurrenceRule>(field: K, value: MonthlyRecurrenceRule[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsMonthlyRecurrenceRule(partial: Partial<MonthlyRecurrenceRule>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}return errors; }export function hasShapeMonthlyRecurrenceRule(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "quantityOfMonths" in o && "day" in o && "name" in o;}export function isMonthlyRecurrenceRule(obj: unknown): obj is MonthlyRecurrenceRule {if(!hasShapeMonthlyRecurrenceRule(obj)){return false;}const result = fromObjectMonthlyRecurrenceRule(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsMonthlyRecurrenceRule = {_errors: Option<Array<string>>; quantityOfMonths: Option<Array<string>>;
            day: Option<Array<string>>;
            name: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedMonthlyRecurrenceRule = {quantityOfMonths: Option<boolean>;
            day: Option<boolean>;
            name: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersMonthlyRecurrenceRule {readonly quantityOfMonths: FieldController<number>;
            readonly day: FieldController<number>;
            readonly name: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformMonthlyRecurrenceRule {readonly data: MonthlyRecurrenceRule; readonly errors: ErrorsMonthlyRecurrenceRule; readonly tainted: TaintedMonthlyRecurrenceRule; readonly fields: FieldControllersMonthlyRecurrenceRule; validate(): Result<MonthlyRecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<MonthlyRecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormMonthlyRecurrenceRule(overrides?: Partial<MonthlyRecurrenceRule>): GigaformMonthlyRecurrenceRule {let data = $state({...defaultValueMonthlyRecurrenceRule(),...overrides}); let errors = $state<ErrorsMonthlyRecurrenceRule>({ _errors: Option.none(), quantityOfMonths: Option.none(), day: Option.none(), name: Option.none() }); let tainted = $state<TaintedMonthlyRecurrenceRule>({ quantityOfMonths: Option.none(), day: Option.none(), name: Option.none() }); const fields: FieldControllersMonthlyRecurrenceRule = {quantityOfMonths: {
                    path: ["quantityOfMonths"] as const,
                    name: "quantityOfMonths",
                    constraints: { required: true },
                    
                    get: () => data.quantityOfMonths,
                    set: (value: number) => { data.quantityOfMonths = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.quantityOfMonths,
                    setError: (value: Option<Array<string>>) => { errors.quantityOfMonths = value; },
                    getTainted: () => tainted.quantityOfMonths,
                    setTainted: (value: Option<boolean>) => { tainted.quantityOfMonths = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldMonthlyRecurrenceRule("quantityOfMonths", data.quantityOfMonths);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                day: {
                    path: ["day"] as const,
                    name: "day",
                    constraints: { required: true },
                    
                    get: () => data.day,
                    set: (value: number) => { data.day = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.day,
                    setError: (value: Option<Array<string>>) => { errors.day = value; },
                    getTainted: () => tainted.day,
                    setTainted: (value: Option<boolean>) => { tainted.day = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldMonthlyRecurrenceRule("day", data.day);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                name: {
                    path: ["name"] as const,
                    name: "name",
                    constraints: { required: true },
                    
                    get: () => data.name,
                    set: (value: string) => { data.name = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.name,
                    setError: (value: Option<Array<string>>) => { errors.name = value; },
                    getTainted: () => tainted.name,
                    setTainted: (value: Option<boolean>) => { tainted.name = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldMonthlyRecurrenceRule("name", data.name);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<MonthlyRecurrenceRule, Array<{field: string; message: string}>>{return fromObjectMonthlyRecurrenceRule(data);}function reset(newOverrides?: Partial<MonthlyRecurrenceRule>): void {data = {...defaultValueMonthlyRecurrenceRule(),...newOverrides}; errors = { _errors: Option.none(), quantityOfMonths: Option.none(), day: Option.none(), name: Option.none() }; tainted = { quantityOfMonths: Option.none(), day: Option.none(), name: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataMonthlyRecurrenceRule(formData: FormData): Result<MonthlyRecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const quantityOfMonthsStr = formData.get("quantityOfMonths");
                obj.quantityOfMonths = quantityOfMonthsStr ? parseFloat(quantityOfMonthsStr as string) : 0;
                if (obj.quantityOfMonths !== undefined && isNaN(obj.quantityOfMonths as number)) obj.quantityOfMonths = 0;
            }
            {
                const dayStr = formData.get("day");
                obj.day = dayStr ? parseFloat(dayStr as string) : 0;
                if (obj.day !== undefined && isNaN(obj.day as number)) obj.day = 0;
            }
            obj.name = formData.get("name") ?? ""; return fromStringifiedJSONMonthlyRecurrenceRule(JSON.stringify(obj));}


export interface Represents {
    
    in: string | Employee;
    
    out: string | Account;
    id: string;
    dateStarted: string;
}

export function defaultValueRepresents(): Represents {return {in: "",
                            out: "",
                            id: "",
                            dateStarted: "", }as Represents;}

export function toStringifiedJSONRepresents(value: Represents): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeRepresents(value, ctx));}export function toObjectRepresents(value: Represents): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeRepresents(value, ctx);}export function __serializeRepresents(value: Represents, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Represents" , __id,}; result["in" ]= value.in; result["out" ]= value.out; result["id" ]= value.id; result["dateStarted" ]= value.dateStarted; return result;}

export function fromStringifiedJSONRepresents(json: string, opts?: DeserializeOptions): Result<Represents, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectRepresents(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectRepresents(obj: unknown, opts?: DeserializeOptions): Result<Represents, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeRepresents(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Represents.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeRepresents(value: any, ctx: DeserializeContext): Represents | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Represents.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("in" in obj)){errors.push({field: "in" , message: "missing required field" });}if(!("out" in obj)){errors.push({field: "out" , message: "missing required field" });}if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("dateStarted" in obj)){errors.push({field: "dateStarted" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_in = obj["in" ]as string | Employee; instance.in = __raw_in; }{const __raw_out = obj["out" ]as string | Account; instance.out = __raw_out; }{const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_dateStarted = obj["dateStarted" ]as string; instance.dateStarted = __raw_dateStarted; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Represents;}export function validateFieldRepresents<K extends keyof Represents>(field: K, value: Represents[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsRepresents(partial: Partial<Represents>): Array<{field: string; message: string}>{return[]; }export function hasShapeRepresents(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "in" in o && "out" in o && "id" in o && "dateStarted" in o;}export function isRepresents(obj: unknown): obj is Represents {if(!hasShapeRepresents(obj)){return false;}const result = fromObjectRepresents(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsRepresents = {_errors: Option<Array<string>>; in: Option<Array<string>>;
            out: Option<Array<string>>;
            id: Option<Array<string>>;
            dateStarted: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedRepresents = {in: Option<boolean>;
            out: Option<boolean>;
            id: Option<boolean>;
            dateStarted: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersRepresents {readonly in: FieldController<string | Employee>;
            readonly out: FieldController<string | Account>;
            readonly id: FieldController<string>;
            readonly dateStarted: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformRepresents {readonly data: Represents; readonly errors: ErrorsRepresents; readonly tainted: TaintedRepresents; readonly fields: FieldControllersRepresents; validate(): Result<Represents, Array<{field: string; message: string}>>; reset(overrides?: Partial<Represents>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormRepresents(overrides?: Partial<Represents>): GigaformRepresents {let data = $state({...defaultValueRepresents(),...overrides}); let errors = $state<ErrorsRepresents>({ _errors: Option.none(), in: Option.none(), out: Option.none(), id: Option.none(), dateStarted: Option.none() }); let tainted = $state<TaintedRepresents>({ in: Option.none(), out: Option.none(), id: Option.none(), dateStarted: Option.none() }); const fields: FieldControllersRepresents = {in: {
                    path: ["in"] as const,
                    name: "in",
                    constraints: { required: true },
                    
                    get: () => data.in,
                    set: (value: string | Employee) => { data.in = value; },
                    transform: (value: string | Employee): string | Employee => value,
                    getError: () => errors.in,
                    setError: (value: Option<Array<string>>) => { errors.in = value; },
                    getTainted: () => tainted.in,
                    setTainted: (value: Option<boolean>) => { tainted.in = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRepresents("in", data.in);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                out: {
                    path: ["out"] as const,
                    name: "out",
                    constraints: { required: true },
                    
                    get: () => data.out,
                    set: (value: string | Account) => { data.out = value; },
                    transform: (value: string | Account): string | Account => value,
                    getError: () => errors.out,
                    setError: (value: Option<Array<string>>) => { errors.out = value; },
                    getTainted: () => tainted.out,
                    setTainted: (value: Option<boolean>) => { tainted.out = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRepresents("out", data.out);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRepresents("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                dateStarted: {
                    path: ["dateStarted"] as const,
                    name: "dateStarted",
                    constraints: { required: true },
                    
                    get: () => data.dateStarted,
                    set: (value: string) => { data.dateStarted = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.dateStarted,
                    setError: (value: Option<Array<string>>) => { errors.dateStarted = value; },
                    getTainted: () => tainted.dateStarted,
                    setTainted: (value: Option<boolean>) => { tainted.dateStarted = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRepresents("dateStarted", data.dateStarted);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Represents, Array<{field: string; message: string}>>{return fromObjectRepresents(data);}function reset(newOverrides?: Partial<Represents>): void {data = {...defaultValueRepresents(),...newOverrides}; errors = { _errors: Option.none(), in: Option.none(), out: Option.none(), id: Option.none(), dateStarted: Option.none() }; tainted = { in: Option.none(), out: Option.none(), id: Option.none(), dateStarted: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataRepresents(formData: FormData): Result<Represents, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.in = formData.get("in") ?? "";
            obj.out = formData.get("out") ?? "";
            obj.id = formData.get("id") ?? "";
            obj.dateStarted = formData.get("dateStarted") ?? ""; return fromStringifiedJSONRepresents(JSON.stringify(obj));}


export interface Payment {
    id: string;
    date: string;
}

export function defaultValuePayment(): Payment {return {id: "",
                            date: "", }as Payment;}

export function toStringifiedJSONPayment(value: Payment): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializePayment(value, ctx));}export function toObjectPayment(value: Payment): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializePayment(value, ctx);}export function __serializePayment(value: Payment, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Payment" , __id,}; result["id" ]= value.id; result["date" ]= value.date; return result;}

export function fromStringifiedJSONPayment(json: string, opts?: DeserializeOptions): Result<Payment, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectPayment(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectPayment(obj: unknown, opts?: DeserializeOptions): Result<Payment, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializePayment(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Payment.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializePayment(value: any, ctx: DeserializeContext): Payment | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Payment.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("date" in obj)){errors.push({field: "date" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_date = obj["date" ]as string; instance.date = __raw_date; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Payment;}export function validateFieldPayment<K extends keyof Payment>(field: K, value: Payment[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsPayment(partial: Partial<Payment>): Array<{field: string; message: string}>{return[]; }export function hasShapePayment(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "date" in o;}export function isPayment(obj: unknown): obj is Payment {if(!hasShapePayment(obj)){return false;}const result = fromObjectPayment(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsPayment = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            date: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedPayment = {id: Option<boolean>;
            date: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersPayment {readonly id: FieldController<string>;
            readonly date: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformPayment {readonly data: Payment; readonly errors: ErrorsPayment; readonly tainted: TaintedPayment; readonly fields: FieldControllersPayment; validate(): Result<Payment, Array<{field: string; message: string}>>; reset(overrides?: Partial<Payment>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormPayment(overrides?: Partial<Payment>): GigaformPayment {let data = $state({...defaultValuePayment(),...overrides}); let errors = $state<ErrorsPayment>({ _errors: Option.none(), id: Option.none(), date: Option.none() }); let tainted = $state<TaintedPayment>({ id: Option.none(), date: Option.none() }); const fields: FieldControllersPayment = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPayment("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                date: {
                    path: ["date"] as const,
                    name: "date",
                    constraints: { required: true },
                    
                    get: () => data.date,
                    set: (value: string) => { data.date = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.date,
                    setError: (value: Option<Array<string>>) => { errors.date = value; },
                    getTainted: () => tainted.date,
                    setTainted: (value: Option<boolean>) => { tainted.date = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPayment("date", data.date);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Payment, Array<{field: string; message: string}>>{return fromObjectPayment(data);}function reset(newOverrides?: Partial<Payment>): void {data = {...defaultValuePayment(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), date: Option.none() }; tainted = { id: Option.none(), date: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataPayment(formData: FormData): Result<Payment, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.date = formData.get("date") ?? ""; return fromStringifiedJSONPayment(JSON.stringify(obj));}


export interface Settings {
    appointmentNotifications: AppointmentNotifications | null;
    commissions: Commissions | null;
    scheduleSettings: ScheduleSettings;
    accountOverviewSettings: OverviewSettings;
    serviceOverviewSettings: OverviewSettings;
    appointmentOverviewSettings: OverviewSettings;
    leadOverviewSettings: OverviewSettings;
    packageOverviewSettings: OverviewSettings;
    productOverviewSettings: OverviewSettings;
    orderOverviewSettings: OverviewSettings;
    taxRateOverviewSettings: OverviewSettings;
    
    homePage: Page;
}

export function defaultValueSettings(): Settings {return {appointmentNotifications: null,
                            commissions: null,
                            scheduleSettings: defaultValueScheduleSettings(),
                            accountOverviewSettings: defaultValueOverviewSettings(),
                            serviceOverviewSettings: defaultValueOverviewSettings(),
                            appointmentOverviewSettings: defaultValueOverviewSettings(),
                            leadOverviewSettings: defaultValueOverviewSettings(),
                            packageOverviewSettings: defaultValueOverviewSettings(),
                            productOverviewSettings: defaultValueOverviewSettings(),
                            orderOverviewSettings: defaultValueOverviewSettings(),
                            taxRateOverviewSettings: defaultValueOverviewSettings(),
                            homePage: "UserHome", }as Settings;}

export function toStringifiedJSONSettings(value: Settings): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeSettings(value, ctx));}export function toObjectSettings(value: Settings): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeSettings(value, ctx);}export function __serializeSettings(value: Settings, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Settings" , __id,}; if(value.appointmentNotifications!== null){result["appointmentNotifications" ]= __serializeAppointmentNotifications(value.appointmentNotifications, ctx); }else {result["appointmentNotifications" ]= null;}if(value.commissions!== null){result["commissions" ]= __serializeCommissions(value.commissions, ctx); }else {result["commissions" ]= null;}result["scheduleSettings" ]= __serializeScheduleSettings(value.scheduleSettings, ctx); result["accountOverviewSettings" ]= __serializeOverviewSettings(value.accountOverviewSettings, ctx); result["serviceOverviewSettings" ]= __serializeOverviewSettings(value.serviceOverviewSettings, ctx); result["appointmentOverviewSettings" ]= __serializeOverviewSettings(value.appointmentOverviewSettings, ctx); result["leadOverviewSettings" ]= __serializeOverviewSettings(value.leadOverviewSettings, ctx); result["packageOverviewSettings" ]= __serializeOverviewSettings(value.packageOverviewSettings, ctx); result["productOverviewSettings" ]= __serializeOverviewSettings(value.productOverviewSettings, ctx); result["orderOverviewSettings" ]= __serializeOverviewSettings(value.orderOverviewSettings, ctx); result["taxRateOverviewSettings" ]= __serializeOverviewSettings(value.taxRateOverviewSettings, ctx); result["homePage" ]= __serializePage(value.homePage, ctx); return result;}

export function fromStringifiedJSONSettings(json: string, opts?: DeserializeOptions): Result<Settings, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectSettings(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectSettings(obj: unknown, opts?: DeserializeOptions): Result<Settings, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeSettings(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Settings.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeSettings(value: any, ctx: DeserializeContext): Settings | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Settings.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("appointmentNotifications" in obj)){errors.push({field: "appointmentNotifications" , message: "missing required field" });}if(!("commissions" in obj)){errors.push({field: "commissions" , message: "missing required field" });}if(!("scheduleSettings" in obj)){errors.push({field: "scheduleSettings" , message: "missing required field" });}if(!("accountOverviewSettings" in obj)){errors.push({field: "accountOverviewSettings" , message: "missing required field" });}if(!("serviceOverviewSettings" in obj)){errors.push({field: "serviceOverviewSettings" , message: "missing required field" });}if(!("appointmentOverviewSettings" in obj)){errors.push({field: "appointmentOverviewSettings" , message: "missing required field" });}if(!("leadOverviewSettings" in obj)){errors.push({field: "leadOverviewSettings" , message: "missing required field" });}if(!("packageOverviewSettings" in obj)){errors.push({field: "packageOverviewSettings" , message: "missing required field" });}if(!("productOverviewSettings" in obj)){errors.push({field: "productOverviewSettings" , message: "missing required field" });}if(!("orderOverviewSettings" in obj)){errors.push({field: "orderOverviewSettings" , message: "missing required field" });}if(!("taxRateOverviewSettings" in obj)){errors.push({field: "taxRateOverviewSettings" , message: "missing required field" });}if(!("homePage" in obj)){errors.push({field: "homePage" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_appointmentNotifications = obj["appointmentNotifications" ]as AppointmentNotifications | null; if(__raw_appointmentNotifications === null){instance.appointmentNotifications = null;}else {const __result = __deserializeAppointmentNotifications(__raw_appointmentNotifications, ctx); ctx.assignOrDefer(instance, "appointmentNotifications" , __result); }}{const __raw_commissions = obj["commissions" ]as Commissions | null; if(__raw_commissions === null){instance.commissions = null;}else {const __result = __deserializeCommissions(__raw_commissions, ctx); ctx.assignOrDefer(instance, "commissions" , __result); }}{const __raw_scheduleSettings = obj["scheduleSettings" ]as ScheduleSettings; {const __result = __deserializeScheduleSettings(__raw_scheduleSettings, ctx); ctx.assignOrDefer(instance, "scheduleSettings" , __result);}}{const __raw_accountOverviewSettings = obj["accountOverviewSettings" ]as OverviewSettings; {const __result = __deserializeOverviewSettings(__raw_accountOverviewSettings, ctx); ctx.assignOrDefer(instance, "accountOverviewSettings" , __result);}}{const __raw_serviceOverviewSettings = obj["serviceOverviewSettings" ]as OverviewSettings; {const __result = __deserializeOverviewSettings(__raw_serviceOverviewSettings, ctx); ctx.assignOrDefer(instance, "serviceOverviewSettings" , __result);}}{const __raw_appointmentOverviewSettings = obj["appointmentOverviewSettings" ]as OverviewSettings; {const __result = __deserializeOverviewSettings(__raw_appointmentOverviewSettings, ctx); ctx.assignOrDefer(instance, "appointmentOverviewSettings" , __result);}}{const __raw_leadOverviewSettings = obj["leadOverviewSettings" ]as OverviewSettings; {const __result = __deserializeOverviewSettings(__raw_leadOverviewSettings, ctx); ctx.assignOrDefer(instance, "leadOverviewSettings" , __result);}}{const __raw_packageOverviewSettings = obj["packageOverviewSettings" ]as OverviewSettings; {const __result = __deserializeOverviewSettings(__raw_packageOverviewSettings, ctx); ctx.assignOrDefer(instance, "packageOverviewSettings" , __result);}}{const __raw_productOverviewSettings = obj["productOverviewSettings" ]as OverviewSettings; {const __result = __deserializeOverviewSettings(__raw_productOverviewSettings, ctx); ctx.assignOrDefer(instance, "productOverviewSettings" , __result);}}{const __raw_orderOverviewSettings = obj["orderOverviewSettings" ]as OverviewSettings; {const __result = __deserializeOverviewSettings(__raw_orderOverviewSettings, ctx); ctx.assignOrDefer(instance, "orderOverviewSettings" , __result);}}{const __raw_taxRateOverviewSettings = obj["taxRateOverviewSettings" ]as OverviewSettings; {const __result = __deserializeOverviewSettings(__raw_taxRateOverviewSettings, ctx); ctx.assignOrDefer(instance, "taxRateOverviewSettings" , __result);}}{const __raw_homePage = obj["homePage" ]as Page; {const __result = __deserializePage(__raw_homePage, ctx); ctx.assignOrDefer(instance, "homePage" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Settings;}export function validateFieldSettings<K extends keyof Settings>(field: K, value: Settings[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsSettings(partial: Partial<Settings>): Array<{field: string; message: string}>{return[]; }export function hasShapeSettings(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "appointmentNotifications" in o && "commissions" in o && "scheduleSettings" in o && "accountOverviewSettings" in o && "serviceOverviewSettings" in o && "appointmentOverviewSettings" in o && "leadOverviewSettings" in o && "packageOverviewSettings" in o && "productOverviewSettings" in o && "orderOverviewSettings" in o && "taxRateOverviewSettings" in o && "homePage" in o;}export function isSettings(obj: unknown): obj is Settings {if(!hasShapeSettings(obj)){return false;}const result = fromObjectSettings(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsSettings = {_errors: Option<Array<string>>; appointmentNotifications: Option<Array<string>>;
            commissions: Option<Array<string>>;
            scheduleSettings: Option<Array<string>>;
            accountOverviewSettings: Option<Array<string>>;
            serviceOverviewSettings: Option<Array<string>>;
            appointmentOverviewSettings: Option<Array<string>>;
            leadOverviewSettings: Option<Array<string>>;
            packageOverviewSettings: Option<Array<string>>;
            productOverviewSettings: Option<Array<string>>;
            orderOverviewSettings: Option<Array<string>>;
            taxRateOverviewSettings: Option<Array<string>>;
            homePage: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedSettings = {appointmentNotifications: Option<boolean>;
            commissions: Option<boolean>;
            scheduleSettings: Option<boolean>;
            accountOverviewSettings: Option<boolean>;
            serviceOverviewSettings: Option<boolean>;
            appointmentOverviewSettings: Option<boolean>;
            leadOverviewSettings: Option<boolean>;
            packageOverviewSettings: Option<boolean>;
            productOverviewSettings: Option<boolean>;
            orderOverviewSettings: Option<boolean>;
            taxRateOverviewSettings: Option<boolean>;
            homePage: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersSettings {readonly appointmentNotifications: FieldController<AppointmentNotifications | null>;
            readonly commissions: FieldController<Commissions | null>;
            readonly scheduleSettings: FieldController<ScheduleSettings>;
            readonly accountOverviewSettings: FieldController<OverviewSettings>;
            readonly serviceOverviewSettings: FieldController<OverviewSettings>;
            readonly appointmentOverviewSettings: FieldController<OverviewSettings>;
            readonly leadOverviewSettings: FieldController<OverviewSettings>;
            readonly packageOverviewSettings: FieldController<OverviewSettings>;
            readonly productOverviewSettings: FieldController<OverviewSettings>;
            readonly orderOverviewSettings: FieldController<OverviewSettings>;
            readonly taxRateOverviewSettings: FieldController<OverviewSettings>;
            readonly homePage: FieldController<Page>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformSettings {readonly data: Settings; readonly errors: ErrorsSettings; readonly tainted: TaintedSettings; readonly fields: FieldControllersSettings; validate(): Result<Settings, Array<{field: string; message: string}>>; reset(overrides?: Partial<Settings>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormSettings(overrides?: Partial<Settings>): GigaformSettings {let data = $state({...defaultValueSettings(),...overrides}); let errors = $state<ErrorsSettings>({ _errors: Option.none(), appointmentNotifications: Option.none(), commissions: Option.none(), scheduleSettings: Option.none(), accountOverviewSettings: Option.none(), serviceOverviewSettings: Option.none(), appointmentOverviewSettings: Option.none(), leadOverviewSettings: Option.none(), packageOverviewSettings: Option.none(), productOverviewSettings: Option.none(), orderOverviewSettings: Option.none(), taxRateOverviewSettings: Option.none(), homePage: Option.none() }); let tainted = $state<TaintedSettings>({ appointmentNotifications: Option.none(), commissions: Option.none(), scheduleSettings: Option.none(), accountOverviewSettings: Option.none(), serviceOverviewSettings: Option.none(), appointmentOverviewSettings: Option.none(), leadOverviewSettings: Option.none(), packageOverviewSettings: Option.none(), productOverviewSettings: Option.none(), orderOverviewSettings: Option.none(), taxRateOverviewSettings: Option.none(), homePage: Option.none() }); const fields: FieldControllersSettings = {appointmentNotifications: {
                    path: ["appointmentNotifications"] as const,
                    name: "appointmentNotifications",
                    constraints: { required: true },
                    
                    get: () => data.appointmentNotifications,
                    set: (value: AppointmentNotifications | null) => { data.appointmentNotifications = value; },
                    transform: (value: AppointmentNotifications | null): AppointmentNotifications | null => value,
                    getError: () => errors.appointmentNotifications,
                    setError: (value: Option<Array<string>>) => { errors.appointmentNotifications = value; },
                    getTainted: () => tainted.appointmentNotifications,
                    setTainted: (value: Option<boolean>) => { tainted.appointmentNotifications = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSettings("appointmentNotifications", data.appointmentNotifications);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                commissions: {
                    path: ["commissions"] as const,
                    name: "commissions",
                    constraints: { required: true },
                    
                    get: () => data.commissions,
                    set: (value: Commissions | null) => { data.commissions = value; },
                    transform: (value: Commissions | null): Commissions | null => value,
                    getError: () => errors.commissions,
                    setError: (value: Option<Array<string>>) => { errors.commissions = value; },
                    getTainted: () => tainted.commissions,
                    setTainted: (value: Option<boolean>) => { tainted.commissions = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSettings("commissions", data.commissions);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                scheduleSettings: {
                    path: ["scheduleSettings"] as const,
                    name: "scheduleSettings",
                    constraints: { required: true },
                    
                    get: () => data.scheduleSettings,
                    set: (value: ScheduleSettings) => { data.scheduleSettings = value; },
                    transform: (value: ScheduleSettings): ScheduleSettings => value,
                    getError: () => errors.scheduleSettings,
                    setError: (value: Option<Array<string>>) => { errors.scheduleSettings = value; },
                    getTainted: () => tainted.scheduleSettings,
                    setTainted: (value: Option<boolean>) => { tainted.scheduleSettings = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSettings("scheduleSettings", data.scheduleSettings);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                accountOverviewSettings: {
                    path: ["accountOverviewSettings"] as const,
                    name: "accountOverviewSettings",
                    constraints: { required: true },
                    
                    get: () => data.accountOverviewSettings,
                    set: (value: OverviewSettings) => { data.accountOverviewSettings = value; },
                    transform: (value: OverviewSettings): OverviewSettings => value,
                    getError: () => errors.accountOverviewSettings,
                    setError: (value: Option<Array<string>>) => { errors.accountOverviewSettings = value; },
                    getTainted: () => tainted.accountOverviewSettings,
                    setTainted: (value: Option<boolean>) => { tainted.accountOverviewSettings = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSettings("accountOverviewSettings", data.accountOverviewSettings);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                serviceOverviewSettings: {
                    path: ["serviceOverviewSettings"] as const,
                    name: "serviceOverviewSettings",
                    constraints: { required: true },
                    
                    get: () => data.serviceOverviewSettings,
                    set: (value: OverviewSettings) => { data.serviceOverviewSettings = value; },
                    transform: (value: OverviewSettings): OverviewSettings => value,
                    getError: () => errors.serviceOverviewSettings,
                    setError: (value: Option<Array<string>>) => { errors.serviceOverviewSettings = value; },
                    getTainted: () => tainted.serviceOverviewSettings,
                    setTainted: (value: Option<boolean>) => { tainted.serviceOverviewSettings = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSettings("serviceOverviewSettings", data.serviceOverviewSettings);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                appointmentOverviewSettings: {
                    path: ["appointmentOverviewSettings"] as const,
                    name: "appointmentOverviewSettings",
                    constraints: { required: true },
                    
                    get: () => data.appointmentOverviewSettings,
                    set: (value: OverviewSettings) => { data.appointmentOverviewSettings = value; },
                    transform: (value: OverviewSettings): OverviewSettings => value,
                    getError: () => errors.appointmentOverviewSettings,
                    setError: (value: Option<Array<string>>) => { errors.appointmentOverviewSettings = value; },
                    getTainted: () => tainted.appointmentOverviewSettings,
                    setTainted: (value: Option<boolean>) => { tainted.appointmentOverviewSettings = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSettings("appointmentOverviewSettings", data.appointmentOverviewSettings);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                leadOverviewSettings: {
                    path: ["leadOverviewSettings"] as const,
                    name: "leadOverviewSettings",
                    constraints: { required: true },
                    
                    get: () => data.leadOverviewSettings,
                    set: (value: OverviewSettings) => { data.leadOverviewSettings = value; },
                    transform: (value: OverviewSettings): OverviewSettings => value,
                    getError: () => errors.leadOverviewSettings,
                    setError: (value: Option<Array<string>>) => { errors.leadOverviewSettings = value; },
                    getTainted: () => tainted.leadOverviewSettings,
                    setTainted: (value: Option<boolean>) => { tainted.leadOverviewSettings = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSettings("leadOverviewSettings", data.leadOverviewSettings);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                packageOverviewSettings: {
                    path: ["packageOverviewSettings"] as const,
                    name: "packageOverviewSettings",
                    constraints: { required: true },
                    
                    get: () => data.packageOverviewSettings,
                    set: (value: OverviewSettings) => { data.packageOverviewSettings = value; },
                    transform: (value: OverviewSettings): OverviewSettings => value,
                    getError: () => errors.packageOverviewSettings,
                    setError: (value: Option<Array<string>>) => { errors.packageOverviewSettings = value; },
                    getTainted: () => tainted.packageOverviewSettings,
                    setTainted: (value: Option<boolean>) => { tainted.packageOverviewSettings = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSettings("packageOverviewSettings", data.packageOverviewSettings);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                productOverviewSettings: {
                    path: ["productOverviewSettings"] as const,
                    name: "productOverviewSettings",
                    constraints: { required: true },
                    
                    get: () => data.productOverviewSettings,
                    set: (value: OverviewSettings) => { data.productOverviewSettings = value; },
                    transform: (value: OverviewSettings): OverviewSettings => value,
                    getError: () => errors.productOverviewSettings,
                    setError: (value: Option<Array<string>>) => { errors.productOverviewSettings = value; },
                    getTainted: () => tainted.productOverviewSettings,
                    setTainted: (value: Option<boolean>) => { tainted.productOverviewSettings = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSettings("productOverviewSettings", data.productOverviewSettings);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                orderOverviewSettings: {
                    path: ["orderOverviewSettings"] as const,
                    name: "orderOverviewSettings",
                    constraints: { required: true },
                    
                    get: () => data.orderOverviewSettings,
                    set: (value: OverviewSettings) => { data.orderOverviewSettings = value; },
                    transform: (value: OverviewSettings): OverviewSettings => value,
                    getError: () => errors.orderOverviewSettings,
                    setError: (value: Option<Array<string>>) => { errors.orderOverviewSettings = value; },
                    getTainted: () => tainted.orderOverviewSettings,
                    setTainted: (value: Option<boolean>) => { tainted.orderOverviewSettings = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSettings("orderOverviewSettings", data.orderOverviewSettings);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                taxRateOverviewSettings: {
                    path: ["taxRateOverviewSettings"] as const,
                    name: "taxRateOverviewSettings",
                    constraints: { required: true },
                    
                    get: () => data.taxRateOverviewSettings,
                    set: (value: OverviewSettings) => { data.taxRateOverviewSettings = value; },
                    transform: (value: OverviewSettings): OverviewSettings => value,
                    getError: () => errors.taxRateOverviewSettings,
                    setError: (value: Option<Array<string>>) => { errors.taxRateOverviewSettings = value; },
                    getTainted: () => tainted.taxRateOverviewSettings,
                    setTainted: (value: Option<boolean>) => { tainted.taxRateOverviewSettings = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSettings("taxRateOverviewSettings", data.taxRateOverviewSettings);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                homePage: {
                    path: ["homePage"] as const,
                    name: "homePage",
                    constraints: { required: true },
                    
                    get: () => data.homePage,
                    set: (value: Page) => { data.homePage = value; },
                    transform: (value: Page): Page => value,
                    getError: () => errors.homePage,
                    setError: (value: Option<Array<string>>) => { errors.homePage = value; },
                    getTainted: () => tainted.homePage,
                    setTainted: (value: Option<boolean>) => { tainted.homePage = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSettings("homePage", data.homePage);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Settings, Array<{field: string; message: string}>>{return fromObjectSettings(data);}function reset(newOverrides?: Partial<Settings>): void {data = {...defaultValueSettings(),...newOverrides}; errors = { _errors: Option.none(), appointmentNotifications: Option.none(), commissions: Option.none(), scheduleSettings: Option.none(), accountOverviewSettings: Option.none(), serviceOverviewSettings: Option.none(), appointmentOverviewSettings: Option.none(), leadOverviewSettings: Option.none(), packageOverviewSettings: Option.none(), productOverviewSettings: Option.none(), orderOverviewSettings: Option.none(), taxRateOverviewSettings: Option.none(), homePage: Option.none() }; tainted = { appointmentNotifications: Option.none(), commissions: Option.none(), scheduleSettings: Option.none(), accountOverviewSettings: Option.none(), serviceOverviewSettings: Option.none(), appointmentOverviewSettings: Option.none(), leadOverviewSettings: Option.none(), packageOverviewSettings: Option.none(), productOverviewSettings: Option.none(), orderOverviewSettings: Option.none(), taxRateOverviewSettings: Option.none(), homePage: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataSettings(formData: FormData): Result<Settings, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.appointmentNotifications = formData.get("appointmentNotifications") ?? "";
            obj.commissions = formData.get("commissions") ?? "";
            {
            // Collect nested object fields with prefix "scheduleSettings."
            const scheduleSettingsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("scheduleSettings.")) {
                    const fieldName = key.slice("scheduleSettings.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = scheduleSettingsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.scheduleSettings = scheduleSettingsObj;
        }
            {
            // Collect nested object fields with prefix "accountOverviewSettings."
            const accountOverviewSettingsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("accountOverviewSettings.")) {
                    const fieldName = key.slice("accountOverviewSettings.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = accountOverviewSettingsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.accountOverviewSettings = accountOverviewSettingsObj;
        }
            {
            // Collect nested object fields with prefix "serviceOverviewSettings."
            const serviceOverviewSettingsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("serviceOverviewSettings.")) {
                    const fieldName = key.slice("serviceOverviewSettings.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = serviceOverviewSettingsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.serviceOverviewSettings = serviceOverviewSettingsObj;
        }
            {
            // Collect nested object fields with prefix "appointmentOverviewSettings."
            const appointmentOverviewSettingsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("appointmentOverviewSettings.")) {
                    const fieldName = key.slice("appointmentOverviewSettings.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = appointmentOverviewSettingsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.appointmentOverviewSettings = appointmentOverviewSettingsObj;
        }
            {
            // Collect nested object fields with prefix "leadOverviewSettings."
            const leadOverviewSettingsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("leadOverviewSettings.")) {
                    const fieldName = key.slice("leadOverviewSettings.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = leadOverviewSettingsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.leadOverviewSettings = leadOverviewSettingsObj;
        }
            {
            // Collect nested object fields with prefix "packageOverviewSettings."
            const packageOverviewSettingsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("packageOverviewSettings.")) {
                    const fieldName = key.slice("packageOverviewSettings.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = packageOverviewSettingsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.packageOverviewSettings = packageOverviewSettingsObj;
        }
            {
            // Collect nested object fields with prefix "productOverviewSettings."
            const productOverviewSettingsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("productOverviewSettings.")) {
                    const fieldName = key.slice("productOverviewSettings.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = productOverviewSettingsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.productOverviewSettings = productOverviewSettingsObj;
        }
            {
            // Collect nested object fields with prefix "orderOverviewSettings."
            const orderOverviewSettingsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("orderOverviewSettings.")) {
                    const fieldName = key.slice("orderOverviewSettings.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = orderOverviewSettingsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.orderOverviewSettings = orderOverviewSettingsObj;
        }
            {
            // Collect nested object fields with prefix "taxRateOverviewSettings."
            const taxRateOverviewSettingsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("taxRateOverviewSettings.")) {
                    const fieldName = key.slice("taxRateOverviewSettings.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = taxRateOverviewSettingsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.taxRateOverviewSettings = taxRateOverviewSettingsObj;
        }
            {
            // Collect nested object fields with prefix "homePage."
            const homePageObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("homePage.")) {
                    const fieldName = key.slice("homePage.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = homePageObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.homePage = homePageObj;
        } return fromStringifiedJSONSettings(JSON.stringify(obj));}


export interface Color {
    red: number;
    green: number;
    blue: number;
}

export function defaultValueColor(): Color {return {red: 0,
                            green: 0,
                            blue: 0, }as Color;}

export function toStringifiedJSONColor(value: Color): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeColor(value, ctx));}export function toObjectColor(value: Color): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeColor(value, ctx);}export function __serializeColor(value: Color, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Color" , __id,}; result["red" ]= value.red; result["green" ]= value.green; result["blue" ]= value.blue; return result;}

export function fromStringifiedJSONColor(json: string, opts?: DeserializeOptions): Result<Color, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectColor(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectColor(obj: unknown, opts?: DeserializeOptions): Result<Color, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeColor(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Color.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeColor(value: any, ctx: DeserializeContext): Color | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Color.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("red" in obj)){errors.push({field: "red" , message: "missing required field" });}if(!("green" in obj)){errors.push({field: "green" , message: "missing required field" });}if(!("blue" in obj)){errors.push({field: "blue" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_red = obj["red" ]as number; instance.red = __raw_red; }{const __raw_green = obj["green" ]as number; instance.green = __raw_green; }{const __raw_blue = obj["blue" ]as number; instance.blue = __raw_blue; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Color;}export function validateFieldColor<K extends keyof Color>(field: K, value: Color[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsColor(partial: Partial<Color>): Array<{field: string; message: string}>{return[]; }export function hasShapeColor(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "red" in o && "green" in o && "blue" in o;}export function isColor(obj: unknown): obj is Color {if(!hasShapeColor(obj)){return false;}const result = fromObjectColor(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsColor = {_errors: Option<Array<string>>; red: Option<Array<string>>;
            green: Option<Array<string>>;
            blue: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedColor = {red: Option<boolean>;
            green: Option<boolean>;
            blue: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersColor {readonly red: FieldController<number>;
            readonly green: FieldController<number>;
            readonly blue: FieldController<number>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformColor {readonly data: Color; readonly errors: ErrorsColor; readonly tainted: TaintedColor; readonly fields: FieldControllersColor; validate(): Result<Color, Array<{field: string; message: string}>>; reset(overrides?: Partial<Color>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormColor(overrides?: Partial<Color>): GigaformColor {let data = $state({...defaultValueColor(),...overrides}); let errors = $state<ErrorsColor>({ _errors: Option.none(), red: Option.none(), green: Option.none(), blue: Option.none() }); let tainted = $state<TaintedColor>({ red: Option.none(), green: Option.none(), blue: Option.none() }); const fields: FieldControllersColor = {red: {
                    path: ["red"] as const,
                    name: "red",
                    constraints: { required: true },
                    
                    get: () => data.red,
                    set: (value: number) => { data.red = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.red,
                    setError: (value: Option<Array<string>>) => { errors.red = value; },
                    getTainted: () => tainted.red,
                    setTainted: (value: Option<boolean>) => { tainted.red = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldColor("red", data.red);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                green: {
                    path: ["green"] as const,
                    name: "green",
                    constraints: { required: true },
                    
                    get: () => data.green,
                    set: (value: number) => { data.green = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.green,
                    setError: (value: Option<Array<string>>) => { errors.green = value; },
                    getTainted: () => tainted.green,
                    setTainted: (value: Option<boolean>) => { tainted.green = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldColor("green", data.green);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                blue: {
                    path: ["blue"] as const,
                    name: "blue",
                    constraints: { required: true },
                    
                    get: () => data.blue,
                    set: (value: number) => { data.blue = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.blue,
                    setError: (value: Option<Array<string>>) => { errors.blue = value; },
                    getTainted: () => tainted.blue,
                    setTainted: (value: Option<boolean>) => { tainted.blue = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldColor("blue", data.blue);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Color, Array<{field: string; message: string}>>{return fromObjectColor(data);}function reset(newOverrides?: Partial<Color>): void {data = {...defaultValueColor(),...newOverrides}; errors = { _errors: Option.none(), red: Option.none(), green: Option.none(), blue: Option.none() }; tainted = { red: Option.none(), green: Option.none(), blue: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataColor(formData: FormData): Result<Color, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const redStr = formData.get("red");
                obj.red = redStr ? parseFloat(redStr as string) : 0;
                if (obj.red !== undefined && isNaN(obj.red as number)) obj.red = 0;
            }
            {
                const greenStr = formData.get("green");
                obj.green = greenStr ? parseFloat(greenStr as string) : 0;
                if (obj.green !== undefined && isNaN(obj.green as number)) obj.green = 0;
            }
            {
                const blueStr = formData.get("blue");
                obj.blue = blueStr ? parseFloat(blueStr as string) : 0;
                if (obj.blue !== undefined && isNaN(obj.blue as number)) obj.blue = 0;
            } return fromStringifiedJSONColor(JSON.stringify(obj));}


export interface CompanyName {
    
    
    companyName: string;
}

export function defaultValueCompanyName(): CompanyName {return {companyName: "", }as CompanyName;}

export function toStringifiedJSONCompanyName(value: CompanyName): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeCompanyName(value, ctx));}export function toObjectCompanyName(value: CompanyName): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeCompanyName(value, ctx);}export function __serializeCompanyName(value: CompanyName, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "CompanyName" , __id,}; result["companyName" ]= value.companyName; return result;}

export function fromStringifiedJSONCompanyName(json: string, opts?: DeserializeOptions): Result<CompanyName, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectCompanyName(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectCompanyName(obj: unknown, opts?: DeserializeOptions): Result<CompanyName, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeCompanyName(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "CompanyName.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeCompanyName(value: any, ctx: DeserializeContext): CompanyName | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "CompanyName.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("companyName" in obj)){errors.push({field: "companyName" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_companyName = obj["companyName" ]as string; 
                if (__raw_companyName.length === 0) {
                    errors.push({ field: "companyName", message: "must not be empty" });
                }
 instance.companyName = __raw_companyName; }if(errors.length>0){throw new DeserializeError(errors);}return instance as CompanyName;}export function validateFieldCompanyName<K extends keyof CompanyName>(field: K, value: CompanyName[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "companyName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "companyName", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsCompanyName(partial: Partial<CompanyName>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("companyName" in partial && partial.companyName!== undefined){const __val = partial.companyName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "companyName", message: "must not be empty" });
                }
}return errors; }export function hasShapeCompanyName(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "companyName" in o;}export function isCompanyName(obj: unknown): obj is CompanyName {if(!hasShapeCompanyName(obj)){return false;}const result = fromObjectCompanyName(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsCompanyName = {_errors: Option<Array<string>>; companyName: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedCompanyName = {companyName: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersCompanyName {readonly companyName: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformCompanyName {readonly data: CompanyName; readonly errors: ErrorsCompanyName; readonly tainted: TaintedCompanyName; readonly fields: FieldControllersCompanyName; validate(): Result<CompanyName, Array<{field: string; message: string}>>; reset(overrides?: Partial<CompanyName>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormCompanyName(overrides?: Partial<CompanyName>): GigaformCompanyName {let data = $state({...defaultValueCompanyName(),...overrides}); let errors = $state<ErrorsCompanyName>({ _errors: Option.none(), companyName: Option.none() }); let tainted = $state<TaintedCompanyName>({ companyName: Option.none() }); const fields: FieldControllersCompanyName = {companyName: {
                    path: ["companyName"] as const,
                    name: "companyName",
                    constraints: { required: true },
                    label: "Company Name",
                    get: () => data.companyName,
                    set: (value: string) => { data.companyName = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.companyName,
                    setError: (value: Option<Array<string>>) => { errors.companyName = value; },
                    getTainted: () => tainted.companyName,
                    setTainted: (value: Option<boolean>) => { tainted.companyName = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompanyName("companyName", data.companyName);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<CompanyName, Array<{field: string; message: string}>>{return fromObjectCompanyName(data);}function reset(newOverrides?: Partial<CompanyName>): void {data = {...defaultValueCompanyName(),...newOverrides}; errors = { _errors: Option.none(), companyName: Option.none() }; tainted = { companyName: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataCompanyName(formData: FormData): Result<CompanyName, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.companyName = formData.get("companyName") ?? ""; return fromStringifiedJSONCompanyName(JSON.stringify(obj));}


export interface Appointment {
    
    id: string;
    
    
    title: string;
    
    
    status: Status;
    
    begins: string;
    
    duration: number;
    
    timeZone: string;
    
    offsetMs: number;
    
    allDay: boolean;
    
    multiDay: boolean;
    
    employees: (string | Employee)[];
    
    
    location: string | Site;
    
    description: string | null;
    
    
    colors: Colors;
    
    recurrenceRule: RecurrenceRule | null;
}

export function defaultValueAppointment(): Appointment {return {id: "",
                            title: "",
                            status: "Scheduled",
                            begins: "",
                            duration: 0,
                            timeZone: "",
                            offsetMs: 0,
                            allDay: false,
                            multiDay: false,
                            employees: [],
                            location: "",
                            description: null,
                            colors: { main: "#000000", hover: "#333333", active: "#666666" },
                            recurrenceRule: null, }as Appointment;}

export function toStringifiedJSONAppointment(value: Appointment): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeAppointment(value, ctx));}export function toObjectAppointment(value: Appointment): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeAppointment(value, ctx);}export function __serializeAppointment(value: Appointment, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Appointment" , __id,}; result["id" ]= value.id; result["title" ]= value.title; result["status" ]= __serializeStatus(value.status, ctx); result["begins" ]= value.begins; result["duration" ]= value.duration; result["timeZone" ]= value.timeZone; result["offsetMs" ]= value.offsetMs; result["allDay" ]= value.allDay; result["multiDay" ]= value.multiDay; result["employees" ]= value.employees; result["location" ]= value.location; result["description" ]= value.description; result["colors" ]= __serializeColors(value.colors, ctx); if(value.recurrenceRule!== null){result["recurrenceRule" ]= __serializeRecurrenceRule(value.recurrenceRule, ctx); }else {result["recurrenceRule" ]= null;}return result;}

export function fromStringifiedJSONAppointment(json: string, opts?: DeserializeOptions): Result<Appointment, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectAppointment(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectAppointment(obj: unknown, opts?: DeserializeOptions): Result<Appointment, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeAppointment(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Appointment.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeAppointment(value: any, ctx: DeserializeContext): Appointment | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Appointment.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("title" in obj)){errors.push({field: "title" , message: "missing required field" });}if(!("status" in obj)){errors.push({field: "status" , message: "missing required field" });}if(!("begins" in obj)){errors.push({field: "begins" , message: "missing required field" });}if(!("duration" in obj)){errors.push({field: "duration" , message: "missing required field" });}if(!("timeZone" in obj)){errors.push({field: "timeZone" , message: "missing required field" });}if(!("offsetMs" in obj)){errors.push({field: "offsetMs" , message: "missing required field" });}if(!("allDay" in obj)){errors.push({field: "allDay" , message: "missing required field" });}if(!("multiDay" in obj)){errors.push({field: "multiDay" , message: "missing required field" });}if(!("employees" in obj)){errors.push({field: "employees" , message: "missing required field" });}if(!("location" in obj)){errors.push({field: "location" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(!("colors" in obj)){errors.push({field: "colors" , message: "missing required field" });}if(!("recurrenceRule" in obj)){errors.push({field: "recurrenceRule" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_title = obj["title" ]as string; 
                if (__raw_title.length === 0) {
                    errors.push({ field: "title", message: "must not be empty" });
                }
 instance.title = __raw_title; }{const __raw_status = obj["status" ]as Status; {const __result = __deserializeStatus(__raw_status, ctx); ctx.assignOrDefer(instance, "status" , __result);}}{const __raw_begins = obj["begins" ]as string; instance.begins = __raw_begins; }{const __raw_duration = obj["duration" ]as number; instance.duration = __raw_duration; }{const __raw_timeZone = obj["timeZone" ]as string; instance.timeZone = __raw_timeZone; }{const __raw_offsetMs = obj["offsetMs" ]as number; instance.offsetMs = __raw_offsetMs; }{const __raw_allDay = obj["allDay" ]as boolean; instance.allDay = __raw_allDay; }{const __raw_multiDay = obj["multiDay" ]as boolean; instance.multiDay = __raw_multiDay; }{const __raw_employees = obj["employees" ]as (string | Employee)[]; if(Array.isArray(__raw_employees)){instance.employees = __raw_employees as (string | Employee)[];}}{const __raw_location = obj["location" ]as string | Site; instance.location = __raw_location; }{const __raw_description = obj["description" ]as string | null; instance.description = __raw_description; }{const __raw_colors = obj["colors" ]as Colors; {const __result = __deserializeColors(__raw_colors, ctx); ctx.assignOrDefer(instance, "colors" , __result);}}{const __raw_recurrenceRule = obj["recurrenceRule" ]as RecurrenceRule | null; if(__raw_recurrenceRule === null){instance.recurrenceRule = null;}else {const __result = __deserializeRecurrenceRule(__raw_recurrenceRule, ctx); ctx.assignOrDefer(instance, "recurrenceRule" , __result); }}if(errors.length>0){throw new DeserializeError(errors);}return instance as Appointment;}export function validateFieldAppointment<K extends keyof Appointment>(field: K, value: Appointment[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "title" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "title", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsAppointment(partial: Partial<Appointment>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("title" in partial && partial.title!== undefined){const __val = partial.title as string; 
                if (__val.length === 0) {
                    errors.push({ field: "title", message: "must not be empty" });
                }
}return errors; }export function hasShapeAppointment(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "title" in o && "status" in o && "begins" in o && "duration" in o && "timeZone" in o && "offsetMs" in o && "allDay" in o && "multiDay" in o && "employees" in o && "location" in o && "description" in o && "colors" in o && "recurrenceRule" in o;}export function isAppointment(obj: unknown): obj is Appointment {if(!hasShapeAppointment(obj)){return false;}const result = fromObjectAppointment(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsAppointment = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            title: Option<Array<string>>;
            status: Option<Array<string>>;
            begins: Option<Array<string>>;
            duration: Option<Array<string>>;
            timeZone: Option<Array<string>>;
            offsetMs: Option<Array<string>>;
            allDay: Option<Array<string>>;
            multiDay: Option<Array<string>>;
            employees: Option<Array<string>>;
            location: Option<Array<string>>;
            description: Option<Array<string>>;
            colors: Option<Array<string>>;
            recurrenceRule: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedAppointment = {id: Option<boolean>;
            title: Option<boolean>;
            status: Option<boolean>;
            begins: Option<boolean>;
            duration: Option<boolean>;
            timeZone: Option<boolean>;
            offsetMs: Option<boolean>;
            allDay: Option<boolean>;
            multiDay: Option<boolean>;
            employees: Option<boolean>;
            location: Option<boolean>;
            description: Option<boolean>;
            colors: Option<boolean>;
            recurrenceRule: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersAppointment {readonly id: FieldController<string>;
            readonly title: FieldController<string>;
            readonly status: FieldController<Status>;
            readonly begins: FieldController<string>;
            readonly duration: FieldController<number>;
            readonly timeZone: FieldController<string>;
            readonly offsetMs: FieldController<number>;
            readonly allDay: FieldController<boolean>;
            readonly multiDay: FieldController<boolean>;
            readonly employees: ArrayFieldController<(string | Employee)>;
            readonly location: FieldController<string | Site>;
            readonly description: FieldController<string | null>;
            readonly colors: FieldController<Colors>;
            readonly recurrenceRule: FieldController<RecurrenceRule | null>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformAppointment {readonly data: Appointment; readonly errors: ErrorsAppointment; readonly tainted: TaintedAppointment; readonly fields: FieldControllersAppointment; validate(): Result<Appointment, Array<{field: string; message: string}>>; reset(overrides?: Partial<Appointment>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormAppointment(overrides?: Partial<Appointment>): GigaformAppointment {let data = $state({...defaultValueAppointment(),...overrides}); let errors = $state<ErrorsAppointment>({ _errors: Option.none(), id: Option.none(), title: Option.none(), status: Option.none(), begins: Option.none(), duration: Option.none(), timeZone: Option.none(), offsetMs: Option.none(), allDay: Option.none(), multiDay: Option.none(), employees: Option.none(), location: Option.none(), description: Option.none(), colors: Option.none(), recurrenceRule: Option.none() }); let tainted = $state<TaintedAppointment>({ id: Option.none(), title: Option.none(), status: Option.none(), begins: Option.none(), duration: Option.none(), timeZone: Option.none(), offsetMs: Option.none(), allDay: Option.none(), multiDay: Option.none(), employees: Option.none(), location: Option.none(), description: Option.none(), colors: Option.none(), recurrenceRule: Option.none() }); const fields: FieldControllersAppointment = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointment("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                title: {
                    path: ["title"] as const,
                    name: "title",
                    constraints: { required: true },
                    label: "Title",
                    get: () => data.title,
                    set: (value: string) => { data.title = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.title,
                    setError: (value: Option<Array<string>>) => { errors.title = value; },
                    getTainted: () => tainted.title,
                    setTainted: (value: Option<boolean>) => { tainted.title = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointment("title", data.title);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                status: {
                    path: ["status"] as const,
                    name: "status",
                    constraints: { required: true },
                    label: "Status",
                    get: () => data.status,
                    set: (value: Status) => { data.status = value; },
                    transform: (value: Status): Status => value,
                    getError: () => errors.status,
                    setError: (value: Option<Array<string>>) => { errors.status = value; },
                    getTainted: () => tainted.status,
                    setTainted: (value: Option<boolean>) => { tainted.status = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointment("status", data.status);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                begins: {
                    path: ["begins"] as const,
                    name: "begins",
                    constraints: { required: true },
                    label: "Begins",
                    get: () => data.begins,
                    set: (value: string) => { data.begins = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.begins,
                    setError: (value: Option<Array<string>>) => { errors.begins = value; },
                    getTainted: () => tainted.begins,
                    setTainted: (value: Option<boolean>) => { tainted.begins = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointment("begins", data.begins);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                duration: {
                    path: ["duration"] as const,
                    name: "duration",
                    constraints: { required: true },
                    label: "Duration",
                    get: () => data.duration,
                    set: (value: number) => { data.duration = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.duration,
                    setError: (value: Option<Array<string>>) => { errors.duration = value; },
                    getTainted: () => tainted.duration,
                    setTainted: (value: Option<boolean>) => { tainted.duration = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointment("duration", data.duration);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                timeZone: {
                    path: ["timeZone"] as const,
                    name: "timeZone",
                    constraints: { required: true },
                    label: "Time Zone",
                    get: () => data.timeZone,
                    set: (value: string) => { data.timeZone = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.timeZone,
                    setError: (value: Option<Array<string>>) => { errors.timeZone = value; },
                    getTainted: () => tainted.timeZone,
                    setTainted: (value: Option<boolean>) => { tainted.timeZone = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointment("timeZone", data.timeZone);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                offsetMs: {
                    path: ["offsetMs"] as const,
                    name: "offsetMs",
                    constraints: { required: true },
                    
                    get: () => data.offsetMs,
                    set: (value: number) => { data.offsetMs = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.offsetMs,
                    setError: (value: Option<Array<string>>) => { errors.offsetMs = value; },
                    getTainted: () => tainted.offsetMs,
                    setTainted: (value: Option<boolean>) => { tainted.offsetMs = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointment("offsetMs", data.offsetMs);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                allDay: {
                    path: ["allDay"] as const,
                    name: "allDay",
                    constraints: { required: true },
                    label: "All Day",
                    get: () => data.allDay,
                    set: (value: boolean) => { data.allDay = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.allDay,
                    setError: (value: Option<Array<string>>) => { errors.allDay = value; },
                    getTainted: () => tainted.allDay,
                    setTainted: (value: Option<boolean>) => { tainted.allDay = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointment("allDay", data.allDay);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                multiDay: {
                    path: ["multiDay"] as const,
                    name: "multiDay",
                    constraints: { required: true },
                    label: "Multi Day",
                    get: () => data.multiDay,
                    set: (value: boolean) => { data.multiDay = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.multiDay,
                    setError: (value: Option<Array<string>>) => { errors.multiDay = value; },
                    getTainted: () => tainted.multiDay,
                    setTainted: (value: Option<boolean>) => { tainted.multiDay = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointment("multiDay", data.multiDay);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                employees: {
                    path: ["employees"] as const,
                    name: "employees",
                    constraints: { required: true },
                    label: "Employees",
                    get: () => data.employees,
                    set: (value: (string | Employee)[]) => { data.employees = value; },
                    transform: (value: (string | Employee)[]): (string | Employee)[] => value,
                    getError: () => errors.employees,
                    setError: (value: Option<Array<string>>) => { errors.employees = value; },
                    getTainted: () => tainted.employees,
                    setTainted: (value: Option<boolean>) => { tainted.employees = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointment("employees", data.employees);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["employees", index] as const,
                        name: `employees.${index}`,
                        constraints: { required: true },
                        get: () => data.employees[index]!,
                        set: (value: (string | Employee)) => { data.employees[index] = value; },
                        transform: (value: (string | Employee)): (string | Employee) => value,
                        getError: () => errors.employees,
                        setError: (value: Option<Array<string>>) => { errors.employees = value; },
                        getTainted: () => tainted.employees,
                        setTainted: (value: Option<boolean>) => { tainted.employees = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: (string | Employee)) => { data.employees.push(item); },
                    remove: (index: number) => { data.employees.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.employees[a]!;
                        data.employees[a] = data.employees[b]!;
                        data.employees[b] = tmp;
                    },
                },
                location: {
                    path: ["location"] as const,
                    name: "location",
                    constraints: { required: true },
                    label: "Location",
                    get: () => data.location,
                    set: (value: string | Site) => { data.location = value; },
                    transform: (value: string | Site): string | Site => value,
                    getError: () => errors.location,
                    setError: (value: Option<Array<string>>) => { errors.location = value; },
                    getTainted: () => tainted.location,
                    setTainted: (value: Option<boolean>) => { tainted.location = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointment("location", data.location);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                description: {
                    path: ["description"] as const,
                    name: "description",
                    constraints: { required: true },
                    label: "Description",
                    get: () => data.description,
                    set: (value: string | null) => { data.description = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.description,
                    setError: (value: Option<Array<string>>) => { errors.description = value; },
                    getTainted: () => tainted.description,
                    setTainted: (value: Option<boolean>) => { tainted.description = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointment("description", data.description);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                colors: {
                    path: ["colors"] as const,
                    name: "colors",
                    constraints: { required: true },
                    
                    get: () => data.colors,
                    set: (value: Colors) => { data.colors = value; },
                    transform: (value: Colors): Colors => value,
                    getError: () => errors.colors,
                    setError: (value: Option<Array<string>>) => { errors.colors = value; },
                    getTainted: () => tainted.colors,
                    setTainted: (value: Option<boolean>) => { tainted.colors = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointment("colors", data.colors);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                recurrenceRule: {
                    path: ["recurrenceRule"] as const,
                    name: "recurrenceRule",
                    constraints: { required: true },
                    
                    get: () => data.recurrenceRule,
                    set: (value: RecurrenceRule | null) => { data.recurrenceRule = value; },
                    transform: (value: RecurrenceRule | null): RecurrenceRule | null => value,
                    getError: () => errors.recurrenceRule,
                    setError: (value: Option<Array<string>>) => { errors.recurrenceRule = value; },
                    getTainted: () => tainted.recurrenceRule,
                    setTainted: (value: Option<boolean>) => { tainted.recurrenceRule = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppointment("recurrenceRule", data.recurrenceRule);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Appointment, Array<{field: string; message: string}>>{return fromObjectAppointment(data);}function reset(newOverrides?: Partial<Appointment>): void {data = {...defaultValueAppointment(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), title: Option.none(), status: Option.none(), begins: Option.none(), duration: Option.none(), timeZone: Option.none(), offsetMs: Option.none(), allDay: Option.none(), multiDay: Option.none(), employees: Option.none(), location: Option.none(), description: Option.none(), colors: Option.none(), recurrenceRule: Option.none() }; tainted = { id: Option.none(), title: Option.none(), status: Option.none(), begins: Option.none(), duration: Option.none(), timeZone: Option.none(), offsetMs: Option.none(), allDay: Option.none(), multiDay: Option.none(), employees: Option.none(), location: Option.none(), description: Option.none(), colors: Option.none(), recurrenceRule: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataAppointment(formData: FormData): Result<Appointment, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.title = formData.get("title") ?? "";
            {
            // Collect nested object fields with prefix "status."
            const statusObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("status.")) {
                    const fieldName = key.slice("status.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = statusObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.status = statusObj;
        }
            obj.begins = formData.get("begins") ?? "";
            {
                const durationStr = formData.get("duration");
                obj.duration = durationStr ? parseFloat(durationStr as string) : 0;
                if (obj.duration !== undefined && isNaN(obj.duration as number)) obj.duration = 0;
            }
            obj.timeZone = formData.get("timeZone") ?? "";
            {
                const offsetMsStr = formData.get("offsetMs");
                obj.offsetMs = offsetMsStr ? parseFloat(offsetMsStr as string) : 0;
                if (obj.offsetMs !== undefined && isNaN(obj.offsetMs as number)) obj.offsetMs = 0;
            }
            {
                const allDayVal = formData.get("allDay");
                obj.allDay = allDayVal === "true" || allDayVal === "on" || allDayVal === "1";
            }
            {
                const multiDayVal = formData.get("multiDay");
                obj.multiDay = multiDayVal === "true" || multiDayVal === "on" || multiDayVal === "1";
            }
            {
                // Collect array items from indexed form fields
                const employeesItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("employees." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("employees." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("employees." + idx + ".")) {
                                const fieldName = key.slice("employees.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        employeesItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.employees = employeesItems;
            }
            obj.location = formData.get("location") ?? "";
            obj.description = formData.get("description") ?? "";
            {
            // Collect nested object fields with prefix "colors."
            const colorsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("colors.")) {
                    const fieldName = key.slice("colors.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = colorsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.colors = colorsObj;
        }
            obj.recurrenceRule = formData.get("recurrenceRule") ?? ""; return fromStringifiedJSONAppointment(JSON.stringify(obj));}


export interface Package {
    
    id: string;
    
    date: string;
}

export function defaultValuePackage(): Package {return {id: "",
                            date: "", }as Package;}

export function toStringifiedJSONPackage(value: Package): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializePackage(value, ctx));}export function toObjectPackage(value: Package): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializePackage(value, ctx);}export function __serializePackage(value: Package, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Package" , __id,}; result["id" ]= value.id; result["date" ]= value.date; return result;}

export function fromStringifiedJSONPackage(json: string, opts?: DeserializeOptions): Result<Package, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectPackage(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectPackage(obj: unknown, opts?: DeserializeOptions): Result<Package, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializePackage(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Package.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializePackage(value: any, ctx: DeserializeContext): Package | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Package.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("date" in obj)){errors.push({field: "date" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_date = obj["date" ]as string; instance.date = __raw_date; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Package;}export function validateFieldPackage<K extends keyof Package>(field: K, value: Package[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsPackage(partial: Partial<Package>): Array<{field: string; message: string}>{return[]; }export function hasShapePackage(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "date" in o;}export function isPackage(obj: unknown): obj is Package {if(!hasShapePackage(obj)){return false;}const result = fromObjectPackage(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsPackage = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            date: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedPackage = {id: Option<boolean>;
            date: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersPackage {readonly id: FieldController<string>;
            readonly date: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformPackage {readonly data: Package; readonly errors: ErrorsPackage; readonly tainted: TaintedPackage; readonly fields: FieldControllersPackage; validate(): Result<Package, Array<{field: string; message: string}>>; reset(overrides?: Partial<Package>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormPackage(overrides?: Partial<Package>): GigaformPackage {let data = $state({...defaultValuePackage(),...overrides}); let errors = $state<ErrorsPackage>({ _errors: Option.none(), id: Option.none(), date: Option.none() }); let tainted = $state<TaintedPackage>({ id: Option.none(), date: Option.none() }); const fields: FieldControllersPackage = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPackage("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                date: {
                    path: ["date"] as const,
                    name: "date",
                    constraints: { required: true },
                    label: "Date",
                    get: () => data.date,
                    set: (value: string) => { data.date = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.date,
                    setError: (value: Option<Array<string>>) => { errors.date = value; },
                    getTainted: () => tainted.date,
                    setTainted: (value: Option<boolean>) => { tainted.date = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPackage("date", data.date);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Package, Array<{field: string; message: string}>>{return fromObjectPackage(data);}function reset(newOverrides?: Partial<Package>): void {data = {...defaultValuePackage(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), date: Option.none() }; tainted = { id: Option.none(), date: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataPackage(formData: FormData): Result<Package, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.date = formData.get("date") ?? ""; return fromStringifiedJSONPackage(JSON.stringify(obj));}


export interface ScheduleSettings {
    daysPerWeek: number;
    
    rowHeight: RowHeight;
    visibleRoutes: string[];
    detailedCards: boolean;
}

export function defaultValueScheduleSettings(): ScheduleSettings {return {daysPerWeek: 0,
                            rowHeight: "Medium",
                            visibleRoutes: [],
                            detailedCards: false, }as ScheduleSettings;}

export function toStringifiedJSONScheduleSettings(value: ScheduleSettings): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeScheduleSettings(value, ctx));}export function toObjectScheduleSettings(value: ScheduleSettings): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeScheduleSettings(value, ctx);}export function __serializeScheduleSettings(value: ScheduleSettings, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "ScheduleSettings" , __id,}; result["daysPerWeek" ]= value.daysPerWeek; result["rowHeight" ]= __serializeRowHeight(value.rowHeight, ctx); result["visibleRoutes" ]= value.visibleRoutes; result["detailedCards" ]= value.detailedCards; return result;}

export function fromStringifiedJSONScheduleSettings(json: string, opts?: DeserializeOptions): Result<ScheduleSettings, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectScheduleSettings(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectScheduleSettings(obj: unknown, opts?: DeserializeOptions): Result<ScheduleSettings, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeScheduleSettings(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "ScheduleSettings.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeScheduleSettings(value: any, ctx: DeserializeContext): ScheduleSettings | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "ScheduleSettings.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("daysPerWeek" in obj)){errors.push({field: "daysPerWeek" , message: "missing required field" });}if(!("rowHeight" in obj)){errors.push({field: "rowHeight" , message: "missing required field" });}if(!("visibleRoutes" in obj)){errors.push({field: "visibleRoutes" , message: "missing required field" });}if(!("detailedCards" in obj)){errors.push({field: "detailedCards" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_daysPerWeek = obj["daysPerWeek" ]as number; instance.daysPerWeek = __raw_daysPerWeek; }{const __raw_rowHeight = obj["rowHeight" ]as RowHeight; {const __result = __deserializeRowHeight(__raw_rowHeight, ctx); ctx.assignOrDefer(instance, "rowHeight" , __result);}}{const __raw_visibleRoutes = obj["visibleRoutes" ]as string[]; if(Array.isArray(__raw_visibleRoutes)){instance.visibleRoutes = __raw_visibleRoutes as string[];}}{const __raw_detailedCards = obj["detailedCards" ]as boolean; instance.detailedCards = __raw_detailedCards; }if(errors.length>0){throw new DeserializeError(errors);}return instance as ScheduleSettings;}export function validateFieldScheduleSettings<K extends keyof ScheduleSettings>(field: K, value: ScheduleSettings[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsScheduleSettings(partial: Partial<ScheduleSettings>): Array<{field: string; message: string}>{return[]; }export function hasShapeScheduleSettings(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "daysPerWeek" in o && "rowHeight" in o && "visibleRoutes" in o && "detailedCards" in o;}export function isScheduleSettings(obj: unknown): obj is ScheduleSettings {if(!hasShapeScheduleSettings(obj)){return false;}const result = fromObjectScheduleSettings(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsScheduleSettings = {_errors: Option<Array<string>>; daysPerWeek: Option<Array<string>>;
            rowHeight: Option<Array<string>>;
            visibleRoutes: Option<Array<string>>;
            detailedCards: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedScheduleSettings = {daysPerWeek: Option<boolean>;
            rowHeight: Option<boolean>;
            visibleRoutes: Option<boolean>;
            detailedCards: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersScheduleSettings {readonly daysPerWeek: FieldController<number>;
            readonly rowHeight: FieldController<RowHeight>;
            readonly visibleRoutes: ArrayFieldController<string>;
            readonly detailedCards: FieldController<boolean>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformScheduleSettings {readonly data: ScheduleSettings; readonly errors: ErrorsScheduleSettings; readonly tainted: TaintedScheduleSettings; readonly fields: FieldControllersScheduleSettings; validate(): Result<ScheduleSettings, Array<{field: string; message: string}>>; reset(overrides?: Partial<ScheduleSettings>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormScheduleSettings(overrides?: Partial<ScheduleSettings>): GigaformScheduleSettings {let data = $state({...defaultValueScheduleSettings(),...overrides}); let errors = $state<ErrorsScheduleSettings>({ _errors: Option.none(), daysPerWeek: Option.none(), rowHeight: Option.none(), visibleRoutes: Option.none(), detailedCards: Option.none() }); let tainted = $state<TaintedScheduleSettings>({ daysPerWeek: Option.none(), rowHeight: Option.none(), visibleRoutes: Option.none(), detailedCards: Option.none() }); const fields: FieldControllersScheduleSettings = {daysPerWeek: {
                    path: ["daysPerWeek"] as const,
                    name: "daysPerWeek",
                    constraints: { required: true },
                    
                    get: () => data.daysPerWeek,
                    set: (value: number) => { data.daysPerWeek = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.daysPerWeek,
                    setError: (value: Option<Array<string>>) => { errors.daysPerWeek = value; },
                    getTainted: () => tainted.daysPerWeek,
                    setTainted: (value: Option<boolean>) => { tainted.daysPerWeek = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldScheduleSettings("daysPerWeek", data.daysPerWeek);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                rowHeight: {
                    path: ["rowHeight"] as const,
                    name: "rowHeight",
                    constraints: { required: true },
                    
                    get: () => data.rowHeight,
                    set: (value: RowHeight) => { data.rowHeight = value; },
                    transform: (value: RowHeight): RowHeight => value,
                    getError: () => errors.rowHeight,
                    setError: (value: Option<Array<string>>) => { errors.rowHeight = value; },
                    getTainted: () => tainted.rowHeight,
                    setTainted: (value: Option<boolean>) => { tainted.rowHeight = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldScheduleSettings("rowHeight", data.rowHeight);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                visibleRoutes: {
                    path: ["visibleRoutes"] as const,
                    name: "visibleRoutes",
                    constraints: { required: true },
                    
                    get: () => data.visibleRoutes,
                    set: (value: string[]) => { data.visibleRoutes = value; },
                    transform: (value: string[]): string[] => value,
                    getError: () => errors.visibleRoutes,
                    setError: (value: Option<Array<string>>) => { errors.visibleRoutes = value; },
                    getTainted: () => tainted.visibleRoutes,
                    setTainted: (value: Option<boolean>) => { tainted.visibleRoutes = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldScheduleSettings("visibleRoutes", data.visibleRoutes);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["visibleRoutes", index] as const,
                        name: `visibleRoutes.${index}`,
                        constraints: { required: true },
                        get: () => data.visibleRoutes[index]!,
                        set: (value: string) => { data.visibleRoutes[index] = value; },
                        transform: (value: string): string => value,
                        getError: () => errors.visibleRoutes,
                        setError: (value: Option<Array<string>>) => { errors.visibleRoutes = value; },
                        getTainted: () => tainted.visibleRoutes,
                        setTainted: (value: Option<boolean>) => { tainted.visibleRoutes = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: string) => { data.visibleRoutes.push(item); },
                    remove: (index: number) => { data.visibleRoutes.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.visibleRoutes[a]!;
                        data.visibleRoutes[a] = data.visibleRoutes[b]!;
                        data.visibleRoutes[b] = tmp;
                    },
                },
                detailedCards: {
                    path: ["detailedCards"] as const,
                    name: "detailedCards",
                    constraints: { required: true },
                    
                    get: () => data.detailedCards,
                    set: (value: boolean) => { data.detailedCards = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.detailedCards,
                    setError: (value: Option<Array<string>>) => { errors.detailedCards = value; },
                    getTainted: () => tainted.detailedCards,
                    setTainted: (value: Option<boolean>) => { tainted.detailedCards = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldScheduleSettings("detailedCards", data.detailedCards);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<ScheduleSettings, Array<{field: string; message: string}>>{return fromObjectScheduleSettings(data);}function reset(newOverrides?: Partial<ScheduleSettings>): void {data = {...defaultValueScheduleSettings(),...newOverrides}; errors = { _errors: Option.none(), daysPerWeek: Option.none(), rowHeight: Option.none(), visibleRoutes: Option.none(), detailedCards: Option.none() }; tainted = { daysPerWeek: Option.none(), rowHeight: Option.none(), visibleRoutes: Option.none(), detailedCards: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataScheduleSettings(formData: FormData): Result<ScheduleSettings, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const daysPerWeekStr = formData.get("daysPerWeek");
                obj.daysPerWeek = daysPerWeekStr ? parseFloat(daysPerWeekStr as string) : 0;
                if (obj.daysPerWeek !== undefined && isNaN(obj.daysPerWeek as number)) obj.daysPerWeek = 0;
            }
            {
            // Collect nested object fields with prefix "rowHeight."
            const rowHeightObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("rowHeight.")) {
                    const fieldName = key.slice("rowHeight.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = rowHeightObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.rowHeight = rowHeightObj;
        }
            obj.visibleRoutes = formData.getAll("visibleRoutes") as Array<string>;
            {
                const detailedCardsVal = formData.get("detailedCards");
                obj.detailedCards = detailedCardsVal === "true" || detailedCardsVal === "on" || detailedCardsVal === "1";
            } return fromStringifiedJSONScheduleSettings(JSON.stringify(obj));}


export interface DailyRecurrenceRule {
    quantityOfDays: number;
}

export function defaultValueDailyRecurrenceRule(): DailyRecurrenceRule {return {quantityOfDays: 0, }as DailyRecurrenceRule;}

export function toStringifiedJSONDailyRecurrenceRule(value: DailyRecurrenceRule): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeDailyRecurrenceRule(value, ctx));}export function toObjectDailyRecurrenceRule(value: DailyRecurrenceRule): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeDailyRecurrenceRule(value, ctx);}export function __serializeDailyRecurrenceRule(value: DailyRecurrenceRule, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "DailyRecurrenceRule" , __id,}; result["quantityOfDays" ]= value.quantityOfDays; return result;}

export function fromStringifiedJSONDailyRecurrenceRule(json: string, opts?: DeserializeOptions): Result<DailyRecurrenceRule, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectDailyRecurrenceRule(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectDailyRecurrenceRule(obj: unknown, opts?: DeserializeOptions): Result<DailyRecurrenceRule, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeDailyRecurrenceRule(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "DailyRecurrenceRule.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeDailyRecurrenceRule(value: any, ctx: DeserializeContext): DailyRecurrenceRule | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "DailyRecurrenceRule.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("quantityOfDays" in obj)){errors.push({field: "quantityOfDays" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_quantityOfDays = obj["quantityOfDays" ]as number; instance.quantityOfDays = __raw_quantityOfDays; }if(errors.length>0){throw new DeserializeError(errors);}return instance as DailyRecurrenceRule;}export function validateFieldDailyRecurrenceRule<K extends keyof DailyRecurrenceRule>(field: K, value: DailyRecurrenceRule[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsDailyRecurrenceRule(partial: Partial<DailyRecurrenceRule>): Array<{field: string; message: string}>{return[]; }export function hasShapeDailyRecurrenceRule(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "quantityOfDays" in o;}export function isDailyRecurrenceRule(obj: unknown): obj is DailyRecurrenceRule {if(!hasShapeDailyRecurrenceRule(obj)){return false;}const result = fromObjectDailyRecurrenceRule(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsDailyRecurrenceRule = {_errors: Option<Array<string>>; quantityOfDays: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedDailyRecurrenceRule = {quantityOfDays: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersDailyRecurrenceRule {readonly quantityOfDays: FieldController<number>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformDailyRecurrenceRule {readonly data: DailyRecurrenceRule; readonly errors: ErrorsDailyRecurrenceRule; readonly tainted: TaintedDailyRecurrenceRule; readonly fields: FieldControllersDailyRecurrenceRule; validate(): Result<DailyRecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<DailyRecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormDailyRecurrenceRule(overrides?: Partial<DailyRecurrenceRule>): GigaformDailyRecurrenceRule {let data = $state({...defaultValueDailyRecurrenceRule(),...overrides}); let errors = $state<ErrorsDailyRecurrenceRule>({ _errors: Option.none(), quantityOfDays: Option.none() }); let tainted = $state<TaintedDailyRecurrenceRule>({ quantityOfDays: Option.none() }); const fields: FieldControllersDailyRecurrenceRule = {quantityOfDays: {
                    path: ["quantityOfDays"] as const,
                    name: "quantityOfDays",
                    constraints: { required: true },
                    
                    get: () => data.quantityOfDays,
                    set: (value: number) => { data.quantityOfDays = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.quantityOfDays,
                    setError: (value: Option<Array<string>>) => { errors.quantityOfDays = value; },
                    getTainted: () => tainted.quantityOfDays,
                    setTainted: (value: Option<boolean>) => { tainted.quantityOfDays = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldDailyRecurrenceRule("quantityOfDays", data.quantityOfDays);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<DailyRecurrenceRule, Array<{field: string; message: string}>>{return fromObjectDailyRecurrenceRule(data);}function reset(newOverrides?: Partial<DailyRecurrenceRule>): void {data = {...defaultValueDailyRecurrenceRule(),...newOverrides}; errors = { _errors: Option.none(), quantityOfDays: Option.none() }; tainted = { quantityOfDays: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataDailyRecurrenceRule(formData: FormData): Result<DailyRecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const quantityOfDaysStr = formData.get("quantityOfDays");
                obj.quantityOfDays = quantityOfDaysStr ? parseFloat(quantityOfDaysStr as string) : 0;
                if (obj.quantityOfDays !== undefined && isNaN(obj.quantityOfDays as number)) obj.quantityOfDays = 0;
            } return fromStringifiedJSONDailyRecurrenceRule(JSON.stringify(obj));}


export interface SignUpCredentials {
    firstName: FirstName;
    lastName: LastName;
    email: EmailParts;
    password: Password;
    rememberMe: boolean;
}

export function defaultValueSignUpCredentials(): SignUpCredentials {return {firstName: defaultValueFirstName(),
                            lastName: defaultValueLastName(),
                            email: defaultValueEmailParts(),
                            password: defaultValuePassword(),
                            rememberMe: false, }as SignUpCredentials;}

export function toStringifiedJSONSignUpCredentials(value: SignUpCredentials): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeSignUpCredentials(value, ctx));}export function toObjectSignUpCredentials(value: SignUpCredentials): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeSignUpCredentials(value, ctx);}export function __serializeSignUpCredentials(value: SignUpCredentials, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "SignUpCredentials" , __id,}; result["firstName" ]= __serializeFirstName(value.firstName, ctx); result["lastName" ]= __serializeLastName(value.lastName, ctx); result["email" ]= __serializeEmailParts(value.email, ctx); result["password" ]= __serializePassword(value.password, ctx); result["rememberMe" ]= value.rememberMe; return result;}

export function fromStringifiedJSONSignUpCredentials(json: string, opts?: DeserializeOptions): Result<SignUpCredentials, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectSignUpCredentials(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectSignUpCredentials(obj: unknown, opts?: DeserializeOptions): Result<SignUpCredentials, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeSignUpCredentials(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "SignUpCredentials.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeSignUpCredentials(value: any, ctx: DeserializeContext): SignUpCredentials | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "SignUpCredentials.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("firstName" in obj)){errors.push({field: "firstName" , message: "missing required field" });}if(!("lastName" in obj)){errors.push({field: "lastName" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("password" in obj)){errors.push({field: "password" , message: "missing required field" });}if(!("rememberMe" in obj)){errors.push({field: "rememberMe" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_firstName = obj["firstName" ]as FirstName; {const __result = __deserializeFirstName(__raw_firstName, ctx); ctx.assignOrDefer(instance, "firstName" , __result);}}{const __raw_lastName = obj["lastName" ]as LastName; {const __result = __deserializeLastName(__raw_lastName, ctx); ctx.assignOrDefer(instance, "lastName" , __result);}}{const __raw_email = obj["email" ]as EmailParts; {const __result = __deserializeEmailParts(__raw_email, ctx); ctx.assignOrDefer(instance, "email" , __result);}}{const __raw_password = obj["password" ]as Password; {const __result = __deserializePassword(__raw_password, ctx); ctx.assignOrDefer(instance, "password" , __result);}}{const __raw_rememberMe = obj["rememberMe" ]as boolean; instance.rememberMe = __raw_rememberMe; }if(errors.length>0){throw new DeserializeError(errors);}return instance as SignUpCredentials;}export function validateFieldSignUpCredentials<K extends keyof SignUpCredentials>(field: K, value: SignUpCredentials[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsSignUpCredentials(partial: Partial<SignUpCredentials>): Array<{field: string; message: string}>{return[]; }export function hasShapeSignUpCredentials(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "firstName" in o && "lastName" in o && "email" in o && "password" in o && "rememberMe" in o;}export function isSignUpCredentials(obj: unknown): obj is SignUpCredentials {if(!hasShapeSignUpCredentials(obj)){return false;}const result = fromObjectSignUpCredentials(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsSignUpCredentials = {_errors: Option<Array<string>>; firstName: Option<Array<string>>;
            lastName: Option<Array<string>>;
            email: Option<Array<string>>;
            password: Option<Array<string>>;
            rememberMe: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedSignUpCredentials = {firstName: Option<boolean>;
            lastName: Option<boolean>;
            email: Option<boolean>;
            password: Option<boolean>;
            rememberMe: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersSignUpCredentials {readonly firstName: FieldController<FirstName>;
            readonly lastName: FieldController<LastName>;
            readonly email: FieldController<EmailParts>;
            readonly password: FieldController<Password>;
            readonly rememberMe: FieldController<boolean>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformSignUpCredentials {readonly data: SignUpCredentials; readonly errors: ErrorsSignUpCredentials; readonly tainted: TaintedSignUpCredentials; readonly fields: FieldControllersSignUpCredentials; validate(): Result<SignUpCredentials, Array<{field: string; message: string}>>; reset(overrides?: Partial<SignUpCredentials>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormSignUpCredentials(overrides?: Partial<SignUpCredentials>): GigaformSignUpCredentials {let data = $state({...defaultValueSignUpCredentials(),...overrides}); let errors = $state<ErrorsSignUpCredentials>({ _errors: Option.none(), firstName: Option.none(), lastName: Option.none(), email: Option.none(), password: Option.none(), rememberMe: Option.none() }); let tainted = $state<TaintedSignUpCredentials>({ firstName: Option.none(), lastName: Option.none(), email: Option.none(), password: Option.none(), rememberMe: Option.none() }); const fields: FieldControllersSignUpCredentials = {firstName: {
                    path: ["firstName"] as const,
                    name: "firstName",
                    constraints: { required: true },
                    
                    get: () => data.firstName,
                    set: (value: FirstName) => { data.firstName = value; },
                    transform: (value: FirstName): FirstName => value,
                    getError: () => errors.firstName,
                    setError: (value: Option<Array<string>>) => { errors.firstName = value; },
                    getTainted: () => tainted.firstName,
                    setTainted: (value: Option<boolean>) => { tainted.firstName = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSignUpCredentials("firstName", data.firstName);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                lastName: {
                    path: ["lastName"] as const,
                    name: "lastName",
                    constraints: { required: true },
                    
                    get: () => data.lastName,
                    set: (value: LastName) => { data.lastName = value; },
                    transform: (value: LastName): LastName => value,
                    getError: () => errors.lastName,
                    setError: (value: Option<Array<string>>) => { errors.lastName = value; },
                    getTainted: () => tainted.lastName,
                    setTainted: (value: Option<boolean>) => { tainted.lastName = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSignUpCredentials("lastName", data.lastName);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                email: {
                    path: ["email"] as const,
                    name: "email",
                    constraints: { required: true },
                    
                    get: () => data.email,
                    set: (value: EmailParts) => { data.email = value; },
                    transform: (value: EmailParts): EmailParts => value,
                    getError: () => errors.email,
                    setError: (value: Option<Array<string>>) => { errors.email = value; },
                    getTainted: () => tainted.email,
                    setTainted: (value: Option<boolean>) => { tainted.email = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSignUpCredentials("email", data.email);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                password: {
                    path: ["password"] as const,
                    name: "password",
                    constraints: { required: true },
                    
                    get: () => data.password,
                    set: (value: Password) => { data.password = value; },
                    transform: (value: Password): Password => value,
                    getError: () => errors.password,
                    setError: (value: Option<Array<string>>) => { errors.password = value; },
                    getTainted: () => tainted.password,
                    setTainted: (value: Option<boolean>) => { tainted.password = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSignUpCredentials("password", data.password);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                rememberMe: {
                    path: ["rememberMe"] as const,
                    name: "rememberMe",
                    constraints: { required: true },
                    
                    get: () => data.rememberMe,
                    set: (value: boolean) => { data.rememberMe = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.rememberMe,
                    setError: (value: Option<Array<string>>) => { errors.rememberMe = value; },
                    getTainted: () => tainted.rememberMe,
                    setTainted: (value: Option<boolean>) => { tainted.rememberMe = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSignUpCredentials("rememberMe", data.rememberMe);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<SignUpCredentials, Array<{field: string; message: string}>>{return fromObjectSignUpCredentials(data);}function reset(newOverrides?: Partial<SignUpCredentials>): void {data = {...defaultValueSignUpCredentials(),...newOverrides}; errors = { _errors: Option.none(), firstName: Option.none(), lastName: Option.none(), email: Option.none(), password: Option.none(), rememberMe: Option.none() }; tainted = { firstName: Option.none(), lastName: Option.none(), email: Option.none(), password: Option.none(), rememberMe: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataSignUpCredentials(formData: FormData): Result<SignUpCredentials, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
            // Collect nested object fields with prefix "firstName."
            const firstNameObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("firstName.")) {
                    const fieldName = key.slice("firstName.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = firstNameObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.firstName = firstNameObj;
        }
            {
            // Collect nested object fields with prefix "lastName."
            const lastNameObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("lastName.")) {
                    const fieldName = key.slice("lastName.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = lastNameObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.lastName = lastNameObj;
        }
            {
            // Collect nested object fields with prefix "email."
            const emailObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("email.")) {
                    const fieldName = key.slice("email.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = emailObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.email = emailObj;
        }
            {
            // Collect nested object fields with prefix "password."
            const passwordObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("password.")) {
                    const fieldName = key.slice("password.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = passwordObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.password = passwordObj;
        }
            {
                const rememberMeVal = formData.get("rememberMe");
                obj.rememberMe = rememberMeVal === "true" || rememberMeVal === "on" || rememberMeVal === "1";
            } return fromStringifiedJSONSignUpCredentials(JSON.stringify(obj));}


export interface OverviewSettings {
    
    rowHeight: RowHeight;
    
    cardOrRow: OverviewDisplay;
    perPage: number;
    columnConfigs: ColumnConfig[];
}

export function defaultValueOverviewSettings(): OverviewSettings {return {rowHeight: "Medium",
                            cardOrRow: "Table",
                            perPage: 0,
                            columnConfigs: [], }as OverviewSettings;}

export function toStringifiedJSONOverviewSettings(value: OverviewSettings): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeOverviewSettings(value, ctx));}export function toObjectOverviewSettings(value: OverviewSettings): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeOverviewSettings(value, ctx);}export function __serializeOverviewSettings(value: OverviewSettings, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "OverviewSettings" , __id,}; result["rowHeight" ]= __serializeRowHeight(value.rowHeight, ctx); result["cardOrRow" ]= __serializeOverviewDisplay(value.cardOrRow, ctx); result["perPage" ]= value.perPage; result["columnConfigs" ]= value.columnConfigs.map((item)=>__serializeColumnConfig(item, ctx)); return result;}

export function fromStringifiedJSONOverviewSettings(json: string, opts?: DeserializeOptions): Result<OverviewSettings, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectOverviewSettings(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectOverviewSettings(obj: unknown, opts?: DeserializeOptions): Result<OverviewSettings, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeOverviewSettings(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "OverviewSettings.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeOverviewSettings(value: any, ctx: DeserializeContext): OverviewSettings | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "OverviewSettings.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("rowHeight" in obj)){errors.push({field: "rowHeight" , message: "missing required field" });}if(!("cardOrRow" in obj)){errors.push({field: "cardOrRow" , message: "missing required field" });}if(!("perPage" in obj)){errors.push({field: "perPage" , message: "missing required field" });}if(!("columnConfigs" in obj)){errors.push({field: "columnConfigs" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_rowHeight = obj["rowHeight" ]as RowHeight; {const __result = __deserializeRowHeight(__raw_rowHeight, ctx); ctx.assignOrDefer(instance, "rowHeight" , __result);}}{const __raw_cardOrRow = obj["cardOrRow" ]as OverviewDisplay; {const __result = __deserializeOverviewDisplay(__raw_cardOrRow, ctx); ctx.assignOrDefer(instance, "cardOrRow" , __result);}}{const __raw_perPage = obj["perPage" ]as number; instance.perPage = __raw_perPage; }{const __raw_columnConfigs = obj["columnConfigs" ]as ColumnConfig[]; if(Array.isArray(__raw_columnConfigs)){instance.columnConfigs = __raw_columnConfigs as ColumnConfig[];}}if(errors.length>0){throw new DeserializeError(errors);}return instance as OverviewSettings;}export function validateFieldOverviewSettings<K extends keyof OverviewSettings>(field: K, value: OverviewSettings[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsOverviewSettings(partial: Partial<OverviewSettings>): Array<{field: string; message: string}>{return[]; }export function hasShapeOverviewSettings(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "rowHeight" in o && "cardOrRow" in o && "perPage" in o && "columnConfigs" in o;}export function isOverviewSettings(obj: unknown): obj is OverviewSettings {if(!hasShapeOverviewSettings(obj)){return false;}const result = fromObjectOverviewSettings(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsOverviewSettings = {_errors: Option<Array<string>>; rowHeight: Option<Array<string>>;
            cardOrRow: Option<Array<string>>;
            perPage: Option<Array<string>>;
            columnConfigs: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedOverviewSettings = {rowHeight: Option<boolean>;
            cardOrRow: Option<boolean>;
            perPage: Option<boolean>;
            columnConfigs: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersOverviewSettings {readonly rowHeight: FieldController<RowHeight>;
            readonly cardOrRow: FieldController<OverviewDisplay>;
            readonly perPage: FieldController<number>;
            readonly columnConfigs: ArrayFieldController<ColumnConfig>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformOverviewSettings {readonly data: OverviewSettings; readonly errors: ErrorsOverviewSettings; readonly tainted: TaintedOverviewSettings; readonly fields: FieldControllersOverviewSettings; validate(): Result<OverviewSettings, Array<{field: string; message: string}>>; reset(overrides?: Partial<OverviewSettings>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormOverviewSettings(overrides?: Partial<OverviewSettings>): GigaformOverviewSettings {let data = $state({...defaultValueOverviewSettings(),...overrides}); let errors = $state<ErrorsOverviewSettings>({ _errors: Option.none(), rowHeight: Option.none(), cardOrRow: Option.none(), perPage: Option.none(), columnConfigs: Option.none() }); let tainted = $state<TaintedOverviewSettings>({ rowHeight: Option.none(), cardOrRow: Option.none(), perPage: Option.none(), columnConfigs: Option.none() }); const fields: FieldControllersOverviewSettings = {rowHeight: {
                    path: ["rowHeight"] as const,
                    name: "rowHeight",
                    constraints: { required: true },
                    
                    get: () => data.rowHeight,
                    set: (value: RowHeight) => { data.rowHeight = value; },
                    transform: (value: RowHeight): RowHeight => value,
                    getError: () => errors.rowHeight,
                    setError: (value: Option<Array<string>>) => { errors.rowHeight = value; },
                    getTainted: () => tainted.rowHeight,
                    setTainted: (value: Option<boolean>) => { tainted.rowHeight = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOverviewSettings("rowHeight", data.rowHeight);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                cardOrRow: {
                    path: ["cardOrRow"] as const,
                    name: "cardOrRow",
                    constraints: { required: true },
                    
                    get: () => data.cardOrRow,
                    set: (value: OverviewDisplay) => { data.cardOrRow = value; },
                    transform: (value: OverviewDisplay): OverviewDisplay => value,
                    getError: () => errors.cardOrRow,
                    setError: (value: Option<Array<string>>) => { errors.cardOrRow = value; },
                    getTainted: () => tainted.cardOrRow,
                    setTainted: (value: Option<boolean>) => { tainted.cardOrRow = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOverviewSettings("cardOrRow", data.cardOrRow);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                perPage: {
                    path: ["perPage"] as const,
                    name: "perPage",
                    constraints: { required: true },
                    
                    get: () => data.perPage,
                    set: (value: number) => { data.perPage = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.perPage,
                    setError: (value: Option<Array<string>>) => { errors.perPage = value; },
                    getTainted: () => tainted.perPage,
                    setTainted: (value: Option<boolean>) => { tainted.perPage = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOverviewSettings("perPage", data.perPage);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                columnConfigs: {
                    path: ["columnConfigs"] as const,
                    name: "columnConfigs",
                    constraints: { required: true },
                    
                    get: () => data.columnConfigs,
                    set: (value: ColumnConfig[]) => { data.columnConfigs = value; },
                    transform: (value: ColumnConfig[]): ColumnConfig[] => value,
                    getError: () => errors.columnConfigs,
                    setError: (value: Option<Array<string>>) => { errors.columnConfigs = value; },
                    getTainted: () => tainted.columnConfigs,
                    setTainted: (value: Option<boolean>) => { tainted.columnConfigs = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOverviewSettings("columnConfigs", data.columnConfigs);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["columnConfigs", index] as const,
                        name: `columnConfigs.${index}`,
                        constraints: { required: true },
                        get: () => data.columnConfigs[index]!,
                        set: (value: ColumnConfig) => { data.columnConfigs[index] = value; },
                        transform: (value: ColumnConfig): ColumnConfig => value,
                        getError: () => errors.columnConfigs,
                        setError: (value: Option<Array<string>>) => { errors.columnConfigs = value; },
                        getTainted: () => tainted.columnConfigs,
                        setTainted: (value: Option<boolean>) => { tainted.columnConfigs = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: ColumnConfig) => { data.columnConfigs.push(item); },
                    remove: (index: number) => { data.columnConfigs.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.columnConfigs[a]!;
                        data.columnConfigs[a] = data.columnConfigs[b]!;
                        data.columnConfigs[b] = tmp;
                    },
                }}; function validate(): Result<OverviewSettings, Array<{field: string; message: string}>>{return fromObjectOverviewSettings(data);}function reset(newOverrides?: Partial<OverviewSettings>): void {data = {...defaultValueOverviewSettings(),...newOverrides}; errors = { _errors: Option.none(), rowHeight: Option.none(), cardOrRow: Option.none(), perPage: Option.none(), columnConfigs: Option.none() }; tainted = { rowHeight: Option.none(), cardOrRow: Option.none(), perPage: Option.none(), columnConfigs: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataOverviewSettings(formData: FormData): Result<OverviewSettings, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
            // Collect nested object fields with prefix "rowHeight."
            const rowHeightObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("rowHeight.")) {
                    const fieldName = key.slice("rowHeight.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = rowHeightObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.rowHeight = rowHeightObj;
        }
            {
            // Collect nested object fields with prefix "cardOrRow."
            const cardOrRowObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("cardOrRow.")) {
                    const fieldName = key.slice("cardOrRow.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = cardOrRowObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.cardOrRow = cardOrRowObj;
        }
            {
                const perPageStr = formData.get("perPage");
                obj.perPage = perPageStr ? parseFloat(perPageStr as string) : 0;
                if (obj.perPage !== undefined && isNaN(obj.perPage as number)) obj.perPage = 0;
            }
            {
                // Collect array items from indexed form fields
                const columnConfigsItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("columnConfigs." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("columnConfigs." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("columnConfigs." + idx + ".")) {
                                const fieldName = key.slice("columnConfigs.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        columnConfigsItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.columnConfigs = columnConfigsItems;
            } return fromStringifiedJSONOverviewSettings(JSON.stringify(obj));}


export interface FirstName {
    
    name: string;
}

export function defaultValueFirstName(): FirstName {return {name: "", }as FirstName;}

export function toStringifiedJSONFirstName(value: FirstName): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeFirstName(value, ctx));}export function toObjectFirstName(value: FirstName): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeFirstName(value, ctx);}export function __serializeFirstName(value: FirstName, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "FirstName" , __id,}; result["name" ]= value.name; return result;}

export function fromStringifiedJSONFirstName(json: string, opts?: DeserializeOptions): Result<FirstName, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectFirstName(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectFirstName(obj: unknown, opts?: DeserializeOptions): Result<FirstName, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeFirstName(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "FirstName.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeFirstName(value: any, ctx: DeserializeContext): FirstName | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "FirstName.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }if(errors.length>0){throw new DeserializeError(errors);}return instance as FirstName;}export function validateFieldFirstName<K extends keyof FirstName>(field: K, value: FirstName[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsFirstName(partial: Partial<FirstName>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}return errors; }export function hasShapeFirstName(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "name" in o;}export function isFirstName(obj: unknown): obj is FirstName {if(!hasShapeFirstName(obj)){return false;}const result = fromObjectFirstName(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsFirstName = {_errors: Option<Array<string>>; name: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedFirstName = {name: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersFirstName {readonly name: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformFirstName {readonly data: FirstName; readonly errors: ErrorsFirstName; readonly tainted: TaintedFirstName; readonly fields: FieldControllersFirstName; validate(): Result<FirstName, Array<{field: string; message: string}>>; reset(overrides?: Partial<FirstName>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormFirstName(overrides?: Partial<FirstName>): GigaformFirstName {let data = $state({...defaultValueFirstName(),...overrides}); let errors = $state<ErrorsFirstName>({ _errors: Option.none(), name: Option.none() }); let tainted = $state<TaintedFirstName>({ name: Option.none() }); const fields: FieldControllersFirstName = {name: {
                    path: ["name"] as const,
                    name: "name",
                    constraints: { required: true },
                    
                    get: () => data.name,
                    set: (value: string) => { data.name = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.name,
                    setError: (value: Option<Array<string>>) => { errors.name = value; },
                    getTainted: () => tainted.name,
                    setTainted: (value: Option<boolean>) => { tainted.name = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldFirstName("name", data.name);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<FirstName, Array<{field: string; message: string}>>{return fromObjectFirstName(data);}function reset(newOverrides?: Partial<FirstName>): void {data = {...defaultValueFirstName(),...newOverrides}; errors = { _errors: Option.none(), name: Option.none() }; tainted = { name: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataFirstName(formData: FormData): Result<FirstName, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.name = formData.get("name") ?? ""; return fromStringifiedJSONFirstName(JSON.stringify(obj));}


export interface Account {
    
    id: string;
    
    
    taxRate: string | TaxRate;
    
    
    site: string | Site;
    
    salesRep: Represents[] | null;
    
    orders: Ordered[];
    
    activity: Did[];
    
    customFields: [string, string][];
    
    accountName: AccountName;
    
    
    sector: Sector;
    
    memo: string | null;
    
    phones: PhoneNumber[];
    
    email: Email;
    
    
    leadSource: string;
    
    colors: Colors;
    
    needsReview: boolean;
    
    hasAlert: boolean;
    
    
    accountType: string;
    
    
    subtype: string;
    
    isTaxExempt: boolean;
    
    
    paymentTerms: string;
    
    tags: string[];
    
    dateAdded: string;
}

export function defaultValueAccount(): Account {return {id: "",
                            taxRate: "",
                            site: "",
                            salesRep: null,
                            orders: [],
                            activity: [],
                            customFields: [],
                            accountName: defaultValueAccountName(),
                            sector: "Residential",
                            memo: null,
                            phones: [],
                            email: defaultValueEmail(),
                            leadSource: "",
                            colors: defaultValueColors(),
                            needsReview: false,
                            hasAlert: false,
                            accountType: "",
                            subtype: "",
                            isTaxExempt: false,
                            paymentTerms: "",
                            tags: [],
                            dateAdded: "", }as Account;}

export function toStringifiedJSONAccount(value: Account): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeAccount(value, ctx));}export function toObjectAccount(value: Account): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeAccount(value, ctx);}export function __serializeAccount(value: Account, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Account" , __id,}; result["id" ]= value.id; result["taxRate" ]= value.taxRate; result["site" ]= value.site; if(value.salesRep!== null){result["salesRep" ]= value.salesRep; }else {result["salesRep" ]= null;}result["orders" ]= value.orders.map((item)=>__serializeOrdered(item, ctx)); result["activity" ]= value.activity.map((item)=>__serializeDid(item, ctx)); result["customFields" ]= value.customFields; result["accountName" ]= __serializeAccountName(value.accountName, ctx); result["sector" ]= __serializeSector(value.sector, ctx); result["memo" ]= value.memo; result["phones" ]= value.phones.map((item)=>__serializePhoneNumber(item, ctx)); result["email" ]= __serializeEmail(value.email, ctx); result["leadSource" ]= value.leadSource; result["colors" ]= __serializeColors(value.colors, ctx); result["needsReview" ]= value.needsReview; result["hasAlert" ]= value.hasAlert; result["accountType" ]= value.accountType; result["subtype" ]= value.subtype; result["isTaxExempt" ]= value.isTaxExempt; result["paymentTerms" ]= value.paymentTerms; result["tags" ]= value.tags; result["dateAdded" ]= value.dateAdded; return result;}

export function fromStringifiedJSONAccount(json: string, opts?: DeserializeOptions): Result<Account, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectAccount(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectAccount(obj: unknown, opts?: DeserializeOptions): Result<Account, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeAccount(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Account.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeAccount(value: any, ctx: DeserializeContext): Account | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Account.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("taxRate" in obj)){errors.push({field: "taxRate" , message: "missing required field" });}if(!("site" in obj)){errors.push({field: "site" , message: "missing required field" });}if(!("salesRep" in obj)){errors.push({field: "salesRep" , message: "missing required field" });}if(!("orders" in obj)){errors.push({field: "orders" , message: "missing required field" });}if(!("activity" in obj)){errors.push({field: "activity" , message: "missing required field" });}if(!("customFields" in obj)){errors.push({field: "customFields" , message: "missing required field" });}if(!("accountName" in obj)){errors.push({field: "accountName" , message: "missing required field" });}if(!("sector" in obj)){errors.push({field: "sector" , message: "missing required field" });}if(!("memo" in obj)){errors.push({field: "memo" , message: "missing required field" });}if(!("phones" in obj)){errors.push({field: "phones" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("leadSource" in obj)){errors.push({field: "leadSource" , message: "missing required field" });}if(!("colors" in obj)){errors.push({field: "colors" , message: "missing required field" });}if(!("needsReview" in obj)){errors.push({field: "needsReview" , message: "missing required field" });}if(!("hasAlert" in obj)){errors.push({field: "hasAlert" , message: "missing required field" });}if(!("accountType" in obj)){errors.push({field: "accountType" , message: "missing required field" });}if(!("subtype" in obj)){errors.push({field: "subtype" , message: "missing required field" });}if(!("isTaxExempt" in obj)){errors.push({field: "isTaxExempt" , message: "missing required field" });}if(!("paymentTerms" in obj)){errors.push({field: "paymentTerms" , message: "missing required field" });}if(!("tags" in obj)){errors.push({field: "tags" , message: "missing required field" });}if(!("dateAdded" in obj)){errors.push({field: "dateAdded" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_taxRate = obj["taxRate" ]as string | TaxRate; instance.taxRate = __raw_taxRate; }{const __raw_site = obj["site" ]as string | Site; instance.site = __raw_site; }{const __raw_salesRep = obj["salesRep" ]as Represents[] | null; if(__raw_salesRep === null){instance.salesRep = null;}else {instance.salesRep = __raw_salesRep; }}{const __raw_orders = obj["orders" ]as Ordered[]; if(Array.isArray(__raw_orders)){instance.orders = __raw_orders as Ordered[];}}{const __raw_activity = obj["activity" ]as Did[]; if(Array.isArray(__raw_activity)){instance.activity = __raw_activity as Did[];}}{const __raw_customFields = obj["customFields" ]as [string, string][]; if(Array.isArray(__raw_customFields)){instance.customFields = __raw_customFields as [string, string][];}}{const __raw_accountName = obj["accountName" ]as AccountName; {const __result = __deserializeAccountName(__raw_accountName, ctx); ctx.assignOrDefer(instance, "accountName" , __result);}}{const __raw_sector = obj["sector" ]as Sector; {const __result = __deserializeSector(__raw_sector, ctx); ctx.assignOrDefer(instance, "sector" , __result);}}{const __raw_memo = obj["memo" ]as string | null; instance.memo = __raw_memo; }{const __raw_phones = obj["phones" ]as PhoneNumber[]; if(Array.isArray(__raw_phones)){instance.phones = __raw_phones as PhoneNumber[];}}{const __raw_email = obj["email" ]as Email; {const __result = __deserializeEmail(__raw_email, ctx); ctx.assignOrDefer(instance, "email" , __result);}}{const __raw_leadSource = obj["leadSource" ]as string; 
                if (__raw_leadSource.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
 instance.leadSource = __raw_leadSource; }{const __raw_colors = obj["colors" ]as Colors; {const __result = __deserializeColors(__raw_colors, ctx); ctx.assignOrDefer(instance, "colors" , __result);}}{const __raw_needsReview = obj["needsReview" ]as boolean; instance.needsReview = __raw_needsReview; }{const __raw_hasAlert = obj["hasAlert" ]as boolean; instance.hasAlert = __raw_hasAlert; }{const __raw_accountType = obj["accountType" ]as string; 
                if (__raw_accountType.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
 instance.accountType = __raw_accountType; }{const __raw_subtype = obj["subtype" ]as string; 
                if (__raw_subtype.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
 instance.subtype = __raw_subtype; }{const __raw_isTaxExempt = obj["isTaxExempt" ]as boolean; instance.isTaxExempt = __raw_isTaxExempt; }{const __raw_paymentTerms = obj["paymentTerms" ]as string; 
                if (__raw_paymentTerms.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
 instance.paymentTerms = __raw_paymentTerms; }{const __raw_tags = obj["tags" ]as string[]; if(Array.isArray(__raw_tags)){instance.tags = __raw_tags as string[];}}{const __raw_dateAdded = obj["dateAdded" ]as string; instance.dateAdded = __raw_dateAdded; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Account;}export function validateFieldAccount<K extends keyof Account>(field: K, value: Account[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "leadSource" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
 break;}case "accountType" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
 break;}case "subtype" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
 break;}case "paymentTerms" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsAccount(partial: Partial<Account>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("leadSource" in partial && partial.leadSource!== undefined){const __val = partial.leadSource as string; 
                if (__val.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
}if("accountType" in partial && partial.accountType!== undefined){const __val = partial.accountType as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
}if("subtype" in partial && partial.subtype!== undefined){const __val = partial.subtype as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
}if("paymentTerms" in partial && partial.paymentTerms!== undefined){const __val = partial.paymentTerms as string; 
                if (__val.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
}return errors; }export function hasShapeAccount(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "taxRate" in o && "site" in o && "salesRep" in o && "orders" in o && "activity" in o && "customFields" in o && "accountName" in o && "sector" in o && "memo" in o && "phones" in o && "email" in o && "leadSource" in o && "colors" in o && "needsReview" in o && "hasAlert" in o && "accountType" in o && "subtype" in o && "isTaxExempt" in o && "paymentTerms" in o && "tags" in o && "dateAdded" in o;}export function isAccount(obj: unknown): obj is Account {if(!hasShapeAccount(obj)){return false;}const result = fromObjectAccount(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsAccount = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            taxRate: Option<Array<string>>;
            site: Option<Array<string>>;
            salesRep: Option<Array<string>>;
            orders: Option<Array<string>>;
            activity: Option<Array<string>>;
            customFields: Option<Array<string>>;
            accountName: Option<Array<string>>;
            sector: Option<Array<string>>;
            memo: Option<Array<string>>;
            phones: Option<Array<string>>;
            email: Option<Array<string>>;
            leadSource: Option<Array<string>>;
            colors: Option<Array<string>>;
            needsReview: Option<Array<string>>;
            hasAlert: Option<Array<string>>;
            accountType: Option<Array<string>>;
            subtype: Option<Array<string>>;
            isTaxExempt: Option<Array<string>>;
            paymentTerms: Option<Array<string>>;
            tags: Option<Array<string>>;
            dateAdded: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedAccount = {id: Option<boolean>;
            taxRate: Option<boolean>;
            site: Option<boolean>;
            salesRep: Option<boolean>;
            orders: Option<boolean>;
            activity: Option<boolean>;
            customFields: Option<boolean>;
            accountName: Option<boolean>;
            sector: Option<boolean>;
            memo: Option<boolean>;
            phones: Option<boolean>;
            email: Option<boolean>;
            leadSource: Option<boolean>;
            colors: Option<boolean>;
            needsReview: Option<boolean>;
            hasAlert: Option<boolean>;
            accountType: Option<boolean>;
            subtype: Option<boolean>;
            isTaxExempt: Option<boolean>;
            paymentTerms: Option<boolean>;
            tags: Option<boolean>;
            dateAdded: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersAccount {readonly id: FieldController<string>;
            readonly taxRate: FieldController<string | TaxRate>;
            readonly site: FieldController<string | Site>;
            readonly salesRep: FieldController<Represents[] | null>;
            readonly orders: ArrayFieldController<Ordered>;
            readonly activity: ArrayFieldController<Did>;
            readonly customFields: ArrayFieldController<[string, string]>;
            readonly accountName: FieldController<AccountName>;
            readonly sector: FieldController<Sector>;
            readonly memo: FieldController<string | null>;
            readonly phones: ArrayFieldController<PhoneNumber>;
            readonly email: FieldController<Email>;
            readonly leadSource: FieldController<string>;
            readonly colors: FieldController<Colors>;
            readonly needsReview: FieldController<boolean>;
            readonly hasAlert: FieldController<boolean>;
            readonly accountType: FieldController<string>;
            readonly subtype: FieldController<string>;
            readonly isTaxExempt: FieldController<boolean>;
            readonly paymentTerms: FieldController<string>;
            readonly tags: ArrayFieldController<string>;
            readonly dateAdded: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformAccount {readonly data: Account; readonly errors: ErrorsAccount; readonly tainted: TaintedAccount; readonly fields: FieldControllersAccount; validate(): Result<Account, Array<{field: string; message: string}>>; reset(overrides?: Partial<Account>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormAccount(overrides?: Partial<Account>): GigaformAccount {let data = $state({...defaultValueAccount(),...overrides}); let errors = $state<ErrorsAccount>({ _errors: Option.none(), id: Option.none(), taxRate: Option.none(), site: Option.none(), salesRep: Option.none(), orders: Option.none(), activity: Option.none(), customFields: Option.none(), accountName: Option.none(), sector: Option.none(), memo: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), colors: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), dateAdded: Option.none() }); let tainted = $state<TaintedAccount>({ id: Option.none(), taxRate: Option.none(), site: Option.none(), salesRep: Option.none(), orders: Option.none(), activity: Option.none(), customFields: Option.none(), accountName: Option.none(), sector: Option.none(), memo: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), colors: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), dateAdded: Option.none() }); const fields: FieldControllersAccount = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                taxRate: {
                    path: ["taxRate"] as const,
                    name: "taxRate",
                    constraints: { required: true },
                    label: "Tax Rate",
                    get: () => data.taxRate,
                    set: (value: string | TaxRate) => { data.taxRate = value; },
                    transform: (value: string | TaxRate): string | TaxRate => value,
                    getError: () => errors.taxRate,
                    setError: (value: Option<Array<string>>) => { errors.taxRate = value; },
                    getTainted: () => tainted.taxRate,
                    setTainted: (value: Option<boolean>) => { tainted.taxRate = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("taxRate", data.taxRate);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                site: {
                    path: ["site"] as const,
                    name: "site",
                    constraints: { required: true },
                    label: "Site",
                    get: () => data.site,
                    set: (value: string | Site) => { data.site = value; },
                    transform: (value: string | Site): string | Site => value,
                    getError: () => errors.site,
                    setError: (value: Option<Array<string>>) => { errors.site = value; },
                    getTainted: () => tainted.site,
                    setTainted: (value: Option<boolean>) => { tainted.site = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("site", data.site);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                salesRep: {
                    path: ["salesRep"] as const,
                    name: "salesRep",
                    constraints: { required: true },
                    label: "Sales Rep",
                    get: () => data.salesRep,
                    set: (value: Represents[] | null) => { data.salesRep = value; },
                    transform: (value: Represents[] | null): Represents[] | null => value,
                    getError: () => errors.salesRep,
                    setError: (value: Option<Array<string>>) => { errors.salesRep = value; },
                    getTainted: () => tainted.salesRep,
                    setTainted: (value: Option<boolean>) => { tainted.salesRep = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("salesRep", data.salesRep);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                orders: {
                    path: ["orders"] as const,
                    name: "orders",
                    constraints: { required: true },
                    
                    get: () => data.orders,
                    set: (value: Ordered[]) => { data.orders = value; },
                    transform: (value: Ordered[]): Ordered[] => value,
                    getError: () => errors.orders,
                    setError: (value: Option<Array<string>>) => { errors.orders = value; },
                    getTainted: () => tainted.orders,
                    setTainted: (value: Option<boolean>) => { tainted.orders = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("orders", data.orders);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["orders", index] as const,
                        name: `orders.${index}`,
                        constraints: { required: true },
                        get: () => data.orders[index]!,
                        set: (value: Ordered) => { data.orders[index] = value; },
                        transform: (value: Ordered): Ordered => value,
                        getError: () => errors.orders,
                        setError: (value: Option<Array<string>>) => { errors.orders = value; },
                        getTainted: () => tainted.orders,
                        setTainted: (value: Option<boolean>) => { tainted.orders = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: Ordered) => { data.orders.push(item); },
                    remove: (index: number) => { data.orders.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.orders[a]!;
                        data.orders[a] = data.orders[b]!;
                        data.orders[b] = tmp;
                    },
                },
                activity: {
                    path: ["activity"] as const,
                    name: "activity",
                    constraints: { required: true },
                    
                    get: () => data.activity,
                    set: (value: Did[]) => { data.activity = value; },
                    transform: (value: Did[]): Did[] => value,
                    getError: () => errors.activity,
                    setError: (value: Option<Array<string>>) => { errors.activity = value; },
                    getTainted: () => tainted.activity,
                    setTainted: (value: Option<boolean>) => { tainted.activity = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("activity", data.activity);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["activity", index] as const,
                        name: `activity.${index}`,
                        constraints: { required: true },
                        get: () => data.activity[index]!,
                        set: (value: Did) => { data.activity[index] = value; },
                        transform: (value: Did): Did => value,
                        getError: () => errors.activity,
                        setError: (value: Option<Array<string>>) => { errors.activity = value; },
                        getTainted: () => tainted.activity,
                        setTainted: (value: Option<boolean>) => { tainted.activity = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: Did) => { data.activity.push(item); },
                    remove: (index: number) => { data.activity.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.activity[a]!;
                        data.activity[a] = data.activity[b]!;
                        data.activity[b] = tmp;
                    },
                },
                customFields: {
                    path: ["customFields"] as const,
                    name: "customFields",
                    constraints: { required: true },
                    
                    get: () => data.customFields,
                    set: (value: [string, string][]) => { data.customFields = value; },
                    transform: (value: [string, string][]): [string, string][] => value,
                    getError: () => errors.customFields,
                    setError: (value: Option<Array<string>>) => { errors.customFields = value; },
                    getTainted: () => tainted.customFields,
                    setTainted: (value: Option<boolean>) => { tainted.customFields = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("customFields", data.customFields);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["customFields", index] as const,
                        name: `customFields.${index}`,
                        constraints: { required: true },
                        get: () => data.customFields[index]!,
                        set: (value: [string, string]) => { data.customFields[index] = value; },
                        transform: (value: [string, string]): [string, string] => value,
                        getError: () => errors.customFields,
                        setError: (value: Option<Array<string>>) => { errors.customFields = value; },
                        getTainted: () => tainted.customFields,
                        setTainted: (value: Option<boolean>) => { tainted.customFields = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: [string, string]) => { data.customFields.push(item); },
                    remove: (index: number) => { data.customFields.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.customFields[a]!;
                        data.customFields[a] = data.customFields[b]!;
                        data.customFields[b] = tmp;
                    },
                },
                accountName: {
                    path: ["accountName"] as const,
                    name: "accountName",
                    constraints: { required: true },
                    
                    get: () => data.accountName,
                    set: (value: AccountName) => { data.accountName = value; },
                    transform: (value: AccountName): AccountName => value,
                    getError: () => errors.accountName,
                    setError: (value: Option<Array<string>>) => { errors.accountName = value; },
                    getTainted: () => tainted.accountName,
                    setTainted: (value: Option<boolean>) => { tainted.accountName = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("accountName", data.accountName);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                sector: {
                    path: ["sector"] as const,
                    name: "sector",
                    constraints: { required: true },
                    label: "Sector",
                    get: () => data.sector,
                    set: (value: Sector) => { data.sector = value; },
                    transform: (value: Sector): Sector => value,
                    getError: () => errors.sector,
                    setError: (value: Option<Array<string>>) => { errors.sector = value; },
                    getTainted: () => tainted.sector,
                    setTainted: (value: Option<boolean>) => { tainted.sector = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("sector", data.sector);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                memo: {
                    path: ["memo"] as const,
                    name: "memo",
                    constraints: { required: true },
                    label: "Memo",
                    get: () => data.memo,
                    set: (value: string | null) => { data.memo = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.memo,
                    setError: (value: Option<Array<string>>) => { errors.memo = value; },
                    getTainted: () => tainted.memo,
                    setTainted: (value: Option<boolean>) => { tainted.memo = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("memo", data.memo);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                phones: {
                    path: ["phones"] as const,
                    name: "phones",
                    constraints: { required: true },
                    
                    get: () => data.phones,
                    set: (value: PhoneNumber[]) => { data.phones = value; },
                    transform: (value: PhoneNumber[]): PhoneNumber[] => value,
                    getError: () => errors.phones,
                    setError: (value: Option<Array<string>>) => { errors.phones = value; },
                    getTainted: () => tainted.phones,
                    setTainted: (value: Option<boolean>) => { tainted.phones = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("phones", data.phones);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["phones", index] as const,
                        name: `phones.${index}`,
                        constraints: { required: true },
                        get: () => data.phones[index]!,
                        set: (value: PhoneNumber) => { data.phones[index] = value; },
                        transform: (value: PhoneNumber): PhoneNumber => value,
                        getError: () => errors.phones,
                        setError: (value: Option<Array<string>>) => { errors.phones = value; },
                        getTainted: () => tainted.phones,
                        setTainted: (value: Option<boolean>) => { tainted.phones = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: PhoneNumber) => { data.phones.push(item); },
                    remove: (index: number) => { data.phones.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.phones[a]!;
                        data.phones[a] = data.phones[b]!;
                        data.phones[b] = tmp;
                    },
                },
                email: {
                    path: ["email"] as const,
                    name: "email",
                    constraints: { required: true },
                    label: "Email",
                    get: () => data.email,
                    set: (value: Email) => { data.email = value; },
                    transform: (value: Email): Email => value,
                    getError: () => errors.email,
                    setError: (value: Option<Array<string>>) => { errors.email = value; },
                    getTainted: () => tainted.email,
                    setTainted: (value: Option<boolean>) => { tainted.email = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("email", data.email);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                leadSource: {
                    path: ["leadSource"] as const,
                    name: "leadSource",
                    constraints: { required: true },
                    label: "Lead Source",
                    get: () => data.leadSource,
                    set: (value: string) => { data.leadSource = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.leadSource,
                    setError: (value: Option<Array<string>>) => { errors.leadSource = value; },
                    getTainted: () => tainted.leadSource,
                    setTainted: (value: Option<boolean>) => { tainted.leadSource = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("leadSource", data.leadSource);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                colors: {
                    path: ["colors"] as const,
                    name: "colors",
                    constraints: { required: true },
                    
                    get: () => data.colors,
                    set: (value: Colors) => { data.colors = value; },
                    transform: (value: Colors): Colors => value,
                    getError: () => errors.colors,
                    setError: (value: Option<Array<string>>) => { errors.colors = value; },
                    getTainted: () => tainted.colors,
                    setTainted: (value: Option<boolean>) => { tainted.colors = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("colors", data.colors);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                needsReview: {
                    path: ["needsReview"] as const,
                    name: "needsReview",
                    constraints: { required: true },
                    label: "Needs Review",
                    get: () => data.needsReview,
                    set: (value: boolean) => { data.needsReview = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.needsReview,
                    setError: (value: Option<Array<string>>) => { errors.needsReview = value; },
                    getTainted: () => tainted.needsReview,
                    setTainted: (value: Option<boolean>) => { tainted.needsReview = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("needsReview", data.needsReview);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                hasAlert: {
                    path: ["hasAlert"] as const,
                    name: "hasAlert",
                    constraints: { required: true },
                    label: "Has Alert",
                    get: () => data.hasAlert,
                    set: (value: boolean) => { data.hasAlert = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.hasAlert,
                    setError: (value: Option<Array<string>>) => { errors.hasAlert = value; },
                    getTainted: () => tainted.hasAlert,
                    setTainted: (value: Option<boolean>) => { tainted.hasAlert = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("hasAlert", data.hasAlert);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                accountType: {
                    path: ["accountType"] as const,
                    name: "accountType",
                    constraints: { required: true },
                    label: "Account Type",
                    get: () => data.accountType,
                    set: (value: string) => { data.accountType = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.accountType,
                    setError: (value: Option<Array<string>>) => { errors.accountType = value; },
                    getTainted: () => tainted.accountType,
                    setTainted: (value: Option<boolean>) => { tainted.accountType = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("accountType", data.accountType);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                subtype: {
                    path: ["subtype"] as const,
                    name: "subtype",
                    constraints: { required: true },
                    label: "Subtype",
                    get: () => data.subtype,
                    set: (value: string) => { data.subtype = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.subtype,
                    setError: (value: Option<Array<string>>) => { errors.subtype = value; },
                    getTainted: () => tainted.subtype,
                    setTainted: (value: Option<boolean>) => { tainted.subtype = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("subtype", data.subtype);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                isTaxExempt: {
                    path: ["isTaxExempt"] as const,
                    name: "isTaxExempt",
                    constraints: { required: true },
                    label: "Tax Exempt",
                    get: () => data.isTaxExempt,
                    set: (value: boolean) => { data.isTaxExempt = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.isTaxExempt,
                    setError: (value: Option<Array<string>>) => { errors.isTaxExempt = value; },
                    getTainted: () => tainted.isTaxExempt,
                    setTainted: (value: Option<boolean>) => { tainted.isTaxExempt = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("isTaxExempt", data.isTaxExempt);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                paymentTerms: {
                    path: ["paymentTerms"] as const,
                    name: "paymentTerms",
                    constraints: { required: true },
                    label: "Payment Terms",
                    get: () => data.paymentTerms,
                    set: (value: string) => { data.paymentTerms = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.paymentTerms,
                    setError: (value: Option<Array<string>>) => { errors.paymentTerms = value; },
                    getTainted: () => tainted.paymentTerms,
                    setTainted: (value: Option<boolean>) => { tainted.paymentTerms = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("paymentTerms", data.paymentTerms);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                tags: {
                    path: ["tags"] as const,
                    name: "tags",
                    constraints: { required: true },
                    label: "Tags",
                    get: () => data.tags,
                    set: (value: string[]) => { data.tags = value; },
                    transform: (value: string[]): string[] => value,
                    getError: () => errors.tags,
                    setError: (value: Option<Array<string>>) => { errors.tags = value; },
                    getTainted: () => tainted.tags,
                    setTainted: (value: Option<boolean>) => { tainted.tags = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("tags", data.tags);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["tags", index] as const,
                        name: `tags.${index}`,
                        constraints: { required: true },
                        get: () => data.tags[index]!,
                        set: (value: string) => { data.tags[index] = value; },
                        transform: (value: string): string => value,
                        getError: () => errors.tags,
                        setError: (value: Option<Array<string>>) => { errors.tags = value; },
                        getTainted: () => tainted.tags,
                        setTainted: (value: Option<boolean>) => { tainted.tags = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: string) => { data.tags.push(item); },
                    remove: (index: number) => { data.tags.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.tags[a]!;
                        data.tags[a] = data.tags[b]!;
                        data.tags[b] = tmp;
                    },
                },
                dateAdded: {
                    path: ["dateAdded"] as const,
                    name: "dateAdded",
                    constraints: { required: true },
                    
                    get: () => data.dateAdded,
                    set: (value: string) => { data.dateAdded = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.dateAdded,
                    setError: (value: Option<Array<string>>) => { errors.dateAdded = value; },
                    getTainted: () => tainted.dateAdded,
                    setTainted: (value: Option<boolean>) => { tainted.dateAdded = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAccount("dateAdded", data.dateAdded);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Account, Array<{field: string; message: string}>>{return fromObjectAccount(data);}function reset(newOverrides?: Partial<Account>): void {data = {...defaultValueAccount(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), taxRate: Option.none(), site: Option.none(), salesRep: Option.none(), orders: Option.none(), activity: Option.none(), customFields: Option.none(), accountName: Option.none(), sector: Option.none(), memo: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), colors: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), dateAdded: Option.none() }; tainted = { id: Option.none(), taxRate: Option.none(), site: Option.none(), salesRep: Option.none(), orders: Option.none(), activity: Option.none(), customFields: Option.none(), accountName: Option.none(), sector: Option.none(), memo: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), colors: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), dateAdded: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataAccount(formData: FormData): Result<Account, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.taxRate = formData.get("taxRate") ?? "";
            obj.site = formData.get("site") ?? "";
            obj.salesRep = formData.get("salesRep") ?? "";
            {
                // Collect array items from indexed form fields
                const ordersItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("orders." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("orders." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("orders." + idx + ".")) {
                                const fieldName = key.slice("orders.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        ordersItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.orders = ordersItems;
            }
            {
                // Collect array items from indexed form fields
                const activityItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("activity." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("activity." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("activity." + idx + ".")) {
                                const fieldName = key.slice("activity.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        activityItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.activity = activityItems;
            }
            {
                // Collect array items from indexed form fields
                const customFieldsItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("customFields." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("customFields." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("customFields." + idx + ".")) {
                                const fieldName = key.slice("customFields.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        customFieldsItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.customFields = customFieldsItems;
            }
            {
            // Collect nested object fields with prefix "accountName."
            const accountNameObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("accountName.")) {
                    const fieldName = key.slice("accountName.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = accountNameObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.accountName = accountNameObj;
        }
            {
            // Collect nested object fields with prefix "sector."
            const sectorObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("sector.")) {
                    const fieldName = key.slice("sector.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = sectorObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.sector = sectorObj;
        }
            obj.memo = formData.get("memo") ?? "";
            {
                // Collect array items from indexed form fields
                const phonesItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("phones." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("phones." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("phones." + idx + ".")) {
                                const fieldName = key.slice("phones.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        phonesItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.phones = phonesItems;
            }
            {
            // Collect nested object fields with prefix "email."
            const emailObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("email.")) {
                    const fieldName = key.slice("email.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = emailObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.email = emailObj;
        }
            obj.leadSource = formData.get("leadSource") ?? "";
            {
            // Collect nested object fields with prefix "colors."
            const colorsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("colors.")) {
                    const fieldName = key.slice("colors.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = colorsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.colors = colorsObj;
        }
            {
                const needsReviewVal = formData.get("needsReview");
                obj.needsReview = needsReviewVal === "true" || needsReviewVal === "on" || needsReviewVal === "1";
            }
            {
                const hasAlertVal = formData.get("hasAlert");
                obj.hasAlert = hasAlertVal === "true" || hasAlertVal === "on" || hasAlertVal === "1";
            }
            obj.accountType = formData.get("accountType") ?? "";
            obj.subtype = formData.get("subtype") ?? "";
            {
                const isTaxExemptVal = formData.get("isTaxExempt");
                obj.isTaxExempt = isTaxExemptVal === "true" || isTaxExemptVal === "on" || isTaxExemptVal === "1";
            }
            obj.paymentTerms = formData.get("paymentTerms") ?? "";
            obj.tags = formData.getAll("tags") as Array<string>;
            obj.dateAdded = formData.get("dateAdded") ?? ""; return fromStringifiedJSONAccount(JSON.stringify(obj));}


export interface Edited {
    
    fieldName: string;
    oldValue: string | null;
    newValue: string | null;
}

export function defaultValueEdited(): Edited {return {fieldName: "",
                            oldValue: null,
                            newValue: null, }as Edited;}

export function toStringifiedJSONEdited(value: Edited): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeEdited(value, ctx));}export function toObjectEdited(value: Edited): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeEdited(value, ctx);}export function __serializeEdited(value: Edited, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Edited" , __id,}; result["fieldName" ]= value.fieldName; result["oldValue" ]= value.oldValue; result["newValue" ]= value.newValue; return result;}

export function fromStringifiedJSONEdited(json: string, opts?: DeserializeOptions): Result<Edited, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectEdited(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectEdited(obj: unknown, opts?: DeserializeOptions): Result<Edited, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeEdited(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Edited.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeEdited(value: any, ctx: DeserializeContext): Edited | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Edited.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("fieldName" in obj)){errors.push({field: "fieldName" , message: "missing required field" });}if(!("oldValue" in obj)){errors.push({field: "oldValue" , message: "missing required field" });}if(!("newValue" in obj)){errors.push({field: "newValue" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_fieldName = obj["fieldName" ]as string; 
                if (__raw_fieldName.length === 0) {
                    errors.push({ field: "fieldName", message: "must not be empty" });
                }
 instance.fieldName = __raw_fieldName; }{const __raw_oldValue = obj["oldValue" ]as string | null; instance.oldValue = __raw_oldValue; }{const __raw_newValue = obj["newValue" ]as string | null; instance.newValue = __raw_newValue; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Edited;}export function validateFieldEdited<K extends keyof Edited>(field: K, value: Edited[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "fieldName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "fieldName", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsEdited(partial: Partial<Edited>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("fieldName" in partial && partial.fieldName!== undefined){const __val = partial.fieldName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "fieldName", message: "must not be empty" });
                }
}return errors; }export function hasShapeEdited(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "fieldName" in o && "oldValue" in o && "newValue" in o;}export function isEdited(obj: unknown): obj is Edited {if(!hasShapeEdited(obj)){return false;}const result = fromObjectEdited(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsEdited = {_errors: Option<Array<string>>; fieldName: Option<Array<string>>;
            oldValue: Option<Array<string>>;
            newValue: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedEdited = {fieldName: Option<boolean>;
            oldValue: Option<boolean>;
            newValue: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersEdited {readonly fieldName: FieldController<string>;
            readonly oldValue: FieldController<string | null>;
            readonly newValue: FieldController<string | null>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformEdited {readonly data: Edited; readonly errors: ErrorsEdited; readonly tainted: TaintedEdited; readonly fields: FieldControllersEdited; validate(): Result<Edited, Array<{field: string; message: string}>>; reset(overrides?: Partial<Edited>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormEdited(overrides?: Partial<Edited>): GigaformEdited {let data = $state({...defaultValueEdited(),...overrides}); let errors = $state<ErrorsEdited>({ _errors: Option.none(), fieldName: Option.none(), oldValue: Option.none(), newValue: Option.none() }); let tainted = $state<TaintedEdited>({ fieldName: Option.none(), oldValue: Option.none(), newValue: Option.none() }); const fields: FieldControllersEdited = {fieldName: {
                    path: ["fieldName"] as const,
                    name: "fieldName",
                    constraints: { required: true },
                    
                    get: () => data.fieldName,
                    set: (value: string) => { data.fieldName = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.fieldName,
                    setError: (value: Option<Array<string>>) => { errors.fieldName = value; },
                    getTainted: () => tainted.fieldName,
                    setTainted: (value: Option<boolean>) => { tainted.fieldName = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEdited("fieldName", data.fieldName);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                oldValue: {
                    path: ["oldValue"] as const,
                    name: "oldValue",
                    constraints: { required: true },
                    
                    get: () => data.oldValue,
                    set: (value: string | null) => { data.oldValue = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.oldValue,
                    setError: (value: Option<Array<string>>) => { errors.oldValue = value; },
                    getTainted: () => tainted.oldValue,
                    setTainted: (value: Option<boolean>) => { tainted.oldValue = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEdited("oldValue", data.oldValue);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                newValue: {
                    path: ["newValue"] as const,
                    name: "newValue",
                    constraints: { required: true },
                    
                    get: () => data.newValue,
                    set: (value: string | null) => { data.newValue = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.newValue,
                    setError: (value: Option<Array<string>>) => { errors.newValue = value; },
                    getTainted: () => tainted.newValue,
                    setTainted: (value: Option<boolean>) => { tainted.newValue = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEdited("newValue", data.newValue);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Edited, Array<{field: string; message: string}>>{return fromObjectEdited(data);}function reset(newOverrides?: Partial<Edited>): void {data = {...defaultValueEdited(),...newOverrides}; errors = { _errors: Option.none(), fieldName: Option.none(), oldValue: Option.none(), newValue: Option.none() }; tainted = { fieldName: Option.none(), oldValue: Option.none(), newValue: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataEdited(formData: FormData): Result<Edited, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.fieldName = formData.get("fieldName") ?? "";
            obj.oldValue = formData.get("oldValue") ?? "";
            obj.newValue = formData.get("newValue") ?? ""; return fromStringifiedJSONEdited(JSON.stringify(obj));}


export interface Order {
    
    id: string;
    
    
    account: string | Account;
    
    
    stage: OrderStage;
    
    number: number;
    
    payments: (string | Payment)[];
    
    
    opportunity: string;
    
    
    reference: string;
    
    
    leadSource: string;
    
    
    salesRep: string | Employee;
    
    
    group: string;
    
    
    subgroup: string;
    
    isPosted: boolean;
    
    needsReview: boolean;
    
    
    actionItem: string;
    
    upsale: number;
    
    dateCreated: string;
    
    
    appointment: string | Appointment;
    
    lastTechs: (string | Employee)[];
    
    package: (string | Package)[] | null;
    
    promotion: (string | Promotion)[] | null;
    
    balance: number;
    
    due: string;
    
    total: number;
    
    
    site: string | Site;
    
    billedItems: BilledItem[];
    
    
    memo: string;
    
    discount: number;
    
    tip: number;
    
    commissions: number[];
}

export function defaultValueOrder(): Order {return {id: "",
                            account: "",
                            stage: "Estimate",
                            number: 0,
                            payments: [],
                            opportunity: "",
                            reference: "",
                            leadSource: "",
                            salesRep: "",
                            group: "",
                            subgroup: "",
                            isPosted: false,
                            needsReview: false,
                            actionItem: "",
                            upsale: 0,
                            dateCreated: "",
                            appointment: "",
                            lastTechs: [],
                            package: null,
                            promotion: null,
                            balance: 0,
                            due: "",
                            total: 0,
                            site: "",
                            billedItems: [],
                            memo: "",
                            discount: 0,
                            tip: 0,
                            commissions: [], }as Order;}

export function toStringifiedJSONOrder(value: Order): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeOrder(value, ctx));}export function toObjectOrder(value: Order): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeOrder(value, ctx);}export function __serializeOrder(value: Order, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Order" , __id,}; result["id" ]= value.id; result["account" ]= value.account; result["stage" ]= __serializeOrderStage(value.stage, ctx); result["number" ]= value.number; result["payments" ]= value.payments; result["opportunity" ]= value.opportunity; result["reference" ]= value.reference; result["leadSource" ]= value.leadSource; result["salesRep" ]= value.salesRep; result["group" ]= value.group; result["subgroup" ]= value.subgroup; result["isPosted" ]= value.isPosted; result["needsReview" ]= value.needsReview; result["actionItem" ]= value.actionItem; result["upsale" ]= value.upsale; result["dateCreated" ]= value.dateCreated; result["appointment" ]= value.appointment; result["lastTechs" ]= value.lastTechs; if(value.package!== null){result["package" ]= value.package; }else {result["package" ]= null;}if(value.promotion!== null){result["promotion" ]= value.promotion; }else {result["promotion" ]= null;}result["balance" ]= value.balance; result["due" ]= value.due; result["total" ]= value.total; result["site" ]= value.site; result["billedItems" ]= value.billedItems.map((item)=>__serializeBilledItem(item, ctx)); result["memo" ]= value.memo; result["discount" ]= value.discount; result["tip" ]= value.tip; result["commissions" ]= value.commissions; return result;}

export function fromStringifiedJSONOrder(json: string, opts?: DeserializeOptions): Result<Order, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectOrder(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectOrder(obj: unknown, opts?: DeserializeOptions): Result<Order, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeOrder(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Order.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeOrder(value: any, ctx: DeserializeContext): Order | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Order.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("account" in obj)){errors.push({field: "account" , message: "missing required field" });}if(!("stage" in obj)){errors.push({field: "stage" , message: "missing required field" });}if(!("number" in obj)){errors.push({field: "number" , message: "missing required field" });}if(!("payments" in obj)){errors.push({field: "payments" , message: "missing required field" });}if(!("opportunity" in obj)){errors.push({field: "opportunity" , message: "missing required field" });}if(!("reference" in obj)){errors.push({field: "reference" , message: "missing required field" });}if(!("leadSource" in obj)){errors.push({field: "leadSource" , message: "missing required field" });}if(!("salesRep" in obj)){errors.push({field: "salesRep" , message: "missing required field" });}if(!("group" in obj)){errors.push({field: "group" , message: "missing required field" });}if(!("subgroup" in obj)){errors.push({field: "subgroup" , message: "missing required field" });}if(!("isPosted" in obj)){errors.push({field: "isPosted" , message: "missing required field" });}if(!("needsReview" in obj)){errors.push({field: "needsReview" , message: "missing required field" });}if(!("actionItem" in obj)){errors.push({field: "actionItem" , message: "missing required field" });}if(!("upsale" in obj)){errors.push({field: "upsale" , message: "missing required field" });}if(!("dateCreated" in obj)){errors.push({field: "dateCreated" , message: "missing required field" });}if(!("appointment" in obj)){errors.push({field: "appointment" , message: "missing required field" });}if(!("lastTechs" in obj)){errors.push({field: "lastTechs" , message: "missing required field" });}if(!("package" in obj)){errors.push({field: "package" , message: "missing required field" });}if(!("promotion" in obj)){errors.push({field: "promotion" , message: "missing required field" });}if(!("balance" in obj)){errors.push({field: "balance" , message: "missing required field" });}if(!("due" in obj)){errors.push({field: "due" , message: "missing required field" });}if(!("total" in obj)){errors.push({field: "total" , message: "missing required field" });}if(!("site" in obj)){errors.push({field: "site" , message: "missing required field" });}if(!("billedItems" in obj)){errors.push({field: "billedItems" , message: "missing required field" });}if(!("memo" in obj)){errors.push({field: "memo" , message: "missing required field" });}if(!("discount" in obj)){errors.push({field: "discount" , message: "missing required field" });}if(!("tip" in obj)){errors.push({field: "tip" , message: "missing required field" });}if(!("commissions" in obj)){errors.push({field: "commissions" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_account = obj["account" ]as string | Account; instance.account = __raw_account; }{const __raw_stage = obj["stage" ]as OrderStage; {const __result = __deserializeOrderStage(__raw_stage, ctx); ctx.assignOrDefer(instance, "stage" , __result);}}{const __raw_number = obj["number" ]as number; instance.number = __raw_number; }{const __raw_payments = obj["payments" ]as (string | Payment)[]; if(Array.isArray(__raw_payments)){instance.payments = __raw_payments as (string | Payment)[];}}{const __raw_opportunity = obj["opportunity" ]as string; 
                if (__raw_opportunity.length === 0) {
                    errors.push({ field: "opportunity", message: "must not be empty" });
                }
 instance.opportunity = __raw_opportunity; }{const __raw_reference = obj["reference" ]as string; 
                if (__raw_reference.length === 0) {
                    errors.push({ field: "reference", message: "must not be empty" });
                }
 instance.reference = __raw_reference; }{const __raw_leadSource = obj["leadSource" ]as string; 
                if (__raw_leadSource.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
 instance.leadSource = __raw_leadSource; }{const __raw_salesRep = obj["salesRep" ]as string | Employee; instance.salesRep = __raw_salesRep; }{const __raw_group = obj["group" ]as string; 
                if (__raw_group.length === 0) {
                    errors.push({ field: "group", message: "must not be empty" });
                }
 instance.group = __raw_group; }{const __raw_subgroup = obj["subgroup" ]as string; 
                if (__raw_subgroup.length === 0) {
                    errors.push({ field: "subgroup", message: "must not be empty" });
                }
 instance.subgroup = __raw_subgroup; }{const __raw_isPosted = obj["isPosted" ]as boolean; instance.isPosted = __raw_isPosted; }{const __raw_needsReview = obj["needsReview" ]as boolean; instance.needsReview = __raw_needsReview; }{const __raw_actionItem = obj["actionItem" ]as string; 
                if (__raw_actionItem.length === 0) {
                    errors.push({ field: "actionItem", message: "must not be empty" });
                }
 instance.actionItem = __raw_actionItem; }{const __raw_upsale = obj["upsale" ]as number; instance.upsale = __raw_upsale; }{const __raw_dateCreated = obj["dateCreated" ]as string; instance.dateCreated = __raw_dateCreated; }{const __raw_appointment = obj["appointment" ]as string | Appointment; instance.appointment = __raw_appointment; }{const __raw_lastTechs = obj["lastTechs" ]as (string | Employee)[]; if(Array.isArray(__raw_lastTechs)){instance.lastTechs = __raw_lastTechs as (string | Employee)[];}}{const __raw_package = obj["package" ]as (string | Package)[] | null; if(__raw_package === null){instance.package = null;}else {instance.package = __raw_package; }}{const __raw_promotion = obj["promotion" ]as (string | Promotion)[] | null; if(__raw_promotion === null){instance.promotion = null;}else {instance.promotion = __raw_promotion; }}{const __raw_balance = obj["balance" ]as number; instance.balance = __raw_balance; }{const __raw_due = obj["due" ]as string; instance.due = __raw_due; }{const __raw_total = obj["total" ]as number; instance.total = __raw_total; }{const __raw_site = obj["site" ]as string | Site; instance.site = __raw_site; }{const __raw_billedItems = obj["billedItems" ]as BilledItem[]; if(Array.isArray(__raw_billedItems)){instance.billedItems = __raw_billedItems as BilledItem[];}}{const __raw_memo = obj["memo" ]as string; 
                if (__raw_memo.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
 instance.memo = __raw_memo; }{const __raw_discount = obj["discount" ]as number; instance.discount = __raw_discount; }{const __raw_tip = obj["tip" ]as number; instance.tip = __raw_tip; }{const __raw_commissions = obj["commissions" ]as number[]; if(Array.isArray(__raw_commissions)){instance.commissions = __raw_commissions as number[];}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Order;}export function validateFieldOrder<K extends keyof Order>(field: K, value: Order[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "opportunity" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "opportunity", message: "must not be empty" });
                }
 break;}case "reference" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "reference", message: "must not be empty" });
                }
 break;}case "leadSource" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
 break;}case "group" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "group", message: "must not be empty" });
                }
 break;}case "subgroup" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subgroup", message: "must not be empty" });
                }
 break;}case "actionItem" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "actionItem", message: "must not be empty" });
                }
 break;}case "memo" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsOrder(partial: Partial<Order>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("opportunity" in partial && partial.opportunity!== undefined){const __val = partial.opportunity as string; 
                if (__val.length === 0) {
                    errors.push({ field: "opportunity", message: "must not be empty" });
                }
}if("reference" in partial && partial.reference!== undefined){const __val = partial.reference as string; 
                if (__val.length === 0) {
                    errors.push({ field: "reference", message: "must not be empty" });
                }
}if("leadSource" in partial && partial.leadSource!== undefined){const __val = partial.leadSource as string; 
                if (__val.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
}if("group" in partial && partial.group!== undefined){const __val = partial.group as string; 
                if (__val.length === 0) {
                    errors.push({ field: "group", message: "must not be empty" });
                }
}if("subgroup" in partial && partial.subgroup!== undefined){const __val = partial.subgroup as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subgroup", message: "must not be empty" });
                }
}if("actionItem" in partial && partial.actionItem!== undefined){const __val = partial.actionItem as string; 
                if (__val.length === 0) {
                    errors.push({ field: "actionItem", message: "must not be empty" });
                }
}if("memo" in partial && partial.memo!== undefined){const __val = partial.memo as string; 
                if (__val.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
}return errors; }export function hasShapeOrder(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "account" in o && "stage" in o && "number" in o && "payments" in o && "opportunity" in o && "reference" in o && "leadSource" in o && "salesRep" in o && "group" in o && "subgroup" in o && "isPosted" in o && "needsReview" in o && "actionItem" in o && "upsale" in o && "dateCreated" in o && "appointment" in o && "lastTechs" in o && "package" in o && "promotion" in o && "balance" in o && "due" in o && "total" in o && "site" in o && "billedItems" in o && "memo" in o && "discount" in o && "tip" in o && "commissions" in o;}export function isOrder(obj: unknown): obj is Order {if(!hasShapeOrder(obj)){return false;}const result = fromObjectOrder(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsOrder = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            account: Option<Array<string>>;
            stage: Option<Array<string>>;
            number: Option<Array<string>>;
            payments: Option<Array<string>>;
            opportunity: Option<Array<string>>;
            reference: Option<Array<string>>;
            leadSource: Option<Array<string>>;
            salesRep: Option<Array<string>>;
            group: Option<Array<string>>;
            subgroup: Option<Array<string>>;
            isPosted: Option<Array<string>>;
            needsReview: Option<Array<string>>;
            actionItem: Option<Array<string>>;
            upsale: Option<Array<string>>;
            dateCreated: Option<Array<string>>;
            appointment: Option<Array<string>>;
            lastTechs: Option<Array<string>>;
            package: Option<Array<string>>;
            promotion: Option<Array<string>>;
            balance: Option<Array<string>>;
            due: Option<Array<string>>;
            total: Option<Array<string>>;
            site: Option<Array<string>>;
            billedItems: Option<Array<string>>;
            memo: Option<Array<string>>;
            discount: Option<Array<string>>;
            tip: Option<Array<string>>;
            commissions: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedOrder = {id: Option<boolean>;
            account: Option<boolean>;
            stage: Option<boolean>;
            number: Option<boolean>;
            payments: Option<boolean>;
            opportunity: Option<boolean>;
            reference: Option<boolean>;
            leadSource: Option<boolean>;
            salesRep: Option<boolean>;
            group: Option<boolean>;
            subgroup: Option<boolean>;
            isPosted: Option<boolean>;
            needsReview: Option<boolean>;
            actionItem: Option<boolean>;
            upsale: Option<boolean>;
            dateCreated: Option<boolean>;
            appointment: Option<boolean>;
            lastTechs: Option<boolean>;
            package: Option<boolean>;
            promotion: Option<boolean>;
            balance: Option<boolean>;
            due: Option<boolean>;
            total: Option<boolean>;
            site: Option<boolean>;
            billedItems: Option<boolean>;
            memo: Option<boolean>;
            discount: Option<boolean>;
            tip: Option<boolean>;
            commissions: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersOrder {readonly id: FieldController<string>;
            readonly account: FieldController<string | Account>;
            readonly stage: FieldController<OrderStage>;
            readonly number: FieldController<number>;
            readonly payments: ArrayFieldController<(string | Payment)>;
            readonly opportunity: FieldController<string>;
            readonly reference: FieldController<string>;
            readonly leadSource: FieldController<string>;
            readonly salesRep: FieldController<string | Employee>;
            readonly group: FieldController<string>;
            readonly subgroup: FieldController<string>;
            readonly isPosted: FieldController<boolean>;
            readonly needsReview: FieldController<boolean>;
            readonly actionItem: FieldController<string>;
            readonly upsale: FieldController<number>;
            readonly dateCreated: FieldController<string>;
            readonly appointment: FieldController<string | Appointment>;
            readonly lastTechs: ArrayFieldController<(string | Employee)>;
            readonly package: FieldController<(string | Package)[] | null>;
            readonly promotion: FieldController<(string | Promotion)[] | null>;
            readonly balance: FieldController<number>;
            readonly due: FieldController<string>;
            readonly total: FieldController<number>;
            readonly site: FieldController<string | Site>;
            readonly billedItems: ArrayFieldController<BilledItem>;
            readonly memo: FieldController<string>;
            readonly discount: FieldController<number>;
            readonly tip: FieldController<number>;
            readonly commissions: ArrayFieldController<number>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformOrder {readonly data: Order; readonly errors: ErrorsOrder; readonly tainted: TaintedOrder; readonly fields: FieldControllersOrder; validate(): Result<Order, Array<{field: string; message: string}>>; reset(overrides?: Partial<Order>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormOrder(overrides?: Partial<Order>): GigaformOrder {let data = $state({...defaultValueOrder(),...overrides}); let errors = $state<ErrorsOrder>({ _errors: Option.none(), id: Option.none(), account: Option.none(), stage: Option.none(), number: Option.none(), payments: Option.none(), opportunity: Option.none(), reference: Option.none(), leadSource: Option.none(), salesRep: Option.none(), group: Option.none(), subgroup: Option.none(), isPosted: Option.none(), needsReview: Option.none(), actionItem: Option.none(), upsale: Option.none(), dateCreated: Option.none(), appointment: Option.none(), lastTechs: Option.none(), package: Option.none(), promotion: Option.none(), balance: Option.none(), due: Option.none(), total: Option.none(), site: Option.none(), billedItems: Option.none(), memo: Option.none(), discount: Option.none(), tip: Option.none(), commissions: Option.none() }); let tainted = $state<TaintedOrder>({ id: Option.none(), account: Option.none(), stage: Option.none(), number: Option.none(), payments: Option.none(), opportunity: Option.none(), reference: Option.none(), leadSource: Option.none(), salesRep: Option.none(), group: Option.none(), subgroup: Option.none(), isPosted: Option.none(), needsReview: Option.none(), actionItem: Option.none(), upsale: Option.none(), dateCreated: Option.none(), appointment: Option.none(), lastTechs: Option.none(), package: Option.none(), promotion: Option.none(), balance: Option.none(), due: Option.none(), total: Option.none(), site: Option.none(), billedItems: Option.none(), memo: Option.none(), discount: Option.none(), tip: Option.none(), commissions: Option.none() }); const fields: FieldControllersOrder = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                account: {
                    path: ["account"] as const,
                    name: "account",
                    constraints: { required: true },
                    label: "Account",
                    get: () => data.account,
                    set: (value: string | Account) => { data.account = value; },
                    transform: (value: string | Account): string | Account => value,
                    getError: () => errors.account,
                    setError: (value: Option<Array<string>>) => { errors.account = value; },
                    getTainted: () => tainted.account,
                    setTainted: (value: Option<boolean>) => { tainted.account = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("account", data.account);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                stage: {
                    path: ["stage"] as const,
                    name: "stage",
                    constraints: { required: true },
                    label: "Stage",
                    get: () => data.stage,
                    set: (value: OrderStage) => { data.stage = value; },
                    transform: (value: OrderStage): OrderStage => value,
                    getError: () => errors.stage,
                    setError: (value: Option<Array<string>>) => { errors.stage = value; },
                    getTainted: () => tainted.stage,
                    setTainted: (value: Option<boolean>) => { tainted.stage = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("stage", data.stage);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                number: {
                    path: ["number"] as const,
                    name: "number",
                    constraints: { required: true },
                    
                    get: () => data.number,
                    set: (value: number) => { data.number = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.number,
                    setError: (value: Option<Array<string>>) => { errors.number = value; },
                    getTainted: () => tainted.number,
                    setTainted: (value: Option<boolean>) => { tainted.number = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("number", data.number);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                payments: {
                    path: ["payments"] as const,
                    name: "payments",
                    constraints: { required: true },
                    
                    get: () => data.payments,
                    set: (value: (string | Payment)[]) => { data.payments = value; },
                    transform: (value: (string | Payment)[]): (string | Payment)[] => value,
                    getError: () => errors.payments,
                    setError: (value: Option<Array<string>>) => { errors.payments = value; },
                    getTainted: () => tainted.payments,
                    setTainted: (value: Option<boolean>) => { tainted.payments = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("payments", data.payments);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["payments", index] as const,
                        name: `payments.${index}`,
                        constraints: { required: true },
                        get: () => data.payments[index]!,
                        set: (value: (string | Payment)) => { data.payments[index] = value; },
                        transform: (value: (string | Payment)): (string | Payment) => value,
                        getError: () => errors.payments,
                        setError: (value: Option<Array<string>>) => { errors.payments = value; },
                        getTainted: () => tainted.payments,
                        setTainted: (value: Option<boolean>) => { tainted.payments = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: (string | Payment)) => { data.payments.push(item); },
                    remove: (index: number) => { data.payments.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.payments[a]!;
                        data.payments[a] = data.payments[b]!;
                        data.payments[b] = tmp;
                    },
                },
                opportunity: {
                    path: ["opportunity"] as const,
                    name: "opportunity",
                    constraints: { required: true },
                    label: "Opportunity",
                    get: () => data.opportunity,
                    set: (value: string) => { data.opportunity = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.opportunity,
                    setError: (value: Option<Array<string>>) => { errors.opportunity = value; },
                    getTainted: () => tainted.opportunity,
                    setTainted: (value: Option<boolean>) => { tainted.opportunity = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("opportunity", data.opportunity);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                reference: {
                    path: ["reference"] as const,
                    name: "reference",
                    constraints: { required: true },
                    label: "Reference",
                    get: () => data.reference,
                    set: (value: string) => { data.reference = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.reference,
                    setError: (value: Option<Array<string>>) => { errors.reference = value; },
                    getTainted: () => tainted.reference,
                    setTainted: (value: Option<boolean>) => { tainted.reference = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("reference", data.reference);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                leadSource: {
                    path: ["leadSource"] as const,
                    name: "leadSource",
                    constraints: { required: true },
                    label: "Lead Source",
                    get: () => data.leadSource,
                    set: (value: string) => { data.leadSource = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.leadSource,
                    setError: (value: Option<Array<string>>) => { errors.leadSource = value; },
                    getTainted: () => tainted.leadSource,
                    setTainted: (value: Option<boolean>) => { tainted.leadSource = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("leadSource", data.leadSource);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                salesRep: {
                    path: ["salesRep"] as const,
                    name: "salesRep",
                    constraints: { required: true },
                    label: "Sales Rep",
                    get: () => data.salesRep,
                    set: (value: string | Employee) => { data.salesRep = value; },
                    transform: (value: string | Employee): string | Employee => value,
                    getError: () => errors.salesRep,
                    setError: (value: Option<Array<string>>) => { errors.salesRep = value; },
                    getTainted: () => tainted.salesRep,
                    setTainted: (value: Option<boolean>) => { tainted.salesRep = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("salesRep", data.salesRep);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                group: {
                    path: ["group"] as const,
                    name: "group",
                    constraints: { required: true },
                    label: "Group",
                    get: () => data.group,
                    set: (value: string) => { data.group = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.group,
                    setError: (value: Option<Array<string>>) => { errors.group = value; },
                    getTainted: () => tainted.group,
                    setTainted: (value: Option<boolean>) => { tainted.group = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("group", data.group);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                subgroup: {
                    path: ["subgroup"] as const,
                    name: "subgroup",
                    constraints: { required: true },
                    label: "Subgroup",
                    get: () => data.subgroup,
                    set: (value: string) => { data.subgroup = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.subgroup,
                    setError: (value: Option<Array<string>>) => { errors.subgroup = value; },
                    getTainted: () => tainted.subgroup,
                    setTainted: (value: Option<boolean>) => { tainted.subgroup = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("subgroup", data.subgroup);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                isPosted: {
                    path: ["isPosted"] as const,
                    name: "isPosted",
                    constraints: { required: true },
                    label: "Posted",
                    get: () => data.isPosted,
                    set: (value: boolean) => { data.isPosted = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.isPosted,
                    setError: (value: Option<Array<string>>) => { errors.isPosted = value; },
                    getTainted: () => tainted.isPosted,
                    setTainted: (value: Option<boolean>) => { tainted.isPosted = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("isPosted", data.isPosted);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                needsReview: {
                    path: ["needsReview"] as const,
                    name: "needsReview",
                    constraints: { required: true },
                    label: "Needs Review",
                    get: () => data.needsReview,
                    set: (value: boolean) => { data.needsReview = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.needsReview,
                    setError: (value: Option<Array<string>>) => { errors.needsReview = value; },
                    getTainted: () => tainted.needsReview,
                    setTainted: (value: Option<boolean>) => { tainted.needsReview = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("needsReview", data.needsReview);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                actionItem: {
                    path: ["actionItem"] as const,
                    name: "actionItem",
                    constraints: { required: true },
                    label: "Action Item",
                    get: () => data.actionItem,
                    set: (value: string) => { data.actionItem = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.actionItem,
                    setError: (value: Option<Array<string>>) => { errors.actionItem = value; },
                    getTainted: () => tainted.actionItem,
                    setTainted: (value: Option<boolean>) => { tainted.actionItem = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("actionItem", data.actionItem);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                upsale: {
                    path: ["upsale"] as const,
                    name: "upsale",
                    constraints: { required: true },
                    
                    get: () => data.upsale,
                    set: (value: number) => { data.upsale = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.upsale,
                    setError: (value: Option<Array<string>>) => { errors.upsale = value; },
                    getTainted: () => tainted.upsale,
                    setTainted: (value: Option<boolean>) => { tainted.upsale = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("upsale", data.upsale);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                dateCreated: {
                    path: ["dateCreated"] as const,
                    name: "dateCreated",
                    constraints: { required: true },
                    
                    get: () => data.dateCreated,
                    set: (value: string) => { data.dateCreated = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.dateCreated,
                    setError: (value: Option<Array<string>>) => { errors.dateCreated = value; },
                    getTainted: () => tainted.dateCreated,
                    setTainted: (value: Option<boolean>) => { tainted.dateCreated = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("dateCreated", data.dateCreated);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                appointment: {
                    path: ["appointment"] as const,
                    name: "appointment",
                    constraints: { required: true },
                    label: "Appointment",
                    get: () => data.appointment,
                    set: (value: string | Appointment) => { data.appointment = value; },
                    transform: (value: string | Appointment): string | Appointment => value,
                    getError: () => errors.appointment,
                    setError: (value: Option<Array<string>>) => { errors.appointment = value; },
                    getTainted: () => tainted.appointment,
                    setTainted: (value: Option<boolean>) => { tainted.appointment = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("appointment", data.appointment);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                lastTechs: {
                    path: ["lastTechs"] as const,
                    name: "lastTechs",
                    constraints: { required: true },
                    label: "Technicians",
                    get: () => data.lastTechs,
                    set: (value: (string | Employee)[]) => { data.lastTechs = value; },
                    transform: (value: (string | Employee)[]): (string | Employee)[] => value,
                    getError: () => errors.lastTechs,
                    setError: (value: Option<Array<string>>) => { errors.lastTechs = value; },
                    getTainted: () => tainted.lastTechs,
                    setTainted: (value: Option<boolean>) => { tainted.lastTechs = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("lastTechs", data.lastTechs);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["lastTechs", index] as const,
                        name: `lastTechs.${index}`,
                        constraints: { required: true },
                        get: () => data.lastTechs[index]!,
                        set: (value: (string | Employee)) => { data.lastTechs[index] = value; },
                        transform: (value: (string | Employee)): (string | Employee) => value,
                        getError: () => errors.lastTechs,
                        setError: (value: Option<Array<string>>) => { errors.lastTechs = value; },
                        getTainted: () => tainted.lastTechs,
                        setTainted: (value: Option<boolean>) => { tainted.lastTechs = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: (string | Employee)) => { data.lastTechs.push(item); },
                    remove: (index: number) => { data.lastTechs.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.lastTechs[a]!;
                        data.lastTechs[a] = data.lastTechs[b]!;
                        data.lastTechs[b] = tmp;
                    },
                },
                package: {
                    path: ["package"] as const,
                    name: "package",
                    constraints: { required: true },
                    
                    get: () => data.package,
                    set: (value: (string | Package)[] | null) => { data.package = value; },
                    transform: (value: (string | Package)[] | null): (string | Package)[] | null => value,
                    getError: () => errors.package,
                    setError: (value: Option<Array<string>>) => { errors.package = value; },
                    getTainted: () => tainted.package,
                    setTainted: (value: Option<boolean>) => { tainted.package = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("package", data.package);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                promotion: {
                    path: ["promotion"] as const,
                    name: "promotion",
                    constraints: { required: true },
                    
                    get: () => data.promotion,
                    set: (value: (string | Promotion)[] | null) => { data.promotion = value; },
                    transform: (value: (string | Promotion)[] | null): (string | Promotion)[] | null => value,
                    getError: () => errors.promotion,
                    setError: (value: Option<Array<string>>) => { errors.promotion = value; },
                    getTainted: () => tainted.promotion,
                    setTainted: (value: Option<boolean>) => { tainted.promotion = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("promotion", data.promotion);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                balance: {
                    path: ["balance"] as const,
                    name: "balance",
                    constraints: { required: true },
                    
                    get: () => data.balance,
                    set: (value: number) => { data.balance = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.balance,
                    setError: (value: Option<Array<string>>) => { errors.balance = value; },
                    getTainted: () => tainted.balance,
                    setTainted: (value: Option<boolean>) => { tainted.balance = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("balance", data.balance);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                due: {
                    path: ["due"] as const,
                    name: "due",
                    constraints: { required: true },
                    label: "Due",
                    get: () => data.due,
                    set: (value: string) => { data.due = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.due,
                    setError: (value: Option<Array<string>>) => { errors.due = value; },
                    getTainted: () => tainted.due,
                    setTainted: (value: Option<boolean>) => { tainted.due = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("due", data.due);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                total: {
                    path: ["total"] as const,
                    name: "total",
                    constraints: { required: true },
                    
                    get: () => data.total,
                    set: (value: number) => { data.total = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.total,
                    setError: (value: Option<Array<string>>) => { errors.total = value; },
                    getTainted: () => tainted.total,
                    setTainted: (value: Option<boolean>) => { tainted.total = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("total", data.total);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                site: {
                    path: ["site"] as const,
                    name: "site",
                    constraints: { required: true },
                    label: "Site",
                    get: () => data.site,
                    set: (value: string | Site) => { data.site = value; },
                    transform: (value: string | Site): string | Site => value,
                    getError: () => errors.site,
                    setError: (value: Option<Array<string>>) => { errors.site = value; },
                    getTainted: () => tainted.site,
                    setTainted: (value: Option<boolean>) => { tainted.site = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("site", data.site);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                billedItems: {
                    path: ["billedItems"] as const,
                    name: "billedItems",
                    constraints: { required: true },
                    
                    get: () => data.billedItems,
                    set: (value: BilledItem[]) => { data.billedItems = value; },
                    transform: (value: BilledItem[]): BilledItem[] => value,
                    getError: () => errors.billedItems,
                    setError: (value: Option<Array<string>>) => { errors.billedItems = value; },
                    getTainted: () => tainted.billedItems,
                    setTainted: (value: Option<boolean>) => { tainted.billedItems = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("billedItems", data.billedItems);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["billedItems", index] as const,
                        name: `billedItems.${index}`,
                        constraints: { required: true },
                        get: () => data.billedItems[index]!,
                        set: (value: BilledItem) => { data.billedItems[index] = value; },
                        transform: (value: BilledItem): BilledItem => value,
                        getError: () => errors.billedItems,
                        setError: (value: Option<Array<string>>) => { errors.billedItems = value; },
                        getTainted: () => tainted.billedItems,
                        setTainted: (value: Option<boolean>) => { tainted.billedItems = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: BilledItem) => { data.billedItems.push(item); },
                    remove: (index: number) => { data.billedItems.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.billedItems[a]!;
                        data.billedItems[a] = data.billedItems[b]!;
                        data.billedItems[b] = tmp;
                    },
                },
                memo: {
                    path: ["memo"] as const,
                    name: "memo",
                    constraints: { required: true },
                    label: "Memo",
                    get: () => data.memo,
                    set: (value: string) => { data.memo = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.memo,
                    setError: (value: Option<Array<string>>) => { errors.memo = value; },
                    getTainted: () => tainted.memo,
                    setTainted: (value: Option<boolean>) => { tainted.memo = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("memo", data.memo);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                discount: {
                    path: ["discount"] as const,
                    name: "discount",
                    constraints: { required: true },
                    
                    get: () => data.discount,
                    set: (value: number) => { data.discount = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.discount,
                    setError: (value: Option<Array<string>>) => { errors.discount = value; },
                    getTainted: () => tainted.discount,
                    setTainted: (value: Option<boolean>) => { tainted.discount = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("discount", data.discount);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                tip: {
                    path: ["tip"] as const,
                    name: "tip",
                    constraints: { required: true },
                    
                    get: () => data.tip,
                    set: (value: number) => { data.tip = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.tip,
                    setError: (value: Option<Array<string>>) => { errors.tip = value; },
                    getTainted: () => tainted.tip,
                    setTainted: (value: Option<boolean>) => { tainted.tip = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("tip", data.tip);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                commissions: {
                    path: ["commissions"] as const,
                    name: "commissions",
                    constraints: { required: true },
                    
                    get: () => data.commissions,
                    set: (value: number[]) => { data.commissions = value; },
                    transform: (value: number[]): number[] => value,
                    getError: () => errors.commissions,
                    setError: (value: Option<Array<string>>) => { errors.commissions = value; },
                    getTainted: () => tainted.commissions,
                    setTainted: (value: Option<boolean>) => { tainted.commissions = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrder("commissions", data.commissions);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["commissions", index] as const,
                        name: `commissions.${index}`,
                        constraints: { required: true },
                        get: () => data.commissions[index]!,
                        set: (value: number) => { data.commissions[index] = value; },
                        transform: (value: number): number => value,
                        getError: () => errors.commissions,
                        setError: (value: Option<Array<string>>) => { errors.commissions = value; },
                        getTainted: () => tainted.commissions,
                        setTainted: (value: Option<boolean>) => { tainted.commissions = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: number) => { data.commissions.push(item); },
                    remove: (index: number) => { data.commissions.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.commissions[a]!;
                        data.commissions[a] = data.commissions[b]!;
                        data.commissions[b] = tmp;
                    },
                }}; function validate(): Result<Order, Array<{field: string; message: string}>>{return fromObjectOrder(data);}function reset(newOverrides?: Partial<Order>): void {data = {...defaultValueOrder(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), account: Option.none(), stage: Option.none(), number: Option.none(), payments: Option.none(), opportunity: Option.none(), reference: Option.none(), leadSource: Option.none(), salesRep: Option.none(), group: Option.none(), subgroup: Option.none(), isPosted: Option.none(), needsReview: Option.none(), actionItem: Option.none(), upsale: Option.none(), dateCreated: Option.none(), appointment: Option.none(), lastTechs: Option.none(), package: Option.none(), promotion: Option.none(), balance: Option.none(), due: Option.none(), total: Option.none(), site: Option.none(), billedItems: Option.none(), memo: Option.none(), discount: Option.none(), tip: Option.none(), commissions: Option.none() }; tainted = { id: Option.none(), account: Option.none(), stage: Option.none(), number: Option.none(), payments: Option.none(), opportunity: Option.none(), reference: Option.none(), leadSource: Option.none(), salesRep: Option.none(), group: Option.none(), subgroup: Option.none(), isPosted: Option.none(), needsReview: Option.none(), actionItem: Option.none(), upsale: Option.none(), dateCreated: Option.none(), appointment: Option.none(), lastTechs: Option.none(), package: Option.none(), promotion: Option.none(), balance: Option.none(), due: Option.none(), total: Option.none(), site: Option.none(), billedItems: Option.none(), memo: Option.none(), discount: Option.none(), tip: Option.none(), commissions: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataOrder(formData: FormData): Result<Order, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.account = formData.get("account") ?? "";
            {
            // Collect nested object fields with prefix "stage."
            const stageObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("stage.")) {
                    const fieldName = key.slice("stage.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = stageObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.stage = stageObj;
        }
            {
                const numberStr = formData.get("number");
                obj.number = numberStr ? parseFloat(numberStr as string) : 0;
                if (obj.number !== undefined && isNaN(obj.number as number)) obj.number = 0;
            }
            {
                // Collect array items from indexed form fields
                const paymentsItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("payments." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("payments." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("payments." + idx + ".")) {
                                const fieldName = key.slice("payments.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        paymentsItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.payments = paymentsItems;
            }
            obj.opportunity = formData.get("opportunity") ?? "";
            obj.reference = formData.get("reference") ?? "";
            obj.leadSource = formData.get("leadSource") ?? "";
            obj.salesRep = formData.get("salesRep") ?? "";
            obj.group = formData.get("group") ?? "";
            obj.subgroup = formData.get("subgroup") ?? "";
            {
                const isPostedVal = formData.get("isPosted");
                obj.isPosted = isPostedVal === "true" || isPostedVal === "on" || isPostedVal === "1";
            }
            {
                const needsReviewVal = formData.get("needsReview");
                obj.needsReview = needsReviewVal === "true" || needsReviewVal === "on" || needsReviewVal === "1";
            }
            obj.actionItem = formData.get("actionItem") ?? "";
            {
                const upsaleStr = formData.get("upsale");
                obj.upsale = upsaleStr ? parseFloat(upsaleStr as string) : 0;
                if (obj.upsale !== undefined && isNaN(obj.upsale as number)) obj.upsale = 0;
            }
            obj.dateCreated = formData.get("dateCreated") ?? "";
            obj.appointment = formData.get("appointment") ?? "";
            {
                // Collect array items from indexed form fields
                const lastTechsItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("lastTechs." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("lastTechs." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("lastTechs." + idx + ".")) {
                                const fieldName = key.slice("lastTechs.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        lastTechsItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.lastTechs = lastTechsItems;
            }
            obj.package = formData.get("package") ?? "";
            obj.promotion = formData.get("promotion") ?? "";
            {
                const balanceStr = formData.get("balance");
                obj.balance = balanceStr ? parseFloat(balanceStr as string) : 0;
                if (obj.balance !== undefined && isNaN(obj.balance as number)) obj.balance = 0;
            }
            obj.due = formData.get("due") ?? "";
            {
                const totalStr = formData.get("total");
                obj.total = totalStr ? parseFloat(totalStr as string) : 0;
                if (obj.total !== undefined && isNaN(obj.total as number)) obj.total = 0;
            }
            obj.site = formData.get("site") ?? "";
            {
                // Collect array items from indexed form fields
                const billedItemsItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("billedItems." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("billedItems." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("billedItems." + idx + ".")) {
                                const fieldName = key.slice("billedItems.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        billedItemsItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.billedItems = billedItemsItems;
            }
            obj.memo = formData.get("memo") ?? "";
            {
                const discountStr = formData.get("discount");
                obj.discount = discountStr ? parseFloat(discountStr as string) : 0;
                if (obj.discount !== undefined && isNaN(obj.discount as number)) obj.discount = 0;
            }
            {
                const tipStr = formData.get("tip");
                obj.tip = tipStr ? parseFloat(tipStr as string) : 0;
                if (obj.tip !== undefined && isNaN(obj.tip as number)) obj.tip = 0;
            }
            obj.commissions = formData.getAll("commissions").map(v => parseFloat(v as string)).filter(n => !isNaN(n)); return fromStringifiedJSONOrder(JSON.stringify(obj));}


export interface Commented {
    
    comment: string;
    replyTo: string | null;
}

export function defaultValueCommented(): Commented {return {comment: "",
                            replyTo: null, }as Commented;}

export function toStringifiedJSONCommented(value: Commented): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeCommented(value, ctx));}export function toObjectCommented(value: Commented): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeCommented(value, ctx);}export function __serializeCommented(value: Commented, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Commented" , __id,}; result["comment" ]= value.comment; result["replyTo" ]= value.replyTo; return result;}

export function fromStringifiedJSONCommented(json: string, opts?: DeserializeOptions): Result<Commented, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectCommented(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectCommented(obj: unknown, opts?: DeserializeOptions): Result<Commented, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeCommented(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Commented.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeCommented(value: any, ctx: DeserializeContext): Commented | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Commented.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("comment" in obj)){errors.push({field: "comment" , message: "missing required field" });}if(!("replyTo" in obj)){errors.push({field: "replyTo" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_comment = obj["comment" ]as string; 
                if (__raw_comment.length === 0) {
                    errors.push({ field: "comment", message: "must not be empty" });
                }
 instance.comment = __raw_comment; }{const __raw_replyTo = obj["replyTo" ]as string | null; instance.replyTo = __raw_replyTo; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Commented;}export function validateFieldCommented<K extends keyof Commented>(field: K, value: Commented[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "comment" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "comment", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsCommented(partial: Partial<Commented>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("comment" in partial && partial.comment!== undefined){const __val = partial.comment as string; 
                if (__val.length === 0) {
                    errors.push({ field: "comment", message: "must not be empty" });
                }
}return errors; }export function hasShapeCommented(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "comment" in o && "replyTo" in o;}export function isCommented(obj: unknown): obj is Commented {if(!hasShapeCommented(obj)){return false;}const result = fromObjectCommented(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsCommented = {_errors: Option<Array<string>>; comment: Option<Array<string>>;
            replyTo: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedCommented = {comment: Option<boolean>;
            replyTo: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersCommented {readonly comment: FieldController<string>;
            readonly replyTo: FieldController<string | null>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformCommented {readonly data: Commented; readonly errors: ErrorsCommented; readonly tainted: TaintedCommented; readonly fields: FieldControllersCommented; validate(): Result<Commented, Array<{field: string; message: string}>>; reset(overrides?: Partial<Commented>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormCommented(overrides?: Partial<Commented>): GigaformCommented {let data = $state({...defaultValueCommented(),...overrides}); let errors = $state<ErrorsCommented>({ _errors: Option.none(), comment: Option.none(), replyTo: Option.none() }); let tainted = $state<TaintedCommented>({ comment: Option.none(), replyTo: Option.none() }); const fields: FieldControllersCommented = {comment: {
                    path: ["comment"] as const,
                    name: "comment",
                    constraints: { required: true },
                    
                    get: () => data.comment,
                    set: (value: string) => { data.comment = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.comment,
                    setError: (value: Option<Array<string>>) => { errors.comment = value; },
                    getTainted: () => tainted.comment,
                    setTainted: (value: Option<boolean>) => { tainted.comment = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCommented("comment", data.comment);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                replyTo: {
                    path: ["replyTo"] as const,
                    name: "replyTo",
                    constraints: { required: true },
                    
                    get: () => data.replyTo,
                    set: (value: string | null) => { data.replyTo = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.replyTo,
                    setError: (value: Option<Array<string>>) => { errors.replyTo = value; },
                    getTainted: () => tainted.replyTo,
                    setTainted: (value: Option<boolean>) => { tainted.replyTo = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCommented("replyTo", data.replyTo);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Commented, Array<{field: string; message: string}>>{return fromObjectCommented(data);}function reset(newOverrides?: Partial<Commented>): void {data = {...defaultValueCommented(),...newOverrides}; errors = { _errors: Option.none(), comment: Option.none(), replyTo: Option.none() }; tainted = { comment: Option.none(), replyTo: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataCommented(formData: FormData): Result<Commented, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.comment = formData.get("comment") ?? "";
            obj.replyTo = formData.get("replyTo") ?? ""; return fromStringifiedJSONCommented(JSON.stringify(obj));}


export interface Custom {
    mappings: DirectionHue[];
}

export function defaultValueCustom(): Custom {return {mappings: [], }as Custom;}

export function toStringifiedJSONCustom(value: Custom): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeCustom(value, ctx));}export function toObjectCustom(value: Custom): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeCustom(value, ctx);}export function __serializeCustom(value: Custom, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Custom" , __id,}; result["mappings" ]= value.mappings.map((item)=>__serializeDirectionHue(item, ctx)); return result;}

export function fromStringifiedJSONCustom(json: string, opts?: DeserializeOptions): Result<Custom, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectCustom(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectCustom(obj: unknown, opts?: DeserializeOptions): Result<Custom, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeCustom(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Custom.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeCustom(value: any, ctx: DeserializeContext): Custom | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Custom.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("mappings" in obj)){errors.push({field: "mappings" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_mappings = obj["mappings" ]as DirectionHue[]; if(Array.isArray(__raw_mappings)){instance.mappings = __raw_mappings as DirectionHue[];}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Custom;}export function validateFieldCustom<K extends keyof Custom>(field: K, value: Custom[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsCustom(partial: Partial<Custom>): Array<{field: string; message: string}>{return[]; }export function hasShapeCustom(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "mappings" in o;}export function isCustom(obj: unknown): obj is Custom {if(!hasShapeCustom(obj)){return false;}const result = fromObjectCustom(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsCustom = {_errors: Option<Array<string>>; mappings: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedCustom = {mappings: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersCustom {readonly mappings: ArrayFieldController<DirectionHue>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformCustom {readonly data: Custom; readonly errors: ErrorsCustom; readonly tainted: TaintedCustom; readonly fields: FieldControllersCustom; validate(): Result<Custom, Array<{field: string; message: string}>>; reset(overrides?: Partial<Custom>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormCustom(overrides?: Partial<Custom>): GigaformCustom {let data = $state({...defaultValueCustom(),...overrides}); let errors = $state<ErrorsCustom>({ _errors: Option.none(), mappings: Option.none() }); let tainted = $state<TaintedCustom>({ mappings: Option.none() }); const fields: FieldControllersCustom = {mappings: {
                    path: ["mappings"] as const,
                    name: "mappings",
                    constraints: { required: true },
                    
                    get: () => data.mappings,
                    set: (value: DirectionHue[]) => { data.mappings = value; },
                    transform: (value: DirectionHue[]): DirectionHue[] => value,
                    getError: () => errors.mappings,
                    setError: (value: Option<Array<string>>) => { errors.mappings = value; },
                    getTainted: () => tainted.mappings,
                    setTainted: (value: Option<boolean>) => { tainted.mappings = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCustom("mappings", data.mappings);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["mappings", index] as const,
                        name: `mappings.${index}`,
                        constraints: { required: true },
                        get: () => data.mappings[index]!,
                        set: (value: DirectionHue) => { data.mappings[index] = value; },
                        transform: (value: DirectionHue): DirectionHue => value,
                        getError: () => errors.mappings,
                        setError: (value: Option<Array<string>>) => { errors.mappings = value; },
                        getTainted: () => tainted.mappings,
                        setTainted: (value: Option<boolean>) => { tainted.mappings = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: DirectionHue) => { data.mappings.push(item); },
                    remove: (index: number) => { data.mappings.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.mappings[a]!;
                        data.mappings[a] = data.mappings[b]!;
                        data.mappings[b] = tmp;
                    },
                }}; function validate(): Result<Custom, Array<{field: string; message: string}>>{return fromObjectCustom(data);}function reset(newOverrides?: Partial<Custom>): void {data = {...defaultValueCustom(),...newOverrides}; errors = { _errors: Option.none(), mappings: Option.none() }; tainted = { mappings: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataCustom(formData: FormData): Result<Custom, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                // Collect array items from indexed form fields
                const mappingsItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("mappings." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("mappings." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("mappings." + idx + ".")) {
                                const fieldName = key.slice("mappings.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        mappingsItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.mappings = mappingsItems;
            } return fromStringifiedJSONCustom(JSON.stringify(obj));}


export interface Colors {
    
    main: string;
    
    hover: string;
    
    active: string;
}

export function defaultValueColors(): Colors {return {main: "",
                            hover: "",
                            active: "", }as Colors;}

export function toStringifiedJSONColors(value: Colors): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeColors(value, ctx));}export function toObjectColors(value: Colors): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeColors(value, ctx);}export function __serializeColors(value: Colors, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Colors" , __id,}; result["main" ]= value.main; result["hover" ]= value.hover; result["active" ]= value.active; return result;}

export function fromStringifiedJSONColors(json: string, opts?: DeserializeOptions): Result<Colors, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectColors(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectColors(obj: unknown, opts?: DeserializeOptions): Result<Colors, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeColors(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Colors.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeColors(value: any, ctx: DeserializeContext): Colors | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Colors.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("main" in obj)){errors.push({field: "main" , message: "missing required field" });}if(!("hover" in obj)){errors.push({field: "hover" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_main = obj["main" ]as string; 
                if (__raw_main.length === 0) {
                    errors.push({ field: "main", message: "must not be empty" });
                }
 instance.main = __raw_main; }{const __raw_hover = obj["hover" ]as string; 
                if (__raw_hover.length === 0) {
                    errors.push({ field: "hover", message: "must not be empty" });
                }
 instance.hover = __raw_hover; }{const __raw_active = obj["active" ]as string; 
                if (__raw_active.length === 0) {
                    errors.push({ field: "active", message: "must not be empty" });
                }
 instance.active = __raw_active; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Colors;}export function validateFieldColors<K extends keyof Colors>(field: K, value: Colors[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "main" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "main", message: "must not be empty" });
                }
 break;}case "hover" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "hover", message: "must not be empty" });
                }
 break;}case "active" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "active", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsColors(partial: Partial<Colors>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("main" in partial && partial.main!== undefined){const __val = partial.main as string; 
                if (__val.length === 0) {
                    errors.push({ field: "main", message: "must not be empty" });
                }
}if("hover" in partial && partial.hover!== undefined){const __val = partial.hover as string; 
                if (__val.length === 0) {
                    errors.push({ field: "hover", message: "must not be empty" });
                }
}if("active" in partial && partial.active!== undefined){const __val = partial.active as string; 
                if (__val.length === 0) {
                    errors.push({ field: "active", message: "must not be empty" });
                }
}return errors; }export function hasShapeColors(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "main" in o && "hover" in o && "active" in o;}export function isColors(obj: unknown): obj is Colors {if(!hasShapeColors(obj)){return false;}const result = fromObjectColors(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsColors = {_errors: Option<Array<string>>; main: Option<Array<string>>;
            hover: Option<Array<string>>;
            active: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedColors = {main: Option<boolean>;
            hover: Option<boolean>;
            active: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersColors {readonly main: FieldController<string>;
            readonly hover: FieldController<string>;
            readonly active: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformColors {readonly data: Colors; readonly errors: ErrorsColors; readonly tainted: TaintedColors; readonly fields: FieldControllersColors; validate(): Result<Colors, Array<{field: string; message: string}>>; reset(overrides?: Partial<Colors>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormColors(overrides?: Partial<Colors>): GigaformColors {let data = $state({...defaultValueColors(),...overrides}); let errors = $state<ErrorsColors>({ _errors: Option.none(), main: Option.none(), hover: Option.none(), active: Option.none() }); let tainted = $state<TaintedColors>({ main: Option.none(), hover: Option.none(), active: Option.none() }); const fields: FieldControllersColors = {main: {
                    path: ["main"] as const,
                    name: "main",
                    constraints: { required: true },
                    
                    get: () => data.main,
                    set: (value: string) => { data.main = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.main,
                    setError: (value: Option<Array<string>>) => { errors.main = value; },
                    getTainted: () => tainted.main,
                    setTainted: (value: Option<boolean>) => { tainted.main = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldColors("main", data.main);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                hover: {
                    path: ["hover"] as const,
                    name: "hover",
                    constraints: { required: true },
                    
                    get: () => data.hover,
                    set: (value: string) => { data.hover = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.hover,
                    setError: (value: Option<Array<string>>) => { errors.hover = value; },
                    getTainted: () => tainted.hover,
                    setTainted: (value: Option<boolean>) => { tainted.hover = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldColors("hover", data.hover);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                active: {
                    path: ["active"] as const,
                    name: "active",
                    constraints: { required: true },
                    
                    get: () => data.active,
                    set: (value: string) => { data.active = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.active,
                    setError: (value: Option<Array<string>>) => { errors.active = value; },
                    getTainted: () => tainted.active,
                    setTainted: (value: Option<boolean>) => { tainted.active = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldColors("active", data.active);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Colors, Array<{field: string; message: string}>>{return fromObjectColors(data);}function reset(newOverrides?: Partial<Colors>): void {data = {...defaultValueColors(),...newOverrides}; errors = { _errors: Option.none(), main: Option.none(), hover: Option.none(), active: Option.none() }; tainted = { main: Option.none(), hover: Option.none(), active: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataColors(formData: FormData): Result<Colors, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.main = formData.get("main") ?? "";
            obj.hover = formData.get("hover") ?? "";
            obj.active = formData.get("active") ?? ""; return fromStringifiedJSONColors(JSON.stringify(obj));}


export interface ProductDefaults {
    
    price: number;
    
    
    description: string;
}

export function defaultValueProductDefaults(): ProductDefaults {return {price: 0,
                            description: "", }as ProductDefaults;}

export function toStringifiedJSONProductDefaults(value: ProductDefaults): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeProductDefaults(value, ctx));}export function toObjectProductDefaults(value: ProductDefaults): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeProductDefaults(value, ctx);}export function __serializeProductDefaults(value: ProductDefaults, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "ProductDefaults" , __id,}; result["price" ]= value.price; result["description" ]= value.description; return result;}

export function fromStringifiedJSONProductDefaults(json: string, opts?: DeserializeOptions): Result<ProductDefaults, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectProductDefaults(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectProductDefaults(obj: unknown, opts?: DeserializeOptions): Result<ProductDefaults, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeProductDefaults(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "ProductDefaults.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeProductDefaults(value: any, ctx: DeserializeContext): ProductDefaults | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "ProductDefaults.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("price" in obj)){errors.push({field: "price" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_price = obj["price" ]as number; instance.price = __raw_price; }{const __raw_description = obj["description" ]as string; 
                if (__raw_description.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 instance.description = __raw_description; }if(errors.length>0){throw new DeserializeError(errors);}return instance as ProductDefaults;}export function validateFieldProductDefaults<K extends keyof ProductDefaults>(field: K, value: ProductDefaults[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "description" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsProductDefaults(partial: Partial<ProductDefaults>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("description" in partial && partial.description!== undefined){const __val = partial.description as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
}return errors; }export function hasShapeProductDefaults(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "price" in o && "description" in o;}export function isProductDefaults(obj: unknown): obj is ProductDefaults {if(!hasShapeProductDefaults(obj)){return false;}const result = fromObjectProductDefaults(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsProductDefaults = {_errors: Option<Array<string>>; price: Option<Array<string>>;
            description: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedProductDefaults = {price: Option<boolean>;
            description: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersProductDefaults {readonly price: FieldController<number>;
            readonly description: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformProductDefaults {readonly data: ProductDefaults; readonly errors: ErrorsProductDefaults; readonly tainted: TaintedProductDefaults; readonly fields: FieldControllersProductDefaults; validate(): Result<ProductDefaults, Array<{field: string; message: string}>>; reset(overrides?: Partial<ProductDefaults>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormProductDefaults(overrides?: Partial<ProductDefaults>): GigaformProductDefaults {let data = $state({...defaultValueProductDefaults(),...overrides}); let errors = $state<ErrorsProductDefaults>({ _errors: Option.none(), price: Option.none(), description: Option.none() }); let tainted = $state<TaintedProductDefaults>({ price: Option.none(), description: Option.none() }); const fields: FieldControllersProductDefaults = {price: {
                    path: ["price"] as const,
                    name: "price",
                    constraints: { required: true },
                    label: "Price",
                    get: () => data.price,
                    set: (value: number) => { data.price = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.price,
                    setError: (value: Option<Array<string>>) => { errors.price = value; },
                    getTainted: () => tainted.price,
                    setTainted: (value: Option<boolean>) => { tainted.price = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldProductDefaults("price", data.price);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                description: {
                    path: ["description"] as const,
                    name: "description",
                    constraints: { required: true },
                    label: "Description",
                    get: () => data.description,
                    set: (value: string) => { data.description = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.description,
                    setError: (value: Option<Array<string>>) => { errors.description = value; },
                    getTainted: () => tainted.description,
                    setTainted: (value: Option<boolean>) => { tainted.description = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldProductDefaults("description", data.description);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<ProductDefaults, Array<{field: string; message: string}>>{return fromObjectProductDefaults(data);}function reset(newOverrides?: Partial<ProductDefaults>): void {data = {...defaultValueProductDefaults(),...newOverrides}; errors = { _errors: Option.none(), price: Option.none(), description: Option.none() }; tainted = { price: Option.none(), description: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataProductDefaults(formData: FormData): Result<ProductDefaults, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const priceStr = formData.get("price");
                obj.price = priceStr ? parseFloat(priceStr as string) : 0;
                if (obj.price !== undefined && isNaN(obj.price as number)) obj.price = 0;
            }
            obj.description = formData.get("description") ?? ""; return fromStringifiedJSONProductDefaults(JSON.stringify(obj));}


export interface Viewed {
    durationSeconds: number | null;
    source: string | null;
}

export function defaultValueViewed(): Viewed {return {durationSeconds: null,
                            source: null, }as Viewed;}

export function toStringifiedJSONViewed(value: Viewed): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeViewed(value, ctx));}export function toObjectViewed(value: Viewed): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeViewed(value, ctx);}export function __serializeViewed(value: Viewed, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Viewed" , __id,}; result["durationSeconds" ]= value.durationSeconds; result["source" ]= value.source; return result;}

export function fromStringifiedJSONViewed(json: string, opts?: DeserializeOptions): Result<Viewed, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectViewed(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectViewed(obj: unknown, opts?: DeserializeOptions): Result<Viewed, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeViewed(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Viewed.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeViewed(value: any, ctx: DeserializeContext): Viewed | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Viewed.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("durationSeconds" in obj)){errors.push({field: "durationSeconds" , message: "missing required field" });}if(!("source" in obj)){errors.push({field: "source" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_durationSeconds = obj["durationSeconds" ]as number | null; instance.durationSeconds = __raw_durationSeconds; }{const __raw_source = obj["source" ]as string | null; instance.source = __raw_source; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Viewed;}export function validateFieldViewed<K extends keyof Viewed>(field: K, value: Viewed[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsViewed(partial: Partial<Viewed>): Array<{field: string; message: string}>{return[]; }export function hasShapeViewed(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "durationSeconds" in o && "source" in o;}export function isViewed(obj: unknown): obj is Viewed {if(!hasShapeViewed(obj)){return false;}const result = fromObjectViewed(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsViewed = {_errors: Option<Array<string>>; durationSeconds: Option<Array<string>>;
            source: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedViewed = {durationSeconds: Option<boolean>;
            source: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersViewed {readonly durationSeconds: FieldController<number | null>;
            readonly source: FieldController<string | null>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformViewed {readonly data: Viewed; readonly errors: ErrorsViewed; readonly tainted: TaintedViewed; readonly fields: FieldControllersViewed; validate(): Result<Viewed, Array<{field: string; message: string}>>; reset(overrides?: Partial<Viewed>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormViewed(overrides?: Partial<Viewed>): GigaformViewed {let data = $state({...defaultValueViewed(),...overrides}); let errors = $state<ErrorsViewed>({ _errors: Option.none(), durationSeconds: Option.none(), source: Option.none() }); let tainted = $state<TaintedViewed>({ durationSeconds: Option.none(), source: Option.none() }); const fields: FieldControllersViewed = {durationSeconds: {
                    path: ["durationSeconds"] as const,
                    name: "durationSeconds",
                    constraints: { required: true },
                    
                    get: () => data.durationSeconds,
                    set: (value: number | null) => { data.durationSeconds = value; },
                    transform: (value: number | null): number | null => value,
                    getError: () => errors.durationSeconds,
                    setError: (value: Option<Array<string>>) => { errors.durationSeconds = value; },
                    getTainted: () => tainted.durationSeconds,
                    setTainted: (value: Option<boolean>) => { tainted.durationSeconds = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldViewed("durationSeconds", data.durationSeconds);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                source: {
                    path: ["source"] as const,
                    name: "source",
                    constraints: { required: true },
                    
                    get: () => data.source,
                    set: (value: string | null) => { data.source = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.source,
                    setError: (value: Option<Array<string>>) => { errors.source = value; },
                    getTainted: () => tainted.source,
                    setTainted: (value: Option<boolean>) => { tainted.source = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldViewed("source", data.source);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Viewed, Array<{field: string; message: string}>>{return fromObjectViewed(data);}function reset(newOverrides?: Partial<Viewed>): void {data = {...defaultValueViewed(),...newOverrides}; errors = { _errors: Option.none(), durationSeconds: Option.none(), source: Option.none() }; tainted = { durationSeconds: Option.none(), source: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataViewed(formData: FormData): Result<Viewed, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const durationSecondsStr = formData.get("durationSeconds");
                obj.durationSeconds = durationSecondsStr ? parseFloat(durationSecondsStr as string) : 0;
                if (obj.durationSeconds !== undefined && isNaN(obj.durationSeconds as number)) obj.durationSeconds = 0;
            }
            obj.source = formData.get("source") ?? ""; return fromStringifiedJSONViewed(JSON.stringify(obj));}


export interface WeeklyRecurrenceRule {
    quantityOfWeeks: number;
    weekdays: Weekday[];
}

export function defaultValueWeeklyRecurrenceRule(): WeeklyRecurrenceRule {return {quantityOfWeeks: 0,
                            weekdays: [], }as WeeklyRecurrenceRule;}

export function toStringifiedJSONWeeklyRecurrenceRule(value: WeeklyRecurrenceRule): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeWeeklyRecurrenceRule(value, ctx));}export function toObjectWeeklyRecurrenceRule(value: WeeklyRecurrenceRule): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeWeeklyRecurrenceRule(value, ctx);}export function __serializeWeeklyRecurrenceRule(value: WeeklyRecurrenceRule, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "WeeklyRecurrenceRule" , __id,}; result["quantityOfWeeks" ]= value.quantityOfWeeks; result["weekdays" ]= value.weekdays.map((item)=>__serializeWeekday(item, ctx)); return result;}

export function fromStringifiedJSONWeeklyRecurrenceRule(json: string, opts?: DeserializeOptions): Result<WeeklyRecurrenceRule, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectWeeklyRecurrenceRule(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectWeeklyRecurrenceRule(obj: unknown, opts?: DeserializeOptions): Result<WeeklyRecurrenceRule, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeWeeklyRecurrenceRule(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "WeeklyRecurrenceRule.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeWeeklyRecurrenceRule(value: any, ctx: DeserializeContext): WeeklyRecurrenceRule | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "WeeklyRecurrenceRule.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("quantityOfWeeks" in obj)){errors.push({field: "quantityOfWeeks" , message: "missing required field" });}if(!("weekdays" in obj)){errors.push({field: "weekdays" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_quantityOfWeeks = obj["quantityOfWeeks" ]as number; instance.quantityOfWeeks = __raw_quantityOfWeeks; }{const __raw_weekdays = obj["weekdays" ]as Weekday[]; if(Array.isArray(__raw_weekdays)){instance.weekdays = __raw_weekdays as Weekday[];}}if(errors.length>0){throw new DeserializeError(errors);}return instance as WeeklyRecurrenceRule;}export function validateFieldWeeklyRecurrenceRule<K extends keyof WeeklyRecurrenceRule>(field: K, value: WeeklyRecurrenceRule[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsWeeklyRecurrenceRule(partial: Partial<WeeklyRecurrenceRule>): Array<{field: string; message: string}>{return[]; }export function hasShapeWeeklyRecurrenceRule(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "quantityOfWeeks" in o && "weekdays" in o;}export function isWeeklyRecurrenceRule(obj: unknown): obj is WeeklyRecurrenceRule {if(!hasShapeWeeklyRecurrenceRule(obj)){return false;}const result = fromObjectWeeklyRecurrenceRule(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsWeeklyRecurrenceRule = {_errors: Option<Array<string>>; quantityOfWeeks: Option<Array<string>>;
            weekdays: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedWeeklyRecurrenceRule = {quantityOfWeeks: Option<boolean>;
            weekdays: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersWeeklyRecurrenceRule {readonly quantityOfWeeks: FieldController<number>;
            readonly weekdays: ArrayFieldController<Weekday>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformWeeklyRecurrenceRule {readonly data: WeeklyRecurrenceRule; readonly errors: ErrorsWeeklyRecurrenceRule; readonly tainted: TaintedWeeklyRecurrenceRule; readonly fields: FieldControllersWeeklyRecurrenceRule; validate(): Result<WeeklyRecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<WeeklyRecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormWeeklyRecurrenceRule(overrides?: Partial<WeeklyRecurrenceRule>): GigaformWeeklyRecurrenceRule {let data = $state({...defaultValueWeeklyRecurrenceRule(),...overrides}); let errors = $state<ErrorsWeeklyRecurrenceRule>({ _errors: Option.none(), quantityOfWeeks: Option.none(), weekdays: Option.none() }); let tainted = $state<TaintedWeeklyRecurrenceRule>({ quantityOfWeeks: Option.none(), weekdays: Option.none() }); const fields: FieldControllersWeeklyRecurrenceRule = {quantityOfWeeks: {
                    path: ["quantityOfWeeks"] as const,
                    name: "quantityOfWeeks",
                    constraints: { required: true },
                    
                    get: () => data.quantityOfWeeks,
                    set: (value: number) => { data.quantityOfWeeks = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.quantityOfWeeks,
                    setError: (value: Option<Array<string>>) => { errors.quantityOfWeeks = value; },
                    getTainted: () => tainted.quantityOfWeeks,
                    setTainted: (value: Option<boolean>) => { tainted.quantityOfWeeks = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldWeeklyRecurrenceRule("quantityOfWeeks", data.quantityOfWeeks);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                weekdays: {
                    path: ["weekdays"] as const,
                    name: "weekdays",
                    constraints: { required: true },
                    
                    get: () => data.weekdays,
                    set: (value: Weekday[]) => { data.weekdays = value; },
                    transform: (value: Weekday[]): Weekday[] => value,
                    getError: () => errors.weekdays,
                    setError: (value: Option<Array<string>>) => { errors.weekdays = value; },
                    getTainted: () => tainted.weekdays,
                    setTainted: (value: Option<boolean>) => { tainted.weekdays = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldWeeklyRecurrenceRule("weekdays", data.weekdays);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["weekdays", index] as const,
                        name: `weekdays.${index}`,
                        constraints: { required: true },
                        get: () => data.weekdays[index]!,
                        set: (value: Weekday) => { data.weekdays[index] = value; },
                        transform: (value: Weekday): Weekday => value,
                        getError: () => errors.weekdays,
                        setError: (value: Option<Array<string>>) => { errors.weekdays = value; },
                        getTainted: () => tainted.weekdays,
                        setTainted: (value: Option<boolean>) => { tainted.weekdays = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: Weekday) => { data.weekdays.push(item); },
                    remove: (index: number) => { data.weekdays.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.weekdays[a]!;
                        data.weekdays[a] = data.weekdays[b]!;
                        data.weekdays[b] = tmp;
                    },
                }}; function validate(): Result<WeeklyRecurrenceRule, Array<{field: string; message: string}>>{return fromObjectWeeklyRecurrenceRule(data);}function reset(newOverrides?: Partial<WeeklyRecurrenceRule>): void {data = {...defaultValueWeeklyRecurrenceRule(),...newOverrides}; errors = { _errors: Option.none(), quantityOfWeeks: Option.none(), weekdays: Option.none() }; tainted = { quantityOfWeeks: Option.none(), weekdays: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataWeeklyRecurrenceRule(formData: FormData): Result<WeeklyRecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const quantityOfWeeksStr = formData.get("quantityOfWeeks");
                obj.quantityOfWeeks = quantityOfWeeksStr ? parseFloat(quantityOfWeeksStr as string) : 0;
                if (obj.quantityOfWeeks !== undefined && isNaN(obj.quantityOfWeeks as number)) obj.quantityOfWeeks = 0;
            }
            {
                // Collect array items from indexed form fields
                const weekdaysItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("weekdays." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("weekdays." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("weekdays." + idx + ".")) {
                                const fieldName = key.slice("weekdays.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        weekdaysItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.weekdays = weekdaysItems;
            } return fromStringifiedJSONWeeklyRecurrenceRule(JSON.stringify(obj));}


export interface Paid {
    amount: number | null;
    currency: string | null;
    paymentMethod: string | null;
}

export function defaultValuePaid(): Paid {return {amount: null,
                            currency: null,
                            paymentMethod: null, }as Paid;}

export function toStringifiedJSONPaid(value: Paid): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializePaid(value, ctx));}export function toObjectPaid(value: Paid): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializePaid(value, ctx);}export function __serializePaid(value: Paid, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Paid" , __id,}; result["amount" ]= value.amount; result["currency" ]= value.currency; result["paymentMethod" ]= value.paymentMethod; return result;}

export function fromStringifiedJSONPaid(json: string, opts?: DeserializeOptions): Result<Paid, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectPaid(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectPaid(obj: unknown, opts?: DeserializeOptions): Result<Paid, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializePaid(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Paid.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializePaid(value: any, ctx: DeserializeContext): Paid | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Paid.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("amount" in obj)){errors.push({field: "amount" , message: "missing required field" });}if(!("currency" in obj)){errors.push({field: "currency" , message: "missing required field" });}if(!("paymentMethod" in obj)){errors.push({field: "paymentMethod" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_amount = obj["amount" ]as number | null; instance.amount = __raw_amount; }{const __raw_currency = obj["currency" ]as string | null; instance.currency = __raw_currency; }{const __raw_paymentMethod = obj["paymentMethod" ]as string | null; instance.paymentMethod = __raw_paymentMethod; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Paid;}export function validateFieldPaid<K extends keyof Paid>(field: K, value: Paid[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsPaid(partial: Partial<Paid>): Array<{field: string; message: string}>{return[]; }export function hasShapePaid(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "amount" in o && "currency" in o && "paymentMethod" in o;}export function isPaid(obj: unknown): obj is Paid {if(!hasShapePaid(obj)){return false;}const result = fromObjectPaid(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsPaid = {_errors: Option<Array<string>>; amount: Option<Array<string>>;
            currency: Option<Array<string>>;
            paymentMethod: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedPaid = {amount: Option<boolean>;
            currency: Option<boolean>;
            paymentMethod: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersPaid {readonly amount: FieldController<number | null>;
            readonly currency: FieldController<string | null>;
            readonly paymentMethod: FieldController<string | null>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformPaid {readonly data: Paid; readonly errors: ErrorsPaid; readonly tainted: TaintedPaid; readonly fields: FieldControllersPaid; validate(): Result<Paid, Array<{field: string; message: string}>>; reset(overrides?: Partial<Paid>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormPaid(overrides?: Partial<Paid>): GigaformPaid {let data = $state({...defaultValuePaid(),...overrides}); let errors = $state<ErrorsPaid>({ _errors: Option.none(), amount: Option.none(), currency: Option.none(), paymentMethod: Option.none() }); let tainted = $state<TaintedPaid>({ amount: Option.none(), currency: Option.none(), paymentMethod: Option.none() }); const fields: FieldControllersPaid = {amount: {
                    path: ["amount"] as const,
                    name: "amount",
                    constraints: { required: true },
                    
                    get: () => data.amount,
                    set: (value: number | null) => { data.amount = value; },
                    transform: (value: number | null): number | null => value,
                    getError: () => errors.amount,
                    setError: (value: Option<Array<string>>) => { errors.amount = value; },
                    getTainted: () => tainted.amount,
                    setTainted: (value: Option<boolean>) => { tainted.amount = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPaid("amount", data.amount);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                currency: {
                    path: ["currency"] as const,
                    name: "currency",
                    constraints: { required: true },
                    
                    get: () => data.currency,
                    set: (value: string | null) => { data.currency = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.currency,
                    setError: (value: Option<Array<string>>) => { errors.currency = value; },
                    getTainted: () => tainted.currency,
                    setTainted: (value: Option<boolean>) => { tainted.currency = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPaid("currency", data.currency);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                paymentMethod: {
                    path: ["paymentMethod"] as const,
                    name: "paymentMethod",
                    constraints: { required: true },
                    
                    get: () => data.paymentMethod,
                    set: (value: string | null) => { data.paymentMethod = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.paymentMethod,
                    setError: (value: Option<Array<string>>) => { errors.paymentMethod = value; },
                    getTainted: () => tainted.paymentMethod,
                    setTainted: (value: Option<boolean>) => { tainted.paymentMethod = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPaid("paymentMethod", data.paymentMethod);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Paid, Array<{field: string; message: string}>>{return fromObjectPaid(data);}function reset(newOverrides?: Partial<Paid>): void {data = {...defaultValuePaid(),...newOverrides}; errors = { _errors: Option.none(), amount: Option.none(), currency: Option.none(), paymentMethod: Option.none() }; tainted = { amount: Option.none(), currency: Option.none(), paymentMethod: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataPaid(formData: FormData): Result<Paid, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const amountStr = formData.get("amount");
                obj.amount = amountStr ? parseFloat(amountStr as string) : 0;
                if (obj.amount !== undefined && isNaN(obj.amount as number)) obj.amount = 0;
            }
            obj.currency = formData.get("currency") ?? "";
            obj.paymentMethod = formData.get("paymentMethod") ?? ""; return fromStringifiedJSONPaid(JSON.stringify(obj));}


export interface TaxRate {
    
    id: string;
    
    
    name: string;
    
    
    taxAgency: string;
    
    zip: number;
    
    
    city: string;
    
    
    county: string;
    
    
    state: string;
    
    isActive: boolean;
    
    
    description: string;
    
    
    taxComponents: { [key: string]: number };
}

export function defaultValueTaxRate(): TaxRate {return {id: "",
                            name: "",
                            taxAgency: "",
                            zip: 0,
                            city: "",
                            county: "",
                            state: "",
                            isActive: false,
                            description: "",
                            taxComponents: {}, }as TaxRate;}

export function toStringifiedJSONTaxRate(value: TaxRate): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeTaxRate(value, ctx));}export function toObjectTaxRate(value: TaxRate): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeTaxRate(value, ctx);}export function __serializeTaxRate(value: TaxRate, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "TaxRate" , __id,}; result["id" ]= value.id; result["name" ]= value.name; result["taxAgency" ]= value.taxAgency; result["zip" ]= value.zip; result["city" ]= value.city; result["county" ]= value.county; result["state" ]= value.state; result["isActive" ]= value.isActive; result["description" ]= value.description; result["taxComponents" ]= value.taxComponents; return result;}

export function fromStringifiedJSONTaxRate(json: string, opts?: DeserializeOptions): Result<TaxRate, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectTaxRate(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectTaxRate(obj: unknown, opts?: DeserializeOptions): Result<TaxRate, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeTaxRate(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "TaxRate.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeTaxRate(value: any, ctx: DeserializeContext): TaxRate | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "TaxRate.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("taxAgency" in obj)){errors.push({field: "taxAgency" , message: "missing required field" });}if(!("zip" in obj)){errors.push({field: "zip" , message: "missing required field" });}if(!("city" in obj)){errors.push({field: "city" , message: "missing required field" });}if(!("county" in obj)){errors.push({field: "county" , message: "missing required field" });}if(!("state" in obj)){errors.push({field: "state" , message: "missing required field" });}if(!("isActive" in obj)){errors.push({field: "isActive" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(!("taxComponents" in obj)){errors.push({field: "taxComponents" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_taxAgency = obj["taxAgency" ]as string; 
                if (__raw_taxAgency.length === 0) {
                    errors.push({ field: "taxAgency", message: "must not be empty" });
                }
 instance.taxAgency = __raw_taxAgency; }{const __raw_zip = obj["zip" ]as number; instance.zip = __raw_zip; }{const __raw_city = obj["city" ]as string; 
                if (__raw_city.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
 instance.city = __raw_city; }{const __raw_county = obj["county" ]as string; 
                if (__raw_county.length === 0) {
                    errors.push({ field: "county", message: "must not be empty" });
                }
 instance.county = __raw_county; }{const __raw_state = obj["state" ]as string; 
                if (__raw_state.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
 instance.state = __raw_state; }{const __raw_isActive = obj["isActive" ]as boolean; instance.isActive = __raw_isActive; }{const __raw_description = obj["description" ]as string; 
                if (__raw_description.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 instance.description = __raw_description; }{const __raw_taxComponents = obj["taxComponents" ]as { [key: string]: number }; instance.taxComponents = __raw_taxComponents; }if(errors.length>0){throw new DeserializeError(errors);}return instance as TaxRate;}export function validateFieldTaxRate<K extends keyof TaxRate>(field: K, value: TaxRate[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "taxAgency" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "taxAgency", message: "must not be empty" });
                }
 break;}case "city" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
 break;}case "county" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "county", message: "must not be empty" });
                }
 break;}case "state" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
 break;}case "description" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsTaxRate(partial: Partial<TaxRate>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("taxAgency" in partial && partial.taxAgency!== undefined){const __val = partial.taxAgency as string; 
                if (__val.length === 0) {
                    errors.push({ field: "taxAgency", message: "must not be empty" });
                }
}if("city" in partial && partial.city!== undefined){const __val = partial.city as string; 
                if (__val.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
}if("county" in partial && partial.county!== undefined){const __val = partial.county as string; 
                if (__val.length === 0) {
                    errors.push({ field: "county", message: "must not be empty" });
                }
}if("state" in partial && partial.state!== undefined){const __val = partial.state as string; 
                if (__val.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
}if("description" in partial && partial.description!== undefined){const __val = partial.description as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
}return errors; }export function hasShapeTaxRate(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "name" in o && "taxAgency" in o && "zip" in o && "city" in o && "county" in o && "state" in o && "isActive" in o && "description" in o && "taxComponents" in o;}export function isTaxRate(obj: unknown): obj is TaxRate {if(!hasShapeTaxRate(obj)){return false;}const result = fromObjectTaxRate(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsTaxRate = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            name: Option<Array<string>>;
            taxAgency: Option<Array<string>>;
            zip: Option<Array<string>>;
            city: Option<Array<string>>;
            county: Option<Array<string>>;
            state: Option<Array<string>>;
            isActive: Option<Array<string>>;
            description: Option<Array<string>>;
            taxComponents: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedTaxRate = {id: Option<boolean>;
            name: Option<boolean>;
            taxAgency: Option<boolean>;
            zip: Option<boolean>;
            city: Option<boolean>;
            county: Option<boolean>;
            state: Option<boolean>;
            isActive: Option<boolean>;
            description: Option<boolean>;
            taxComponents: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersTaxRate {readonly id: FieldController<string>;
            readonly name: FieldController<string>;
            readonly taxAgency: FieldController<string>;
            readonly zip: FieldController<number>;
            readonly city: FieldController<string>;
            readonly county: FieldController<string>;
            readonly state: FieldController<string>;
            readonly isActive: FieldController<boolean>;
            readonly description: FieldController<string>;
            readonly taxComponents: FieldController<{ [key: string]: number }>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformTaxRate {readonly data: TaxRate; readonly errors: ErrorsTaxRate; readonly tainted: TaintedTaxRate; readonly fields: FieldControllersTaxRate; validate(): Result<TaxRate, Array<{field: string; message: string}>>; reset(overrides?: Partial<TaxRate>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormTaxRate(overrides?: Partial<TaxRate>): GigaformTaxRate {let data = $state({...defaultValueTaxRate(),...overrides}); let errors = $state<ErrorsTaxRate>({ _errors: Option.none(), id: Option.none(), name: Option.none(), taxAgency: Option.none(), zip: Option.none(), city: Option.none(), county: Option.none(), state: Option.none(), isActive: Option.none(), description: Option.none(), taxComponents: Option.none() }); let tainted = $state<TaintedTaxRate>({ id: Option.none(), name: Option.none(), taxAgency: Option.none(), zip: Option.none(), city: Option.none(), county: Option.none(), state: Option.none(), isActive: Option.none(), description: Option.none(), taxComponents: Option.none() }); const fields: FieldControllersTaxRate = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldTaxRate("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                name: {
                    path: ["name"] as const,
                    name: "name",
                    constraints: { required: true },
                    label: "Name",
                    get: () => data.name,
                    set: (value: string) => { data.name = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.name,
                    setError: (value: Option<Array<string>>) => { errors.name = value; },
                    getTainted: () => tainted.name,
                    setTainted: (value: Option<boolean>) => { tainted.name = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldTaxRate("name", data.name);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                taxAgency: {
                    path: ["taxAgency"] as const,
                    name: "taxAgency",
                    constraints: { required: true },
                    label: "Tax Agency",
                    get: () => data.taxAgency,
                    set: (value: string) => { data.taxAgency = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.taxAgency,
                    setError: (value: Option<Array<string>>) => { errors.taxAgency = value; },
                    getTainted: () => tainted.taxAgency,
                    setTainted: (value: Option<boolean>) => { tainted.taxAgency = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldTaxRate("taxAgency", data.taxAgency);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                zip: {
                    path: ["zip"] as const,
                    name: "zip",
                    constraints: { required: true },
                    label: "Zip",
                    get: () => data.zip,
                    set: (value: number) => { data.zip = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.zip,
                    setError: (value: Option<Array<string>>) => { errors.zip = value; },
                    getTainted: () => tainted.zip,
                    setTainted: (value: Option<boolean>) => { tainted.zip = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldTaxRate("zip", data.zip);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                city: {
                    path: ["city"] as const,
                    name: "city",
                    constraints: { required: true },
                    label: "City",
                    get: () => data.city,
                    set: (value: string) => { data.city = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.city,
                    setError: (value: Option<Array<string>>) => { errors.city = value; },
                    getTainted: () => tainted.city,
                    setTainted: (value: Option<boolean>) => { tainted.city = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldTaxRate("city", data.city);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                county: {
                    path: ["county"] as const,
                    name: "county",
                    constraints: { required: true },
                    label: "County",
                    get: () => data.county,
                    set: (value: string) => { data.county = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.county,
                    setError: (value: Option<Array<string>>) => { errors.county = value; },
                    getTainted: () => tainted.county,
                    setTainted: (value: Option<boolean>) => { tainted.county = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldTaxRate("county", data.county);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                state: {
                    path: ["state"] as const,
                    name: "state",
                    constraints: { required: true },
                    label: "State",
                    get: () => data.state,
                    set: (value: string) => { data.state = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.state,
                    setError: (value: Option<Array<string>>) => { errors.state = value; },
                    getTainted: () => tainted.state,
                    setTainted: (value: Option<boolean>) => { tainted.state = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldTaxRate("state", data.state);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                isActive: {
                    path: ["isActive"] as const,
                    name: "isActive",
                    constraints: { required: true },
                    label: "Active",
                    get: () => data.isActive,
                    set: (value: boolean) => { data.isActive = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.isActive,
                    setError: (value: Option<Array<string>>) => { errors.isActive = value; },
                    getTainted: () => tainted.isActive,
                    setTainted: (value: Option<boolean>) => { tainted.isActive = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldTaxRate("isActive", data.isActive);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                description: {
                    path: ["description"] as const,
                    name: "description",
                    constraints: { required: true },
                    label: "Description",
                    get: () => data.description,
                    set: (value: string) => { data.description = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.description,
                    setError: (value: Option<Array<string>>) => { errors.description = value; },
                    getTainted: () => tainted.description,
                    setTainted: (value: Option<boolean>) => { tainted.description = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldTaxRate("description", data.description);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                taxComponents: {
                    path: ["taxComponents"] as const,
                    name: "taxComponents",
                    constraints: { required: true },
                    
                    get: () => data.taxComponents,
                    set: (value: { [key: string]: number }) => { data.taxComponents = value; },
                    transform: (value: { [key: string]: number }): { [key: string]: number } => value,
                    getError: () => errors.taxComponents,
                    setError: (value: Option<Array<string>>) => { errors.taxComponents = value; },
                    getTainted: () => tainted.taxComponents,
                    setTainted: (value: Option<boolean>) => { tainted.taxComponents = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldTaxRate("taxComponents", data.taxComponents);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<TaxRate, Array<{field: string; message: string}>>{return fromObjectTaxRate(data);}function reset(newOverrides?: Partial<TaxRate>): void {data = {...defaultValueTaxRate(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), name: Option.none(), taxAgency: Option.none(), zip: Option.none(), city: Option.none(), county: Option.none(), state: Option.none(), isActive: Option.none(), description: Option.none(), taxComponents: Option.none() }; tainted = { id: Option.none(), name: Option.none(), taxAgency: Option.none(), zip: Option.none(), city: Option.none(), county: Option.none(), state: Option.none(), isActive: Option.none(), description: Option.none(), taxComponents: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataTaxRate(formData: FormData): Result<TaxRate, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.name = formData.get("name") ?? "";
            obj.taxAgency = formData.get("taxAgency") ?? "";
            {
                const zipStr = formData.get("zip");
                obj.zip = zipStr ? parseFloat(zipStr as string) : 0;
                if (obj.zip !== undefined && isNaN(obj.zip as number)) obj.zip = 0;
            }
            obj.city = formData.get("city") ?? "";
            obj.county = formData.get("county") ?? "";
            obj.state = formData.get("state") ?? "";
            {
                const isActiveVal = formData.get("isActive");
                obj.isActive = isActiveVal === "true" || isActiveVal === "on" || isActiveVal === "1";
            }
            obj.description = formData.get("description") ?? "";
            obj.taxComponents = formData.get("taxComponents") ?? ""; return fromStringifiedJSONTaxRate(JSON.stringify(obj));}


export interface Address {
    
    street: string;
    
    city: string;
    
    state: string;
    
    zipcode: string;
}

export function defaultValueAddress(): Address {return {street: "",
                            city: "",
                            state: "",
                            zipcode: "", }as Address;}

export function toStringifiedJSONAddress(value: Address): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeAddress(value, ctx));}export function toObjectAddress(value: Address): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeAddress(value, ctx);}export function __serializeAddress(value: Address, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Address" , __id,}; result["street" ]= value.street; result["city" ]= value.city; result["state" ]= value.state; result["zipcode" ]= value.zipcode; return result;}

export function fromStringifiedJSONAddress(json: string, opts?: DeserializeOptions): Result<Address, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectAddress(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectAddress(obj: unknown, opts?: DeserializeOptions): Result<Address, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeAddress(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Address.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeAddress(value: any, ctx: DeserializeContext): Address | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Address.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("street" in obj)){errors.push({field: "street" , message: "missing required field" });}if(!("city" in obj)){errors.push({field: "city" , message: "missing required field" });}if(!("state" in obj)){errors.push({field: "state" , message: "missing required field" });}if(!("zipcode" in obj)){errors.push({field: "zipcode" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_street = obj["street" ]as string; 
                if (__raw_street.length === 0) {
                    errors.push({ field: "street", message: "must not be empty" });
                }
 instance.street = __raw_street; }{const __raw_city = obj["city" ]as string; 
                if (__raw_city.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
 instance.city = __raw_city; }{const __raw_state = obj["state" ]as string; 
                if (__raw_state.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
 instance.state = __raw_state; }{const __raw_zipcode = obj["zipcode" ]as string; 
                if (__raw_zipcode.length === 0) {
                    errors.push({ field: "zipcode", message: "must not be empty" });
                }
 instance.zipcode = __raw_zipcode; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Address;}export function validateFieldAddress<K extends keyof Address>(field: K, value: Address[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "street" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "street", message: "must not be empty" });
                }
 break;}case "city" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
 break;}case "state" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
 break;}case "zipcode" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "zipcode", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsAddress(partial: Partial<Address>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("street" in partial && partial.street!== undefined){const __val = partial.street as string; 
                if (__val.length === 0) {
                    errors.push({ field: "street", message: "must not be empty" });
                }
}if("city" in partial && partial.city!== undefined){const __val = partial.city as string; 
                if (__val.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
}if("state" in partial && partial.state!== undefined){const __val = partial.state as string; 
                if (__val.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
}if("zipcode" in partial && partial.zipcode!== undefined){const __val = partial.zipcode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "zipcode", message: "must not be empty" });
                }
}return errors; }export function hasShapeAddress(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "street" in o && "city" in o && "state" in o && "zipcode" in o;}export function isAddress(obj: unknown): obj is Address {if(!hasShapeAddress(obj)){return false;}const result = fromObjectAddress(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsAddress = {_errors: Option<Array<string>>; street: Option<Array<string>>;
            city: Option<Array<string>>;
            state: Option<Array<string>>;
            zipcode: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedAddress = {street: Option<boolean>;
            city: Option<boolean>;
            state: Option<boolean>;
            zipcode: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersAddress {readonly street: FieldController<string>;
            readonly city: FieldController<string>;
            readonly state: FieldController<string>;
            readonly zipcode: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformAddress {readonly data: Address; readonly errors: ErrorsAddress; readonly tainted: TaintedAddress; readonly fields: FieldControllersAddress; validate(): Result<Address, Array<{field: string; message: string}>>; reset(overrides?: Partial<Address>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormAddress(overrides?: Partial<Address>): GigaformAddress {let data = $state({...defaultValueAddress(),...overrides}); let errors = $state<ErrorsAddress>({ _errors: Option.none(), street: Option.none(), city: Option.none(), state: Option.none(), zipcode: Option.none() }); let tainted = $state<TaintedAddress>({ street: Option.none(), city: Option.none(), state: Option.none(), zipcode: Option.none() }); const fields: FieldControllersAddress = {street: {
                    path: ["street"] as const,
                    name: "street",
                    constraints: { required: true },
                    
                    get: () => data.street,
                    set: (value: string) => { data.street = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.street,
                    setError: (value: Option<Array<string>>) => { errors.street = value; },
                    getTainted: () => tainted.street,
                    setTainted: (value: Option<boolean>) => { tainted.street = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAddress("street", data.street);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                city: {
                    path: ["city"] as const,
                    name: "city",
                    constraints: { required: true },
                    
                    get: () => data.city,
                    set: (value: string) => { data.city = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.city,
                    setError: (value: Option<Array<string>>) => { errors.city = value; },
                    getTainted: () => tainted.city,
                    setTainted: (value: Option<boolean>) => { tainted.city = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAddress("city", data.city);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                state: {
                    path: ["state"] as const,
                    name: "state",
                    constraints: { required: true },
                    
                    get: () => data.state,
                    set: (value: string) => { data.state = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.state,
                    setError: (value: Option<Array<string>>) => { errors.state = value; },
                    getTainted: () => tainted.state,
                    setTainted: (value: Option<boolean>) => { tainted.state = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAddress("state", data.state);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                zipcode: {
                    path: ["zipcode"] as const,
                    name: "zipcode",
                    constraints: { required: true },
                    
                    get: () => data.zipcode,
                    set: (value: string) => { data.zipcode = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.zipcode,
                    setError: (value: Option<Array<string>>) => { errors.zipcode = value; },
                    getTainted: () => tainted.zipcode,
                    setTainted: (value: Option<boolean>) => { tainted.zipcode = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAddress("zipcode", data.zipcode);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Address, Array<{field: string; message: string}>>{return fromObjectAddress(data);}function reset(newOverrides?: Partial<Address>): void {data = {...defaultValueAddress(),...newOverrides}; errors = { _errors: Option.none(), street: Option.none(), city: Option.none(), state: Option.none(), zipcode: Option.none() }; tainted = { street: Option.none(), city: Option.none(), state: Option.none(), zipcode: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataAddress(formData: FormData): Result<Address, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.street = formData.get("street") ?? "";
            obj.city = formData.get("city") ?? "";
            obj.state = formData.get("state") ?? "";
            obj.zipcode = formData.get("zipcode") ?? ""; return fromStringifiedJSONAddress(JSON.stringify(obj));}


export interface Lead {
    
    id: string;
    
    number: number | null;
    
    accepted: boolean;
    
    probability: number;
    
    
    priority: Priority;
    
    dueDate: string | null;
    
    closeDate: string | null;
    
    value: number;
    
    
    stage: LeadStage;
    
    
    status: string;
    
    description: string | null;
    
    
    nextStep: NextStep;
    
    favorite: boolean;
    
    dateAdded: string | null;
    
    taxRate: (string | TaxRate) | null;
    
    
    sector: Sector;
    
    leadName: AccountName;
    
    phones: PhoneNumber[];
    
    email: Email;
    
    leadSource: string | null;
    
    
    site: string | Site;
    
    
    memo: string;
    
    needsReview: boolean;
    
    hasAlert: boolean;
    
    salesRep: Represents[] | null;
    
    color: string | null;
    
    
    accountType: string;
    
    
    subtype: string;
    
    isTaxExempt: boolean;
    
    
    paymentTerms: string;
    
    tags: string[];
    
    customFields: [string, string][];
}

export function defaultValueLead(): Lead {return {id: "",
                            number: null,
                            accepted: false,
                            probability: 0,
                            priority: "Medium",
                            dueDate: null,
                            closeDate: null,
                            value: 0,
                            stage: "Open",
                            status: "",
                            description: null,
                            nextStep: "InitialContact",
                            favorite: false,
                            dateAdded: null,
                            taxRate: null,
                            sector: "Residential",
                            leadName: defaultValueAccountName(),
                            phones: [],
                            email: defaultValueEmail(),
                            leadSource: null,
                            site: "",
                            memo: "",
                            needsReview: false,
                            hasAlert: false,
                            salesRep: null,
                            color: null,
                            accountType: "",
                            subtype: "",
                            isTaxExempt: false,
                            paymentTerms: "",
                            tags: [],
                            customFields: [], }as Lead;}

export function toStringifiedJSONLead(value: Lead): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeLead(value, ctx));}export function toObjectLead(value: Lead): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeLead(value, ctx);}export function __serializeLead(value: Lead, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Lead" , __id,}; result["id" ]= value.id; result["number" ]= value.number; result["accepted" ]= value.accepted; result["probability" ]= value.probability; result["priority" ]= __serializePriority(value.priority, ctx); result["dueDate" ]= value.dueDate; result["closeDate" ]= value.closeDate; result["value" ]= value.value; result["stage" ]= __serializeLeadStage(value.stage, ctx); result["status" ]= value.status; result["description" ]= value.description; result["nextStep" ]= __serializeNextStep(value.nextStep, ctx); result["favorite" ]= value.favorite; result["dateAdded" ]= value.dateAdded; if(value.taxRate!== null){result["taxRate" ]= value.taxRate; }else {result["taxRate" ]= null;}result["sector" ]= __serializeSector(value.sector, ctx); result["leadName" ]= __serializeAccountName(value.leadName, ctx); result["phones" ]= value.phones.map((item)=>__serializePhoneNumber(item, ctx)); result["email" ]= __serializeEmail(value.email, ctx); result["leadSource" ]= value.leadSource; result["site" ]= value.site; result["memo" ]= value.memo; result["needsReview" ]= value.needsReview; result["hasAlert" ]= value.hasAlert; if(value.salesRep!== null){result["salesRep" ]= value.salesRep; }else {result["salesRep" ]= null;}result["color" ]= value.color; result["accountType" ]= value.accountType; result["subtype" ]= value.subtype; result["isTaxExempt" ]= value.isTaxExempt; result["paymentTerms" ]= value.paymentTerms; result["tags" ]= value.tags; result["customFields" ]= value.customFields; return result;}

export function fromStringifiedJSONLead(json: string, opts?: DeserializeOptions): Result<Lead, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectLead(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectLead(obj: unknown, opts?: DeserializeOptions): Result<Lead, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeLead(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Lead.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeLead(value: any, ctx: DeserializeContext): Lead | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Lead.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("number" in obj)){errors.push({field: "number" , message: "missing required field" });}if(!("accepted" in obj)){errors.push({field: "accepted" , message: "missing required field" });}if(!("probability" in obj)){errors.push({field: "probability" , message: "missing required field" });}if(!("priority" in obj)){errors.push({field: "priority" , message: "missing required field" });}if(!("dueDate" in obj)){errors.push({field: "dueDate" , message: "missing required field" });}if(!("closeDate" in obj)){errors.push({field: "closeDate" , message: "missing required field" });}if(!("value" in obj)){errors.push({field: "value" , message: "missing required field" });}if(!("stage" in obj)){errors.push({field: "stage" , message: "missing required field" });}if(!("status" in obj)){errors.push({field: "status" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(!("nextStep" in obj)){errors.push({field: "nextStep" , message: "missing required field" });}if(!("favorite" in obj)){errors.push({field: "favorite" , message: "missing required field" });}if(!("dateAdded" in obj)){errors.push({field: "dateAdded" , message: "missing required field" });}if(!("taxRate" in obj)){errors.push({field: "taxRate" , message: "missing required field" });}if(!("sector" in obj)){errors.push({field: "sector" , message: "missing required field" });}if(!("leadName" in obj)){errors.push({field: "leadName" , message: "missing required field" });}if(!("phones" in obj)){errors.push({field: "phones" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("leadSource" in obj)){errors.push({field: "leadSource" , message: "missing required field" });}if(!("site" in obj)){errors.push({field: "site" , message: "missing required field" });}if(!("memo" in obj)){errors.push({field: "memo" , message: "missing required field" });}if(!("needsReview" in obj)){errors.push({field: "needsReview" , message: "missing required field" });}if(!("hasAlert" in obj)){errors.push({field: "hasAlert" , message: "missing required field" });}if(!("salesRep" in obj)){errors.push({field: "salesRep" , message: "missing required field" });}if(!("color" in obj)){errors.push({field: "color" , message: "missing required field" });}if(!("accountType" in obj)){errors.push({field: "accountType" , message: "missing required field" });}if(!("subtype" in obj)){errors.push({field: "subtype" , message: "missing required field" });}if(!("isTaxExempt" in obj)){errors.push({field: "isTaxExempt" , message: "missing required field" });}if(!("paymentTerms" in obj)){errors.push({field: "paymentTerms" , message: "missing required field" });}if(!("tags" in obj)){errors.push({field: "tags" , message: "missing required field" });}if(!("customFields" in obj)){errors.push({field: "customFields" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_number = obj["number" ]as number | null; instance.number = __raw_number; }{const __raw_accepted = obj["accepted" ]as boolean; instance.accepted = __raw_accepted; }{const __raw_probability = obj["probability" ]as number; instance.probability = __raw_probability; }{const __raw_priority = obj["priority" ]as Priority; {const __result = __deserializePriority(__raw_priority, ctx); ctx.assignOrDefer(instance, "priority" , __result);}}{const __raw_dueDate = obj["dueDate" ]as string | null; instance.dueDate = __raw_dueDate; }{const __raw_closeDate = obj["closeDate" ]as string | null; instance.closeDate = __raw_closeDate; }{const __raw_value = obj["value" ]as number; instance.value = __raw_value; }{const __raw_stage = obj["stage" ]as LeadStage; {const __result = __deserializeLeadStage(__raw_stage, ctx); ctx.assignOrDefer(instance, "stage" , __result);}}{const __raw_status = obj["status" ]as string; 
                if (__raw_status.length === 0) {
                    errors.push({ field: "status", message: "must not be empty" });
                }
 instance.status = __raw_status; }{const __raw_description = obj["description" ]as string | null; instance.description = __raw_description; }{const __raw_nextStep = obj["nextStep" ]as NextStep; {const __result = __deserializeNextStep(__raw_nextStep, ctx); ctx.assignOrDefer(instance, "nextStep" , __result);}}{const __raw_favorite = obj["favorite" ]as boolean; instance.favorite = __raw_favorite; }{const __raw_dateAdded = obj["dateAdded" ]as string | null; instance.dateAdded = __raw_dateAdded; }{const __raw_taxRate = obj["taxRate" ]as (string | TaxRate) | null; if(__raw_taxRate === null){instance.taxRate = null;}else {instance.taxRate = __raw_taxRate; }}{const __raw_sector = obj["sector" ]as Sector; {const __result = __deserializeSector(__raw_sector, ctx); ctx.assignOrDefer(instance, "sector" , __result);}}{const __raw_leadName = obj["leadName" ]as AccountName; {const __result = __deserializeAccountName(__raw_leadName, ctx); ctx.assignOrDefer(instance, "leadName" , __result);}}{const __raw_phones = obj["phones" ]as PhoneNumber[]; if(Array.isArray(__raw_phones)){instance.phones = __raw_phones as PhoneNumber[];}}{const __raw_email = obj["email" ]as Email; {const __result = __deserializeEmail(__raw_email, ctx); ctx.assignOrDefer(instance, "email" , __result);}}{const __raw_leadSource = obj["leadSource" ]as string | null; instance.leadSource = __raw_leadSource; }{const __raw_site = obj["site" ]as string | Site; instance.site = __raw_site; }{const __raw_memo = obj["memo" ]as string; 
                if (__raw_memo.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
 instance.memo = __raw_memo; }{const __raw_needsReview = obj["needsReview" ]as boolean; instance.needsReview = __raw_needsReview; }{const __raw_hasAlert = obj["hasAlert" ]as boolean; instance.hasAlert = __raw_hasAlert; }{const __raw_salesRep = obj["salesRep" ]as Represents[] | null; if(__raw_salesRep === null){instance.salesRep = null;}else {instance.salesRep = __raw_salesRep; }}{const __raw_color = obj["color" ]as string | null; instance.color = __raw_color; }{const __raw_accountType = obj["accountType" ]as string; 
                if (__raw_accountType.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
 instance.accountType = __raw_accountType; }{const __raw_subtype = obj["subtype" ]as string; 
                if (__raw_subtype.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
 instance.subtype = __raw_subtype; }{const __raw_isTaxExempt = obj["isTaxExempt" ]as boolean; instance.isTaxExempt = __raw_isTaxExempt; }{const __raw_paymentTerms = obj["paymentTerms" ]as string; 
                if (__raw_paymentTerms.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
 instance.paymentTerms = __raw_paymentTerms; }{const __raw_tags = obj["tags" ]as string[]; if(Array.isArray(__raw_tags)){instance.tags = __raw_tags as string[];}}{const __raw_customFields = obj["customFields" ]as [string, string][]; if(Array.isArray(__raw_customFields)){instance.customFields = __raw_customFields as [string, string][];}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Lead;}export function validateFieldLead<K extends keyof Lead>(field: K, value: Lead[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "status" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "status", message: "must not be empty" });
                }
 break;}case "memo" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
 break;}case "accountType" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
 break;}case "subtype" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
 break;}case "paymentTerms" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsLead(partial: Partial<Lead>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("status" in partial && partial.status!== undefined){const __val = partial.status as string; 
                if (__val.length === 0) {
                    errors.push({ field: "status", message: "must not be empty" });
                }
}if("memo" in partial && partial.memo!== undefined){const __val = partial.memo as string; 
                if (__val.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
}if("accountType" in partial && partial.accountType!== undefined){const __val = partial.accountType as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
}if("subtype" in partial && partial.subtype!== undefined){const __val = partial.subtype as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
}if("paymentTerms" in partial && partial.paymentTerms!== undefined){const __val = partial.paymentTerms as string; 
                if (__val.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
}return errors; }export function hasShapeLead(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "number" in o && "accepted" in o && "probability" in o && "priority" in o && "dueDate" in o && "closeDate" in o && "value" in o && "stage" in o && "status" in o && "description" in o && "nextStep" in o && "favorite" in o && "dateAdded" in o && "taxRate" in o && "sector" in o && "leadName" in o && "phones" in o && "email" in o && "leadSource" in o && "site" in o && "memo" in o && "needsReview" in o && "hasAlert" in o && "salesRep" in o && "color" in o && "accountType" in o && "subtype" in o && "isTaxExempt" in o && "paymentTerms" in o && "tags" in o && "customFields" in o;}export function isLead(obj: unknown): obj is Lead {if(!hasShapeLead(obj)){return false;}const result = fromObjectLead(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsLead = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            number: Option<Array<string>>;
            accepted: Option<Array<string>>;
            probability: Option<Array<string>>;
            priority: Option<Array<string>>;
            dueDate: Option<Array<string>>;
            closeDate: Option<Array<string>>;
            value: Option<Array<string>>;
            stage: Option<Array<string>>;
            status: Option<Array<string>>;
            description: Option<Array<string>>;
            nextStep: Option<Array<string>>;
            favorite: Option<Array<string>>;
            dateAdded: Option<Array<string>>;
            taxRate: Option<Array<string>>;
            sector: Option<Array<string>>;
            leadName: Option<Array<string>>;
            phones: Option<Array<string>>;
            email: Option<Array<string>>;
            leadSource: Option<Array<string>>;
            site: Option<Array<string>>;
            memo: Option<Array<string>>;
            needsReview: Option<Array<string>>;
            hasAlert: Option<Array<string>>;
            salesRep: Option<Array<string>>;
            color: Option<Array<string>>;
            accountType: Option<Array<string>>;
            subtype: Option<Array<string>>;
            isTaxExempt: Option<Array<string>>;
            paymentTerms: Option<Array<string>>;
            tags: Option<Array<string>>;
            customFields: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedLead = {id: Option<boolean>;
            number: Option<boolean>;
            accepted: Option<boolean>;
            probability: Option<boolean>;
            priority: Option<boolean>;
            dueDate: Option<boolean>;
            closeDate: Option<boolean>;
            value: Option<boolean>;
            stage: Option<boolean>;
            status: Option<boolean>;
            description: Option<boolean>;
            nextStep: Option<boolean>;
            favorite: Option<boolean>;
            dateAdded: Option<boolean>;
            taxRate: Option<boolean>;
            sector: Option<boolean>;
            leadName: Option<boolean>;
            phones: Option<boolean>;
            email: Option<boolean>;
            leadSource: Option<boolean>;
            site: Option<boolean>;
            memo: Option<boolean>;
            needsReview: Option<boolean>;
            hasAlert: Option<boolean>;
            salesRep: Option<boolean>;
            color: Option<boolean>;
            accountType: Option<boolean>;
            subtype: Option<boolean>;
            isTaxExempt: Option<boolean>;
            paymentTerms: Option<boolean>;
            tags: Option<boolean>;
            customFields: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersLead {readonly id: FieldController<string>;
            readonly number: FieldController<number | null>;
            readonly accepted: FieldController<boolean>;
            readonly probability: FieldController<number>;
            readonly priority: FieldController<Priority>;
            readonly dueDate: FieldController<string | null>;
            readonly closeDate: FieldController<string | null>;
            readonly value: FieldController<number>;
            readonly stage: FieldController<LeadStage>;
            readonly status: FieldController<string>;
            readonly description: FieldController<string | null>;
            readonly nextStep: FieldController<NextStep>;
            readonly favorite: FieldController<boolean>;
            readonly dateAdded: FieldController<string | null>;
            readonly taxRate: FieldController<(string | TaxRate) | null>;
            readonly sector: FieldController<Sector>;
            readonly leadName: FieldController<AccountName>;
            readonly phones: ArrayFieldController<PhoneNumber>;
            readonly email: FieldController<Email>;
            readonly leadSource: FieldController<string | null>;
            readonly site: FieldController<string | Site>;
            readonly memo: FieldController<string>;
            readonly needsReview: FieldController<boolean>;
            readonly hasAlert: FieldController<boolean>;
            readonly salesRep: FieldController<Represents[] | null>;
            readonly color: FieldController<string | null>;
            readonly accountType: FieldController<string>;
            readonly subtype: FieldController<string>;
            readonly isTaxExempt: FieldController<boolean>;
            readonly paymentTerms: FieldController<string>;
            readonly tags: ArrayFieldController<string>;
            readonly customFields: ArrayFieldController<[string, string]>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformLead {readonly data: Lead; readonly errors: ErrorsLead; readonly tainted: TaintedLead; readonly fields: FieldControllersLead; validate(): Result<Lead, Array<{field: string; message: string}>>; reset(overrides?: Partial<Lead>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormLead(overrides?: Partial<Lead>): GigaformLead {let data = $state({...defaultValueLead(),...overrides}); let errors = $state<ErrorsLead>({ _errors: Option.none(), id: Option.none(), number: Option.none(), accepted: Option.none(), probability: Option.none(), priority: Option.none(), dueDate: Option.none(), closeDate: Option.none(), value: Option.none(), stage: Option.none(), status: Option.none(), description: Option.none(), nextStep: Option.none(), favorite: Option.none(), dateAdded: Option.none(), taxRate: Option.none(), sector: Option.none(), leadName: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), site: Option.none(), memo: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), salesRep: Option.none(), color: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), customFields: Option.none() }); let tainted = $state<TaintedLead>({ id: Option.none(), number: Option.none(), accepted: Option.none(), probability: Option.none(), priority: Option.none(), dueDate: Option.none(), closeDate: Option.none(), value: Option.none(), stage: Option.none(), status: Option.none(), description: Option.none(), nextStep: Option.none(), favorite: Option.none(), dateAdded: Option.none(), taxRate: Option.none(), sector: Option.none(), leadName: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), site: Option.none(), memo: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), salesRep: Option.none(), color: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), customFields: Option.none() }); const fields: FieldControllersLead = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                number: {
                    path: ["number"] as const,
                    name: "number",
                    constraints: { required: true },
                    
                    get: () => data.number,
                    set: (value: number | null) => { data.number = value; },
                    transform: (value: number | null): number | null => value,
                    getError: () => errors.number,
                    setError: (value: Option<Array<string>>) => { errors.number = value; },
                    getTainted: () => tainted.number,
                    setTainted: (value: Option<boolean>) => { tainted.number = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("number", data.number);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                accepted: {
                    path: ["accepted"] as const,
                    name: "accepted",
                    constraints: { required: true },
                    
                    get: () => data.accepted,
                    set: (value: boolean) => { data.accepted = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.accepted,
                    setError: (value: Option<Array<string>>) => { errors.accepted = value; },
                    getTainted: () => tainted.accepted,
                    setTainted: (value: Option<boolean>) => { tainted.accepted = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("accepted", data.accepted);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                probability: {
                    path: ["probability"] as const,
                    name: "probability",
                    constraints: { required: true },
                    label: "Probability",
                    get: () => data.probability,
                    set: (value: number) => { data.probability = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.probability,
                    setError: (value: Option<Array<string>>) => { errors.probability = value; },
                    getTainted: () => tainted.probability,
                    setTainted: (value: Option<boolean>) => { tainted.probability = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("probability", data.probability);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                priority: {
                    path: ["priority"] as const,
                    name: "priority",
                    constraints: { required: true },
                    label: "Priority",
                    get: () => data.priority,
                    set: (value: Priority) => { data.priority = value; },
                    transform: (value: Priority): Priority => value,
                    getError: () => errors.priority,
                    setError: (value: Option<Array<string>>) => { errors.priority = value; },
                    getTainted: () => tainted.priority,
                    setTainted: (value: Option<boolean>) => { tainted.priority = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("priority", data.priority);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                dueDate: {
                    path: ["dueDate"] as const,
                    name: "dueDate",
                    constraints: { required: true },
                    label: "Due Date",
                    get: () => data.dueDate,
                    set: (value: string | null) => { data.dueDate = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.dueDate,
                    setError: (value: Option<Array<string>>) => { errors.dueDate = value; },
                    getTainted: () => tainted.dueDate,
                    setTainted: (value: Option<boolean>) => { tainted.dueDate = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("dueDate", data.dueDate);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                closeDate: {
                    path: ["closeDate"] as const,
                    name: "closeDate",
                    constraints: { required: true },
                    label: "Close Date",
                    get: () => data.closeDate,
                    set: (value: string | null) => { data.closeDate = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.closeDate,
                    setError: (value: Option<Array<string>>) => { errors.closeDate = value; },
                    getTainted: () => tainted.closeDate,
                    setTainted: (value: Option<boolean>) => { tainted.closeDate = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("closeDate", data.closeDate);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                value: {
                    path: ["value"] as const,
                    name: "value",
                    constraints: { required: true },
                    label: "Value",
                    get: () => data.value,
                    set: (value: number) => { data.value = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.value,
                    setError: (value: Option<Array<string>>) => { errors.value = value; },
                    getTainted: () => tainted.value,
                    setTainted: (value: Option<boolean>) => { tainted.value = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("value", data.value);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                stage: {
                    path: ["stage"] as const,
                    name: "stage",
                    constraints: { required: true },
                    label: "Stage",
                    get: () => data.stage,
                    set: (value: LeadStage) => { data.stage = value; },
                    transform: (value: LeadStage): LeadStage => value,
                    getError: () => errors.stage,
                    setError: (value: Option<Array<string>>) => { errors.stage = value; },
                    getTainted: () => tainted.stage,
                    setTainted: (value: Option<boolean>) => { tainted.stage = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("stage", data.stage);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                status: {
                    path: ["status"] as const,
                    name: "status",
                    constraints: { required: true },
                    label: "Status",
                    get: () => data.status,
                    set: (value: string) => { data.status = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.status,
                    setError: (value: Option<Array<string>>) => { errors.status = value; },
                    getTainted: () => tainted.status,
                    setTainted: (value: Option<boolean>) => { tainted.status = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("status", data.status);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                description: {
                    path: ["description"] as const,
                    name: "description",
                    constraints: { required: true },
                    label: "Description",
                    get: () => data.description,
                    set: (value: string | null) => { data.description = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.description,
                    setError: (value: Option<Array<string>>) => { errors.description = value; },
                    getTainted: () => tainted.description,
                    setTainted: (value: Option<boolean>) => { tainted.description = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("description", data.description);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                nextStep: {
                    path: ["nextStep"] as const,
                    name: "nextStep",
                    constraints: { required: true },
                    
                    get: () => data.nextStep,
                    set: (value: NextStep) => { data.nextStep = value; },
                    transform: (value: NextStep): NextStep => value,
                    getError: () => errors.nextStep,
                    setError: (value: Option<Array<string>>) => { errors.nextStep = value; },
                    getTainted: () => tainted.nextStep,
                    setTainted: (value: Option<boolean>) => { tainted.nextStep = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("nextStep", data.nextStep);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                favorite: {
                    path: ["favorite"] as const,
                    name: "favorite",
                    constraints: { required: true },
                    label: "Favorite",
                    get: () => data.favorite,
                    set: (value: boolean) => { data.favorite = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.favorite,
                    setError: (value: Option<Array<string>>) => { errors.favorite = value; },
                    getTainted: () => tainted.favorite,
                    setTainted: (value: Option<boolean>) => { tainted.favorite = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("favorite", data.favorite);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                dateAdded: {
                    path: ["dateAdded"] as const,
                    name: "dateAdded",
                    constraints: { required: true },
                    
                    get: () => data.dateAdded,
                    set: (value: string | null) => { data.dateAdded = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.dateAdded,
                    setError: (value: Option<Array<string>>) => { errors.dateAdded = value; },
                    getTainted: () => tainted.dateAdded,
                    setTainted: (value: Option<boolean>) => { tainted.dateAdded = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("dateAdded", data.dateAdded);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                taxRate: {
                    path: ["taxRate"] as const,
                    name: "taxRate",
                    constraints: { required: true },
                    label: "Tax Rate",
                    get: () => data.taxRate,
                    set: (value: (string | TaxRate) | null) => { data.taxRate = value; },
                    transform: (value: (string | TaxRate) | null): (string | TaxRate) | null => value,
                    getError: () => errors.taxRate,
                    setError: (value: Option<Array<string>>) => { errors.taxRate = value; },
                    getTainted: () => tainted.taxRate,
                    setTainted: (value: Option<boolean>) => { tainted.taxRate = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("taxRate", data.taxRate);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                sector: {
                    path: ["sector"] as const,
                    name: "sector",
                    constraints: { required: true },
                    label: "Sector",
                    get: () => data.sector,
                    set: (value: Sector) => { data.sector = value; },
                    transform: (value: Sector): Sector => value,
                    getError: () => errors.sector,
                    setError: (value: Option<Array<string>>) => { errors.sector = value; },
                    getTainted: () => tainted.sector,
                    setTainted: (value: Option<boolean>) => { tainted.sector = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("sector", data.sector);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                leadName: {
                    path: ["leadName"] as const,
                    name: "leadName",
                    constraints: { required: true },
                    
                    get: () => data.leadName,
                    set: (value: AccountName) => { data.leadName = value; },
                    transform: (value: AccountName): AccountName => value,
                    getError: () => errors.leadName,
                    setError: (value: Option<Array<string>>) => { errors.leadName = value; },
                    getTainted: () => tainted.leadName,
                    setTainted: (value: Option<boolean>) => { tainted.leadName = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("leadName", data.leadName);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                phones: {
                    path: ["phones"] as const,
                    name: "phones",
                    constraints: { required: true },
                    
                    get: () => data.phones,
                    set: (value: PhoneNumber[]) => { data.phones = value; },
                    transform: (value: PhoneNumber[]): PhoneNumber[] => value,
                    getError: () => errors.phones,
                    setError: (value: Option<Array<string>>) => { errors.phones = value; },
                    getTainted: () => tainted.phones,
                    setTainted: (value: Option<boolean>) => { tainted.phones = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("phones", data.phones);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["phones", index] as const,
                        name: `phones.${index}`,
                        constraints: { required: true },
                        get: () => data.phones[index]!,
                        set: (value: PhoneNumber) => { data.phones[index] = value; },
                        transform: (value: PhoneNumber): PhoneNumber => value,
                        getError: () => errors.phones,
                        setError: (value: Option<Array<string>>) => { errors.phones = value; },
                        getTainted: () => tainted.phones,
                        setTainted: (value: Option<boolean>) => { tainted.phones = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: PhoneNumber) => { data.phones.push(item); },
                    remove: (index: number) => { data.phones.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.phones[a]!;
                        data.phones[a] = data.phones[b]!;
                        data.phones[b] = tmp;
                    },
                },
                email: {
                    path: ["email"] as const,
                    name: "email",
                    constraints: { required: true },
                    label: "Email",
                    get: () => data.email,
                    set: (value: Email) => { data.email = value; },
                    transform: (value: Email): Email => value,
                    getError: () => errors.email,
                    setError: (value: Option<Array<string>>) => { errors.email = value; },
                    getTainted: () => tainted.email,
                    setTainted: (value: Option<boolean>) => { tainted.email = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("email", data.email);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                leadSource: {
                    path: ["leadSource"] as const,
                    name: "leadSource",
                    constraints: { required: true },
                    label: "Lead Source",
                    get: () => data.leadSource,
                    set: (value: string | null) => { data.leadSource = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.leadSource,
                    setError: (value: Option<Array<string>>) => { errors.leadSource = value; },
                    getTainted: () => tainted.leadSource,
                    setTainted: (value: Option<boolean>) => { tainted.leadSource = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("leadSource", data.leadSource);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                site: {
                    path: ["site"] as const,
                    name: "site",
                    constraints: { required: true },
                    label: "Site",
                    get: () => data.site,
                    set: (value: string | Site) => { data.site = value; },
                    transform: (value: string | Site): string | Site => value,
                    getError: () => errors.site,
                    setError: (value: Option<Array<string>>) => { errors.site = value; },
                    getTainted: () => tainted.site,
                    setTainted: (value: Option<boolean>) => { tainted.site = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("site", data.site);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                memo: {
                    path: ["memo"] as const,
                    name: "memo",
                    constraints: { required: true },
                    label: "Memo",
                    get: () => data.memo,
                    set: (value: string) => { data.memo = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.memo,
                    setError: (value: Option<Array<string>>) => { errors.memo = value; },
                    getTainted: () => tainted.memo,
                    setTainted: (value: Option<boolean>) => { tainted.memo = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("memo", data.memo);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                needsReview: {
                    path: ["needsReview"] as const,
                    name: "needsReview",
                    constraints: { required: true },
                    label: "Needs Review",
                    get: () => data.needsReview,
                    set: (value: boolean) => { data.needsReview = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.needsReview,
                    setError: (value: Option<Array<string>>) => { errors.needsReview = value; },
                    getTainted: () => tainted.needsReview,
                    setTainted: (value: Option<boolean>) => { tainted.needsReview = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("needsReview", data.needsReview);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                hasAlert: {
                    path: ["hasAlert"] as const,
                    name: "hasAlert",
                    constraints: { required: true },
                    label: "Has Alert",
                    get: () => data.hasAlert,
                    set: (value: boolean) => { data.hasAlert = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.hasAlert,
                    setError: (value: Option<Array<string>>) => { errors.hasAlert = value; },
                    getTainted: () => tainted.hasAlert,
                    setTainted: (value: Option<boolean>) => { tainted.hasAlert = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("hasAlert", data.hasAlert);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                salesRep: {
                    path: ["salesRep"] as const,
                    name: "salesRep",
                    constraints: { required: true },
                    label: "Sales Rep",
                    get: () => data.salesRep,
                    set: (value: Represents[] | null) => { data.salesRep = value; },
                    transform: (value: Represents[] | null): Represents[] | null => value,
                    getError: () => errors.salesRep,
                    setError: (value: Option<Array<string>>) => { errors.salesRep = value; },
                    getTainted: () => tainted.salesRep,
                    setTainted: (value: Option<boolean>) => { tainted.salesRep = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("salesRep", data.salesRep);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                color: {
                    path: ["color"] as const,
                    name: "color",
                    constraints: { required: true },
                    
                    get: () => data.color,
                    set: (value: string | null) => { data.color = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.color,
                    setError: (value: Option<Array<string>>) => { errors.color = value; },
                    getTainted: () => tainted.color,
                    setTainted: (value: Option<boolean>) => { tainted.color = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("color", data.color);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                accountType: {
                    path: ["accountType"] as const,
                    name: "accountType",
                    constraints: { required: true },
                    label: "Account Type",
                    get: () => data.accountType,
                    set: (value: string) => { data.accountType = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.accountType,
                    setError: (value: Option<Array<string>>) => { errors.accountType = value; },
                    getTainted: () => tainted.accountType,
                    setTainted: (value: Option<boolean>) => { tainted.accountType = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("accountType", data.accountType);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                subtype: {
                    path: ["subtype"] as const,
                    name: "subtype",
                    constraints: { required: true },
                    label: "Subtype",
                    get: () => data.subtype,
                    set: (value: string) => { data.subtype = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.subtype,
                    setError: (value: Option<Array<string>>) => { errors.subtype = value; },
                    getTainted: () => tainted.subtype,
                    setTainted: (value: Option<boolean>) => { tainted.subtype = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("subtype", data.subtype);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                isTaxExempt: {
                    path: ["isTaxExempt"] as const,
                    name: "isTaxExempt",
                    constraints: { required: true },
                    label: "Tax Exempt",
                    get: () => data.isTaxExempt,
                    set: (value: boolean) => { data.isTaxExempt = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.isTaxExempt,
                    setError: (value: Option<Array<string>>) => { errors.isTaxExempt = value; },
                    getTainted: () => tainted.isTaxExempt,
                    setTainted: (value: Option<boolean>) => { tainted.isTaxExempt = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("isTaxExempt", data.isTaxExempt);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                paymentTerms: {
                    path: ["paymentTerms"] as const,
                    name: "paymentTerms",
                    constraints: { required: true },
                    label: "Payment Terms",
                    get: () => data.paymentTerms,
                    set: (value: string) => { data.paymentTerms = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.paymentTerms,
                    setError: (value: Option<Array<string>>) => { errors.paymentTerms = value; },
                    getTainted: () => tainted.paymentTerms,
                    setTainted: (value: Option<boolean>) => { tainted.paymentTerms = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("paymentTerms", data.paymentTerms);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                tags: {
                    path: ["tags"] as const,
                    name: "tags",
                    constraints: { required: true },
                    label: "Tags",
                    get: () => data.tags,
                    set: (value: string[]) => { data.tags = value; },
                    transform: (value: string[]): string[] => value,
                    getError: () => errors.tags,
                    setError: (value: Option<Array<string>>) => { errors.tags = value; },
                    getTainted: () => tainted.tags,
                    setTainted: (value: Option<boolean>) => { tainted.tags = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("tags", data.tags);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["tags", index] as const,
                        name: `tags.${index}`,
                        constraints: { required: true },
                        get: () => data.tags[index]!,
                        set: (value: string) => { data.tags[index] = value; },
                        transform: (value: string): string => value,
                        getError: () => errors.tags,
                        setError: (value: Option<Array<string>>) => { errors.tags = value; },
                        getTainted: () => tainted.tags,
                        setTainted: (value: Option<boolean>) => { tainted.tags = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: string) => { data.tags.push(item); },
                    remove: (index: number) => { data.tags.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.tags[a]!;
                        data.tags[a] = data.tags[b]!;
                        data.tags[b] = tmp;
                    },
                },
                customFields: {
                    path: ["customFields"] as const,
                    name: "customFields",
                    constraints: { required: true },
                    
                    get: () => data.customFields,
                    set: (value: [string, string][]) => { data.customFields = value; },
                    transform: (value: [string, string][]): [string, string][] => value,
                    getError: () => errors.customFields,
                    setError: (value: Option<Array<string>>) => { errors.customFields = value; },
                    getTainted: () => tainted.customFields,
                    setTainted: (value: Option<boolean>) => { tainted.customFields = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLead("customFields", data.customFields);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["customFields", index] as const,
                        name: `customFields.${index}`,
                        constraints: { required: true },
                        get: () => data.customFields[index]!,
                        set: (value: [string, string]) => { data.customFields[index] = value; },
                        transform: (value: [string, string]): [string, string] => value,
                        getError: () => errors.customFields,
                        setError: (value: Option<Array<string>>) => { errors.customFields = value; },
                        getTainted: () => tainted.customFields,
                        setTainted: (value: Option<boolean>) => { tainted.customFields = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: [string, string]) => { data.customFields.push(item); },
                    remove: (index: number) => { data.customFields.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.customFields[a]!;
                        data.customFields[a] = data.customFields[b]!;
                        data.customFields[b] = tmp;
                    },
                }}; function validate(): Result<Lead, Array<{field: string; message: string}>>{return fromObjectLead(data);}function reset(newOverrides?: Partial<Lead>): void {data = {...defaultValueLead(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), number: Option.none(), accepted: Option.none(), probability: Option.none(), priority: Option.none(), dueDate: Option.none(), closeDate: Option.none(), value: Option.none(), stage: Option.none(), status: Option.none(), description: Option.none(), nextStep: Option.none(), favorite: Option.none(), dateAdded: Option.none(), taxRate: Option.none(), sector: Option.none(), leadName: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), site: Option.none(), memo: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), salesRep: Option.none(), color: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), customFields: Option.none() }; tainted = { id: Option.none(), number: Option.none(), accepted: Option.none(), probability: Option.none(), priority: Option.none(), dueDate: Option.none(), closeDate: Option.none(), value: Option.none(), stage: Option.none(), status: Option.none(), description: Option.none(), nextStep: Option.none(), favorite: Option.none(), dateAdded: Option.none(), taxRate: Option.none(), sector: Option.none(), leadName: Option.none(), phones: Option.none(), email: Option.none(), leadSource: Option.none(), site: Option.none(), memo: Option.none(), needsReview: Option.none(), hasAlert: Option.none(), salesRep: Option.none(), color: Option.none(), accountType: Option.none(), subtype: Option.none(), isTaxExempt: Option.none(), paymentTerms: Option.none(), tags: Option.none(), customFields: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataLead(formData: FormData): Result<Lead, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            {
                const numberStr = formData.get("number");
                obj.number = numberStr ? parseFloat(numberStr as string) : 0;
                if (obj.number !== undefined && isNaN(obj.number as number)) obj.number = 0;
            }
            {
                const acceptedVal = formData.get("accepted");
                obj.accepted = acceptedVal === "true" || acceptedVal === "on" || acceptedVal === "1";
            }
            {
                const probabilityStr = formData.get("probability");
                obj.probability = probabilityStr ? parseFloat(probabilityStr as string) : 0;
                if (obj.probability !== undefined && isNaN(obj.probability as number)) obj.probability = 0;
            }
            {
            // Collect nested object fields with prefix "priority."
            const priorityObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("priority.")) {
                    const fieldName = key.slice("priority.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = priorityObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.priority = priorityObj;
        }
            obj.dueDate = formData.get("dueDate") ?? "";
            obj.closeDate = formData.get("closeDate") ?? "";
            {
                const valueStr = formData.get("value");
                obj.value = valueStr ? parseFloat(valueStr as string) : 0;
                if (obj.value !== undefined && isNaN(obj.value as number)) obj.value = 0;
            }
            {
            // Collect nested object fields with prefix "stage."
            const stageObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("stage.")) {
                    const fieldName = key.slice("stage.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = stageObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.stage = stageObj;
        }
            obj.status = formData.get("status") ?? "";
            obj.description = formData.get("description") ?? "";
            {
            // Collect nested object fields with prefix "nextStep."
            const nextStepObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("nextStep.")) {
                    const fieldName = key.slice("nextStep.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = nextStepObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.nextStep = nextStepObj;
        }
            {
                const favoriteVal = formData.get("favorite");
                obj.favorite = favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1";
            }
            obj.dateAdded = formData.get("dateAdded") ?? "";
            obj.taxRate = formData.get("taxRate") ?? "";
            {
            // Collect nested object fields with prefix "sector."
            const sectorObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("sector.")) {
                    const fieldName = key.slice("sector.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = sectorObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.sector = sectorObj;
        }
            {
            // Collect nested object fields with prefix "leadName."
            const leadNameObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("leadName.")) {
                    const fieldName = key.slice("leadName.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = leadNameObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.leadName = leadNameObj;
        }
            {
                // Collect array items from indexed form fields
                const phonesItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("phones." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("phones." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("phones." + idx + ".")) {
                                const fieldName = key.slice("phones.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        phonesItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.phones = phonesItems;
            }
            {
            // Collect nested object fields with prefix "email."
            const emailObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("email.")) {
                    const fieldName = key.slice("email.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = emailObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.email = emailObj;
        }
            obj.leadSource = formData.get("leadSource") ?? "";
            obj.site = formData.get("site") ?? "";
            obj.memo = formData.get("memo") ?? "";
            {
                const needsReviewVal = formData.get("needsReview");
                obj.needsReview = needsReviewVal === "true" || needsReviewVal === "on" || needsReviewVal === "1";
            }
            {
                const hasAlertVal = formData.get("hasAlert");
                obj.hasAlert = hasAlertVal === "true" || hasAlertVal === "on" || hasAlertVal === "1";
            }
            obj.salesRep = formData.get("salesRep") ?? "";
            obj.color = formData.get("color") ?? "";
            obj.accountType = formData.get("accountType") ?? "";
            obj.subtype = formData.get("subtype") ?? "";
            {
                const isTaxExemptVal = formData.get("isTaxExempt");
                obj.isTaxExempt = isTaxExemptVal === "true" || isTaxExemptVal === "on" || isTaxExemptVal === "1";
            }
            obj.paymentTerms = formData.get("paymentTerms") ?? "";
            obj.tags = formData.getAll("tags") as Array<string>;
            {
                // Collect array items from indexed form fields
                const customFieldsItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("customFields." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("customFields." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("customFields." + idx + ".")) {
                                const fieldName = key.slice("customFields.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        customFieldsItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.customFields = customFieldsItems;
            } return fromStringifiedJSONLead(JSON.stringify(obj));}


export interface AppPermissions {
    applications: Applications[];
    pages: Page[];
    data: Table[];
}

export function defaultValueAppPermissions(): AppPermissions {return {applications: [],
                            pages: [],
                            data: [], }as AppPermissions;}

export function toStringifiedJSONAppPermissions(value: AppPermissions): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeAppPermissions(value, ctx));}export function toObjectAppPermissions(value: AppPermissions): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeAppPermissions(value, ctx);}export function __serializeAppPermissions(value: AppPermissions, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "AppPermissions" , __id,}; result["applications" ]= value.applications.map((item)=>__serializeApplications(item, ctx)); result["pages" ]= value.pages.map((item)=>__serializePage(item, ctx)); result["data" ]= value.data.map((item)=>__serializeTable(item, ctx)); return result;}

export function fromStringifiedJSONAppPermissions(json: string, opts?: DeserializeOptions): Result<AppPermissions, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectAppPermissions(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectAppPermissions(obj: unknown, opts?: DeserializeOptions): Result<AppPermissions, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeAppPermissions(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "AppPermissions.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeAppPermissions(value: any, ctx: DeserializeContext): AppPermissions | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "AppPermissions.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("applications" in obj)){errors.push({field: "applications" , message: "missing required field" });}if(!("pages" in obj)){errors.push({field: "pages" , message: "missing required field" });}if(!("data" in obj)){errors.push({field: "data" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_applications = obj["applications" ]as Applications[]; if(Array.isArray(__raw_applications)){instance.applications = __raw_applications as Applications[];}}{const __raw_pages = obj["pages" ]as Page[]; if(Array.isArray(__raw_pages)){instance.pages = __raw_pages as Page[];}}{const __raw_data = obj["data" ]as Table[]; if(Array.isArray(__raw_data)){instance.data = __raw_data as Table[];}}if(errors.length>0){throw new DeserializeError(errors);}return instance as AppPermissions;}export function validateFieldAppPermissions<K extends keyof AppPermissions>(field: K, value: AppPermissions[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsAppPermissions(partial: Partial<AppPermissions>): Array<{field: string; message: string}>{return[]; }export function hasShapeAppPermissions(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "applications" in o && "pages" in o && "data" in o;}export function isAppPermissions(obj: unknown): obj is AppPermissions {if(!hasShapeAppPermissions(obj)){return false;}const result = fromObjectAppPermissions(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsAppPermissions = {_errors: Option<Array<string>>; applications: Option<Array<string>>;
            pages: Option<Array<string>>;
            data: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedAppPermissions = {applications: Option<boolean>;
            pages: Option<boolean>;
            data: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersAppPermissions {readonly applications: ArrayFieldController<Applications>;
            readonly pages: ArrayFieldController<Page>;
            readonly data: ArrayFieldController<Table>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformAppPermissions {readonly data: AppPermissions; readonly errors: ErrorsAppPermissions; readonly tainted: TaintedAppPermissions; readonly fields: FieldControllersAppPermissions; validate(): Result<AppPermissions, Array<{field: string; message: string}>>; reset(overrides?: Partial<AppPermissions>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormAppPermissions(overrides?: Partial<AppPermissions>): GigaformAppPermissions {let data = $state({...defaultValueAppPermissions(),...overrides}); let errors = $state<ErrorsAppPermissions>({ _errors: Option.none(), applications: Option.none(), pages: Option.none(), data: Option.none() }); let tainted = $state<TaintedAppPermissions>({ applications: Option.none(), pages: Option.none(), data: Option.none() }); const fields: FieldControllersAppPermissions = {applications: {
                    path: ["applications"] as const,
                    name: "applications",
                    constraints: { required: true },
                    
                    get: () => data.applications,
                    set: (value: Applications[]) => { data.applications = value; },
                    transform: (value: Applications[]): Applications[] => value,
                    getError: () => errors.applications,
                    setError: (value: Option<Array<string>>) => { errors.applications = value; },
                    getTainted: () => tainted.applications,
                    setTainted: (value: Option<boolean>) => { tainted.applications = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppPermissions("applications", data.applications);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["applications", index] as const,
                        name: `applications.${index}`,
                        constraints: { required: true },
                        get: () => data.applications[index]!,
                        set: (value: Applications) => { data.applications[index] = value; },
                        transform: (value: Applications): Applications => value,
                        getError: () => errors.applications,
                        setError: (value: Option<Array<string>>) => { errors.applications = value; },
                        getTainted: () => tainted.applications,
                        setTainted: (value: Option<boolean>) => { tainted.applications = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: Applications) => { data.applications.push(item); },
                    remove: (index: number) => { data.applications.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.applications[a]!;
                        data.applications[a] = data.applications[b]!;
                        data.applications[b] = tmp;
                    },
                },
                pages: {
                    path: ["pages"] as const,
                    name: "pages",
                    constraints: { required: true },
                    
                    get: () => data.pages,
                    set: (value: Page[]) => { data.pages = value; },
                    transform: (value: Page[]): Page[] => value,
                    getError: () => errors.pages,
                    setError: (value: Option<Array<string>>) => { errors.pages = value; },
                    getTainted: () => tainted.pages,
                    setTainted: (value: Option<boolean>) => { tainted.pages = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppPermissions("pages", data.pages);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["pages", index] as const,
                        name: `pages.${index}`,
                        constraints: { required: true },
                        get: () => data.pages[index]!,
                        set: (value: Page) => { data.pages[index] = value; },
                        transform: (value: Page): Page => value,
                        getError: () => errors.pages,
                        setError: (value: Option<Array<string>>) => { errors.pages = value; },
                        getTainted: () => tainted.pages,
                        setTainted: (value: Option<boolean>) => { tainted.pages = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: Page) => { data.pages.push(item); },
                    remove: (index: number) => { data.pages.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.pages[a]!;
                        data.pages[a] = data.pages[b]!;
                        data.pages[b] = tmp;
                    },
                },
                data: {
                    path: ["data"] as const,
                    name: "data",
                    constraints: { required: true },
                    
                    get: () => data.data,
                    set: (value: Table[]) => { data.data = value; },
                    transform: (value: Table[]): Table[] => value,
                    getError: () => errors.data,
                    setError: (value: Option<Array<string>>) => { errors.data = value; },
                    getTainted: () => tainted.data,
                    setTainted: (value: Option<boolean>) => { tainted.data = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldAppPermissions("data", data.data);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["data", index] as const,
                        name: `data.${index}`,
                        constraints: { required: true },
                        get: () => data.data[index]!,
                        set: (value: Table) => { data.data[index] = value; },
                        transform: (value: Table): Table => value,
                        getError: () => errors.data,
                        setError: (value: Option<Array<string>>) => { errors.data = value; },
                        getTainted: () => tainted.data,
                        setTainted: (value: Option<boolean>) => { tainted.data = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: Table) => { data.data.push(item); },
                    remove: (index: number) => { data.data.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.data[a]!;
                        data.data[a] = data.data[b]!;
                        data.data[b] = tmp;
                    },
                }}; function validate(): Result<AppPermissions, Array<{field: string; message: string}>>{return fromObjectAppPermissions(data);}function reset(newOverrides?: Partial<AppPermissions>): void {data = {...defaultValueAppPermissions(),...newOverrides}; errors = { _errors: Option.none(), applications: Option.none(), pages: Option.none(), data: Option.none() }; tainted = { applications: Option.none(), pages: Option.none(), data: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataAppPermissions(formData: FormData): Result<AppPermissions, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                // Collect array items from indexed form fields
                const applicationsItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("applications." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("applications." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("applications." + idx + ".")) {
                                const fieldName = key.slice("applications.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        applicationsItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.applications = applicationsItems;
            }
            {
                // Collect array items from indexed form fields
                const pagesItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("pages." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("pages." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("pages." + idx + ".")) {
                                const fieldName = key.slice("pages.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        pagesItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.pages = pagesItems;
            }
            {
                // Collect array items from indexed form fields
                const dataItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("data." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("data." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("data." + idx + ".")) {
                                const fieldName = key.slice("data.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        dataItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.data = dataItems;
            } return fromStringifiedJSONAppPermissions(JSON.stringify(obj));}


export interface Company {
    id: string;
    
    legalName: string;
    
    headquarters: string | Site;
    phones: PhoneNumber[];
    
    fax: string;
    
    email: string;
    
    website: string;
    
    taxId: string;
    referenceNumber: number;
    
    postalCodeLookup: string;
    timeZone: string;
    
    defaultTax: string | TaxRate;
    
    defaultTaxLocation: string;
    defaultAreaCode: number;
    
    defaultAccountType: string;
    
    lookupFormatting: string;
    
    accountNameFormat: string;
    merchantServiceProvider: string | null;
    
    dateDisplayStyle: string;
    hasAutoCommission: boolean;
    hasAutoDaylightSavings: boolean;
    hasAutoFmsTracking: boolean;
    hasNotifications: boolean;
    hasRequiredLeadSource: boolean;
    hasRequiredEmail: boolean;
    hasSortServiceItemsAlphabetically: boolean;
    hasAttachOrderToAppointmentEmails: boolean;
    scheduleInterval: number;
    colorsConfig: ColorsConfig;
}

export function defaultValueCompany(): Company {return {id: "",
                            legalName: "",
                            headquarters: "",
                            phones: [],
                            fax: "",
                            email: "",
                            website: "",
                            taxId: "",
                            referenceNumber: 0,
                            postalCodeLookup: "",
                            timeZone: "",
                            defaultTax: "",
                            defaultTaxLocation: "",
                            defaultAreaCode: 0,
                            defaultAccountType: "",
                            lookupFormatting: "",
                            accountNameFormat: "",
                            merchantServiceProvider: null,
                            dateDisplayStyle: "",
                            hasAutoCommission: false,
                            hasAutoDaylightSavings: false,
                            hasAutoFmsTracking: false,
                            hasNotifications: false,
                            hasRequiredLeadSource: false,
                            hasRequiredEmail: false,
                            hasSortServiceItemsAlphabetically: false,
                            hasAttachOrderToAppointmentEmails: false,
                            scheduleInterval: 0,
                            colorsConfig: defaultValueColorsConfig(), }as Company;}

export function toStringifiedJSONCompany(value: Company): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeCompany(value, ctx));}export function toObjectCompany(value: Company): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeCompany(value, ctx);}export function __serializeCompany(value: Company, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Company" , __id,}; result["id" ]= value.id; result["legalName" ]= value.legalName; result["headquarters" ]= value.headquarters; result["phones" ]= value.phones.map((item)=>__serializePhoneNumber(item, ctx)); result["fax" ]= value.fax; result["email" ]= value.email; result["website" ]= value.website; result["taxId" ]= value.taxId; result["referenceNumber" ]= value.referenceNumber; result["postalCodeLookup" ]= value.postalCodeLookup; result["timeZone" ]= value.timeZone; result["defaultTax" ]= value.defaultTax; result["defaultTaxLocation" ]= value.defaultTaxLocation; result["defaultAreaCode" ]= value.defaultAreaCode; result["defaultAccountType" ]= value.defaultAccountType; result["lookupFormatting" ]= value.lookupFormatting; result["accountNameFormat" ]= value.accountNameFormat; result["merchantServiceProvider" ]= value.merchantServiceProvider; result["dateDisplayStyle" ]= value.dateDisplayStyle; result["hasAutoCommission" ]= value.hasAutoCommission; result["hasAutoDaylightSavings" ]= value.hasAutoDaylightSavings; result["hasAutoFmsTracking" ]= value.hasAutoFmsTracking; result["hasNotifications" ]= value.hasNotifications; result["hasRequiredLeadSource" ]= value.hasRequiredLeadSource; result["hasRequiredEmail" ]= value.hasRequiredEmail; result["hasSortServiceItemsAlphabetically" ]= value.hasSortServiceItemsAlphabetically; result["hasAttachOrderToAppointmentEmails" ]= value.hasAttachOrderToAppointmentEmails; result["scheduleInterval" ]= value.scheduleInterval; result["colorsConfig" ]= __serializeColorsConfig(value.colorsConfig, ctx); return result;}

export function fromStringifiedJSONCompany(json: string, opts?: DeserializeOptions): Result<Company, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectCompany(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectCompany(obj: unknown, opts?: DeserializeOptions): Result<Company, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeCompany(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Company.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeCompany(value: any, ctx: DeserializeContext): Company | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Company.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("legalName" in obj)){errors.push({field: "legalName" , message: "missing required field" });}if(!("headquarters" in obj)){errors.push({field: "headquarters" , message: "missing required field" });}if(!("phones" in obj)){errors.push({field: "phones" , message: "missing required field" });}if(!("fax" in obj)){errors.push({field: "fax" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("website" in obj)){errors.push({field: "website" , message: "missing required field" });}if(!("taxId" in obj)){errors.push({field: "taxId" , message: "missing required field" });}if(!("referenceNumber" in obj)){errors.push({field: "referenceNumber" , message: "missing required field" });}if(!("postalCodeLookup" in obj)){errors.push({field: "postalCodeLookup" , message: "missing required field" });}if(!("timeZone" in obj)){errors.push({field: "timeZone" , message: "missing required field" });}if(!("defaultTax" in obj)){errors.push({field: "defaultTax" , message: "missing required field" });}if(!("defaultTaxLocation" in obj)){errors.push({field: "defaultTaxLocation" , message: "missing required field" });}if(!("defaultAreaCode" in obj)){errors.push({field: "defaultAreaCode" , message: "missing required field" });}if(!("defaultAccountType" in obj)){errors.push({field: "defaultAccountType" , message: "missing required field" });}if(!("lookupFormatting" in obj)){errors.push({field: "lookupFormatting" , message: "missing required field" });}if(!("accountNameFormat" in obj)){errors.push({field: "accountNameFormat" , message: "missing required field" });}if(!("merchantServiceProvider" in obj)){errors.push({field: "merchantServiceProvider" , message: "missing required field" });}if(!("dateDisplayStyle" in obj)){errors.push({field: "dateDisplayStyle" , message: "missing required field" });}if(!("hasAutoCommission" in obj)){errors.push({field: "hasAutoCommission" , message: "missing required field" });}if(!("hasAutoDaylightSavings" in obj)){errors.push({field: "hasAutoDaylightSavings" , message: "missing required field" });}if(!("hasAutoFmsTracking" in obj)){errors.push({field: "hasAutoFmsTracking" , message: "missing required field" });}if(!("hasNotifications" in obj)){errors.push({field: "hasNotifications" , message: "missing required field" });}if(!("hasRequiredLeadSource" in obj)){errors.push({field: "hasRequiredLeadSource" , message: "missing required field" });}if(!("hasRequiredEmail" in obj)){errors.push({field: "hasRequiredEmail" , message: "missing required field" });}if(!("hasSortServiceItemsAlphabetically" in obj)){errors.push({field: "hasSortServiceItemsAlphabetically" , message: "missing required field" });}if(!("hasAttachOrderToAppointmentEmails" in obj)){errors.push({field: "hasAttachOrderToAppointmentEmails" , message: "missing required field" });}if(!("scheduleInterval" in obj)){errors.push({field: "scheduleInterval" , message: "missing required field" });}if(!("colorsConfig" in obj)){errors.push({field: "colorsConfig" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_legalName = obj["legalName" ]as string; 
                if (__raw_legalName.length === 0) {
                    errors.push({ field: "legalName", message: "must not be empty" });
                }
 instance.legalName = __raw_legalName; }{const __raw_headquarters = obj["headquarters" ]as string | Site; instance.headquarters = __raw_headquarters; }{const __raw_phones = obj["phones" ]as PhoneNumber[]; if(Array.isArray(__raw_phones)){instance.phones = __raw_phones as PhoneNumber[];}}{const __raw_fax = obj["fax" ]as string; 
                if (__raw_fax.length === 0) {
                    errors.push({ field: "fax", message: "must not be empty" });
                }
 instance.fax = __raw_fax; }{const __raw_email = obj["email" ]as string; 
                if (__raw_email.length === 0) {
                    errors.push({ field: "email", message: "must not be empty" });
                }
 instance.email = __raw_email; }{const __raw_website = obj["website" ]as string; 
                if (__raw_website.length === 0) {
                    errors.push({ field: "website", message: "must not be empty" });
                }
 instance.website = __raw_website; }{const __raw_taxId = obj["taxId" ]as string; 
                if (__raw_taxId.length === 0) {
                    errors.push({ field: "taxId", message: "must not be empty" });
                }
 instance.taxId = __raw_taxId; }{const __raw_referenceNumber = obj["referenceNumber" ]as number; instance.referenceNumber = __raw_referenceNumber; }{const __raw_postalCodeLookup = obj["postalCodeLookup" ]as string; 
                if (__raw_postalCodeLookup.length === 0) {
                    errors.push({ field: "postalCodeLookup", message: "must not be empty" });
                }
 instance.postalCodeLookup = __raw_postalCodeLookup; }{const __raw_timeZone = obj["timeZone" ]as string; instance.timeZone = __raw_timeZone; }{const __raw_defaultTax = obj["defaultTax" ]as string | TaxRate; instance.defaultTax = __raw_defaultTax; }{const __raw_defaultTaxLocation = obj["defaultTaxLocation" ]as string; 
                if (__raw_defaultTaxLocation.length === 0) {
                    errors.push({ field: "defaultTaxLocation", message: "must not be empty" });
                }
 instance.defaultTaxLocation = __raw_defaultTaxLocation; }{const __raw_defaultAreaCode = obj["defaultAreaCode" ]as number; instance.defaultAreaCode = __raw_defaultAreaCode; }{const __raw_defaultAccountType = obj["defaultAccountType" ]as string; 
                if (__raw_defaultAccountType.length === 0) {
                    errors.push({ field: "defaultAccountType", message: "must not be empty" });
                }
 instance.defaultAccountType = __raw_defaultAccountType; }{const __raw_lookupFormatting = obj["lookupFormatting" ]as string; 
                if (__raw_lookupFormatting.length === 0) {
                    errors.push({ field: "lookupFormatting", message: "must not be empty" });
                }
 instance.lookupFormatting = __raw_lookupFormatting; }{const __raw_accountNameFormat = obj["accountNameFormat" ]as string; 
                if (__raw_accountNameFormat.length === 0) {
                    errors.push({ field: "accountNameFormat", message: "must not be empty" });
                }
 instance.accountNameFormat = __raw_accountNameFormat; }{const __raw_merchantServiceProvider = obj["merchantServiceProvider" ]as string | null; instance.merchantServiceProvider = __raw_merchantServiceProvider; }{const __raw_dateDisplayStyle = obj["dateDisplayStyle" ]as string; 
                if (__raw_dateDisplayStyle.length === 0) {
                    errors.push({ field: "dateDisplayStyle", message: "must not be empty" });
                }
 instance.dateDisplayStyle = __raw_dateDisplayStyle; }{const __raw_hasAutoCommission = obj["hasAutoCommission" ]as boolean; instance.hasAutoCommission = __raw_hasAutoCommission; }{const __raw_hasAutoDaylightSavings = obj["hasAutoDaylightSavings" ]as boolean; instance.hasAutoDaylightSavings = __raw_hasAutoDaylightSavings; }{const __raw_hasAutoFmsTracking = obj["hasAutoFmsTracking" ]as boolean; instance.hasAutoFmsTracking = __raw_hasAutoFmsTracking; }{const __raw_hasNotifications = obj["hasNotifications" ]as boolean; instance.hasNotifications = __raw_hasNotifications; }{const __raw_hasRequiredLeadSource = obj["hasRequiredLeadSource" ]as boolean; instance.hasRequiredLeadSource = __raw_hasRequiredLeadSource; }{const __raw_hasRequiredEmail = obj["hasRequiredEmail" ]as boolean; instance.hasRequiredEmail = __raw_hasRequiredEmail; }{const __raw_hasSortServiceItemsAlphabetically = obj["hasSortServiceItemsAlphabetically" ]as boolean; instance.hasSortServiceItemsAlphabetically = __raw_hasSortServiceItemsAlphabetically; }{const __raw_hasAttachOrderToAppointmentEmails = obj["hasAttachOrderToAppointmentEmails" ]as boolean; instance.hasAttachOrderToAppointmentEmails = __raw_hasAttachOrderToAppointmentEmails; }{const __raw_scheduleInterval = obj["scheduleInterval" ]as number; instance.scheduleInterval = __raw_scheduleInterval; }{const __raw_colorsConfig = obj["colorsConfig" ]as ColorsConfig; {const __result = __deserializeColorsConfig(__raw_colorsConfig, ctx); ctx.assignOrDefer(instance, "colorsConfig" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Company;}export function validateFieldCompany<K extends keyof Company>(field: K, value: Company[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "legalName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "legalName", message: "must not be empty" });
                }
 break;}case "fax" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "fax", message: "must not be empty" });
                }
 break;}case "email" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "email", message: "must not be empty" });
                }
 break;}case "website" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "website", message: "must not be empty" });
                }
 break;}case "taxId" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "taxId", message: "must not be empty" });
                }
 break;}case "postalCodeLookup" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "postalCodeLookup", message: "must not be empty" });
                }
 break;}case "defaultTaxLocation" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "defaultTaxLocation", message: "must not be empty" });
                }
 break;}case "defaultAccountType" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "defaultAccountType", message: "must not be empty" });
                }
 break;}case "lookupFormatting" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lookupFormatting", message: "must not be empty" });
                }
 break;}case "accountNameFormat" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountNameFormat", message: "must not be empty" });
                }
 break;}case "dateDisplayStyle" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "dateDisplayStyle", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsCompany(partial: Partial<Company>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("legalName" in partial && partial.legalName!== undefined){const __val = partial.legalName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "legalName", message: "must not be empty" });
                }
}if("fax" in partial && partial.fax!== undefined){const __val = partial.fax as string; 
                if (__val.length === 0) {
                    errors.push({ field: "fax", message: "must not be empty" });
                }
}if("email" in partial && partial.email!== undefined){const __val = partial.email as string; 
                if (__val.length === 0) {
                    errors.push({ field: "email", message: "must not be empty" });
                }
}if("website" in partial && partial.website!== undefined){const __val = partial.website as string; 
                if (__val.length === 0) {
                    errors.push({ field: "website", message: "must not be empty" });
                }
}if("taxId" in partial && partial.taxId!== undefined){const __val = partial.taxId as string; 
                if (__val.length === 0) {
                    errors.push({ field: "taxId", message: "must not be empty" });
                }
}if("postalCodeLookup" in partial && partial.postalCodeLookup!== undefined){const __val = partial.postalCodeLookup as string; 
                if (__val.length === 0) {
                    errors.push({ field: "postalCodeLookup", message: "must not be empty" });
                }
}if("defaultTaxLocation" in partial && partial.defaultTaxLocation!== undefined){const __val = partial.defaultTaxLocation as string; 
                if (__val.length === 0) {
                    errors.push({ field: "defaultTaxLocation", message: "must not be empty" });
                }
}if("defaultAccountType" in partial && partial.defaultAccountType!== undefined){const __val = partial.defaultAccountType as string; 
                if (__val.length === 0) {
                    errors.push({ field: "defaultAccountType", message: "must not be empty" });
                }
}if("lookupFormatting" in partial && partial.lookupFormatting!== undefined){const __val = partial.lookupFormatting as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lookupFormatting", message: "must not be empty" });
                }
}if("accountNameFormat" in partial && partial.accountNameFormat!== undefined){const __val = partial.accountNameFormat as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountNameFormat", message: "must not be empty" });
                }
}if("dateDisplayStyle" in partial && partial.dateDisplayStyle!== undefined){const __val = partial.dateDisplayStyle as string; 
                if (__val.length === 0) {
                    errors.push({ field: "dateDisplayStyle", message: "must not be empty" });
                }
}return errors; }export function hasShapeCompany(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "legalName" in o && "headquarters" in o && "phones" in o && "fax" in o && "email" in o && "website" in o && "taxId" in o && "referenceNumber" in o && "postalCodeLookup" in o && "timeZone" in o && "defaultTax" in o && "defaultTaxLocation" in o && "defaultAreaCode" in o && "defaultAccountType" in o && "lookupFormatting" in o && "accountNameFormat" in o && "merchantServiceProvider" in o && "dateDisplayStyle" in o && "hasAutoCommission" in o && "hasAutoDaylightSavings" in o && "hasAutoFmsTracking" in o && "hasNotifications" in o && "hasRequiredLeadSource" in o && "hasRequiredEmail" in o && "hasSortServiceItemsAlphabetically" in o && "hasAttachOrderToAppointmentEmails" in o && "scheduleInterval" in o && "colorsConfig" in o;}export function isCompany(obj: unknown): obj is Company {if(!hasShapeCompany(obj)){return false;}const result = fromObjectCompany(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsCompany = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            legalName: Option<Array<string>>;
            headquarters: Option<Array<string>>;
            phones: Option<Array<string>>;
            fax: Option<Array<string>>;
            email: Option<Array<string>>;
            website: Option<Array<string>>;
            taxId: Option<Array<string>>;
            referenceNumber: Option<Array<string>>;
            postalCodeLookup: Option<Array<string>>;
            timeZone: Option<Array<string>>;
            defaultTax: Option<Array<string>>;
            defaultTaxLocation: Option<Array<string>>;
            defaultAreaCode: Option<Array<string>>;
            defaultAccountType: Option<Array<string>>;
            lookupFormatting: Option<Array<string>>;
            accountNameFormat: Option<Array<string>>;
            merchantServiceProvider: Option<Array<string>>;
            dateDisplayStyle: Option<Array<string>>;
            hasAutoCommission: Option<Array<string>>;
            hasAutoDaylightSavings: Option<Array<string>>;
            hasAutoFmsTracking: Option<Array<string>>;
            hasNotifications: Option<Array<string>>;
            hasRequiredLeadSource: Option<Array<string>>;
            hasRequiredEmail: Option<Array<string>>;
            hasSortServiceItemsAlphabetically: Option<Array<string>>;
            hasAttachOrderToAppointmentEmails: Option<Array<string>>;
            scheduleInterval: Option<Array<string>>;
            colorsConfig: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedCompany = {id: Option<boolean>;
            legalName: Option<boolean>;
            headquarters: Option<boolean>;
            phones: Option<boolean>;
            fax: Option<boolean>;
            email: Option<boolean>;
            website: Option<boolean>;
            taxId: Option<boolean>;
            referenceNumber: Option<boolean>;
            postalCodeLookup: Option<boolean>;
            timeZone: Option<boolean>;
            defaultTax: Option<boolean>;
            defaultTaxLocation: Option<boolean>;
            defaultAreaCode: Option<boolean>;
            defaultAccountType: Option<boolean>;
            lookupFormatting: Option<boolean>;
            accountNameFormat: Option<boolean>;
            merchantServiceProvider: Option<boolean>;
            dateDisplayStyle: Option<boolean>;
            hasAutoCommission: Option<boolean>;
            hasAutoDaylightSavings: Option<boolean>;
            hasAutoFmsTracking: Option<boolean>;
            hasNotifications: Option<boolean>;
            hasRequiredLeadSource: Option<boolean>;
            hasRequiredEmail: Option<boolean>;
            hasSortServiceItemsAlphabetically: Option<boolean>;
            hasAttachOrderToAppointmentEmails: Option<boolean>;
            scheduleInterval: Option<boolean>;
            colorsConfig: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersCompany {readonly id: FieldController<string>;
            readonly legalName: FieldController<string>;
            readonly headquarters: FieldController<string | Site>;
            readonly phones: ArrayFieldController<PhoneNumber>;
            readonly fax: FieldController<string>;
            readonly email: FieldController<string>;
            readonly website: FieldController<string>;
            readonly taxId: FieldController<string>;
            readonly referenceNumber: FieldController<number>;
            readonly postalCodeLookup: FieldController<string>;
            readonly timeZone: FieldController<string>;
            readonly defaultTax: FieldController<string | TaxRate>;
            readonly defaultTaxLocation: FieldController<string>;
            readonly defaultAreaCode: FieldController<number>;
            readonly defaultAccountType: FieldController<string>;
            readonly lookupFormatting: FieldController<string>;
            readonly accountNameFormat: FieldController<string>;
            readonly merchantServiceProvider: FieldController<string | null>;
            readonly dateDisplayStyle: FieldController<string>;
            readonly hasAutoCommission: FieldController<boolean>;
            readonly hasAutoDaylightSavings: FieldController<boolean>;
            readonly hasAutoFmsTracking: FieldController<boolean>;
            readonly hasNotifications: FieldController<boolean>;
            readonly hasRequiredLeadSource: FieldController<boolean>;
            readonly hasRequiredEmail: FieldController<boolean>;
            readonly hasSortServiceItemsAlphabetically: FieldController<boolean>;
            readonly hasAttachOrderToAppointmentEmails: FieldController<boolean>;
            readonly scheduleInterval: FieldController<number>;
            readonly colorsConfig: FieldController<ColorsConfig>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformCompany {readonly data: Company; readonly errors: ErrorsCompany; readonly tainted: TaintedCompany; readonly fields: FieldControllersCompany; validate(): Result<Company, Array<{field: string; message: string}>>; reset(overrides?: Partial<Company>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormCompany(overrides?: Partial<Company>): GigaformCompany {let data = $state({...defaultValueCompany(),...overrides}); let errors = $state<ErrorsCompany>({ _errors: Option.none(), id: Option.none(), legalName: Option.none(), headquarters: Option.none(), phones: Option.none(), fax: Option.none(), email: Option.none(), website: Option.none(), taxId: Option.none(), referenceNumber: Option.none(), postalCodeLookup: Option.none(), timeZone: Option.none(), defaultTax: Option.none(), defaultTaxLocation: Option.none(), defaultAreaCode: Option.none(), defaultAccountType: Option.none(), lookupFormatting: Option.none(), accountNameFormat: Option.none(), merchantServiceProvider: Option.none(), dateDisplayStyle: Option.none(), hasAutoCommission: Option.none(), hasAutoDaylightSavings: Option.none(), hasAutoFmsTracking: Option.none(), hasNotifications: Option.none(), hasRequiredLeadSource: Option.none(), hasRequiredEmail: Option.none(), hasSortServiceItemsAlphabetically: Option.none(), hasAttachOrderToAppointmentEmails: Option.none(), scheduleInterval: Option.none(), colorsConfig: Option.none() }); let tainted = $state<TaintedCompany>({ id: Option.none(), legalName: Option.none(), headquarters: Option.none(), phones: Option.none(), fax: Option.none(), email: Option.none(), website: Option.none(), taxId: Option.none(), referenceNumber: Option.none(), postalCodeLookup: Option.none(), timeZone: Option.none(), defaultTax: Option.none(), defaultTaxLocation: Option.none(), defaultAreaCode: Option.none(), defaultAccountType: Option.none(), lookupFormatting: Option.none(), accountNameFormat: Option.none(), merchantServiceProvider: Option.none(), dateDisplayStyle: Option.none(), hasAutoCommission: Option.none(), hasAutoDaylightSavings: Option.none(), hasAutoFmsTracking: Option.none(), hasNotifications: Option.none(), hasRequiredLeadSource: Option.none(), hasRequiredEmail: Option.none(), hasSortServiceItemsAlphabetically: Option.none(), hasAttachOrderToAppointmentEmails: Option.none(), scheduleInterval: Option.none(), colorsConfig: Option.none() }); const fields: FieldControllersCompany = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                legalName: {
                    path: ["legalName"] as const,
                    name: "legalName",
                    constraints: { required: true },
                    
                    get: () => data.legalName,
                    set: (value: string) => { data.legalName = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.legalName,
                    setError: (value: Option<Array<string>>) => { errors.legalName = value; },
                    getTainted: () => tainted.legalName,
                    setTainted: (value: Option<boolean>) => { tainted.legalName = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("legalName", data.legalName);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                headquarters: {
                    path: ["headquarters"] as const,
                    name: "headquarters",
                    constraints: { required: true },
                    
                    get: () => data.headquarters,
                    set: (value: string | Site) => { data.headquarters = value; },
                    transform: (value: string | Site): string | Site => value,
                    getError: () => errors.headquarters,
                    setError: (value: Option<Array<string>>) => { errors.headquarters = value; },
                    getTainted: () => tainted.headquarters,
                    setTainted: (value: Option<boolean>) => { tainted.headquarters = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("headquarters", data.headquarters);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                phones: {
                    path: ["phones"] as const,
                    name: "phones",
                    constraints: { required: true },
                    
                    get: () => data.phones,
                    set: (value: PhoneNumber[]) => { data.phones = value; },
                    transform: (value: PhoneNumber[]): PhoneNumber[] => value,
                    getError: () => errors.phones,
                    setError: (value: Option<Array<string>>) => { errors.phones = value; },
                    getTainted: () => tainted.phones,
                    setTainted: (value: Option<boolean>) => { tainted.phones = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("phones", data.phones);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["phones", index] as const,
                        name: `phones.${index}`,
                        constraints: { required: true },
                        get: () => data.phones[index]!,
                        set: (value: PhoneNumber) => { data.phones[index] = value; },
                        transform: (value: PhoneNumber): PhoneNumber => value,
                        getError: () => errors.phones,
                        setError: (value: Option<Array<string>>) => { errors.phones = value; },
                        getTainted: () => tainted.phones,
                        setTainted: (value: Option<boolean>) => { tainted.phones = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: PhoneNumber) => { data.phones.push(item); },
                    remove: (index: number) => { data.phones.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.phones[a]!;
                        data.phones[a] = data.phones[b]!;
                        data.phones[b] = tmp;
                    },
                },
                fax: {
                    path: ["fax"] as const,
                    name: "fax",
                    constraints: { required: true },
                    
                    get: () => data.fax,
                    set: (value: string) => { data.fax = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.fax,
                    setError: (value: Option<Array<string>>) => { errors.fax = value; },
                    getTainted: () => tainted.fax,
                    setTainted: (value: Option<boolean>) => { tainted.fax = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("fax", data.fax);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                email: {
                    path: ["email"] as const,
                    name: "email",
                    constraints: { required: true },
                    
                    get: () => data.email,
                    set: (value: string) => { data.email = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.email,
                    setError: (value: Option<Array<string>>) => { errors.email = value; },
                    getTainted: () => tainted.email,
                    setTainted: (value: Option<boolean>) => { tainted.email = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("email", data.email);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                website: {
                    path: ["website"] as const,
                    name: "website",
                    constraints: { required: true },
                    
                    get: () => data.website,
                    set: (value: string) => { data.website = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.website,
                    setError: (value: Option<Array<string>>) => { errors.website = value; },
                    getTainted: () => tainted.website,
                    setTainted: (value: Option<boolean>) => { tainted.website = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("website", data.website);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                taxId: {
                    path: ["taxId"] as const,
                    name: "taxId",
                    constraints: { required: true },
                    
                    get: () => data.taxId,
                    set: (value: string) => { data.taxId = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.taxId,
                    setError: (value: Option<Array<string>>) => { errors.taxId = value; },
                    getTainted: () => tainted.taxId,
                    setTainted: (value: Option<boolean>) => { tainted.taxId = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("taxId", data.taxId);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                referenceNumber: {
                    path: ["referenceNumber"] as const,
                    name: "referenceNumber",
                    constraints: { required: true },
                    
                    get: () => data.referenceNumber,
                    set: (value: number) => { data.referenceNumber = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.referenceNumber,
                    setError: (value: Option<Array<string>>) => { errors.referenceNumber = value; },
                    getTainted: () => tainted.referenceNumber,
                    setTainted: (value: Option<boolean>) => { tainted.referenceNumber = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("referenceNumber", data.referenceNumber);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                postalCodeLookup: {
                    path: ["postalCodeLookup"] as const,
                    name: "postalCodeLookup",
                    constraints: { required: true },
                    
                    get: () => data.postalCodeLookup,
                    set: (value: string) => { data.postalCodeLookup = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.postalCodeLookup,
                    setError: (value: Option<Array<string>>) => { errors.postalCodeLookup = value; },
                    getTainted: () => tainted.postalCodeLookup,
                    setTainted: (value: Option<boolean>) => { tainted.postalCodeLookup = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("postalCodeLookup", data.postalCodeLookup);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                timeZone: {
                    path: ["timeZone"] as const,
                    name: "timeZone",
                    constraints: { required: true },
                    
                    get: () => data.timeZone,
                    set: (value: string) => { data.timeZone = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.timeZone,
                    setError: (value: Option<Array<string>>) => { errors.timeZone = value; },
                    getTainted: () => tainted.timeZone,
                    setTainted: (value: Option<boolean>) => { tainted.timeZone = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("timeZone", data.timeZone);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                defaultTax: {
                    path: ["defaultTax"] as const,
                    name: "defaultTax",
                    constraints: { required: true },
                    
                    get: () => data.defaultTax,
                    set: (value: string | TaxRate) => { data.defaultTax = value; },
                    transform: (value: string | TaxRate): string | TaxRate => value,
                    getError: () => errors.defaultTax,
                    setError: (value: Option<Array<string>>) => { errors.defaultTax = value; },
                    getTainted: () => tainted.defaultTax,
                    setTainted: (value: Option<boolean>) => { tainted.defaultTax = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("defaultTax", data.defaultTax);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                defaultTaxLocation: {
                    path: ["defaultTaxLocation"] as const,
                    name: "defaultTaxLocation",
                    constraints: { required: true },
                    
                    get: () => data.defaultTaxLocation,
                    set: (value: string) => { data.defaultTaxLocation = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.defaultTaxLocation,
                    setError: (value: Option<Array<string>>) => { errors.defaultTaxLocation = value; },
                    getTainted: () => tainted.defaultTaxLocation,
                    setTainted: (value: Option<boolean>) => { tainted.defaultTaxLocation = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("defaultTaxLocation", data.defaultTaxLocation);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                defaultAreaCode: {
                    path: ["defaultAreaCode"] as const,
                    name: "defaultAreaCode",
                    constraints: { required: true },
                    
                    get: () => data.defaultAreaCode,
                    set: (value: number) => { data.defaultAreaCode = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.defaultAreaCode,
                    setError: (value: Option<Array<string>>) => { errors.defaultAreaCode = value; },
                    getTainted: () => tainted.defaultAreaCode,
                    setTainted: (value: Option<boolean>) => { tainted.defaultAreaCode = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("defaultAreaCode", data.defaultAreaCode);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                defaultAccountType: {
                    path: ["defaultAccountType"] as const,
                    name: "defaultAccountType",
                    constraints: { required: true },
                    
                    get: () => data.defaultAccountType,
                    set: (value: string) => { data.defaultAccountType = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.defaultAccountType,
                    setError: (value: Option<Array<string>>) => { errors.defaultAccountType = value; },
                    getTainted: () => tainted.defaultAccountType,
                    setTainted: (value: Option<boolean>) => { tainted.defaultAccountType = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("defaultAccountType", data.defaultAccountType);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                lookupFormatting: {
                    path: ["lookupFormatting"] as const,
                    name: "lookupFormatting",
                    constraints: { required: true },
                    
                    get: () => data.lookupFormatting,
                    set: (value: string) => { data.lookupFormatting = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.lookupFormatting,
                    setError: (value: Option<Array<string>>) => { errors.lookupFormatting = value; },
                    getTainted: () => tainted.lookupFormatting,
                    setTainted: (value: Option<boolean>) => { tainted.lookupFormatting = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("lookupFormatting", data.lookupFormatting);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                accountNameFormat: {
                    path: ["accountNameFormat"] as const,
                    name: "accountNameFormat",
                    constraints: { required: true },
                    
                    get: () => data.accountNameFormat,
                    set: (value: string) => { data.accountNameFormat = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.accountNameFormat,
                    setError: (value: Option<Array<string>>) => { errors.accountNameFormat = value; },
                    getTainted: () => tainted.accountNameFormat,
                    setTainted: (value: Option<boolean>) => { tainted.accountNameFormat = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("accountNameFormat", data.accountNameFormat);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                merchantServiceProvider: {
                    path: ["merchantServiceProvider"] as const,
                    name: "merchantServiceProvider",
                    constraints: { required: true },
                    
                    get: () => data.merchantServiceProvider,
                    set: (value: string | null) => { data.merchantServiceProvider = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.merchantServiceProvider,
                    setError: (value: Option<Array<string>>) => { errors.merchantServiceProvider = value; },
                    getTainted: () => tainted.merchantServiceProvider,
                    setTainted: (value: Option<boolean>) => { tainted.merchantServiceProvider = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("merchantServiceProvider", data.merchantServiceProvider);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                dateDisplayStyle: {
                    path: ["dateDisplayStyle"] as const,
                    name: "dateDisplayStyle",
                    constraints: { required: true },
                    
                    get: () => data.dateDisplayStyle,
                    set: (value: string) => { data.dateDisplayStyle = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.dateDisplayStyle,
                    setError: (value: Option<Array<string>>) => { errors.dateDisplayStyle = value; },
                    getTainted: () => tainted.dateDisplayStyle,
                    setTainted: (value: Option<boolean>) => { tainted.dateDisplayStyle = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("dateDisplayStyle", data.dateDisplayStyle);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                hasAutoCommission: {
                    path: ["hasAutoCommission"] as const,
                    name: "hasAutoCommission",
                    constraints: { required: true },
                    
                    get: () => data.hasAutoCommission,
                    set: (value: boolean) => { data.hasAutoCommission = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.hasAutoCommission,
                    setError: (value: Option<Array<string>>) => { errors.hasAutoCommission = value; },
                    getTainted: () => tainted.hasAutoCommission,
                    setTainted: (value: Option<boolean>) => { tainted.hasAutoCommission = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("hasAutoCommission", data.hasAutoCommission);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                hasAutoDaylightSavings: {
                    path: ["hasAutoDaylightSavings"] as const,
                    name: "hasAutoDaylightSavings",
                    constraints: { required: true },
                    
                    get: () => data.hasAutoDaylightSavings,
                    set: (value: boolean) => { data.hasAutoDaylightSavings = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.hasAutoDaylightSavings,
                    setError: (value: Option<Array<string>>) => { errors.hasAutoDaylightSavings = value; },
                    getTainted: () => tainted.hasAutoDaylightSavings,
                    setTainted: (value: Option<boolean>) => { tainted.hasAutoDaylightSavings = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("hasAutoDaylightSavings", data.hasAutoDaylightSavings);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                hasAutoFmsTracking: {
                    path: ["hasAutoFmsTracking"] as const,
                    name: "hasAutoFmsTracking",
                    constraints: { required: true },
                    
                    get: () => data.hasAutoFmsTracking,
                    set: (value: boolean) => { data.hasAutoFmsTracking = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.hasAutoFmsTracking,
                    setError: (value: Option<Array<string>>) => { errors.hasAutoFmsTracking = value; },
                    getTainted: () => tainted.hasAutoFmsTracking,
                    setTainted: (value: Option<boolean>) => { tainted.hasAutoFmsTracking = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("hasAutoFmsTracking", data.hasAutoFmsTracking);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                hasNotifications: {
                    path: ["hasNotifications"] as const,
                    name: "hasNotifications",
                    constraints: { required: true },
                    
                    get: () => data.hasNotifications,
                    set: (value: boolean) => { data.hasNotifications = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.hasNotifications,
                    setError: (value: Option<Array<string>>) => { errors.hasNotifications = value; },
                    getTainted: () => tainted.hasNotifications,
                    setTainted: (value: Option<boolean>) => { tainted.hasNotifications = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("hasNotifications", data.hasNotifications);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                hasRequiredLeadSource: {
                    path: ["hasRequiredLeadSource"] as const,
                    name: "hasRequiredLeadSource",
                    constraints: { required: true },
                    
                    get: () => data.hasRequiredLeadSource,
                    set: (value: boolean) => { data.hasRequiredLeadSource = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.hasRequiredLeadSource,
                    setError: (value: Option<Array<string>>) => { errors.hasRequiredLeadSource = value; },
                    getTainted: () => tainted.hasRequiredLeadSource,
                    setTainted: (value: Option<boolean>) => { tainted.hasRequiredLeadSource = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("hasRequiredLeadSource", data.hasRequiredLeadSource);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                hasRequiredEmail: {
                    path: ["hasRequiredEmail"] as const,
                    name: "hasRequiredEmail",
                    constraints: { required: true },
                    
                    get: () => data.hasRequiredEmail,
                    set: (value: boolean) => { data.hasRequiredEmail = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.hasRequiredEmail,
                    setError: (value: Option<Array<string>>) => { errors.hasRequiredEmail = value; },
                    getTainted: () => tainted.hasRequiredEmail,
                    setTainted: (value: Option<boolean>) => { tainted.hasRequiredEmail = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("hasRequiredEmail", data.hasRequiredEmail);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                hasSortServiceItemsAlphabetically: {
                    path: ["hasSortServiceItemsAlphabetically"] as const,
                    name: "hasSortServiceItemsAlphabetically",
                    constraints: { required: true },
                    
                    get: () => data.hasSortServiceItemsAlphabetically,
                    set: (value: boolean) => { data.hasSortServiceItemsAlphabetically = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.hasSortServiceItemsAlphabetically,
                    setError: (value: Option<Array<string>>) => { errors.hasSortServiceItemsAlphabetically = value; },
                    getTainted: () => tainted.hasSortServiceItemsAlphabetically,
                    setTainted: (value: Option<boolean>) => { tainted.hasSortServiceItemsAlphabetically = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("hasSortServiceItemsAlphabetically", data.hasSortServiceItemsAlphabetically);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                hasAttachOrderToAppointmentEmails: {
                    path: ["hasAttachOrderToAppointmentEmails"] as const,
                    name: "hasAttachOrderToAppointmentEmails",
                    constraints: { required: true },
                    
                    get: () => data.hasAttachOrderToAppointmentEmails,
                    set: (value: boolean) => { data.hasAttachOrderToAppointmentEmails = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.hasAttachOrderToAppointmentEmails,
                    setError: (value: Option<Array<string>>) => { errors.hasAttachOrderToAppointmentEmails = value; },
                    getTainted: () => tainted.hasAttachOrderToAppointmentEmails,
                    setTainted: (value: Option<boolean>) => { tainted.hasAttachOrderToAppointmentEmails = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("hasAttachOrderToAppointmentEmails", data.hasAttachOrderToAppointmentEmails);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                scheduleInterval: {
                    path: ["scheduleInterval"] as const,
                    name: "scheduleInterval",
                    constraints: { required: true },
                    
                    get: () => data.scheduleInterval,
                    set: (value: number) => { data.scheduleInterval = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.scheduleInterval,
                    setError: (value: Option<Array<string>>) => { errors.scheduleInterval = value; },
                    getTainted: () => tainted.scheduleInterval,
                    setTainted: (value: Option<boolean>) => { tainted.scheduleInterval = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("scheduleInterval", data.scheduleInterval);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                colorsConfig: {
                    path: ["colorsConfig"] as const,
                    name: "colorsConfig",
                    constraints: { required: true },
                    
                    get: () => data.colorsConfig,
                    set: (value: ColorsConfig) => { data.colorsConfig = value; },
                    transform: (value: ColorsConfig): ColorsConfig => value,
                    getError: () => errors.colorsConfig,
                    setError: (value: Option<Array<string>>) => { errors.colorsConfig = value; },
                    getTainted: () => tainted.colorsConfig,
                    setTainted: (value: Option<boolean>) => { tainted.colorsConfig = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCompany("colorsConfig", data.colorsConfig);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Company, Array<{field: string; message: string}>>{return fromObjectCompany(data);}function reset(newOverrides?: Partial<Company>): void {data = {...defaultValueCompany(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), legalName: Option.none(), headquarters: Option.none(), phones: Option.none(), fax: Option.none(), email: Option.none(), website: Option.none(), taxId: Option.none(), referenceNumber: Option.none(), postalCodeLookup: Option.none(), timeZone: Option.none(), defaultTax: Option.none(), defaultTaxLocation: Option.none(), defaultAreaCode: Option.none(), defaultAccountType: Option.none(), lookupFormatting: Option.none(), accountNameFormat: Option.none(), merchantServiceProvider: Option.none(), dateDisplayStyle: Option.none(), hasAutoCommission: Option.none(), hasAutoDaylightSavings: Option.none(), hasAutoFmsTracking: Option.none(), hasNotifications: Option.none(), hasRequiredLeadSource: Option.none(), hasRequiredEmail: Option.none(), hasSortServiceItemsAlphabetically: Option.none(), hasAttachOrderToAppointmentEmails: Option.none(), scheduleInterval: Option.none(), colorsConfig: Option.none() }; tainted = { id: Option.none(), legalName: Option.none(), headquarters: Option.none(), phones: Option.none(), fax: Option.none(), email: Option.none(), website: Option.none(), taxId: Option.none(), referenceNumber: Option.none(), postalCodeLookup: Option.none(), timeZone: Option.none(), defaultTax: Option.none(), defaultTaxLocation: Option.none(), defaultAreaCode: Option.none(), defaultAccountType: Option.none(), lookupFormatting: Option.none(), accountNameFormat: Option.none(), merchantServiceProvider: Option.none(), dateDisplayStyle: Option.none(), hasAutoCommission: Option.none(), hasAutoDaylightSavings: Option.none(), hasAutoFmsTracking: Option.none(), hasNotifications: Option.none(), hasRequiredLeadSource: Option.none(), hasRequiredEmail: Option.none(), hasSortServiceItemsAlphabetically: Option.none(), hasAttachOrderToAppointmentEmails: Option.none(), scheduleInterval: Option.none(), colorsConfig: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataCompany(formData: FormData): Result<Company, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.legalName = formData.get("legalName") ?? "";
            obj.headquarters = formData.get("headquarters") ?? "";
            {
                // Collect array items from indexed form fields
                const phonesItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("phones." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("phones." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("phones." + idx + ".")) {
                                const fieldName = key.slice("phones.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        phonesItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.phones = phonesItems;
            }
            obj.fax = formData.get("fax") ?? "";
            obj.email = formData.get("email") ?? "";
            obj.website = formData.get("website") ?? "";
            obj.taxId = formData.get("taxId") ?? "";
            {
                const referenceNumberStr = formData.get("referenceNumber");
                obj.referenceNumber = referenceNumberStr ? parseFloat(referenceNumberStr as string) : 0;
                if (obj.referenceNumber !== undefined && isNaN(obj.referenceNumber as number)) obj.referenceNumber = 0;
            }
            obj.postalCodeLookup = formData.get("postalCodeLookup") ?? "";
            obj.timeZone = formData.get("timeZone") ?? "";
            obj.defaultTax = formData.get("defaultTax") ?? "";
            obj.defaultTaxLocation = formData.get("defaultTaxLocation") ?? "";
            {
                const defaultAreaCodeStr = formData.get("defaultAreaCode");
                obj.defaultAreaCode = defaultAreaCodeStr ? parseFloat(defaultAreaCodeStr as string) : 0;
                if (obj.defaultAreaCode !== undefined && isNaN(obj.defaultAreaCode as number)) obj.defaultAreaCode = 0;
            }
            obj.defaultAccountType = formData.get("defaultAccountType") ?? "";
            obj.lookupFormatting = formData.get("lookupFormatting") ?? "";
            obj.accountNameFormat = formData.get("accountNameFormat") ?? "";
            obj.merchantServiceProvider = formData.get("merchantServiceProvider") ?? "";
            obj.dateDisplayStyle = formData.get("dateDisplayStyle") ?? "";
            {
                const hasAutoCommissionVal = formData.get("hasAutoCommission");
                obj.hasAutoCommission = hasAutoCommissionVal === "true" || hasAutoCommissionVal === "on" || hasAutoCommissionVal === "1";
            }
            {
                const hasAutoDaylightSavingsVal = formData.get("hasAutoDaylightSavings");
                obj.hasAutoDaylightSavings = hasAutoDaylightSavingsVal === "true" || hasAutoDaylightSavingsVal === "on" || hasAutoDaylightSavingsVal === "1";
            }
            {
                const hasAutoFmsTrackingVal = formData.get("hasAutoFmsTracking");
                obj.hasAutoFmsTracking = hasAutoFmsTrackingVal === "true" || hasAutoFmsTrackingVal === "on" || hasAutoFmsTrackingVal === "1";
            }
            {
                const hasNotificationsVal = formData.get("hasNotifications");
                obj.hasNotifications = hasNotificationsVal === "true" || hasNotificationsVal === "on" || hasNotificationsVal === "1";
            }
            {
                const hasRequiredLeadSourceVal = formData.get("hasRequiredLeadSource");
                obj.hasRequiredLeadSource = hasRequiredLeadSourceVal === "true" || hasRequiredLeadSourceVal === "on" || hasRequiredLeadSourceVal === "1";
            }
            {
                const hasRequiredEmailVal = formData.get("hasRequiredEmail");
                obj.hasRequiredEmail = hasRequiredEmailVal === "true" || hasRequiredEmailVal === "on" || hasRequiredEmailVal === "1";
            }
            {
                const hasSortServiceItemsAlphabeticallyVal = formData.get("hasSortServiceItemsAlphabetically");
                obj.hasSortServiceItemsAlphabetically = hasSortServiceItemsAlphabeticallyVal === "true" || hasSortServiceItemsAlphabeticallyVal === "on" || hasSortServiceItemsAlphabeticallyVal === "1";
            }
            {
                const hasAttachOrderToAppointmentEmailsVal = formData.get("hasAttachOrderToAppointmentEmails");
                obj.hasAttachOrderToAppointmentEmails = hasAttachOrderToAppointmentEmailsVal === "true" || hasAttachOrderToAppointmentEmailsVal === "on" || hasAttachOrderToAppointmentEmailsVal === "1";
            }
            {
                const scheduleIntervalStr = formData.get("scheduleInterval");
                obj.scheduleInterval = scheduleIntervalStr ? parseFloat(scheduleIntervalStr as string) : 0;
                if (obj.scheduleInterval !== undefined && isNaN(obj.scheduleInterval as number)) obj.scheduleInterval = 0;
            }
            {
            // Collect nested object fields with prefix "colorsConfig."
            const colorsConfigObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("colorsConfig.")) {
                    const fieldName = key.slice("colorsConfig.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = colorsConfigObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.colorsConfig = colorsConfigObj;
        } return fromStringifiedJSONCompany(JSON.stringify(obj));}


export interface Ordinal {
    north: number;
    northeast: number;
    east: number;
    southeast: number;
    south: number;
    southwest: number;
    west: number;
    northwest: number;
}

export function defaultValueOrdinal(): Ordinal {return {north: 0,
                            northeast: 0,
                            east: 0,
                            southeast: 0,
                            south: 0,
                            southwest: 0,
                            west: 0,
                            northwest: 0, }as Ordinal;}

export function toStringifiedJSONOrdinal(value: Ordinal): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeOrdinal(value, ctx));}export function toObjectOrdinal(value: Ordinal): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeOrdinal(value, ctx);}export function __serializeOrdinal(value: Ordinal, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Ordinal" , __id,}; result["north" ]= value.north; result["northeast" ]= value.northeast; result["east" ]= value.east; result["southeast" ]= value.southeast; result["south" ]= value.south; result["southwest" ]= value.southwest; result["west" ]= value.west; result["northwest" ]= value.northwest; return result;}

export function fromStringifiedJSONOrdinal(json: string, opts?: DeserializeOptions): Result<Ordinal, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectOrdinal(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectOrdinal(obj: unknown, opts?: DeserializeOptions): Result<Ordinal, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeOrdinal(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Ordinal.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeOrdinal(value: any, ctx: DeserializeContext): Ordinal | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Ordinal.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("north" in obj)){errors.push({field: "north" , message: "missing required field" });}if(!("northeast" in obj)){errors.push({field: "northeast" , message: "missing required field" });}if(!("east" in obj)){errors.push({field: "east" , message: "missing required field" });}if(!("southeast" in obj)){errors.push({field: "southeast" , message: "missing required field" });}if(!("south" in obj)){errors.push({field: "south" , message: "missing required field" });}if(!("southwest" in obj)){errors.push({field: "southwest" , message: "missing required field" });}if(!("west" in obj)){errors.push({field: "west" , message: "missing required field" });}if(!("northwest" in obj)){errors.push({field: "northwest" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_north = obj["north" ]as number; instance.north = __raw_north; }{const __raw_northeast = obj["northeast" ]as number; instance.northeast = __raw_northeast; }{const __raw_east = obj["east" ]as number; instance.east = __raw_east; }{const __raw_southeast = obj["southeast" ]as number; instance.southeast = __raw_southeast; }{const __raw_south = obj["south" ]as number; instance.south = __raw_south; }{const __raw_southwest = obj["southwest" ]as number; instance.southwest = __raw_southwest; }{const __raw_west = obj["west" ]as number; instance.west = __raw_west; }{const __raw_northwest = obj["northwest" ]as number; instance.northwest = __raw_northwest; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Ordinal;}export function validateFieldOrdinal<K extends keyof Ordinal>(field: K, value: Ordinal[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsOrdinal(partial: Partial<Ordinal>): Array<{field: string; message: string}>{return[]; }export function hasShapeOrdinal(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "north" in o && "northeast" in o && "east" in o && "southeast" in o && "south" in o && "southwest" in o && "west" in o && "northwest" in o;}export function isOrdinal(obj: unknown): obj is Ordinal {if(!hasShapeOrdinal(obj)){return false;}const result = fromObjectOrdinal(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsOrdinal = {_errors: Option<Array<string>>; north: Option<Array<string>>;
            northeast: Option<Array<string>>;
            east: Option<Array<string>>;
            southeast: Option<Array<string>>;
            south: Option<Array<string>>;
            southwest: Option<Array<string>>;
            west: Option<Array<string>>;
            northwest: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedOrdinal = {north: Option<boolean>;
            northeast: Option<boolean>;
            east: Option<boolean>;
            southeast: Option<boolean>;
            south: Option<boolean>;
            southwest: Option<boolean>;
            west: Option<boolean>;
            northwest: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersOrdinal {readonly north: FieldController<number>;
            readonly northeast: FieldController<number>;
            readonly east: FieldController<number>;
            readonly southeast: FieldController<number>;
            readonly south: FieldController<number>;
            readonly southwest: FieldController<number>;
            readonly west: FieldController<number>;
            readonly northwest: FieldController<number>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformOrdinal {readonly data: Ordinal; readonly errors: ErrorsOrdinal; readonly tainted: TaintedOrdinal; readonly fields: FieldControllersOrdinal; validate(): Result<Ordinal, Array<{field: string; message: string}>>; reset(overrides?: Partial<Ordinal>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormOrdinal(overrides?: Partial<Ordinal>): GigaformOrdinal {let data = $state({...defaultValueOrdinal(),...overrides}); let errors = $state<ErrorsOrdinal>({ _errors: Option.none(), north: Option.none(), northeast: Option.none(), east: Option.none(), southeast: Option.none(), south: Option.none(), southwest: Option.none(), west: Option.none(), northwest: Option.none() }); let tainted = $state<TaintedOrdinal>({ north: Option.none(), northeast: Option.none(), east: Option.none(), southeast: Option.none(), south: Option.none(), southwest: Option.none(), west: Option.none(), northwest: Option.none() }); const fields: FieldControllersOrdinal = {north: {
                    path: ["north"] as const,
                    name: "north",
                    constraints: { required: true },
                    
                    get: () => data.north,
                    set: (value: number) => { data.north = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.north,
                    setError: (value: Option<Array<string>>) => { errors.north = value; },
                    getTainted: () => tainted.north,
                    setTainted: (value: Option<boolean>) => { tainted.north = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrdinal("north", data.north);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                northeast: {
                    path: ["northeast"] as const,
                    name: "northeast",
                    constraints: { required: true },
                    
                    get: () => data.northeast,
                    set: (value: number) => { data.northeast = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.northeast,
                    setError: (value: Option<Array<string>>) => { errors.northeast = value; },
                    getTainted: () => tainted.northeast,
                    setTainted: (value: Option<boolean>) => { tainted.northeast = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrdinal("northeast", data.northeast);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                east: {
                    path: ["east"] as const,
                    name: "east",
                    constraints: { required: true },
                    
                    get: () => data.east,
                    set: (value: number) => { data.east = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.east,
                    setError: (value: Option<Array<string>>) => { errors.east = value; },
                    getTainted: () => tainted.east,
                    setTainted: (value: Option<boolean>) => { tainted.east = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrdinal("east", data.east);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                southeast: {
                    path: ["southeast"] as const,
                    name: "southeast",
                    constraints: { required: true },
                    
                    get: () => data.southeast,
                    set: (value: number) => { data.southeast = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.southeast,
                    setError: (value: Option<Array<string>>) => { errors.southeast = value; },
                    getTainted: () => tainted.southeast,
                    setTainted: (value: Option<boolean>) => { tainted.southeast = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrdinal("southeast", data.southeast);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                south: {
                    path: ["south"] as const,
                    name: "south",
                    constraints: { required: true },
                    
                    get: () => data.south,
                    set: (value: number) => { data.south = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.south,
                    setError: (value: Option<Array<string>>) => { errors.south = value; },
                    getTainted: () => tainted.south,
                    setTainted: (value: Option<boolean>) => { tainted.south = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrdinal("south", data.south);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                southwest: {
                    path: ["southwest"] as const,
                    name: "southwest",
                    constraints: { required: true },
                    
                    get: () => data.southwest,
                    set: (value: number) => { data.southwest = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.southwest,
                    setError: (value: Option<Array<string>>) => { errors.southwest = value; },
                    getTainted: () => tainted.southwest,
                    setTainted: (value: Option<boolean>) => { tainted.southwest = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrdinal("southwest", data.southwest);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                west: {
                    path: ["west"] as const,
                    name: "west",
                    constraints: { required: true },
                    
                    get: () => data.west,
                    set: (value: number) => { data.west = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.west,
                    setError: (value: Option<Array<string>>) => { errors.west = value; },
                    getTainted: () => tainted.west,
                    setTainted: (value: Option<boolean>) => { tainted.west = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrdinal("west", data.west);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                northwest: {
                    path: ["northwest"] as const,
                    name: "northwest",
                    constraints: { required: true },
                    
                    get: () => data.northwest,
                    set: (value: number) => { data.northwest = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.northwest,
                    setError: (value: Option<Array<string>>) => { errors.northwest = value; },
                    getTainted: () => tainted.northwest,
                    setTainted: (value: Option<boolean>) => { tainted.northwest = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrdinal("northwest", data.northwest);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Ordinal, Array<{field: string; message: string}>>{return fromObjectOrdinal(data);}function reset(newOverrides?: Partial<Ordinal>): void {data = {...defaultValueOrdinal(),...newOverrides}; errors = { _errors: Option.none(), north: Option.none(), northeast: Option.none(), east: Option.none(), southeast: Option.none(), south: Option.none(), southwest: Option.none(), west: Option.none(), northwest: Option.none() }; tainted = { north: Option.none(), northeast: Option.none(), east: Option.none(), southeast: Option.none(), south: Option.none(), southwest: Option.none(), west: Option.none(), northwest: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataOrdinal(formData: FormData): Result<Ordinal, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const northStr = formData.get("north");
                obj.north = northStr ? parseFloat(northStr as string) : 0;
                if (obj.north !== undefined && isNaN(obj.north as number)) obj.north = 0;
            }
            {
                const northeastStr = formData.get("northeast");
                obj.northeast = northeastStr ? parseFloat(northeastStr as string) : 0;
                if (obj.northeast !== undefined && isNaN(obj.northeast as number)) obj.northeast = 0;
            }
            {
                const eastStr = formData.get("east");
                obj.east = eastStr ? parseFloat(eastStr as string) : 0;
                if (obj.east !== undefined && isNaN(obj.east as number)) obj.east = 0;
            }
            {
                const southeastStr = formData.get("southeast");
                obj.southeast = southeastStr ? parseFloat(southeastStr as string) : 0;
                if (obj.southeast !== undefined && isNaN(obj.southeast as number)) obj.southeast = 0;
            }
            {
                const southStr = formData.get("south");
                obj.south = southStr ? parseFloat(southStr as string) : 0;
                if (obj.south !== undefined && isNaN(obj.south as number)) obj.south = 0;
            }
            {
                const southwestStr = formData.get("southwest");
                obj.southwest = southwestStr ? parseFloat(southwestStr as string) : 0;
                if (obj.southwest !== undefined && isNaN(obj.southwest as number)) obj.southwest = 0;
            }
            {
                const westStr = formData.get("west");
                obj.west = westStr ? parseFloat(westStr as string) : 0;
                if (obj.west !== undefined && isNaN(obj.west as number)) obj.west = 0;
            }
            {
                const northwestStr = formData.get("northwest");
                obj.northwest = northwestStr ? parseFloat(northwestStr as string) : 0;
                if (obj.northwest !== undefined && isNaN(obj.northwest as number)) obj.northwest = 0;
            } return fromStringifiedJSONOrdinal(JSON.stringify(obj));}


export interface Password {
    
    password: string;
}

export function defaultValuePassword(): Password {return {password: "", }as Password;}

export function toStringifiedJSONPassword(value: Password): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializePassword(value, ctx));}export function toObjectPassword(value: Password): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializePassword(value, ctx);}export function __serializePassword(value: Password, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Password" , __id,}; result["password" ]= value.password; return result;}

export function fromStringifiedJSONPassword(json: string, opts?: DeserializeOptions): Result<Password, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectPassword(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectPassword(obj: unknown, opts?: DeserializeOptions): Result<Password, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializePassword(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Password.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializePassword(value: any, ctx: DeserializeContext): Password | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Password.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("password" in obj)){errors.push({field: "password" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_password = obj["password" ]as string; 
                if (__raw_password.length === 0) {
                    errors.push({ field: "password", message: "must not be empty" });
                }
 instance.password = __raw_password; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Password;}export function validateFieldPassword<K extends keyof Password>(field: K, value: Password[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "password" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "password", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsPassword(partial: Partial<Password>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("password" in partial && partial.password!== undefined){const __val = partial.password as string; 
                if (__val.length === 0) {
                    errors.push({ field: "password", message: "must not be empty" });
                }
}return errors; }export function hasShapePassword(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "password" in o;}export function isPassword(obj: unknown): obj is Password {if(!hasShapePassword(obj)){return false;}const result = fromObjectPassword(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsPassword = {_errors: Option<Array<string>>; password: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedPassword = {password: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersPassword {readonly password: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformPassword {readonly data: Password; readonly errors: ErrorsPassword; readonly tainted: TaintedPassword; readonly fields: FieldControllersPassword; validate(): Result<Password, Array<{field: string; message: string}>>; reset(overrides?: Partial<Password>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormPassword(overrides?: Partial<Password>): GigaformPassword {let data = $state({...defaultValuePassword(),...overrides}); let errors = $state<ErrorsPassword>({ _errors: Option.none(), password: Option.none() }); let tainted = $state<TaintedPassword>({ password: Option.none() }); const fields: FieldControllersPassword = {password: {
                    path: ["password"] as const,
                    name: "password",
                    constraints: { required: true },
                    
                    get: () => data.password,
                    set: (value: string) => { data.password = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.password,
                    setError: (value: Option<Array<string>>) => { errors.password = value; },
                    getTainted: () => tainted.password,
                    setTainted: (value: Option<boolean>) => { tainted.password = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldPassword("password", data.password);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Password, Array<{field: string; message: string}>>{return fromObjectPassword(data);}function reset(newOverrides?: Partial<Password>): void {data = {...defaultValuePassword(),...newOverrides}; errors = { _errors: Option.none(), password: Option.none() }; tainted = { password: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataPassword(formData: FormData): Result<Password, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.password = formData.get("password") ?? ""; return fromStringifiedJSONPassword(JSON.stringify(obj));}


export interface Created {
    initialData: string | null;
}

export function defaultValueCreated(): Created {return {initialData: null, }as Created;}

export function toStringifiedJSONCreated(value: Created): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeCreated(value, ctx));}export function toObjectCreated(value: Created): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeCreated(value, ctx);}export function __serializeCreated(value: Created, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Created" , __id,}; result["initialData" ]= value.initialData; return result;}

export function fromStringifiedJSONCreated(json: string, opts?: DeserializeOptions): Result<Created, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectCreated(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectCreated(obj: unknown, opts?: DeserializeOptions): Result<Created, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeCreated(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Created.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeCreated(value: any, ctx: DeserializeContext): Created | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Created.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("initialData" in obj)){errors.push({field: "initialData" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_initialData = obj["initialData" ]as string | null; instance.initialData = __raw_initialData; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Created;}export function validateFieldCreated<K extends keyof Created>(field: K, value: Created[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsCreated(partial: Partial<Created>): Array<{field: string; message: string}>{return[]; }export function hasShapeCreated(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "initialData" in o;}export function isCreated(obj: unknown): obj is Created {if(!hasShapeCreated(obj)){return false;}const result = fromObjectCreated(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsCreated = {_errors: Option<Array<string>>; initialData: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedCreated = {initialData: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersCreated {readonly initialData: FieldController<string | null>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformCreated {readonly data: Created; readonly errors: ErrorsCreated; readonly tainted: TaintedCreated; readonly fields: FieldControllersCreated; validate(): Result<Created, Array<{field: string; message: string}>>; reset(overrides?: Partial<Created>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormCreated(overrides?: Partial<Created>): GigaformCreated {let data = $state({...defaultValueCreated(),...overrides}); let errors = $state<ErrorsCreated>({ _errors: Option.none(), initialData: Option.none() }); let tainted = $state<TaintedCreated>({ initialData: Option.none() }); const fields: FieldControllersCreated = {initialData: {
                    path: ["initialData"] as const,
                    name: "initialData",
                    constraints: { required: true },
                    
                    get: () => data.initialData,
                    set: (value: string | null) => { data.initialData = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.initialData,
                    setError: (value: Option<Array<string>>) => { errors.initialData = value; },
                    getTainted: () => tainted.initialData,
                    setTainted: (value: Option<boolean>) => { tainted.initialData = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCreated("initialData", data.initialData);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Created, Array<{field: string; message: string}>>{return fromObjectCreated(data);}function reset(newOverrides?: Partial<Created>): void {data = {...defaultValueCreated(),...newOverrides}; errors = { _errors: Option.none(), initialData: Option.none() }; tainted = { initialData: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataCreated(formData: FormData): Result<Created, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.initialData = formData.get("initialData") ?? ""; return fromStringifiedJSONCreated(JSON.stringify(obj));}


export interface Employee {
    id: string;
    imageUrl: string | null;
    
    name: string;
    phones: PhoneNumber[];
    
    role: string;
    
    title: JobTitle;
    email: Email;
    
    address: string;
    
    username: string;
    
    route: string | Route;
    ratePerHour: number;
    active: boolean;
    isTechnician: boolean;
    isSalesRep: boolean;
    description: string | null;
    linkedinUrl: string | null;
    attendance: string[];
    settings: Settings;
}

export function defaultValueEmployee(): Employee {return {id: "",
                            imageUrl: null,
                            name: "",
                            phones: [],
                            role: "",
                            title: "Technician",
                            email: defaultValueEmail(),
                            address: "",
                            username: "",
                            route: "",
                            ratePerHour: 0,
                            active: false,
                            isTechnician: false,
                            isSalesRep: false,
                            description: null,
                            linkedinUrl: null,
                            attendance: [],
                            settings: defaultValueSettings(), }as Employee;}

export function toStringifiedJSONEmployee(value: Employee): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeEmployee(value, ctx));}export function toObjectEmployee(value: Employee): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeEmployee(value, ctx);}export function __serializeEmployee(value: Employee, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Employee" , __id,}; result["id" ]= value.id; result["imageUrl" ]= value.imageUrl; result["name" ]= value.name; result["phones" ]= value.phones.map((item)=>__serializePhoneNumber(item, ctx)); result["role" ]= value.role; result["title" ]= __serializeJobTitle(value.title, ctx); result["email" ]= __serializeEmail(value.email, ctx); result["address" ]= value.address; result["username" ]= value.username; result["route" ]= value.route; result["ratePerHour" ]= value.ratePerHour; result["active" ]= value.active; result["isTechnician" ]= value.isTechnician; result["isSalesRep" ]= value.isSalesRep; result["description" ]= value.description; result["linkedinUrl" ]= value.linkedinUrl; result["attendance" ]= value.attendance; result["settings" ]= __serializeSettings(value.settings, ctx); return result;}

export function fromStringifiedJSONEmployee(json: string, opts?: DeserializeOptions): Result<Employee, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectEmployee(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectEmployee(obj: unknown, opts?: DeserializeOptions): Result<Employee, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeEmployee(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Employee.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeEmployee(value: any, ctx: DeserializeContext): Employee | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Employee.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("imageUrl" in obj)){errors.push({field: "imageUrl" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("phones" in obj)){errors.push({field: "phones" , message: "missing required field" });}if(!("role" in obj)){errors.push({field: "role" , message: "missing required field" });}if(!("title" in obj)){errors.push({field: "title" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("address" in obj)){errors.push({field: "address" , message: "missing required field" });}if(!("username" in obj)){errors.push({field: "username" , message: "missing required field" });}if(!("route" in obj)){errors.push({field: "route" , message: "missing required field" });}if(!("ratePerHour" in obj)){errors.push({field: "ratePerHour" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(!("isTechnician" in obj)){errors.push({field: "isTechnician" , message: "missing required field" });}if(!("isSalesRep" in obj)){errors.push({field: "isSalesRep" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(!("linkedinUrl" in obj)){errors.push({field: "linkedinUrl" , message: "missing required field" });}if(!("attendance" in obj)){errors.push({field: "attendance" , message: "missing required field" });}if(!("settings" in obj)){errors.push({field: "settings" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_imageUrl = obj["imageUrl" ]as string | null; instance.imageUrl = __raw_imageUrl; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_phones = obj["phones" ]as PhoneNumber[]; if(Array.isArray(__raw_phones)){instance.phones = __raw_phones as PhoneNumber[];}}{const __raw_role = obj["role" ]as string; 
                if (__raw_role.length === 0) {
                    errors.push({ field: "role", message: "must not be empty" });
                }
 instance.role = __raw_role; }{const __raw_title = obj["title" ]as JobTitle; {const __result = __deserializeJobTitle(__raw_title, ctx); ctx.assignOrDefer(instance, "title" , __result);}}{const __raw_email = obj["email" ]as Email; {const __result = __deserializeEmail(__raw_email, ctx); ctx.assignOrDefer(instance, "email" , __result);}}{const __raw_address = obj["address" ]as string; 
                if (__raw_address.length === 0) {
                    errors.push({ field: "address", message: "must not be empty" });
                }
 instance.address = __raw_address; }{const __raw_username = obj["username" ]as string; 
                if (__raw_username.length === 0) {
                    errors.push({ field: "username", message: "must not be empty" });
                }
 instance.username = __raw_username; }{const __raw_route = obj["route" ]as string | Route; instance.route = __raw_route; }{const __raw_ratePerHour = obj["ratePerHour" ]as number; instance.ratePerHour = __raw_ratePerHour; }{const __raw_active = obj["active" ]as boolean; instance.active = __raw_active; }{const __raw_isTechnician = obj["isTechnician" ]as boolean; instance.isTechnician = __raw_isTechnician; }{const __raw_isSalesRep = obj["isSalesRep" ]as boolean; instance.isSalesRep = __raw_isSalesRep; }{const __raw_description = obj["description" ]as string | null; instance.description = __raw_description; }{const __raw_linkedinUrl = obj["linkedinUrl" ]as string | null; instance.linkedinUrl = __raw_linkedinUrl; }{const __raw_attendance = obj["attendance" ]as string[]; if(Array.isArray(__raw_attendance)){instance.attendance = __raw_attendance as string[];}}{const __raw_settings = obj["settings" ]as Settings; {const __result = __deserializeSettings(__raw_settings, ctx); ctx.assignOrDefer(instance, "settings" , __result);}}if(errors.length>0){throw new DeserializeError(errors);}return instance as Employee;}export function validateFieldEmployee<K extends keyof Employee>(field: K, value: Employee[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "role" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "role", message: "must not be empty" });
                }
 break;}case "address" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "address", message: "must not be empty" });
                }
 break;}case "username" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "username", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsEmployee(partial: Partial<Employee>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("role" in partial && partial.role!== undefined){const __val = partial.role as string; 
                if (__val.length === 0) {
                    errors.push({ field: "role", message: "must not be empty" });
                }
}if("address" in partial && partial.address!== undefined){const __val = partial.address as string; 
                if (__val.length === 0) {
                    errors.push({ field: "address", message: "must not be empty" });
                }
}if("username" in partial && partial.username!== undefined){const __val = partial.username as string; 
                if (__val.length === 0) {
                    errors.push({ field: "username", message: "must not be empty" });
                }
}return errors; }export function hasShapeEmployee(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "imageUrl" in o && "name" in o && "phones" in o && "role" in o && "title" in o && "email" in o && "address" in o && "username" in o && "route" in o && "ratePerHour" in o && "active" in o && "isTechnician" in o && "isSalesRep" in o && "description" in o && "linkedinUrl" in o && "attendance" in o && "settings" in o;}export function isEmployee(obj: unknown): obj is Employee {if(!hasShapeEmployee(obj)){return false;}const result = fromObjectEmployee(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsEmployee = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            imageUrl: Option<Array<string>>;
            name: Option<Array<string>>;
            phones: Option<Array<string>>;
            role: Option<Array<string>>;
            title: Option<Array<string>>;
            email: Option<Array<string>>;
            address: Option<Array<string>>;
            username: Option<Array<string>>;
            route: Option<Array<string>>;
            ratePerHour: Option<Array<string>>;
            active: Option<Array<string>>;
            isTechnician: Option<Array<string>>;
            isSalesRep: Option<Array<string>>;
            description: Option<Array<string>>;
            linkedinUrl: Option<Array<string>>;
            attendance: Option<Array<string>>;
            settings: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedEmployee = {id: Option<boolean>;
            imageUrl: Option<boolean>;
            name: Option<boolean>;
            phones: Option<boolean>;
            role: Option<boolean>;
            title: Option<boolean>;
            email: Option<boolean>;
            address: Option<boolean>;
            username: Option<boolean>;
            route: Option<boolean>;
            ratePerHour: Option<boolean>;
            active: Option<boolean>;
            isTechnician: Option<boolean>;
            isSalesRep: Option<boolean>;
            description: Option<boolean>;
            linkedinUrl: Option<boolean>;
            attendance: Option<boolean>;
            settings: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersEmployee {readonly id: FieldController<string>;
            readonly imageUrl: FieldController<string | null>;
            readonly name: FieldController<string>;
            readonly phones: ArrayFieldController<PhoneNumber>;
            readonly role: FieldController<string>;
            readonly title: FieldController<JobTitle>;
            readonly email: FieldController<Email>;
            readonly address: FieldController<string>;
            readonly username: FieldController<string>;
            readonly route: FieldController<string | Route>;
            readonly ratePerHour: FieldController<number>;
            readonly active: FieldController<boolean>;
            readonly isTechnician: FieldController<boolean>;
            readonly isSalesRep: FieldController<boolean>;
            readonly description: FieldController<string | null>;
            readonly linkedinUrl: FieldController<string | null>;
            readonly attendance: ArrayFieldController<string>;
            readonly settings: FieldController<Settings>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformEmployee {readonly data: Employee; readonly errors: ErrorsEmployee; readonly tainted: TaintedEmployee; readonly fields: FieldControllersEmployee; validate(): Result<Employee, Array<{field: string; message: string}>>; reset(overrides?: Partial<Employee>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormEmployee(overrides?: Partial<Employee>): GigaformEmployee {let data = $state({...defaultValueEmployee(),...overrides}); let errors = $state<ErrorsEmployee>({ _errors: Option.none(), id: Option.none(), imageUrl: Option.none(), name: Option.none(), phones: Option.none(), role: Option.none(), title: Option.none(), email: Option.none(), address: Option.none(), username: Option.none(), route: Option.none(), ratePerHour: Option.none(), active: Option.none(), isTechnician: Option.none(), isSalesRep: Option.none(), description: Option.none(), linkedinUrl: Option.none(), attendance: Option.none(), settings: Option.none() }); let tainted = $state<TaintedEmployee>({ id: Option.none(), imageUrl: Option.none(), name: Option.none(), phones: Option.none(), role: Option.none(), title: Option.none(), email: Option.none(), address: Option.none(), username: Option.none(), route: Option.none(), ratePerHour: Option.none(), active: Option.none(), isTechnician: Option.none(), isSalesRep: Option.none(), description: Option.none(), linkedinUrl: Option.none(), attendance: Option.none(), settings: Option.none() }); const fields: FieldControllersEmployee = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                imageUrl: {
                    path: ["imageUrl"] as const,
                    name: "imageUrl",
                    constraints: { required: true },
                    
                    get: () => data.imageUrl,
                    set: (value: string | null) => { data.imageUrl = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.imageUrl,
                    setError: (value: Option<Array<string>>) => { errors.imageUrl = value; },
                    getTainted: () => tainted.imageUrl,
                    setTainted: (value: Option<boolean>) => { tainted.imageUrl = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("imageUrl", data.imageUrl);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                name: {
                    path: ["name"] as const,
                    name: "name",
                    constraints: { required: true },
                    
                    get: () => data.name,
                    set: (value: string) => { data.name = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.name,
                    setError: (value: Option<Array<string>>) => { errors.name = value; },
                    getTainted: () => tainted.name,
                    setTainted: (value: Option<boolean>) => { tainted.name = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("name", data.name);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                phones: {
                    path: ["phones"] as const,
                    name: "phones",
                    constraints: { required: true },
                    
                    get: () => data.phones,
                    set: (value: PhoneNumber[]) => { data.phones = value; },
                    transform: (value: PhoneNumber[]): PhoneNumber[] => value,
                    getError: () => errors.phones,
                    setError: (value: Option<Array<string>>) => { errors.phones = value; },
                    getTainted: () => tainted.phones,
                    setTainted: (value: Option<boolean>) => { tainted.phones = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("phones", data.phones);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["phones", index] as const,
                        name: `phones.${index}`,
                        constraints: { required: true },
                        get: () => data.phones[index]!,
                        set: (value: PhoneNumber) => { data.phones[index] = value; },
                        transform: (value: PhoneNumber): PhoneNumber => value,
                        getError: () => errors.phones,
                        setError: (value: Option<Array<string>>) => { errors.phones = value; },
                        getTainted: () => tainted.phones,
                        setTainted: (value: Option<boolean>) => { tainted.phones = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: PhoneNumber) => { data.phones.push(item); },
                    remove: (index: number) => { data.phones.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.phones[a]!;
                        data.phones[a] = data.phones[b]!;
                        data.phones[b] = tmp;
                    },
                },
                role: {
                    path: ["role"] as const,
                    name: "role",
                    constraints: { required: true },
                    
                    get: () => data.role,
                    set: (value: string) => { data.role = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.role,
                    setError: (value: Option<Array<string>>) => { errors.role = value; },
                    getTainted: () => tainted.role,
                    setTainted: (value: Option<boolean>) => { tainted.role = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("role", data.role);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                title: {
                    path: ["title"] as const,
                    name: "title",
                    constraints: { required: true },
                    
                    get: () => data.title,
                    set: (value: JobTitle) => { data.title = value; },
                    transform: (value: JobTitle): JobTitle => value,
                    getError: () => errors.title,
                    setError: (value: Option<Array<string>>) => { errors.title = value; },
                    getTainted: () => tainted.title,
                    setTainted: (value: Option<boolean>) => { tainted.title = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("title", data.title);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                email: {
                    path: ["email"] as const,
                    name: "email",
                    constraints: { required: true },
                    
                    get: () => data.email,
                    set: (value: Email) => { data.email = value; },
                    transform: (value: Email): Email => value,
                    getError: () => errors.email,
                    setError: (value: Option<Array<string>>) => { errors.email = value; },
                    getTainted: () => tainted.email,
                    setTainted: (value: Option<boolean>) => { tainted.email = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("email", data.email);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                address: {
                    path: ["address"] as const,
                    name: "address",
                    constraints: { required: true },
                    
                    get: () => data.address,
                    set: (value: string) => { data.address = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.address,
                    setError: (value: Option<Array<string>>) => { errors.address = value; },
                    getTainted: () => tainted.address,
                    setTainted: (value: Option<boolean>) => { tainted.address = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("address", data.address);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                username: {
                    path: ["username"] as const,
                    name: "username",
                    constraints: { required: true },
                    
                    get: () => data.username,
                    set: (value: string) => { data.username = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.username,
                    setError: (value: Option<Array<string>>) => { errors.username = value; },
                    getTainted: () => tainted.username,
                    setTainted: (value: Option<boolean>) => { tainted.username = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("username", data.username);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                route: {
                    path: ["route"] as const,
                    name: "route",
                    constraints: { required: true },
                    
                    get: () => data.route,
                    set: (value: string | Route) => { data.route = value; },
                    transform: (value: string | Route): string | Route => value,
                    getError: () => errors.route,
                    setError: (value: Option<Array<string>>) => { errors.route = value; },
                    getTainted: () => tainted.route,
                    setTainted: (value: Option<boolean>) => { tainted.route = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("route", data.route);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                ratePerHour: {
                    path: ["ratePerHour"] as const,
                    name: "ratePerHour",
                    constraints: { required: true },
                    
                    get: () => data.ratePerHour,
                    set: (value: number) => { data.ratePerHour = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.ratePerHour,
                    setError: (value: Option<Array<string>>) => { errors.ratePerHour = value; },
                    getTainted: () => tainted.ratePerHour,
                    setTainted: (value: Option<boolean>) => { tainted.ratePerHour = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("ratePerHour", data.ratePerHour);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                active: {
                    path: ["active"] as const,
                    name: "active",
                    constraints: { required: true },
                    
                    get: () => data.active,
                    set: (value: boolean) => { data.active = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.active,
                    setError: (value: Option<Array<string>>) => { errors.active = value; },
                    getTainted: () => tainted.active,
                    setTainted: (value: Option<boolean>) => { tainted.active = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("active", data.active);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                isTechnician: {
                    path: ["isTechnician"] as const,
                    name: "isTechnician",
                    constraints: { required: true },
                    
                    get: () => data.isTechnician,
                    set: (value: boolean) => { data.isTechnician = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.isTechnician,
                    setError: (value: Option<Array<string>>) => { errors.isTechnician = value; },
                    getTainted: () => tainted.isTechnician,
                    setTainted: (value: Option<boolean>) => { tainted.isTechnician = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("isTechnician", data.isTechnician);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                isSalesRep: {
                    path: ["isSalesRep"] as const,
                    name: "isSalesRep",
                    constraints: { required: true },
                    
                    get: () => data.isSalesRep,
                    set: (value: boolean) => { data.isSalesRep = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.isSalesRep,
                    setError: (value: Option<Array<string>>) => { errors.isSalesRep = value; },
                    getTainted: () => tainted.isSalesRep,
                    setTainted: (value: Option<boolean>) => { tainted.isSalesRep = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("isSalesRep", data.isSalesRep);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                description: {
                    path: ["description"] as const,
                    name: "description",
                    constraints: { required: true },
                    
                    get: () => data.description,
                    set: (value: string | null) => { data.description = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.description,
                    setError: (value: Option<Array<string>>) => { errors.description = value; },
                    getTainted: () => tainted.description,
                    setTainted: (value: Option<boolean>) => { tainted.description = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("description", data.description);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                linkedinUrl: {
                    path: ["linkedinUrl"] as const,
                    name: "linkedinUrl",
                    constraints: { required: true },
                    
                    get: () => data.linkedinUrl,
                    set: (value: string | null) => { data.linkedinUrl = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.linkedinUrl,
                    setError: (value: Option<Array<string>>) => { errors.linkedinUrl = value; },
                    getTainted: () => tainted.linkedinUrl,
                    setTainted: (value: Option<boolean>) => { tainted.linkedinUrl = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("linkedinUrl", data.linkedinUrl);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                attendance: {
                    path: ["attendance"] as const,
                    name: "attendance",
                    constraints: { required: true },
                    
                    get: () => data.attendance,
                    set: (value: string[]) => { data.attendance = value; },
                    transform: (value: string[]): string[] => value,
                    getError: () => errors.attendance,
                    setError: (value: Option<Array<string>>) => { errors.attendance = value; },
                    getTainted: () => tainted.attendance,
                    setTainted: (value: Option<boolean>) => { tainted.attendance = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("attendance", data.attendance);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["attendance", index] as const,
                        name: `attendance.${index}`,
                        constraints: { required: true },
                        get: () => data.attendance[index]!,
                        set: (value: string) => { data.attendance[index] = value; },
                        transform: (value: string): string => value,
                        getError: () => errors.attendance,
                        setError: (value: Option<Array<string>>) => { errors.attendance = value; },
                        getTainted: () => tainted.attendance,
                        setTainted: (value: Option<boolean>) => { tainted.attendance = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: string) => { data.attendance.push(item); },
                    remove: (index: number) => { data.attendance.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.attendance[a]!;
                        data.attendance[a] = data.attendance[b]!;
                        data.attendance[b] = tmp;
                    },
                },
                settings: {
                    path: ["settings"] as const,
                    name: "settings",
                    constraints: { required: true },
                    
                    get: () => data.settings,
                    set: (value: Settings) => { data.settings = value; },
                    transform: (value: Settings): Settings => value,
                    getError: () => errors.settings,
                    setError: (value: Option<Array<string>>) => { errors.settings = value; },
                    getTainted: () => tainted.settings,
                    setTainted: (value: Option<boolean>) => { tainted.settings = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmployee("settings", data.settings);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Employee, Array<{field: string; message: string}>>{return fromObjectEmployee(data);}function reset(newOverrides?: Partial<Employee>): void {data = {...defaultValueEmployee(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), imageUrl: Option.none(), name: Option.none(), phones: Option.none(), role: Option.none(), title: Option.none(), email: Option.none(), address: Option.none(), username: Option.none(), route: Option.none(), ratePerHour: Option.none(), active: Option.none(), isTechnician: Option.none(), isSalesRep: Option.none(), description: Option.none(), linkedinUrl: Option.none(), attendance: Option.none(), settings: Option.none() }; tainted = { id: Option.none(), imageUrl: Option.none(), name: Option.none(), phones: Option.none(), role: Option.none(), title: Option.none(), email: Option.none(), address: Option.none(), username: Option.none(), route: Option.none(), ratePerHour: Option.none(), active: Option.none(), isTechnician: Option.none(), isSalesRep: Option.none(), description: Option.none(), linkedinUrl: Option.none(), attendance: Option.none(), settings: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataEmployee(formData: FormData): Result<Employee, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.imageUrl = formData.get("imageUrl") ?? "";
            obj.name = formData.get("name") ?? "";
            {
                // Collect array items from indexed form fields
                const phonesItems: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("phones." + idx + ".") || idx === 0) {
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("phones." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {
                        const item: Record<string, unknown> = {};
                        for (const [key, value] of Array.from(formData.entries())) {
                            if (key.startsWith("phones." + idx + ".")) {
                                const fieldName = key.slice("phones.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }
                        }
                        phonesItems.push(item);
                    }
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }
                obj.phones = phonesItems;
            }
            obj.role = formData.get("role") ?? "";
            {
            // Collect nested object fields with prefix "title."
            const titleObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("title.")) {
                    const fieldName = key.slice("title.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = titleObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.title = titleObj;
        }
            {
            // Collect nested object fields with prefix "email."
            const emailObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("email.")) {
                    const fieldName = key.slice("email.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = emailObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.email = emailObj;
        }
            obj.address = formData.get("address") ?? "";
            obj.username = formData.get("username") ?? "";
            obj.route = formData.get("route") ?? "";
            {
                const ratePerHourStr = formData.get("ratePerHour");
                obj.ratePerHour = ratePerHourStr ? parseFloat(ratePerHourStr as string) : 0;
                if (obj.ratePerHour !== undefined && isNaN(obj.ratePerHour as number)) obj.ratePerHour = 0;
            }
            {
                const activeVal = formData.get("active");
                obj.active = activeVal === "true" || activeVal === "on" || activeVal === "1";
            }
            {
                const isTechnicianVal = formData.get("isTechnician");
                obj.isTechnician = isTechnicianVal === "true" || isTechnicianVal === "on" || isTechnicianVal === "1";
            }
            {
                const isSalesRepVal = formData.get("isSalesRep");
                obj.isSalesRep = isSalesRepVal === "true" || isSalesRepVal === "on" || isSalesRepVal === "1";
            }
            obj.description = formData.get("description") ?? "";
            obj.linkedinUrl = formData.get("linkedinUrl") ?? "";
            obj.attendance = formData.getAll("attendance") as Array<string>;
            {
            // Collect nested object fields with prefix "settings."
            const settingsObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("settings.")) {
                    const fieldName = key.slice("settings.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = settingsObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.settings = settingsObj;
        } return fromStringifiedJSONEmployee(JSON.stringify(obj));}


export interface Commissions {
    
    technician: string;
    
    salesRep: string;
}

export function defaultValueCommissions(): Commissions {return {technician: "",
                            salesRep: "", }as Commissions;}

export function toStringifiedJSONCommissions(value: Commissions): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeCommissions(value, ctx));}export function toObjectCommissions(value: Commissions): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeCommissions(value, ctx);}export function __serializeCommissions(value: Commissions, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Commissions" , __id,}; result["technician" ]= value.technician; result["salesRep" ]= value.salesRep; return result;}

export function fromStringifiedJSONCommissions(json: string, opts?: DeserializeOptions): Result<Commissions, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectCommissions(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectCommissions(obj: unknown, opts?: DeserializeOptions): Result<Commissions, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeCommissions(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Commissions.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeCommissions(value: any, ctx: DeserializeContext): Commissions | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Commissions.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("technician" in obj)){errors.push({field: "technician" , message: "missing required field" });}if(!("salesRep" in obj)){errors.push({field: "salesRep" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_technician = obj["technician" ]as string; 
                if (__raw_technician.length === 0) {
                    errors.push({ field: "technician", message: "must not be empty" });
                }
 instance.technician = __raw_technician; }{const __raw_salesRep = obj["salesRep" ]as string; 
                if (__raw_salesRep.length === 0) {
                    errors.push({ field: "salesRep", message: "must not be empty" });
                }
 instance.salesRep = __raw_salesRep; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Commissions;}export function validateFieldCommissions<K extends keyof Commissions>(field: K, value: Commissions[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "technician" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "technician", message: "must not be empty" });
                }
 break;}case "salesRep" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "salesRep", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsCommissions(partial: Partial<Commissions>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("technician" in partial && partial.technician!== undefined){const __val = partial.technician as string; 
                if (__val.length === 0) {
                    errors.push({ field: "technician", message: "must not be empty" });
                }
}if("salesRep" in partial && partial.salesRep!== undefined){const __val = partial.salesRep as string; 
                if (__val.length === 0) {
                    errors.push({ field: "salesRep", message: "must not be empty" });
                }
}return errors; }export function hasShapeCommissions(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "technician" in o && "salesRep" in o;}export function isCommissions(obj: unknown): obj is Commissions {if(!hasShapeCommissions(obj)){return false;}const result = fromObjectCommissions(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsCommissions = {_errors: Option<Array<string>>; technician: Option<Array<string>>;
            salesRep: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedCommissions = {technician: Option<boolean>;
            salesRep: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersCommissions {readonly technician: FieldController<string>;
            readonly salesRep: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformCommissions {readonly data: Commissions; readonly errors: ErrorsCommissions; readonly tainted: TaintedCommissions; readonly fields: FieldControllersCommissions; validate(): Result<Commissions, Array<{field: string; message: string}>>; reset(overrides?: Partial<Commissions>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormCommissions(overrides?: Partial<Commissions>): GigaformCommissions {let data = $state({...defaultValueCommissions(),...overrides}); let errors = $state<ErrorsCommissions>({ _errors: Option.none(), technician: Option.none(), salesRep: Option.none() }); let tainted = $state<TaintedCommissions>({ technician: Option.none(), salesRep: Option.none() }); const fields: FieldControllersCommissions = {technician: {
                    path: ["technician"] as const,
                    name: "technician",
                    constraints: { required: true },
                    
                    get: () => data.technician,
                    set: (value: string) => { data.technician = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.technician,
                    setError: (value: Option<Array<string>>) => { errors.technician = value; },
                    getTainted: () => tainted.technician,
                    setTainted: (value: Option<boolean>) => { tainted.technician = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCommissions("technician", data.technician);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                salesRep: {
                    path: ["salesRep"] as const,
                    name: "salesRep",
                    constraints: { required: true },
                    
                    get: () => data.salesRep,
                    set: (value: string) => { data.salesRep = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.salesRep,
                    setError: (value: Option<Array<string>>) => { errors.salesRep = value; },
                    getTainted: () => tainted.salesRep,
                    setTainted: (value: Option<boolean>) => { tainted.salesRep = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCommissions("salesRep", data.salesRep);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Commissions, Array<{field: string; message: string}>>{return fromObjectCommissions(data);}function reset(newOverrides?: Partial<Commissions>): void {data = {...defaultValueCommissions(),...newOverrides}; errors = { _errors: Option.none(), technician: Option.none(), salesRep: Option.none() }; tainted = { technician: Option.none(), salesRep: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataCommissions(formData: FormData): Result<Commissions, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.technician = formData.get("technician") ?? "";
            obj.salesRep = formData.get("salesRep") ?? ""; return fromStringifiedJSONCommissions(JSON.stringify(obj));}


export interface Number {
    
    countryCode: string;
    
    areaCode: string;
    
    localNumber: string;
}

export function defaultValueNumber(): Number {return {countryCode: "",
                            areaCode: "",
                            localNumber: "", }as Number;}

export function toStringifiedJSONNumber(value: Number): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeNumber(value, ctx));}export function toObjectNumber(value: Number): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeNumber(value, ctx);}export function __serializeNumber(value: Number, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Number" , __id,}; result["countryCode" ]= value.countryCode; result["areaCode" ]= value.areaCode; result["localNumber" ]= value.localNumber; return result;}

export function fromStringifiedJSONNumber(json: string, opts?: DeserializeOptions): Result<Number, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectNumber(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectNumber(obj: unknown, opts?: DeserializeOptions): Result<Number, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeNumber(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Number.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeNumber(value: any, ctx: DeserializeContext): Number | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Number.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("countryCode" in obj)){errors.push({field: "countryCode" , message: "missing required field" });}if(!("areaCode" in obj)){errors.push({field: "areaCode" , message: "missing required field" });}if(!("localNumber" in obj)){errors.push({field: "localNumber" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_countryCode = obj["countryCode" ]as string; 
                if (__raw_countryCode.length === 0) {
                    errors.push({ field: "countryCode", message: "must not be empty" });
                }
 instance.countryCode = __raw_countryCode; }{const __raw_areaCode = obj["areaCode" ]as string; 
                if (__raw_areaCode.length === 0) {
                    errors.push({ field: "areaCode", message: "must not be empty" });
                }
 instance.areaCode = __raw_areaCode; }{const __raw_localNumber = obj["localNumber" ]as string; 
                if (__raw_localNumber.length === 0) {
                    errors.push({ field: "localNumber", message: "must not be empty" });
                }
 instance.localNumber = __raw_localNumber; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Number;}export function validateFieldNumber<K extends keyof Number>(field: K, value: Number[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "countryCode" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "countryCode", message: "must not be empty" });
                }
 break;}case "areaCode" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "areaCode", message: "must not be empty" });
                }
 break;}case "localNumber" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "localNumber", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsNumber(partial: Partial<Number>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("countryCode" in partial && partial.countryCode!== undefined){const __val = partial.countryCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "countryCode", message: "must not be empty" });
                }
}if("areaCode" in partial && partial.areaCode!== undefined){const __val = partial.areaCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "areaCode", message: "must not be empty" });
                }
}if("localNumber" in partial && partial.localNumber!== undefined){const __val = partial.localNumber as string; 
                if (__val.length === 0) {
                    errors.push({ field: "localNumber", message: "must not be empty" });
                }
}return errors; }export function hasShapeNumber(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "countryCode" in o && "areaCode" in o && "localNumber" in o;}export function isNumber(obj: unknown): obj is Number {if(!hasShapeNumber(obj)){return false;}const result = fromObjectNumber(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsNumber = {_errors: Option<Array<string>>; countryCode: Option<Array<string>>;
            areaCode: Option<Array<string>>;
            localNumber: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedNumber = {countryCode: Option<boolean>;
            areaCode: Option<boolean>;
            localNumber: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersNumber {readonly countryCode: FieldController<string>;
            readonly areaCode: FieldController<string>;
            readonly localNumber: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformNumber {readonly data: Number; readonly errors: ErrorsNumber; readonly tainted: TaintedNumber; readonly fields: FieldControllersNumber; validate(): Result<Number, Array<{field: string; message: string}>>; reset(overrides?: Partial<Number>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormNumber(overrides?: Partial<Number>): GigaformNumber {let data = $state({...defaultValueNumber(),...overrides}); let errors = $state<ErrorsNumber>({ _errors: Option.none(), countryCode: Option.none(), areaCode: Option.none(), localNumber: Option.none() }); let tainted = $state<TaintedNumber>({ countryCode: Option.none(), areaCode: Option.none(), localNumber: Option.none() }); const fields: FieldControllersNumber = {countryCode: {
                    path: ["countryCode"] as const,
                    name: "countryCode",
                    constraints: { required: true },
                    
                    get: () => data.countryCode,
                    set: (value: string) => { data.countryCode = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.countryCode,
                    setError: (value: Option<Array<string>>) => { errors.countryCode = value; },
                    getTainted: () => tainted.countryCode,
                    setTainted: (value: Option<boolean>) => { tainted.countryCode = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldNumber("countryCode", data.countryCode);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                areaCode: {
                    path: ["areaCode"] as const,
                    name: "areaCode",
                    constraints: { required: true },
                    
                    get: () => data.areaCode,
                    set: (value: string) => { data.areaCode = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.areaCode,
                    setError: (value: Option<Array<string>>) => { errors.areaCode = value; },
                    getTainted: () => tainted.areaCode,
                    setTainted: (value: Option<boolean>) => { tainted.areaCode = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldNumber("areaCode", data.areaCode);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                localNumber: {
                    path: ["localNumber"] as const,
                    name: "localNumber",
                    constraints: { required: true },
                    
                    get: () => data.localNumber,
                    set: (value: string) => { data.localNumber = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.localNumber,
                    setError: (value: Option<Array<string>>) => { errors.localNumber = value; },
                    getTainted: () => tainted.localNumber,
                    setTainted: (value: Option<boolean>) => { tainted.localNumber = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldNumber("localNumber", data.localNumber);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Number, Array<{field: string; message: string}>>{return fromObjectNumber(data);}function reset(newOverrides?: Partial<Number>): void {data = {...defaultValueNumber(),...newOverrides}; errors = { _errors: Option.none(), countryCode: Option.none(), areaCode: Option.none(), localNumber: Option.none() }; tainted = { countryCode: Option.none(), areaCode: Option.none(), localNumber: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataNumber(formData: FormData): Result<Number, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.countryCode = formData.get("countryCode") ?? "";
            obj.areaCode = formData.get("areaCode") ?? "";
            obj.localNumber = formData.get("localNumber") ?? ""; return fromStringifiedJSONNumber(JSON.stringify(obj));}


export interface DataPath {
    path: string[];
    formatter: string | null;
}

export function defaultValueDataPath(): DataPath {return {path: [],
                            formatter: null, }as DataPath;}

export function toStringifiedJSONDataPath(value: DataPath): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeDataPath(value, ctx));}export function toObjectDataPath(value: DataPath): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeDataPath(value, ctx);}export function __serializeDataPath(value: DataPath, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "DataPath" , __id,}; result["path" ]= value.path; result["formatter" ]= value.formatter; return result;}

export function fromStringifiedJSONDataPath(json: string, opts?: DeserializeOptions): Result<DataPath, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectDataPath(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectDataPath(obj: unknown, opts?: DeserializeOptions): Result<DataPath, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeDataPath(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "DataPath.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeDataPath(value: any, ctx: DeserializeContext): DataPath | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "DataPath.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("path" in obj)){errors.push({field: "path" , message: "missing required field" });}if(!("formatter" in obj)){errors.push({field: "formatter" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_path = obj["path" ]as string[]; if(Array.isArray(__raw_path)){instance.path = __raw_path as string[];}}{const __raw_formatter = obj["formatter" ]as string | null; instance.formatter = __raw_formatter; }if(errors.length>0){throw new DeserializeError(errors);}return instance as DataPath;}export function validateFieldDataPath<K extends keyof DataPath>(field: K, value: DataPath[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsDataPath(partial: Partial<DataPath>): Array<{field: string; message: string}>{return[]; }export function hasShapeDataPath(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "path" in o && "formatter" in o;}export function isDataPath(obj: unknown): obj is DataPath {if(!hasShapeDataPath(obj)){return false;}const result = fromObjectDataPath(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsDataPath = {_errors: Option<Array<string>>; path: Option<Array<string>>;
            formatter: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedDataPath = {path: Option<boolean>;
            formatter: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersDataPath {readonly path: ArrayFieldController<string>;
            readonly formatter: FieldController<string | null>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformDataPath {readonly data: DataPath; readonly errors: ErrorsDataPath; readonly tainted: TaintedDataPath; readonly fields: FieldControllersDataPath; validate(): Result<DataPath, Array<{field: string; message: string}>>; reset(overrides?: Partial<DataPath>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormDataPath(overrides?: Partial<DataPath>): GigaformDataPath {let data = $state({...defaultValueDataPath(),...overrides}); let errors = $state<ErrorsDataPath>({ _errors: Option.none(), path: Option.none(), formatter: Option.none() }); let tainted = $state<TaintedDataPath>({ path: Option.none(), formatter: Option.none() }); const fields: FieldControllersDataPath = {path: {
                    path: ["path"] as const,
                    name: "path",
                    constraints: { required: true },
                    
                    get: () => data.path,
                    set: (value: string[]) => { data.path = value; },
                    transform: (value: string[]): string[] => value,
                    getError: () => errors.path,
                    setError: (value: Option<Array<string>>) => { errors.path = value; },
                    getTainted: () => tainted.path,
                    setTainted: (value: Option<boolean>) => { tainted.path = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldDataPath("path", data.path);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["path", index] as const,
                        name: `path.${index}`,
                        constraints: { required: true },
                        get: () => data.path[index]!,
                        set: (value: string) => { data.path[index] = value; },
                        transform: (value: string): string => value,
                        getError: () => errors.path,
                        setError: (value: Option<Array<string>>) => { errors.path = value; },
                        getTainted: () => tainted.path,
                        setTainted: (value: Option<boolean>) => { tainted.path = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: string) => { data.path.push(item); },
                    remove: (index: number) => { data.path.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.path[a]!;
                        data.path[a] = data.path[b]!;
                        data.path[b] = tmp;
                    },
                },
                formatter: {
                    path: ["formatter"] as const,
                    name: "formatter",
                    constraints: { required: true },
                    
                    get: () => data.formatter,
                    set: (value: string | null) => { data.formatter = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.formatter,
                    setError: (value: Option<Array<string>>) => { errors.formatter = value; },
                    getTainted: () => tainted.formatter,
                    setTainted: (value: Option<boolean>) => { tainted.formatter = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldDataPath("formatter", data.formatter);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<DataPath, Array<{field: string; message: string}>>{return fromObjectDataPath(data);}function reset(newOverrides?: Partial<DataPath>): void {data = {...defaultValueDataPath(),...newOverrides}; errors = { _errors: Option.none(), path: Option.none(), formatter: Option.none() }; tainted = { path: Option.none(), formatter: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataDataPath(formData: FormData): Result<DataPath, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.path = formData.getAll("path") as Array<string>;
            obj.formatter = formData.get("formatter") ?? ""; return fromStringifiedJSONDataPath(JSON.stringify(obj));}


export interface Route {
    id: string;
    techs: (string | Employee)[] | null;
    active: boolean;
    
    name: string;
    
    phone: string;
    
    position: string;
    serviceRoute: boolean;
    defaultDurationHours: number;
    tags: string[];
    icon: string | null;
    color: string | null;
}

export function defaultValueRoute(): Route {return {id: "",
                            techs: null,
                            active: false,
                            name: "",
                            phone: "",
                            position: "",
                            serviceRoute: false,
                            defaultDurationHours: 0,
                            tags: [],
                            icon: null,
                            color: null, }as Route;}

export function toStringifiedJSONRoute(value: Route): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeRoute(value, ctx));}export function toObjectRoute(value: Route): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeRoute(value, ctx);}export function __serializeRoute(value: Route, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Route" , __id,}; result["id" ]= value.id; if(value.techs!== null){result["techs" ]= value.techs; }else {result["techs" ]= null;}result["active" ]= value.active; result["name" ]= value.name; result["phone" ]= value.phone; result["position" ]= value.position; result["serviceRoute" ]= value.serviceRoute; result["defaultDurationHours" ]= value.defaultDurationHours; result["tags" ]= value.tags; result["icon" ]= value.icon; result["color" ]= value.color; return result;}

export function fromStringifiedJSONRoute(json: string, opts?: DeserializeOptions): Result<Route, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectRoute(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectRoute(obj: unknown, opts?: DeserializeOptions): Result<Route, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeRoute(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Route.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeRoute(value: any, ctx: DeserializeContext): Route | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Route.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("techs" in obj)){errors.push({field: "techs" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("phone" in obj)){errors.push({field: "phone" , message: "missing required field" });}if(!("position" in obj)){errors.push({field: "position" , message: "missing required field" });}if(!("serviceRoute" in obj)){errors.push({field: "serviceRoute" , message: "missing required field" });}if(!("defaultDurationHours" in obj)){errors.push({field: "defaultDurationHours" , message: "missing required field" });}if(!("tags" in obj)){errors.push({field: "tags" , message: "missing required field" });}if(!("icon" in obj)){errors.push({field: "icon" , message: "missing required field" });}if(!("color" in obj)){errors.push({field: "color" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_techs = obj["techs" ]as (string | Employee)[] | null; if(__raw_techs === null){instance.techs = null;}else {instance.techs = __raw_techs; }}{const __raw_active = obj["active" ]as boolean; instance.active = __raw_active; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_phone = obj["phone" ]as string; 
                if (__raw_phone.length === 0) {
                    errors.push({ field: "phone", message: "must not be empty" });
                }
 instance.phone = __raw_phone; }{const __raw_position = obj["position" ]as string; 
                if (__raw_position.length === 0) {
                    errors.push({ field: "position", message: "must not be empty" });
                }
 instance.position = __raw_position; }{const __raw_serviceRoute = obj["serviceRoute" ]as boolean; instance.serviceRoute = __raw_serviceRoute; }{const __raw_defaultDurationHours = obj["defaultDurationHours" ]as number; instance.defaultDurationHours = __raw_defaultDurationHours; }{const __raw_tags = obj["tags" ]as string[]; if(Array.isArray(__raw_tags)){instance.tags = __raw_tags as string[];}}{const __raw_icon = obj["icon" ]as string | null; instance.icon = __raw_icon; }{const __raw_color = obj["color" ]as string | null; instance.color = __raw_color; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Route;}export function validateFieldRoute<K extends keyof Route>(field: K, value: Route[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "phone" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "phone", message: "must not be empty" });
                }
 break;}case "position" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "position", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsRoute(partial: Partial<Route>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("phone" in partial && partial.phone!== undefined){const __val = partial.phone as string; 
                if (__val.length === 0) {
                    errors.push({ field: "phone", message: "must not be empty" });
                }
}if("position" in partial && partial.position!== undefined){const __val = partial.position as string; 
                if (__val.length === 0) {
                    errors.push({ field: "position", message: "must not be empty" });
                }
}return errors; }export function hasShapeRoute(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "techs" in o && "active" in o && "name" in o && "phone" in o && "position" in o && "serviceRoute" in o && "defaultDurationHours" in o && "tags" in o && "icon" in o && "color" in o;}export function isRoute(obj: unknown): obj is Route {if(!hasShapeRoute(obj)){return false;}const result = fromObjectRoute(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsRoute = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            techs: Option<Array<string>>;
            active: Option<Array<string>>;
            name: Option<Array<string>>;
            phone: Option<Array<string>>;
            position: Option<Array<string>>;
            serviceRoute: Option<Array<string>>;
            defaultDurationHours: Option<Array<string>>;
            tags: Option<Array<string>>;
            icon: Option<Array<string>>;
            color: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedRoute = {id: Option<boolean>;
            techs: Option<boolean>;
            active: Option<boolean>;
            name: Option<boolean>;
            phone: Option<boolean>;
            position: Option<boolean>;
            serviceRoute: Option<boolean>;
            defaultDurationHours: Option<boolean>;
            tags: Option<boolean>;
            icon: Option<boolean>;
            color: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersRoute {readonly id: FieldController<string>;
            readonly techs: FieldController<(string | Employee)[] | null>;
            readonly active: FieldController<boolean>;
            readonly name: FieldController<string>;
            readonly phone: FieldController<string>;
            readonly position: FieldController<string>;
            readonly serviceRoute: FieldController<boolean>;
            readonly defaultDurationHours: FieldController<number>;
            readonly tags: ArrayFieldController<string>;
            readonly icon: FieldController<string | null>;
            readonly color: FieldController<string | null>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformRoute {readonly data: Route; readonly errors: ErrorsRoute; readonly tainted: TaintedRoute; readonly fields: FieldControllersRoute; validate(): Result<Route, Array<{field: string; message: string}>>; reset(overrides?: Partial<Route>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormRoute(overrides?: Partial<Route>): GigaformRoute {let data = $state({...defaultValueRoute(),...overrides}); let errors = $state<ErrorsRoute>({ _errors: Option.none(), id: Option.none(), techs: Option.none(), active: Option.none(), name: Option.none(), phone: Option.none(), position: Option.none(), serviceRoute: Option.none(), defaultDurationHours: Option.none(), tags: Option.none(), icon: Option.none(), color: Option.none() }); let tainted = $state<TaintedRoute>({ id: Option.none(), techs: Option.none(), active: Option.none(), name: Option.none(), phone: Option.none(), position: Option.none(), serviceRoute: Option.none(), defaultDurationHours: Option.none(), tags: Option.none(), icon: Option.none(), color: Option.none() }); const fields: FieldControllersRoute = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRoute("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                techs: {
                    path: ["techs"] as const,
                    name: "techs",
                    constraints: { required: true },
                    
                    get: () => data.techs,
                    set: (value: (string | Employee)[] | null) => { data.techs = value; },
                    transform: (value: (string | Employee)[] | null): (string | Employee)[] | null => value,
                    getError: () => errors.techs,
                    setError: (value: Option<Array<string>>) => { errors.techs = value; },
                    getTainted: () => tainted.techs,
                    setTainted: (value: Option<boolean>) => { tainted.techs = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRoute("techs", data.techs);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                active: {
                    path: ["active"] as const,
                    name: "active",
                    constraints: { required: true },
                    
                    get: () => data.active,
                    set: (value: boolean) => { data.active = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.active,
                    setError: (value: Option<Array<string>>) => { errors.active = value; },
                    getTainted: () => tainted.active,
                    setTainted: (value: Option<boolean>) => { tainted.active = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRoute("active", data.active);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                name: {
                    path: ["name"] as const,
                    name: "name",
                    constraints: { required: true },
                    
                    get: () => data.name,
                    set: (value: string) => { data.name = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.name,
                    setError: (value: Option<Array<string>>) => { errors.name = value; },
                    getTainted: () => tainted.name,
                    setTainted: (value: Option<boolean>) => { tainted.name = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRoute("name", data.name);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                phone: {
                    path: ["phone"] as const,
                    name: "phone",
                    constraints: { required: true },
                    
                    get: () => data.phone,
                    set: (value: string) => { data.phone = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.phone,
                    setError: (value: Option<Array<string>>) => { errors.phone = value; },
                    getTainted: () => tainted.phone,
                    setTainted: (value: Option<boolean>) => { tainted.phone = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRoute("phone", data.phone);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                position: {
                    path: ["position"] as const,
                    name: "position",
                    constraints: { required: true },
                    
                    get: () => data.position,
                    set: (value: string) => { data.position = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.position,
                    setError: (value: Option<Array<string>>) => { errors.position = value; },
                    getTainted: () => tainted.position,
                    setTainted: (value: Option<boolean>) => { tainted.position = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRoute("position", data.position);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                serviceRoute: {
                    path: ["serviceRoute"] as const,
                    name: "serviceRoute",
                    constraints: { required: true },
                    
                    get: () => data.serviceRoute,
                    set: (value: boolean) => { data.serviceRoute = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.serviceRoute,
                    setError: (value: Option<Array<string>>) => { errors.serviceRoute = value; },
                    getTainted: () => tainted.serviceRoute,
                    setTainted: (value: Option<boolean>) => { tainted.serviceRoute = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRoute("serviceRoute", data.serviceRoute);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                defaultDurationHours: {
                    path: ["defaultDurationHours"] as const,
                    name: "defaultDurationHours",
                    constraints: { required: true },
                    
                    get: () => data.defaultDurationHours,
                    set: (value: number) => { data.defaultDurationHours = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.defaultDurationHours,
                    setError: (value: Option<Array<string>>) => { errors.defaultDurationHours = value; },
                    getTainted: () => tainted.defaultDurationHours,
                    setTainted: (value: Option<boolean>) => { tainted.defaultDurationHours = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRoute("defaultDurationHours", data.defaultDurationHours);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                tags: {
                    path: ["tags"] as const,
                    name: "tags",
                    constraints: { required: true },
                    
                    get: () => data.tags,
                    set: (value: string[]) => { data.tags = value; },
                    transform: (value: string[]): string[] => value,
                    getError: () => errors.tags,
                    setError: (value: Option<Array<string>>) => { errors.tags = value; },
                    getTainted: () => tainted.tags,
                    setTainted: (value: Option<boolean>) => { tainted.tags = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRoute("tags", data.tags);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    at: (index: number) => ({
                        path: ["tags", index] as const,
                        name: `tags.${index}`,
                        constraints: { required: true },
                        get: () => data.tags[index]!,
                        set: (value: string) => { data.tags[index] = value; },
                        transform: (value: string): string => value,
                        getError: () => errors.tags,
                        setError: (value: Option<Array<string>>) => { errors.tags = value; },
                        getTainted: () => tainted.tags,
                        setTainted: (value: Option<boolean>) => { tainted.tags = value; },
                        validate: (): Array<string> => [],
                    }),
                    push: (item: string) => { data.tags.push(item); },
                    remove: (index: number) => { data.tags.splice(index, 1); },
                    swap: (a: number, b: number) => {
                        const tmp = data.tags[a]!;
                        data.tags[a] = data.tags[b]!;
                        data.tags[b] = tmp;
                    },
                },
                icon: {
                    path: ["icon"] as const,
                    name: "icon",
                    constraints: { required: true },
                    
                    get: () => data.icon,
                    set: (value: string | null) => { data.icon = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.icon,
                    setError: (value: Option<Array<string>>) => { errors.icon = value; },
                    getTainted: () => tainted.icon,
                    setTainted: (value: Option<boolean>) => { tainted.icon = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRoute("icon", data.icon);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                color: {
                    path: ["color"] as const,
                    name: "color",
                    constraints: { required: true },
                    
                    get: () => data.color,
                    set: (value: string | null) => { data.color = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.color,
                    setError: (value: Option<Array<string>>) => { errors.color = value; },
                    getTainted: () => tainted.color,
                    setTainted: (value: Option<boolean>) => { tainted.color = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRoute("color", data.color);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Route, Array<{field: string; message: string}>>{return fromObjectRoute(data);}function reset(newOverrides?: Partial<Route>): void {data = {...defaultValueRoute(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), techs: Option.none(), active: Option.none(), name: Option.none(), phone: Option.none(), position: Option.none(), serviceRoute: Option.none(), defaultDurationHours: Option.none(), tags: Option.none(), icon: Option.none(), color: Option.none() }; tainted = { id: Option.none(), techs: Option.none(), active: Option.none(), name: Option.none(), phone: Option.none(), position: Option.none(), serviceRoute: Option.none(), defaultDurationHours: Option.none(), tags: Option.none(), icon: Option.none(), color: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataRoute(formData: FormData): Result<Route, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.techs = formData.get("techs") ?? "";
            {
                const activeVal = formData.get("active");
                obj.active = activeVal === "true" || activeVal === "on" || activeVal === "1";
            }
            obj.name = formData.get("name") ?? "";
            obj.phone = formData.get("phone") ?? "";
            obj.position = formData.get("position") ?? "";
            {
                const serviceRouteVal = formData.get("serviceRoute");
                obj.serviceRoute = serviceRouteVal === "true" || serviceRouteVal === "on" || serviceRouteVal === "1";
            }
            {
                const defaultDurationHoursStr = formData.get("defaultDurationHours");
                obj.defaultDurationHours = defaultDurationHoursStr ? parseFloat(defaultDurationHoursStr as string) : 0;
                if (obj.defaultDurationHours !== undefined && isNaN(obj.defaultDurationHours as number)) obj.defaultDurationHours = 0;
            }
            obj.tags = formData.getAll("tags") as Array<string>;
            obj.icon = formData.get("icon") ?? "";
            obj.color = formData.get("color") ?? ""; return fromStringifiedJSONRoute(JSON.stringify(obj));}


export interface EmailParts {
    
    local: string;
    
    domainName: string;
    
    topLevelDomain: string;
}

export function defaultValueEmailParts(): EmailParts {return {local: "",
                            domainName: "",
                            topLevelDomain: "", }as EmailParts;}

export function toStringifiedJSONEmailParts(value: EmailParts): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeEmailParts(value, ctx));}export function toObjectEmailParts(value: EmailParts): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeEmailParts(value, ctx);}export function __serializeEmailParts(value: EmailParts, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "EmailParts" , __id,}; result["local" ]= value.local; result["domainName" ]= value.domainName; result["topLevelDomain" ]= value.topLevelDomain; return result;}

export function fromStringifiedJSONEmailParts(json: string, opts?: DeserializeOptions): Result<EmailParts, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectEmailParts(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectEmailParts(obj: unknown, opts?: DeserializeOptions): Result<EmailParts, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeEmailParts(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "EmailParts.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeEmailParts(value: any, ctx: DeserializeContext): EmailParts | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "EmailParts.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("local" in obj)){errors.push({field: "local" , message: "missing required field" });}if(!("domainName" in obj)){errors.push({field: "domainName" , message: "missing required field" });}if(!("topLevelDomain" in obj)){errors.push({field: "topLevelDomain" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_local = obj["local" ]as string; 
                if (__raw_local.length === 0) {
                    errors.push({ field: "local", message: "must not be empty" });
                }
 instance.local = __raw_local; }{const __raw_domainName = obj["domainName" ]as string; 
                if (__raw_domainName.length === 0) {
                    errors.push({ field: "domainName", message: "must not be empty" });
                }
 instance.domainName = __raw_domainName; }{const __raw_topLevelDomain = obj["topLevelDomain" ]as string; 
                if (__raw_topLevelDomain.length === 0) {
                    errors.push({ field: "topLevelDomain", message: "must not be empty" });
                }
 instance.topLevelDomain = __raw_topLevelDomain; }if(errors.length>0){throw new DeserializeError(errors);}return instance as EmailParts;}export function validateFieldEmailParts<K extends keyof EmailParts>(field: K, value: EmailParts[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "local" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "local", message: "must not be empty" });
                }
 break;}case "domainName" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "domainName", message: "must not be empty" });
                }
 break;}case "topLevelDomain" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "topLevelDomain", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsEmailParts(partial: Partial<EmailParts>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("local" in partial && partial.local!== undefined){const __val = partial.local as string; 
                if (__val.length === 0) {
                    errors.push({ field: "local", message: "must not be empty" });
                }
}if("domainName" in partial && partial.domainName!== undefined){const __val = partial.domainName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "domainName", message: "must not be empty" });
                }
}if("topLevelDomain" in partial && partial.topLevelDomain!== undefined){const __val = partial.topLevelDomain as string; 
                if (__val.length === 0) {
                    errors.push({ field: "topLevelDomain", message: "must not be empty" });
                }
}return errors; }export function hasShapeEmailParts(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "local" in o && "domainName" in o && "topLevelDomain" in o;}export function isEmailParts(obj: unknown): obj is EmailParts {if(!hasShapeEmailParts(obj)){return false;}const result = fromObjectEmailParts(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsEmailParts = {_errors: Option<Array<string>>; local: Option<Array<string>>;
            domainName: Option<Array<string>>;
            topLevelDomain: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedEmailParts = {local: Option<boolean>;
            domainName: Option<boolean>;
            topLevelDomain: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersEmailParts {readonly local: FieldController<string>;
            readonly domainName: FieldController<string>;
            readonly topLevelDomain: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformEmailParts {readonly data: EmailParts; readonly errors: ErrorsEmailParts; readonly tainted: TaintedEmailParts; readonly fields: FieldControllersEmailParts; validate(): Result<EmailParts, Array<{field: string; message: string}>>; reset(overrides?: Partial<EmailParts>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormEmailParts(overrides?: Partial<EmailParts>): GigaformEmailParts {let data = $state({...defaultValueEmailParts(),...overrides}); let errors = $state<ErrorsEmailParts>({ _errors: Option.none(), local: Option.none(), domainName: Option.none(), topLevelDomain: Option.none() }); let tainted = $state<TaintedEmailParts>({ local: Option.none(), domainName: Option.none(), topLevelDomain: Option.none() }); const fields: FieldControllersEmailParts = {local: {
                    path: ["local"] as const,
                    name: "local",
                    constraints: { required: true },
                    
                    get: () => data.local,
                    set: (value: string) => { data.local = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.local,
                    setError: (value: Option<Array<string>>) => { errors.local = value; },
                    getTainted: () => tainted.local,
                    setTainted: (value: Option<boolean>) => { tainted.local = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmailParts("local", data.local);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                domainName: {
                    path: ["domainName"] as const,
                    name: "domainName",
                    constraints: { required: true },
                    
                    get: () => data.domainName,
                    set: (value: string) => { data.domainName = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.domainName,
                    setError: (value: Option<Array<string>>) => { errors.domainName = value; },
                    getTainted: () => tainted.domainName,
                    setTainted: (value: Option<boolean>) => { tainted.domainName = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmailParts("domainName", data.domainName);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                topLevelDomain: {
                    path: ["topLevelDomain"] as const,
                    name: "topLevelDomain",
                    constraints: { required: true },
                    
                    get: () => data.topLevelDomain,
                    set: (value: string) => { data.topLevelDomain = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.topLevelDomain,
                    setError: (value: Option<Array<string>>) => { errors.topLevelDomain = value; },
                    getTainted: () => tainted.topLevelDomain,
                    setTainted: (value: Option<boolean>) => { tainted.topLevelDomain = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmailParts("topLevelDomain", data.topLevelDomain);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<EmailParts, Array<{field: string; message: string}>>{return fromObjectEmailParts(data);}function reset(newOverrides?: Partial<EmailParts>): void {data = {...defaultValueEmailParts(),...newOverrides}; errors = { _errors: Option.none(), local: Option.none(), domainName: Option.none(), topLevelDomain: Option.none() }; tainted = { local: Option.none(), domainName: Option.none(), topLevelDomain: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataEmailParts(formData: FormData): Result<EmailParts, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.local = formData.get("local") ?? "";
            obj.domainName = formData.get("domainName") ?? "";
            obj.topLevelDomain = formData.get("topLevelDomain") ?? ""; return fromStringifiedJSONEmailParts(JSON.stringify(obj));}


export interface Sent {
    recipient: string | null;
    method: string | null;
}

export function defaultValueSent(): Sent {return {recipient: null,
                            method: null, }as Sent;}

export function toStringifiedJSONSent(value: Sent): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeSent(value, ctx));}export function toObjectSent(value: Sent): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeSent(value, ctx);}export function __serializeSent(value: Sent, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Sent" , __id,}; result["recipient" ]= value.recipient; result["method" ]= value.method; return result;}

export function fromStringifiedJSONSent(json: string, opts?: DeserializeOptions): Result<Sent, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectSent(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectSent(obj: unknown, opts?: DeserializeOptions): Result<Sent, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeSent(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Sent.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeSent(value: any, ctx: DeserializeContext): Sent | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Sent.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("recipient" in obj)){errors.push({field: "recipient" , message: "missing required field" });}if(!("method" in obj)){errors.push({field: "method" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_recipient = obj["recipient" ]as string | null; instance.recipient = __raw_recipient; }{const __raw_method = obj["method" ]as string | null; instance.method = __raw_method; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Sent;}export function validateFieldSent<K extends keyof Sent>(field: K, value: Sent[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsSent(partial: Partial<Sent>): Array<{field: string; message: string}>{return[]; }export function hasShapeSent(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "recipient" in o && "method" in o;}export function isSent(obj: unknown): obj is Sent {if(!hasShapeSent(obj)){return false;}const result = fromObjectSent(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsSent = {_errors: Option<Array<string>>; recipient: Option<Array<string>>;
            method: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedSent = {recipient: Option<boolean>;
            method: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersSent {readonly recipient: FieldController<string | null>;
            readonly method: FieldController<string | null>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformSent {readonly data: Sent; readonly errors: ErrorsSent; readonly tainted: TaintedSent; readonly fields: FieldControllersSent; validate(): Result<Sent, Array<{field: string; message: string}>>; reset(overrides?: Partial<Sent>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormSent(overrides?: Partial<Sent>): GigaformSent {let data = $state({...defaultValueSent(),...overrides}); let errors = $state<ErrorsSent>({ _errors: Option.none(), recipient: Option.none(), method: Option.none() }); let tainted = $state<TaintedSent>({ recipient: Option.none(), method: Option.none() }); const fields: FieldControllersSent = {recipient: {
                    path: ["recipient"] as const,
                    name: "recipient",
                    constraints: { required: true },
                    
                    get: () => data.recipient,
                    set: (value: string | null) => { data.recipient = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.recipient,
                    setError: (value: Option<Array<string>>) => { errors.recipient = value; },
                    getTainted: () => tainted.recipient,
                    setTainted: (value: Option<boolean>) => { tainted.recipient = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSent("recipient", data.recipient);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                method: {
                    path: ["method"] as const,
                    name: "method",
                    constraints: { required: true },
                    
                    get: () => data.method,
                    set: (value: string | null) => { data.method = value; },
                    transform: (value: string | null): string | null => value,
                    getError: () => errors.method,
                    setError: (value: Option<Array<string>>) => { errors.method = value; },
                    getTainted: () => tainted.method,
                    setTainted: (value: Option<boolean>) => { tainted.method = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldSent("method", data.method);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Sent, Array<{field: string; message: string}>>{return fromObjectSent(data);}function reset(newOverrides?: Partial<Sent>): void {data = {...defaultValueSent(),...newOverrides}; errors = { _errors: Option.none(), recipient: Option.none(), method: Option.none() }; tainted = { recipient: Option.none(), method: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataSent(formData: FormData): Result<Sent, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.recipient = formData.get("recipient") ?? "";
            obj.method = formData.get("method") ?? ""; return fromStringifiedJSONSent(JSON.stringify(obj));}


export interface BilledItem {
    
    
    item: Item;
    
    quantity: number;
    
    taxed: boolean;
    
    upsale: boolean;
}

export function defaultValueBilledItem(): BilledItem {return {item: "",
                            quantity: 0,
                            taxed: false,
                            upsale: false, }as BilledItem;}

export function toStringifiedJSONBilledItem(value: BilledItem): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeBilledItem(value, ctx));}export function toObjectBilledItem(value: BilledItem): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeBilledItem(value, ctx);}export function __serializeBilledItem(value: BilledItem, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "BilledItem" , __id,}; result["item" ]= __serializeItem(value.item, ctx); result["quantity" ]= value.quantity; result["taxed" ]= value.taxed; result["upsale" ]= value.upsale; return result;}

export function fromStringifiedJSONBilledItem(json: string, opts?: DeserializeOptions): Result<BilledItem, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectBilledItem(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectBilledItem(obj: unknown, opts?: DeserializeOptions): Result<BilledItem, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeBilledItem(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "BilledItem.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeBilledItem(value: any, ctx: DeserializeContext): BilledItem | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "BilledItem.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("item" in obj)){errors.push({field: "item" , message: "missing required field" });}if(!("quantity" in obj)){errors.push({field: "quantity" , message: "missing required field" });}if(!("taxed" in obj)){errors.push({field: "taxed" , message: "missing required field" });}if(!("upsale" in obj)){errors.push({field: "upsale" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_item = obj["item" ]as Item; {const __result = __deserializeItem(__raw_item, ctx); ctx.assignOrDefer(instance, "item" , __result);}}{const __raw_quantity = obj["quantity" ]as number; instance.quantity = __raw_quantity; }{const __raw_taxed = obj["taxed" ]as boolean; instance.taxed = __raw_taxed; }{const __raw_upsale = obj["upsale" ]as boolean; instance.upsale = __raw_upsale; }if(errors.length>0){throw new DeserializeError(errors);}return instance as BilledItem;}export function validateFieldBilledItem<K extends keyof BilledItem>(field: K, value: BilledItem[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsBilledItem(partial: Partial<BilledItem>): Array<{field: string; message: string}>{return[]; }export function hasShapeBilledItem(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "item" in o && "quantity" in o && "taxed" in o && "upsale" in o;}export function isBilledItem(obj: unknown): obj is BilledItem {if(!hasShapeBilledItem(obj)){return false;}const result = fromObjectBilledItem(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsBilledItem = {_errors: Option<Array<string>>; item: Option<Array<string>>;
            quantity: Option<Array<string>>;
            taxed: Option<Array<string>>;
            upsale: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedBilledItem = {item: Option<boolean>;
            quantity: Option<boolean>;
            taxed: Option<boolean>;
            upsale: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersBilledItem {readonly item: FieldController<Item>;
            readonly quantity: FieldController<number>;
            readonly taxed: FieldController<boolean>;
            readonly upsale: FieldController<boolean>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformBilledItem {readonly data: BilledItem; readonly errors: ErrorsBilledItem; readonly tainted: TaintedBilledItem; readonly fields: FieldControllersBilledItem; validate(): Result<BilledItem, Array<{field: string; message: string}>>; reset(overrides?: Partial<BilledItem>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormBilledItem(overrides?: Partial<BilledItem>): GigaformBilledItem {let data = $state({...defaultValueBilledItem(),...overrides}); let errors = $state<ErrorsBilledItem>({ _errors: Option.none(), item: Option.none(), quantity: Option.none(), taxed: Option.none(), upsale: Option.none() }); let tainted = $state<TaintedBilledItem>({ item: Option.none(), quantity: Option.none(), taxed: Option.none(), upsale: Option.none() }); const fields: FieldControllersBilledItem = {item: {
                    path: ["item"] as const,
                    name: "item",
                    constraints: { required: true },
                    label: "Item",
                    get: () => data.item,
                    set: (value: Item) => { data.item = value; },
                    transform: (value: Item): Item => value,
                    getError: () => errors.item,
                    setError: (value: Option<Array<string>>) => { errors.item = value; },
                    getTainted: () => tainted.item,
                    setTainted: (value: Option<boolean>) => { tainted.item = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldBilledItem("item", data.item);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                quantity: {
                    path: ["quantity"] as const,
                    name: "quantity",
                    constraints: { required: true },
                    label: "Quantity",
                    get: () => data.quantity,
                    set: (value: number) => { data.quantity = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.quantity,
                    setError: (value: Option<Array<string>>) => { errors.quantity = value; },
                    getTainted: () => tainted.quantity,
                    setTainted: (value: Option<boolean>) => { tainted.quantity = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldBilledItem("quantity", data.quantity);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                taxed: {
                    path: ["taxed"] as const,
                    name: "taxed",
                    constraints: { required: true },
                    label: "Taxed",
                    get: () => data.taxed,
                    set: (value: boolean) => { data.taxed = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.taxed,
                    setError: (value: Option<Array<string>>) => { errors.taxed = value; },
                    getTainted: () => tainted.taxed,
                    setTainted: (value: Option<boolean>) => { tainted.taxed = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldBilledItem("taxed", data.taxed);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                upsale: {
                    path: ["upsale"] as const,
                    name: "upsale",
                    constraints: { required: true },
                    label: "Upsale",
                    get: () => data.upsale,
                    set: (value: boolean) => { data.upsale = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.upsale,
                    setError: (value: Option<Array<string>>) => { errors.upsale = value; },
                    getTainted: () => tainted.upsale,
                    setTainted: (value: Option<boolean>) => { tainted.upsale = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldBilledItem("upsale", data.upsale);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<BilledItem, Array<{field: string; message: string}>>{return fromObjectBilledItem(data);}function reset(newOverrides?: Partial<BilledItem>): void {data = {...defaultValueBilledItem(),...newOverrides}; errors = { _errors: Option.none(), item: Option.none(), quantity: Option.none(), taxed: Option.none(), upsale: Option.none() }; tainted = { item: Option.none(), quantity: Option.none(), taxed: Option.none(), upsale: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataBilledItem(formData: FormData): Result<BilledItem, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
            // Collect nested object fields with prefix "item."
            const itemObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("item.")) {
                    const fieldName = key.slice("item.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = itemObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.item = itemObj;
        }
            {
                const quantityStr = formData.get("quantity");
                obj.quantity = quantityStr ? parseFloat(quantityStr as string) : 0;
                if (obj.quantity !== undefined && isNaN(obj.quantity as number)) obj.quantity = 0;
            }
            {
                const taxedVal = formData.get("taxed");
                obj.taxed = taxedVal === "true" || taxedVal === "on" || taxedVal === "1";
            }
            {
                const upsaleVal = formData.get("upsale");
                obj.upsale = upsaleVal === "true" || upsaleVal === "on" || upsaleVal === "1";
            } return fromStringifiedJSONBilledItem(JSON.stringify(obj));}


export interface Coordinates {
    lat: number;
    lng: number;
}

export function defaultValueCoordinates(): Coordinates {return {lat: 0,
                            lng: 0, }as Coordinates;}

export function toStringifiedJSONCoordinates(value: Coordinates): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeCoordinates(value, ctx));}export function toObjectCoordinates(value: Coordinates): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeCoordinates(value, ctx);}export function __serializeCoordinates(value: Coordinates, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Coordinates" , __id,}; result["lat" ]= value.lat; result["lng" ]= value.lng; return result;}

export function fromStringifiedJSONCoordinates(json: string, opts?: DeserializeOptions): Result<Coordinates, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectCoordinates(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectCoordinates(obj: unknown, opts?: DeserializeOptions): Result<Coordinates, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeCoordinates(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Coordinates.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeCoordinates(value: any, ctx: DeserializeContext): Coordinates | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Coordinates.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("lat" in obj)){errors.push({field: "lat" , message: "missing required field" });}if(!("lng" in obj)){errors.push({field: "lng" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_lat = obj["lat" ]as number; instance.lat = __raw_lat; }{const __raw_lng = obj["lng" ]as number; instance.lng = __raw_lng; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Coordinates;}export function validateFieldCoordinates<K extends keyof Coordinates>(field: K, value: Coordinates[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsCoordinates(partial: Partial<Coordinates>): Array<{field: string; message: string}>{return[]; }export function hasShapeCoordinates(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "lat" in o && "lng" in o;}export function isCoordinates(obj: unknown): obj is Coordinates {if(!hasShapeCoordinates(obj)){return false;}const result = fromObjectCoordinates(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsCoordinates = {_errors: Option<Array<string>>; lat: Option<Array<string>>;
            lng: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedCoordinates = {lat: Option<boolean>;
            lng: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersCoordinates {readonly lat: FieldController<number>;
            readonly lng: FieldController<number>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformCoordinates {readonly data: Coordinates; readonly errors: ErrorsCoordinates; readonly tainted: TaintedCoordinates; readonly fields: FieldControllersCoordinates; validate(): Result<Coordinates, Array<{field: string; message: string}>>; reset(overrides?: Partial<Coordinates>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormCoordinates(overrides?: Partial<Coordinates>): GigaformCoordinates {let data = $state({...defaultValueCoordinates(),...overrides}); let errors = $state<ErrorsCoordinates>({ _errors: Option.none(), lat: Option.none(), lng: Option.none() }); let tainted = $state<TaintedCoordinates>({ lat: Option.none(), lng: Option.none() }); const fields: FieldControllersCoordinates = {lat: {
                    path: ["lat"] as const,
                    name: "lat",
                    constraints: { required: true },
                    
                    get: () => data.lat,
                    set: (value: number) => { data.lat = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.lat,
                    setError: (value: Option<Array<string>>) => { errors.lat = value; },
                    getTainted: () => tainted.lat,
                    setTainted: (value: Option<boolean>) => { tainted.lat = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCoordinates("lat", data.lat);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                lng: {
                    path: ["lng"] as const,
                    name: "lng",
                    constraints: { required: true },
                    
                    get: () => data.lng,
                    set: (value: number) => { data.lng = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.lng,
                    setError: (value: Option<Array<string>>) => { errors.lng = value; },
                    getTainted: () => tainted.lng,
                    setTainted: (value: Option<boolean>) => { tainted.lng = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCoordinates("lng", data.lng);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Coordinates, Array<{field: string; message: string}>>{return fromObjectCoordinates(data);}function reset(newOverrides?: Partial<Coordinates>): void {data = {...defaultValueCoordinates(),...newOverrides}; errors = { _errors: Option.none(), lat: Option.none(), lng: Option.none() }; tainted = { lat: Option.none(), lng: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataCoordinates(formData: FormData): Result<Coordinates, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const latStr = formData.get("lat");
                obj.lat = latStr ? parseFloat(latStr as string) : 0;
                if (obj.lat !== undefined && isNaN(obj.lat as number)) obj.lat = 0;
            }
            {
                const lngStr = formData.get("lng");
                obj.lng = lngStr ? parseFloat(lngStr as string) : 0;
                if (obj.lng !== undefined && isNaN(obj.lng as number)) obj.lng = 0;
            } return fromStringifiedJSONCoordinates(JSON.stringify(obj));}


export interface Ordered {
    id: string;
    
    in: string | Account;
    
    out: string | Order;
    date: string;
}

export function defaultValueOrdered(): Ordered {return {id: "",
                            in: "",
                            out: "",
                            date: "", }as Ordered;}

export function toStringifiedJSONOrdered(value: Ordered): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeOrdered(value, ctx));}export function toObjectOrdered(value: Ordered): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeOrdered(value, ctx);}export function __serializeOrdered(value: Ordered, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Ordered" , __id,}; result["id" ]= value.id; result["in" ]= value.in; result["out" ]= value.out; result["date" ]= value.date; return result;}

export function fromStringifiedJSONOrdered(json: string, opts?: DeserializeOptions): Result<Ordered, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectOrdered(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectOrdered(obj: unknown, opts?: DeserializeOptions): Result<Ordered, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeOrdered(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Ordered.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeOrdered(value: any, ctx: DeserializeContext): Ordered | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Ordered.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("in" in obj)){errors.push({field: "in" , message: "missing required field" });}if(!("out" in obj)){errors.push({field: "out" , message: "missing required field" });}if(!("date" in obj)){errors.push({field: "date" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_in = obj["in" ]as string | Account; instance.in = __raw_in; }{const __raw_out = obj["out" ]as string | Order; instance.out = __raw_out; }{const __raw_date = obj["date" ]as string; instance.date = __raw_date; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Ordered;}export function validateFieldOrdered<K extends keyof Ordered>(field: K, value: Ordered[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsOrdered(partial: Partial<Ordered>): Array<{field: string; message: string}>{return[]; }export function hasShapeOrdered(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "in" in o && "out" in o && "date" in o;}export function isOrdered(obj: unknown): obj is Ordered {if(!hasShapeOrdered(obj)){return false;}const result = fromObjectOrdered(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsOrdered = {_errors: Option<Array<string>>; id: Option<Array<string>>;
            in: Option<Array<string>>;
            out: Option<Array<string>>;
            date: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedOrdered = {id: Option<boolean>;
            in: Option<boolean>;
            out: Option<boolean>;
            date: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersOrdered {readonly id: FieldController<string>;
            readonly in: FieldController<string | Account>;
            readonly out: FieldController<string | Order>;
            readonly date: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformOrdered {readonly data: Ordered; readonly errors: ErrorsOrdered; readonly tainted: TaintedOrdered; readonly fields: FieldControllersOrdered; validate(): Result<Ordered, Array<{field: string; message: string}>>; reset(overrides?: Partial<Ordered>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormOrdered(overrides?: Partial<Ordered>): GigaformOrdered {let data = $state({...defaultValueOrdered(),...overrides}); let errors = $state<ErrorsOrdered>({ _errors: Option.none(), id: Option.none(), in: Option.none(), out: Option.none(), date: Option.none() }); let tainted = $state<TaintedOrdered>({ id: Option.none(), in: Option.none(), out: Option.none(), date: Option.none() }); const fields: FieldControllersOrdered = {id: {
                    path: ["id"] as const,
                    name: "id",
                    constraints: { required: true },
                    
                    get: () => data.id,
                    set: (value: string) => { data.id = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.id,
                    setError: (value: Option<Array<string>>) => { errors.id = value; },
                    getTainted: () => tainted.id,
                    setTainted: (value: Option<boolean>) => { tainted.id = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrdered("id", data.id);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                in: {
                    path: ["in"] as const,
                    name: "in",
                    constraints: { required: true },
                    
                    get: () => data.in,
                    set: (value: string | Account) => { data.in = value; },
                    transform: (value: string | Account): string | Account => value,
                    getError: () => errors.in,
                    setError: (value: Option<Array<string>>) => { errors.in = value; },
                    getTainted: () => tainted.in,
                    setTainted: (value: Option<boolean>) => { tainted.in = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrdered("in", data.in);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                out: {
                    path: ["out"] as const,
                    name: "out",
                    constraints: { required: true },
                    
                    get: () => data.out,
                    set: (value: string | Order) => { data.out = value; },
                    transform: (value: string | Order): string | Order => value,
                    getError: () => errors.out,
                    setError: (value: Option<Array<string>>) => { errors.out = value; },
                    getTainted: () => tainted.out,
                    setTainted: (value: Option<boolean>) => { tainted.out = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrdered("out", data.out);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                date: {
                    path: ["date"] as const,
                    name: "date",
                    constraints: { required: true },
                    
                    get: () => data.date,
                    set: (value: string) => { data.date = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.date,
                    setError: (value: Option<Array<string>>) => { errors.date = value; },
                    getTainted: () => tainted.date,
                    setTainted: (value: Option<boolean>) => { tainted.date = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldOrdered("date", data.date);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Ordered, Array<{field: string; message: string}>>{return fromObjectOrdered(data);}function reset(newOverrides?: Partial<Ordered>): void {data = {...defaultValueOrdered(),...newOverrides}; errors = { _errors: Option.none(), id: Option.none(), in: Option.none(), out: Option.none(), date: Option.none() }; tainted = { id: Option.none(), in: Option.none(), out: Option.none(), date: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataOrdered(formData: FormData): Result<Ordered, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id") ?? "";
            obj.in = formData.get("in") ?? "";
            obj.out = formData.get("out") ?? "";
            obj.date = formData.get("date") ?? ""; return fromStringifiedJSONOrdered(JSON.stringify(obj));}


export interface Email {
    
    canEmail: boolean;
    
    
    emailString: string;
}

export function defaultValueEmail(): Email {return {canEmail: false,
                            emailString: "", }as Email;}

export function toStringifiedJSONEmail(value: Email): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeEmail(value, ctx));}export function toObjectEmail(value: Email): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeEmail(value, ctx);}export function __serializeEmail(value: Email, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Email" , __id,}; result["canEmail" ]= value.canEmail; result["emailString" ]= value.emailString; return result;}

export function fromStringifiedJSONEmail(json: string, opts?: DeserializeOptions): Result<Email, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectEmail(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectEmail(obj: unknown, opts?: DeserializeOptions): Result<Email, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeEmail(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Email.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeEmail(value: any, ctx: DeserializeContext): Email | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Email.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("canEmail" in obj)){errors.push({field: "canEmail" , message: "missing required field" });}if(!("emailString" in obj)){errors.push({field: "emailString" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_canEmail = obj["canEmail" ]as boolean; instance.canEmail = __raw_canEmail; }{const __raw_emailString = obj["emailString" ]as string; 
                if (__raw_emailString.length === 0) {
                    errors.push({ field: "emailString", message: "must not be empty" });
                }

                if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__raw_emailString)) {
                    errors.push({ field: "emailString", message: "must be a valid email" });
                }
 instance.emailString = __raw_emailString; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Email;}export function validateFieldEmail<K extends keyof Email>(field: K, value: Email[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "emailString" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "emailString", message: "must not be empty" });
                }

                if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__val)) {
                    errors.push({ field: "emailString", message: "must be a valid email" });
                }
 break;}}return errors; }export function validateFieldsEmail(partial: Partial<Email>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("emailString" in partial && partial.emailString!== undefined){const __val = partial.emailString as string; 
                if (__val.length === 0) {
                    errors.push({ field: "emailString", message: "must not be empty" });
                }

                if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__val)) {
                    errors.push({ field: "emailString", message: "must be a valid email" });
                }
}return errors; }export function hasShapeEmail(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "canEmail" in o && "emailString" in o;}export function isEmail(obj: unknown): obj is Email {if(!hasShapeEmail(obj)){return false;}const result = fromObjectEmail(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsEmail = {_errors: Option<Array<string>>; canEmail: Option<Array<string>>;
            emailString: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedEmail = {canEmail: Option<boolean>;
            emailString: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersEmail {readonly canEmail: FieldController<boolean>;
            readonly emailString: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformEmail {readonly data: Email; readonly errors: ErrorsEmail; readonly tainted: TaintedEmail; readonly fields: FieldControllersEmail; validate(): Result<Email, Array<{field: string; message: string}>>; reset(overrides?: Partial<Email>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormEmail(overrides?: Partial<Email>): GigaformEmail {let data = $state({...defaultValueEmail(),...overrides}); let errors = $state<ErrorsEmail>({ _errors: Option.none(), canEmail: Option.none(), emailString: Option.none() }); let tainted = $state<TaintedEmail>({ canEmail: Option.none(), emailString: Option.none() }); const fields: FieldControllersEmail = {canEmail: {
                    path: ["canEmail"] as const,
                    name: "canEmail",
                    constraints: { required: true },
                    label: "Can Email",
                    get: () => data.canEmail,
                    set: (value: boolean) => { data.canEmail = value; },
                    transform: (value: boolean): boolean => value,
                    getError: () => errors.canEmail,
                    setError: (value: Option<Array<string>>) => { errors.canEmail = value; },
                    getTainted: () => tainted.canEmail,
                    setTainted: (value: Option<boolean>) => { tainted.canEmail = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmail("canEmail", data.canEmail);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                emailString: {
                    path: ["emailString"] as const,
                    name: "emailString",
                    constraints: { required: true, type: "email" },
                    label: "Email",
                    get: () => data.emailString,
                    set: (value: string) => { data.emailString = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.emailString,
                    setError: (value: Option<Array<string>>) => { errors.emailString = value; },
                    getTainted: () => tainted.emailString,
                    setTainted: (value: Option<boolean>) => { tainted.emailString = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldEmail("emailString", data.emailString);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Email, Array<{field: string; message: string}>>{return fromObjectEmail(data);}function reset(newOverrides?: Partial<Email>): void {data = {...defaultValueEmail(),...newOverrides}; errors = { _errors: Option.none(), canEmail: Option.none(), emailString: Option.none() }; tainted = { canEmail: Option.none(), emailString: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataEmail(formData: FormData): Result<Email, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const canEmailVal = formData.get("canEmail");
                obj.canEmail = canEmailVal === "true" || canEmailVal === "on" || canEmailVal === "1";
            }
            obj.emailString = formData.get("emailString") ?? ""; return fromStringifiedJSONEmail(JSON.stringify(obj));}


export interface RecurrenceRule {
    interval: Interval;
    recurrenceBegins: string;
    recurrenceEnds: RecurrenceEnd | null;
    cancelledInstances: string[] | null;
    additionalInstances: string[] | null;
}

export function defaultValueRecurrenceRule(): RecurrenceRule {return {interval: defaultValueInterval(),
                            recurrenceBegins: "",
                            recurrenceEnds: null,
                            cancelledInstances: null,
                            additionalInstances: null, }as RecurrenceRule;}

export function toStringifiedJSONRecurrenceRule(value: RecurrenceRule): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeRecurrenceRule(value, ctx));}export function toObjectRecurrenceRule(value: RecurrenceRule): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeRecurrenceRule(value, ctx);}export function __serializeRecurrenceRule(value: RecurrenceRule, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "RecurrenceRule" , __id,}; result["interval" ]= __serializeInterval(value.interval, ctx); result["recurrenceBegins" ]= value.recurrenceBegins; if(value.recurrenceEnds!== null){result["recurrenceEnds" ]= __serializeRecurrenceEnd(value.recurrenceEnds, ctx); }else {result["recurrenceEnds" ]= null;}if(value.cancelledInstances!== null){result["cancelledInstances" ]= value.cancelledInstances; }else {result["cancelledInstances" ]= null;}if(value.additionalInstances!== null){result["additionalInstances" ]= value.additionalInstances; }else {result["additionalInstances" ]= null;}return result;}

export function fromStringifiedJSONRecurrenceRule(json: string, opts?: DeserializeOptions): Result<RecurrenceRule, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectRecurrenceRule(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectRecurrenceRule(obj: unknown, opts?: DeserializeOptions): Result<RecurrenceRule, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeRecurrenceRule(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "RecurrenceRule.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeRecurrenceRule(value: any, ctx: DeserializeContext): RecurrenceRule | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "RecurrenceRule.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("interval" in obj)){errors.push({field: "interval" , message: "missing required field" });}if(!("recurrenceBegins" in obj)){errors.push({field: "recurrenceBegins" , message: "missing required field" });}if(!("recurrenceEnds" in obj)){errors.push({field: "recurrenceEnds" , message: "missing required field" });}if(!("cancelledInstances" in obj)){errors.push({field: "cancelledInstances" , message: "missing required field" });}if(!("additionalInstances" in obj)){errors.push({field: "additionalInstances" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_interval = obj["interval" ]as Interval; {const __result = __deserializeInterval(__raw_interval, ctx); ctx.assignOrDefer(instance, "interval" , __result);}}{const __raw_recurrenceBegins = obj["recurrenceBegins" ]as string; instance.recurrenceBegins = __raw_recurrenceBegins; }{const __raw_recurrenceEnds = obj["recurrenceEnds" ]as RecurrenceEnd | null; if(__raw_recurrenceEnds === null){instance.recurrenceEnds = null;}else {const __result = __deserializeRecurrenceEnd(__raw_recurrenceEnds, ctx); ctx.assignOrDefer(instance, "recurrenceEnds" , __result); }}{const __raw_cancelledInstances = obj["cancelledInstances" ]as string[] | null; if(__raw_cancelledInstances === null){instance.cancelledInstances = null;}else {instance.cancelledInstances = __raw_cancelledInstances; }}{const __raw_additionalInstances = obj["additionalInstances" ]as string[] | null; if(__raw_additionalInstances === null){instance.additionalInstances = null;}else {instance.additionalInstances = __raw_additionalInstances; }}if(errors.length>0){throw new DeserializeError(errors);}return instance as RecurrenceRule;}export function validateFieldRecurrenceRule<K extends keyof RecurrenceRule>(field: K, value: RecurrenceRule[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsRecurrenceRule(partial: Partial<RecurrenceRule>): Array<{field: string; message: string}>{return[]; }export function hasShapeRecurrenceRule(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "interval" in o && "recurrenceBegins" in o && "recurrenceEnds" in o && "cancelledInstances" in o && "additionalInstances" in o;}export function isRecurrenceRule(obj: unknown): obj is RecurrenceRule {if(!hasShapeRecurrenceRule(obj)){return false;}const result = fromObjectRecurrenceRule(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsRecurrenceRule = {_errors: Option<Array<string>>; interval: Option<Array<string>>;
            recurrenceBegins: Option<Array<string>>;
            recurrenceEnds: Option<Array<string>>;
            cancelledInstances: Option<Array<string>>;
            additionalInstances: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedRecurrenceRule = {interval: Option<boolean>;
            recurrenceBegins: Option<boolean>;
            recurrenceEnds: Option<boolean>;
            cancelledInstances: Option<boolean>;
            additionalInstances: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersRecurrenceRule {readonly interval: FieldController<Interval>;
            readonly recurrenceBegins: FieldController<string>;
            readonly recurrenceEnds: FieldController<RecurrenceEnd | null>;
            readonly cancelledInstances: FieldController<string[] | null>;
            readonly additionalInstances: FieldController<string[] | null>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformRecurrenceRule {readonly data: RecurrenceRule; readonly errors: ErrorsRecurrenceRule; readonly tainted: TaintedRecurrenceRule; readonly fields: FieldControllersRecurrenceRule; validate(): Result<RecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<RecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormRecurrenceRule(overrides?: Partial<RecurrenceRule>): GigaformRecurrenceRule {let data = $state({...defaultValueRecurrenceRule(),...overrides}); let errors = $state<ErrorsRecurrenceRule>({ _errors: Option.none(), interval: Option.none(), recurrenceBegins: Option.none(), recurrenceEnds: Option.none(), cancelledInstances: Option.none(), additionalInstances: Option.none() }); let tainted = $state<TaintedRecurrenceRule>({ interval: Option.none(), recurrenceBegins: Option.none(), recurrenceEnds: Option.none(), cancelledInstances: Option.none(), additionalInstances: Option.none() }); const fields: FieldControllersRecurrenceRule = {interval: {
                    path: ["interval"] as const,
                    name: "interval",
                    constraints: { required: true },
                    
                    get: () => data.interval,
                    set: (value: Interval) => { data.interval = value; },
                    transform: (value: Interval): Interval => value,
                    getError: () => errors.interval,
                    setError: (value: Option<Array<string>>) => { errors.interval = value; },
                    getTainted: () => tainted.interval,
                    setTainted: (value: Option<boolean>) => { tainted.interval = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRecurrenceRule("interval", data.interval);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                recurrenceBegins: {
                    path: ["recurrenceBegins"] as const,
                    name: "recurrenceBegins",
                    constraints: { required: true },
                    
                    get: () => data.recurrenceBegins,
                    set: (value: string) => { data.recurrenceBegins = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.recurrenceBegins,
                    setError: (value: Option<Array<string>>) => { errors.recurrenceBegins = value; },
                    getTainted: () => tainted.recurrenceBegins,
                    setTainted: (value: Option<boolean>) => { tainted.recurrenceBegins = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRecurrenceRule("recurrenceBegins", data.recurrenceBegins);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                recurrenceEnds: {
                    path: ["recurrenceEnds"] as const,
                    name: "recurrenceEnds",
                    constraints: { required: true },
                    
                    get: () => data.recurrenceEnds,
                    set: (value: RecurrenceEnd | null) => { data.recurrenceEnds = value; },
                    transform: (value: RecurrenceEnd | null): RecurrenceEnd | null => value,
                    getError: () => errors.recurrenceEnds,
                    setError: (value: Option<Array<string>>) => { errors.recurrenceEnds = value; },
                    getTainted: () => tainted.recurrenceEnds,
                    setTainted: (value: Option<boolean>) => { tainted.recurrenceEnds = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRecurrenceRule("recurrenceEnds", data.recurrenceEnds);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                cancelledInstances: {
                    path: ["cancelledInstances"] as const,
                    name: "cancelledInstances",
                    constraints: { required: true },
                    
                    get: () => data.cancelledInstances,
                    set: (value: string[] | null) => { data.cancelledInstances = value; },
                    transform: (value: string[] | null): string[] | null => value,
                    getError: () => errors.cancelledInstances,
                    setError: (value: Option<Array<string>>) => { errors.cancelledInstances = value; },
                    getTainted: () => tainted.cancelledInstances,
                    setTainted: (value: Option<boolean>) => { tainted.cancelledInstances = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRecurrenceRule("cancelledInstances", data.cancelledInstances);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                additionalInstances: {
                    path: ["additionalInstances"] as const,
                    name: "additionalInstances",
                    constraints: { required: true },
                    
                    get: () => data.additionalInstances,
                    set: (value: string[] | null) => { data.additionalInstances = value; },
                    transform: (value: string[] | null): string[] | null => value,
                    getError: () => errors.additionalInstances,
                    setError: (value: Option<Array<string>>) => { errors.additionalInstances = value; },
                    getTainted: () => tainted.additionalInstances,
                    setTainted: (value: Option<boolean>) => { tainted.additionalInstances = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldRecurrenceRule("additionalInstances", data.additionalInstances);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<RecurrenceRule, Array<{field: string; message: string}>>{return fromObjectRecurrenceRule(data);}function reset(newOverrides?: Partial<RecurrenceRule>): void {data = {...defaultValueRecurrenceRule(),...newOverrides}; errors = { _errors: Option.none(), interval: Option.none(), recurrenceBegins: Option.none(), recurrenceEnds: Option.none(), cancelledInstances: Option.none(), additionalInstances: Option.none() }; tainted = { interval: Option.none(), recurrenceBegins: Option.none(), recurrenceEnds: Option.none(), cancelledInstances: Option.none(), additionalInstances: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataRecurrenceRule(formData: FormData): Result<RecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
            // Collect nested object fields with prefix "interval."
            const intervalObj: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("interval.")) {
                    const fieldName = key.slice("interval.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = intervalObj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.interval = intervalObj;
        }
            obj.recurrenceBegins = formData.get("recurrenceBegins") ?? "";
            obj.recurrenceEnds = formData.get("recurrenceEnds") ?? "";
            obj.cancelledInstances = formData.get("cancelledInstances") ?? "";
            obj.additionalInstances = formData.get("additionalInstances") ?? ""; return fromStringifiedJSONRecurrenceRule(JSON.stringify(obj));}


export interface LastName {
    
    name: string;
}

export function defaultValueLastName(): LastName {return {name: "", }as LastName;}

export function toStringifiedJSONLastName(value: LastName): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeLastName(value, ctx));}export function toObjectLastName(value: LastName): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeLastName(value, ctx);}export function __serializeLastName(value: LastName, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "LastName" , __id,}; result["name" ]= value.name; return result;}

export function fromStringifiedJSONLastName(json: string, opts?: DeserializeOptions): Result<LastName, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectLastName(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectLastName(obj: unknown, opts?: DeserializeOptions): Result<LastName, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeLastName(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "LastName.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeLastName(value: any, ctx: DeserializeContext): LastName | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "LastName.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }if(errors.length>0){throw new DeserializeError(errors);}return instance as LastName;}export function validateFieldLastName<K extends keyof LastName>(field: K, value: LastName[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(field){case "name" : {const __val = value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}}return errors; }export function validateFieldsLastName(partial: Partial<LastName>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in partial && partial.name!== undefined){const __val = partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}return errors; }export function hasShapeLastName(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "name" in o;}export function isLastName(obj: unknown): obj is LastName {if(!hasShapeLastName(obj)){return false;}const result = fromObjectLastName(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsLastName = {_errors: Option<Array<string>>; name: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedLastName = {name: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersLastName {readonly name: FieldController<string>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformLastName {readonly data: LastName; readonly errors: ErrorsLastName; readonly tainted: TaintedLastName; readonly fields: FieldControllersLastName; validate(): Result<LastName, Array<{field: string; message: string}>>; reset(overrides?: Partial<LastName>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormLastName(overrides?: Partial<LastName>): GigaformLastName {let data = $state({...defaultValueLastName(),...overrides}); let errors = $state<ErrorsLastName>({ _errors: Option.none(), name: Option.none() }); let tainted = $state<TaintedLastName>({ name: Option.none() }); const fields: FieldControllersLastName = {name: {
                    path: ["name"] as const,
                    name: "name",
                    constraints: { required: true },
                    
                    get: () => data.name,
                    set: (value: string) => { data.name = value; },
                    transform: (value: string): string => value,
                    getError: () => errors.name,
                    setError: (value: Option<Array<string>>) => { errors.name = value; },
                    getTainted: () => tainted.name,
                    setTainted: (value: Option<boolean>) => { tainted.name = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldLastName("name", data.name);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<LastName, Array<{field: string; message: string}>>{return fromObjectLastName(data);}function reset(newOverrides?: Partial<LastName>): void {data = {...defaultValueLastName(),...newOverrides}; errors = { _errors: Option.none(), name: Option.none() }; tainted = { name: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataLastName(formData: FormData): Result<LastName, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.name = formData.get("name") ?? ""; return fromStringifiedJSONLastName(JSON.stringify(obj));}


export interface Cardinal {
    north: number;
    east: number;
    south: number;
    west: number;
}

export function defaultValueCardinal(): Cardinal {return {north: 0,
                            east: 0,
                            south: 0,
                            west: 0, }as Cardinal;}

export function toStringifiedJSONCardinal(value: Cardinal): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeCardinal(value, ctx));}export function toObjectCardinal(value: Cardinal): Record<string, unknown>{const ctx = SerializeContext.create(); return __serializeCardinal(value, ctx);}export function __serializeCardinal(value: Cardinal, ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Cardinal" , __id,}; result["north" ]= value.north; result["east" ]= value.east; result["south" ]= value.south; result["west" ]= value.west; return result;}

export function fromStringifiedJSONCardinal(json: string, opts?: DeserializeOptions): Result<Cardinal, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectCardinal(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectCardinal(obj: unknown, opts?: DeserializeOptions): Result<Cardinal, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeCardinal(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Cardinal.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeCardinal(value: any, ctx: DeserializeContext): Cardinal | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new DeserializeError([{field: "_root" , message: "Cardinal.__deserialize: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("north" in obj)){errors.push({field: "north" , message: "missing required field" });}if(!("east" in obj)){errors.push({field: "east" , message: "missing required field" });}if(!("south" in obj)){errors.push({field: "south" , message: "missing required field" });}if(!("west" in obj)){errors.push({field: "west" , message: "missing required field" });}if(errors.length>0){throw new DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_north = obj["north" ]as number; instance.north = __raw_north; }{const __raw_east = obj["east" ]as number; instance.east = __raw_east; }{const __raw_south = obj["south" ]as number; instance.south = __raw_south; }{const __raw_west = obj["west" ]as number; instance.west = __raw_west; }if(errors.length>0){throw new DeserializeError(errors);}return instance as Cardinal;}export function validateFieldCardinal<K extends keyof Cardinal>(field: K, value: Cardinal[K]): Array<{field: string; message: string}>{return[]; }export function validateFieldsCardinal(partial: Partial<Cardinal>): Array<{field: string; message: string}>{return[]; }export function hasShapeCardinal(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "north" in o && "east" in o && "south" in o && "west" in o;}export function isCardinal(obj: unknown): obj is Cardinal {if(!hasShapeCardinal(obj)){return false;}const result = fromObjectCardinal(obj); return Result.isOk(result);}

/** Nested error structure matching the data shape */export type ErrorsCardinal = {_errors: Option<Array<string>>; north: Option<Array<string>>;
            east: Option<Array<string>>;
            south: Option<Array<string>>;
            west: Option<Array<string>>;}; /** Nested boolean structure for tracking touched/dirty fields */export type TaintedCardinal = {north: Option<boolean>;
            east: Option<boolean>;
            south: Option<boolean>;
            west: Option<boolean>;}; /** Type-safe field controllers for this form */export interface FieldControllersCardinal {readonly north: FieldController<number>;
            readonly east: FieldController<number>;
            readonly south: FieldController<number>;
            readonly west: FieldController<number>;}/** Gigaform instance containing reactive state and field controllers */export interface GigaformCardinal {readonly data: Cardinal; readonly errors: ErrorsCardinal; readonly tainted: TaintedCardinal; readonly fields: FieldControllersCardinal; validate(): Result<Cardinal, Array<{field: string; message: string}>>; reset(overrides?: Partial<Cardinal>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createFormCardinal(overrides?: Partial<Cardinal>): GigaformCardinal {let data = $state({...defaultValueCardinal(),...overrides}); let errors = $state<ErrorsCardinal>({ _errors: Option.none(), north: Option.none(), east: Option.none(), south: Option.none(), west: Option.none() }); let tainted = $state<TaintedCardinal>({ north: Option.none(), east: Option.none(), south: Option.none(), west: Option.none() }); const fields: FieldControllersCardinal = {north: {
                    path: ["north"] as const,
                    name: "north",
                    constraints: { required: true },
                    
                    get: () => data.north,
                    set: (value: number) => { data.north = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.north,
                    setError: (value: Option<Array<string>>) => { errors.north = value; },
                    getTainted: () => tainted.north,
                    setTainted: (value: Option<boolean>) => { tainted.north = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCardinal("north", data.north);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                east: {
                    path: ["east"] as const,
                    name: "east",
                    constraints: { required: true },
                    
                    get: () => data.east,
                    set: (value: number) => { data.east = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.east,
                    setError: (value: Option<Array<string>>) => { errors.east = value; },
                    getTainted: () => tainted.east,
                    setTainted: (value: Option<boolean>) => { tainted.east = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCardinal("east", data.east);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                south: {
                    path: ["south"] as const,
                    name: "south",
                    constraints: { required: true },
                    
                    get: () => data.south,
                    set: (value: number) => { data.south = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.south,
                    setError: (value: Option<Array<string>>) => { errors.south = value; },
                    getTainted: () => tainted.south,
                    setTainted: (value: Option<boolean>) => { tainted.south = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCardinal("south", data.south);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                },
                west: {
                    path: ["west"] as const,
                    name: "west",
                    constraints: { required: true },
                    
                    get: () => data.west,
                    set: (value: number) => { data.west = value; },
                    transform: (value: number): number => value,
                    getError: () => errors.west,
                    setError: (value: Option<Array<string>>) => { errors.west = value; },
                    getTainted: () => tainted.west,
                    setTainted: (value: Option<boolean>) => { tainted.west = value; },
                    validate: (): Array<string> => {
                        const fieldErrors = validateFieldCardinal("west", data.west);
                        return fieldErrors.map((e: { field: string; message: string }) => e.message);
                    },
                    
                }}; function validate(): Result<Cardinal, Array<{field: string; message: string}>>{return fromObjectCardinal(data);}function reset(newOverrides?: Partial<Cardinal>): void {data = {...defaultValueCardinal(),...newOverrides}; errors = { _errors: Option.none(), north: Option.none(), east: Option.none(), south: Option.none(), west: Option.none() }; tainted = { north: Option.none(), east: Option.none(), south: Option.none(), west: Option.none() };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */export function fromFormDataCardinal(formData: FormData): Result<Cardinal, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {
                const northStr = formData.get("north");
                obj.north = northStr ? parseFloat(northStr as string) : 0;
                if (obj.north !== undefined && isNaN(obj.north as number)) obj.north = 0;
            }
            {
                const eastStr = formData.get("east");
                obj.east = eastStr ? parseFloat(eastStr as string) : 0;
                if (obj.east !== undefined && isNaN(obj.east as number)) obj.east = 0;
            }
            {
                const southStr = formData.get("south");
                obj.south = southStr ? parseFloat(southStr as string) : 0;
                if (obj.south !== undefined && isNaN(obj.south as number)) obj.south = 0;
            }
            {
                const westStr = formData.get("west");
                obj.west = westStr ? parseFloat(westStr as string) : 0;
                if (obj.west !== undefined && isNaN(obj.west as number)) obj.west = 0;
            } return fromStringifiedJSONCardinal(JSON.stringify(obj));}


export type Interval =
    | /** @default */ DailyRecurrenceRule
    | WeeklyRecurrenceRule
    | MonthlyRecurrenceRule
    | YearlyRecurrenceRule;

export function defaultValueInterval(): Interval {return defaultValueDailyRecurrenceRule();}

export function toStringifiedJSONInterval(value: Interval): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeInterval(value, ctx));}export function toObjectInterval(value: Interval): unknown {const ctx = SerializeContext.create(); return __serializeInterval(value, ctx);}export function __serializeInterval(value: Interval, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONInterval(json: string, opts?: DeserializeOptions): Result<Interval, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectInterval(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectInterval(obj: unknown, opts?: DeserializeOptions): Result<Interval, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeInterval(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Interval.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeInterval(value: any, ctx: DeserializeContext): Interval | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Interval | PendingRef;}if(typeof value!== "object" || value === null){throw new DeserializeError([{field: "_root" , message: "Interval.__deserialize: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new DeserializeError([{field: "_root" , message: "Interval.__deserialize: missing __type field for union dispatch" }]);}if(__typeName === "DailyRecurrenceRule" ){return __deserializeDailyRecurrenceRule(value, ctx)as Interval;}if(__typeName === "WeeklyRecurrenceRule" ){return __deserializeWeeklyRecurrenceRule(value, ctx)as Interval;}if(__typeName === "MonthlyRecurrenceRule" ){return __deserializeMonthlyRecurrenceRule(value, ctx)as Interval;}if(__typeName === "YearlyRecurrenceRule" ){return __deserializeYearlyRecurrenceRule(value, ctx)as Interval;}throw new DeserializeError([{field: "_root" , message: "Interval.__deserialize: unknown type \"" + __typeName + "\". Expected one of: DailyRecurrenceRule, WeeklyRecurrenceRule, MonthlyRecurrenceRule, YearlyRecurrenceRule" }]); }export function isInterval(value: unknown): value is Interval {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "DailyRecurrenceRule" || __typeName === "WeeklyRecurrenceRule" || __typeName === "MonthlyRecurrenceRule" || __typeName === "YearlyRecurrenceRule" ; }

/** Per-variant error types */export type DailyRecurrenceRuleErrorsInterval = { _errors: Option<Array<string>>;  };
        export type WeeklyRecurrenceRuleErrorsInterval = { _errors: Option<Array<string>>;  };
        export type MonthlyRecurrenceRuleErrorsInterval = { _errors: Option<Array<string>>;  };
        export type YearlyRecurrenceRuleErrorsInterval = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type DailyRecurrenceRuleTaintedInterval = {  };
        export type WeeklyRecurrenceRuleTaintedInterval = {  };
        export type MonthlyRecurrenceRuleTaintedInterval = {  };
        export type YearlyRecurrenceRuleTaintedInterval = {  }; /** Union error type */export type ErrorsInterval = ({ _type: "DailyRecurrenceRule" } & DailyRecurrenceRuleErrorsInterval) | ({ _type: "WeeklyRecurrenceRule" } & WeeklyRecurrenceRuleErrorsInterval) | ({ _type: "MonthlyRecurrenceRule" } & MonthlyRecurrenceRuleErrorsInterval) | ({ _type: "YearlyRecurrenceRule" } & YearlyRecurrenceRuleErrorsInterval); /** Union tainted type */export type TaintedInterval = ({ _type: "DailyRecurrenceRule" } & DailyRecurrenceRuleTaintedInterval) | ({ _type: "WeeklyRecurrenceRule" } & WeeklyRecurrenceRuleTaintedInterval) | ({ _type: "MonthlyRecurrenceRule" } & MonthlyRecurrenceRuleTaintedInterval) | ({ _type: "YearlyRecurrenceRule" } & YearlyRecurrenceRuleTaintedInterval); /** Per-variant field controller types */export interface DailyRecurrenceRuleFieldControllersInterval {  }
        export interface WeeklyRecurrenceRuleFieldControllersInterval {  }
        export interface MonthlyRecurrenceRuleFieldControllersInterval {  }
        export interface YearlyRecurrenceRuleFieldControllersInterval {  } /** Union Gigaform interface with variant switching */export interface GigaformInterval {readonly currentVariant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule"; readonly data: Interval; readonly errors: ErrorsInterval; readonly tainted: TaintedInterval; readonly variants: VariantFieldsInterval; switchVariant(variant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule"): void; validate(): Result<Interval, Array<{field: string; message: string}>>; reset(overrides?: Partial<Interval>): void;}/** Variant fields container */export interface VariantFieldsInterval {readonly DailyRecurrenceRule: { readonly fields: DailyRecurrenceRuleFieldControllersInterval };
            readonly WeeklyRecurrenceRule: { readonly fields: WeeklyRecurrenceRuleFieldControllersInterval };
            readonly MonthlyRecurrenceRule: { readonly fields: MonthlyRecurrenceRuleFieldControllersInterval };
            readonly YearlyRecurrenceRule: { readonly fields: YearlyRecurrenceRuleFieldControllersInterval };}/** Gets default value for a specific variant */function getDefaultForVariantInterval(variant: string): Interval {
        switch (variant) {
            case "DailyRecurrenceRule": return defaultValueDailyRecurrenceRule() as Interval;
            case "WeeklyRecurrenceRule": return defaultValueWeeklyRecurrenceRule() as Interval;
            case "MonthlyRecurrenceRule": return defaultValueMonthlyRecurrenceRule() as Interval;
            case "YearlyRecurrenceRule": return defaultValueYearlyRecurrenceRule() as Interval;
            default: return defaultValueDailyRecurrenceRule() as Interval;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormInterval(initial?: Interval): GigaformInterval {const initialVariant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule" = "DailyRecurrenceRule"; let currentVariant = $state<"DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule">(initialVariant); let data = $state<Interval>(initial?? getDefaultForVariantInterval(initialVariant)); let errors = $state<ErrorsInterval>({}as ErrorsInterval); let tainted = $state<TaintedInterval>({}as TaintedInterval); const variants: VariantFieldsInterval = {DailyRecurrenceRule: {
                    fields: {
                        
                    } as DailyRecurrenceRuleFieldControllersInterval
                },
                WeeklyRecurrenceRule: {
                    fields: {
                        
                    } as WeeklyRecurrenceRuleFieldControllersInterval
                },
                MonthlyRecurrenceRule: {
                    fields: {
                        
                    } as MonthlyRecurrenceRuleFieldControllersInterval
                },
                YearlyRecurrenceRule: {
                    fields: {
                        
                    } as YearlyRecurrenceRuleFieldControllersInterval
                }}; function switchVariant(variant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule"): void {currentVariant = variant; data = getDefaultForVariantInterval(variant); errors = {}as ErrorsInterval; tainted = {}as TaintedInterval;}function validate(): Result<Interval, Array<{field: string; message: string}>>{return fromObjectInterval(data);}function reset(overrides?: Partial<Interval>): void {data = overrides ? overrides as typeof data : getDefaultForVariantInterval(currentVariant); errors = {}as ErrorsInterval; tainted = {}as TaintedInterval;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataInterval(formData: FormData): Result<Interval, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if (discriminant === "DailyRecurrenceRule") {
                
            } else if (discriminant === "WeeklyRecurrenceRule") {
                
            } else if (discriminant === "MonthlyRecurrenceRule") {
                
            } else if (discriminant === "YearlyRecurrenceRule") {
                
            } return fromStringifiedJSONInterval(JSON.stringify(obj));}


export type Page =
    | /** @default */ 'SalesHomeDashboard'
    | 'SalesHomeProducts'
    | 'SalesHomeServices'
    | 'SalesHomePackages'
    | 'SalesHomeTaxRates'
    | 'SalesLeadsOverview'
    | 'SalesLeadsActivities'
    | 'SalesLeadsCampaigns'
    | 'SalesLeadsDripCampaigns'
    | 'SalesLeadsOpportunities'
    | 'SalesLeadsPromotions'
    | 'SalesAccountsOverview'
    | 'SalesAccountsActivities'
    | 'SalesAccountsBilling'
    | 'SalesAccountsContracts'
    | 'SalesOrdersOverview'
    | 'SalesOrdersActivities'
    | 'SalesOrdersPayments'
    | 'SalesOrdersCommissions'
    | 'SalesSchedulingSchedule'
    | 'SalesSchedulingAppointments'
    | 'SalesSchedulingRecurring'
    | 'SalesSchedulingRoutes'
    | 'SalesSchedulingReminders'
    | 'UserHome';

export function defaultValuePage(): Page {return 'SalesHomeDashboard';}

export function toStringifiedJSONPage(value: Page): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializePage(value, ctx));}export function toObjectPage(value: Page): unknown {const ctx = SerializeContext.create(); return __serializePage(value, ctx);}export function __serializePage(value: Page, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONPage(json: string, opts?: DeserializeOptions): Result<Page, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectPage(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectPage(obj: unknown, opts?: DeserializeOptions): Result<Page, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializePage(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Page.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializePage(value: any, ctx: DeserializeContext): Page | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Page | PendingRef;}const allowedValues = ['SalesHomeDashboard', 'SalesHomeProducts', 'SalesHomeServices', 'SalesHomePackages', 'SalesHomeTaxRates', 'SalesLeadsOverview', 'SalesLeadsActivities', 'SalesLeadsCampaigns', 'SalesLeadsDripCampaigns', 'SalesLeadsOpportunities', 'SalesLeadsPromotions', 'SalesAccountsOverview', 'SalesAccountsActivities', 'SalesAccountsBilling', 'SalesAccountsContracts', 'SalesOrdersOverview', 'SalesOrdersActivities', 'SalesOrdersPayments', 'SalesOrdersCommissions', 'SalesSchedulingSchedule', 'SalesSchedulingAppointments', 'SalesSchedulingRecurring', 'SalesSchedulingRoutes', 'SalesSchedulingReminders', 'UserHome', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for Page: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Page; }export function isPage(value: unknown): value is Page {const allowedValues = ['SalesHomeDashboard', 'SalesHomeProducts', 'SalesHomeServices', 'SalesHomePackages', 'SalesHomeTaxRates', 'SalesLeadsOverview', 'SalesLeadsActivities', 'SalesLeadsCampaigns', 'SalesLeadsDripCampaigns', 'SalesLeadsOpportunities', 'SalesLeadsPromotions', 'SalesAccountsOverview', 'SalesAccountsActivities', 'SalesAccountsBilling', 'SalesAccountsContracts', 'SalesOrdersOverview', 'SalesOrdersActivities', 'SalesOrdersPayments', 'SalesOrdersCommissions', 'SalesSchedulingSchedule', 'SalesSchedulingAppointments', 'SalesSchedulingRecurring', 'SalesSchedulingRoutes', 'SalesSchedulingReminders', 'UserHome', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type SalesHomeDashboardErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesHomeProductsErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesHomeServicesErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesHomePackagesErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesHomeTaxRatesErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesLeadsOverviewErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesLeadsActivitiesErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesLeadsCampaignsErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesLeadsDripCampaignsErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesLeadsOpportunitiesErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesLeadsPromotionsErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesAccountsOverviewErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesAccountsActivitiesErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesAccountsBillingErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesAccountsContractsErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesOrdersOverviewErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesOrdersActivitiesErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesOrdersPaymentsErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesOrdersCommissionsErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesSchedulingScheduleErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesSchedulingAppointmentsErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesSchedulingRecurringErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesSchedulingRoutesErrorsPage = { _errors: Option<Array<string>>;  };
        export type SalesSchedulingRemindersErrorsPage = { _errors: Option<Array<string>>;  };
        export type UserHomeErrorsPage = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type SalesHomeDashboardTaintedPage = {  };
        export type SalesHomeProductsTaintedPage = {  };
        export type SalesHomeServicesTaintedPage = {  };
        export type SalesHomePackagesTaintedPage = {  };
        export type SalesHomeTaxRatesTaintedPage = {  };
        export type SalesLeadsOverviewTaintedPage = {  };
        export type SalesLeadsActivitiesTaintedPage = {  };
        export type SalesLeadsCampaignsTaintedPage = {  };
        export type SalesLeadsDripCampaignsTaintedPage = {  };
        export type SalesLeadsOpportunitiesTaintedPage = {  };
        export type SalesLeadsPromotionsTaintedPage = {  };
        export type SalesAccountsOverviewTaintedPage = {  };
        export type SalesAccountsActivitiesTaintedPage = {  };
        export type SalesAccountsBillingTaintedPage = {  };
        export type SalesAccountsContractsTaintedPage = {  };
        export type SalesOrdersOverviewTaintedPage = {  };
        export type SalesOrdersActivitiesTaintedPage = {  };
        export type SalesOrdersPaymentsTaintedPage = {  };
        export type SalesOrdersCommissionsTaintedPage = {  };
        export type SalesSchedulingScheduleTaintedPage = {  };
        export type SalesSchedulingAppointmentsTaintedPage = {  };
        export type SalesSchedulingRecurringTaintedPage = {  };
        export type SalesSchedulingRoutesTaintedPage = {  };
        export type SalesSchedulingRemindersTaintedPage = {  };
        export type UserHomeTaintedPage = {  }; /** Union error type */export type ErrorsPage = ({ _value: "SalesHomeDashboard" } & SalesHomeDashboardErrorsPage) | ({ _value: "SalesHomeProducts" } & SalesHomeProductsErrorsPage) | ({ _value: "SalesHomeServices" } & SalesHomeServicesErrorsPage) | ({ _value: "SalesHomePackages" } & SalesHomePackagesErrorsPage) | ({ _value: "SalesHomeTaxRates" } & SalesHomeTaxRatesErrorsPage) | ({ _value: "SalesLeadsOverview" } & SalesLeadsOverviewErrorsPage) | ({ _value: "SalesLeadsActivities" } & SalesLeadsActivitiesErrorsPage) | ({ _value: "SalesLeadsCampaigns" } & SalesLeadsCampaignsErrorsPage) | ({ _value: "SalesLeadsDripCampaigns" } & SalesLeadsDripCampaignsErrorsPage) | ({ _value: "SalesLeadsOpportunities" } & SalesLeadsOpportunitiesErrorsPage) | ({ _value: "SalesLeadsPromotions" } & SalesLeadsPromotionsErrorsPage) | ({ _value: "SalesAccountsOverview" } & SalesAccountsOverviewErrorsPage) | ({ _value: "SalesAccountsActivities" } & SalesAccountsActivitiesErrorsPage) | ({ _value: "SalesAccountsBilling" } & SalesAccountsBillingErrorsPage) | ({ _value: "SalesAccountsContracts" } & SalesAccountsContractsErrorsPage) | ({ _value: "SalesOrdersOverview" } & SalesOrdersOverviewErrorsPage) | ({ _value: "SalesOrdersActivities" } & SalesOrdersActivitiesErrorsPage) | ({ _value: "SalesOrdersPayments" } & SalesOrdersPaymentsErrorsPage) | ({ _value: "SalesOrdersCommissions" } & SalesOrdersCommissionsErrorsPage) | ({ _value: "SalesSchedulingSchedule" } & SalesSchedulingScheduleErrorsPage) | ({ _value: "SalesSchedulingAppointments" } & SalesSchedulingAppointmentsErrorsPage) | ({ _value: "SalesSchedulingRecurring" } & SalesSchedulingRecurringErrorsPage) | ({ _value: "SalesSchedulingRoutes" } & SalesSchedulingRoutesErrorsPage) | ({ _value: "SalesSchedulingReminders" } & SalesSchedulingRemindersErrorsPage) | ({ _value: "UserHome" } & UserHomeErrorsPage); /** Union tainted type */export type TaintedPage = ({ _value: "SalesHomeDashboard" } & SalesHomeDashboardTaintedPage) | ({ _value: "SalesHomeProducts" } & SalesHomeProductsTaintedPage) | ({ _value: "SalesHomeServices" } & SalesHomeServicesTaintedPage) | ({ _value: "SalesHomePackages" } & SalesHomePackagesTaintedPage) | ({ _value: "SalesHomeTaxRates" } & SalesHomeTaxRatesTaintedPage) | ({ _value: "SalesLeadsOverview" } & SalesLeadsOverviewTaintedPage) | ({ _value: "SalesLeadsActivities" } & SalesLeadsActivitiesTaintedPage) | ({ _value: "SalesLeadsCampaigns" } & SalesLeadsCampaignsTaintedPage) | ({ _value: "SalesLeadsDripCampaigns" } & SalesLeadsDripCampaignsTaintedPage) | ({ _value: "SalesLeadsOpportunities" } & SalesLeadsOpportunitiesTaintedPage) | ({ _value: "SalesLeadsPromotions" } & SalesLeadsPromotionsTaintedPage) | ({ _value: "SalesAccountsOverview" } & SalesAccountsOverviewTaintedPage) | ({ _value: "SalesAccountsActivities" } & SalesAccountsActivitiesTaintedPage) | ({ _value: "SalesAccountsBilling" } & SalesAccountsBillingTaintedPage) | ({ _value: "SalesAccountsContracts" } & SalesAccountsContractsTaintedPage) | ({ _value: "SalesOrdersOverview" } & SalesOrdersOverviewTaintedPage) | ({ _value: "SalesOrdersActivities" } & SalesOrdersActivitiesTaintedPage) | ({ _value: "SalesOrdersPayments" } & SalesOrdersPaymentsTaintedPage) | ({ _value: "SalesOrdersCommissions" } & SalesOrdersCommissionsTaintedPage) | ({ _value: "SalesSchedulingSchedule" } & SalesSchedulingScheduleTaintedPage) | ({ _value: "SalesSchedulingAppointments" } & SalesSchedulingAppointmentsTaintedPage) | ({ _value: "SalesSchedulingRecurring" } & SalesSchedulingRecurringTaintedPage) | ({ _value: "SalesSchedulingRoutes" } & SalesSchedulingRoutesTaintedPage) | ({ _value: "SalesSchedulingReminders" } & SalesSchedulingRemindersTaintedPage) | ({ _value: "UserHome" } & UserHomeTaintedPage); /** Per-variant field controller types */export interface SalesHomeDashboardFieldControllersPage {  }
        export interface SalesHomeProductsFieldControllersPage {  }
        export interface SalesHomeServicesFieldControllersPage {  }
        export interface SalesHomePackagesFieldControllersPage {  }
        export interface SalesHomeTaxRatesFieldControllersPage {  }
        export interface SalesLeadsOverviewFieldControllersPage {  }
        export interface SalesLeadsActivitiesFieldControllersPage {  }
        export interface SalesLeadsCampaignsFieldControllersPage {  }
        export interface SalesLeadsDripCampaignsFieldControllersPage {  }
        export interface SalesLeadsOpportunitiesFieldControllersPage {  }
        export interface SalesLeadsPromotionsFieldControllersPage {  }
        export interface SalesAccountsOverviewFieldControllersPage {  }
        export interface SalesAccountsActivitiesFieldControllersPage {  }
        export interface SalesAccountsBillingFieldControllersPage {  }
        export interface SalesAccountsContractsFieldControllersPage {  }
        export interface SalesOrdersOverviewFieldControllersPage {  }
        export interface SalesOrdersActivitiesFieldControllersPage {  }
        export interface SalesOrdersPaymentsFieldControllersPage {  }
        export interface SalesOrdersCommissionsFieldControllersPage {  }
        export interface SalesSchedulingScheduleFieldControllersPage {  }
        export interface SalesSchedulingAppointmentsFieldControllersPage {  }
        export interface SalesSchedulingRecurringFieldControllersPage {  }
        export interface SalesSchedulingRoutesFieldControllersPage {  }
        export interface SalesSchedulingRemindersFieldControllersPage {  }
        export interface UserHomeFieldControllersPage {  } /** Union Gigaform interface with variant switching */export interface GigaformPage {readonly currentVariant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome"; readonly data: Page; readonly errors: ErrorsPage; readonly tainted: TaintedPage; readonly variants: VariantFieldsPage; switchVariant(variant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome"): void; validate(): Result<Page, Array<{field: string; message: string}>>; reset(overrides?: Partial<Page>): void;}/** Variant fields container */export interface VariantFieldsPage {readonly SalesHomeDashboard: { readonly fields: SalesHomeDashboardFieldControllersPage };
            readonly SalesHomeProducts: { readonly fields: SalesHomeProductsFieldControllersPage };
            readonly SalesHomeServices: { readonly fields: SalesHomeServicesFieldControllersPage };
            readonly SalesHomePackages: { readonly fields: SalesHomePackagesFieldControllersPage };
            readonly SalesHomeTaxRates: { readonly fields: SalesHomeTaxRatesFieldControllersPage };
            readonly SalesLeadsOverview: { readonly fields: SalesLeadsOverviewFieldControllersPage };
            readonly SalesLeadsActivities: { readonly fields: SalesLeadsActivitiesFieldControllersPage };
            readonly SalesLeadsCampaigns: { readonly fields: SalesLeadsCampaignsFieldControllersPage };
            readonly SalesLeadsDripCampaigns: { readonly fields: SalesLeadsDripCampaignsFieldControllersPage };
            readonly SalesLeadsOpportunities: { readonly fields: SalesLeadsOpportunitiesFieldControllersPage };
            readonly SalesLeadsPromotions: { readonly fields: SalesLeadsPromotionsFieldControllersPage };
            readonly SalesAccountsOverview: { readonly fields: SalesAccountsOverviewFieldControllersPage };
            readonly SalesAccountsActivities: { readonly fields: SalesAccountsActivitiesFieldControllersPage };
            readonly SalesAccountsBilling: { readonly fields: SalesAccountsBillingFieldControllersPage };
            readonly SalesAccountsContracts: { readonly fields: SalesAccountsContractsFieldControllersPage };
            readonly SalesOrdersOverview: { readonly fields: SalesOrdersOverviewFieldControllersPage };
            readonly SalesOrdersActivities: { readonly fields: SalesOrdersActivitiesFieldControllersPage };
            readonly SalesOrdersPayments: { readonly fields: SalesOrdersPaymentsFieldControllersPage };
            readonly SalesOrdersCommissions: { readonly fields: SalesOrdersCommissionsFieldControllersPage };
            readonly SalesSchedulingSchedule: { readonly fields: SalesSchedulingScheduleFieldControllersPage };
            readonly SalesSchedulingAppointments: { readonly fields: SalesSchedulingAppointmentsFieldControllersPage };
            readonly SalesSchedulingRecurring: { readonly fields: SalesSchedulingRecurringFieldControllersPage };
            readonly SalesSchedulingRoutes: { readonly fields: SalesSchedulingRoutesFieldControllersPage };
            readonly SalesSchedulingReminders: { readonly fields: SalesSchedulingRemindersFieldControllersPage };
            readonly UserHome: { readonly fields: UserHomeFieldControllersPage };}/** Gets default value for a specific variant */function getDefaultForVariantPage(variant: string): Page {
        switch (variant) {
            case "SalesHomeDashboard": return "SalesHomeDashboard" as Page;
            case "SalesHomeProducts": return "SalesHomeProducts" as Page;
            case "SalesHomeServices": return "SalesHomeServices" as Page;
            case "SalesHomePackages": return "SalesHomePackages" as Page;
            case "SalesHomeTaxRates": return "SalesHomeTaxRates" as Page;
            case "SalesLeadsOverview": return "SalesLeadsOverview" as Page;
            case "SalesLeadsActivities": return "SalesLeadsActivities" as Page;
            case "SalesLeadsCampaigns": return "SalesLeadsCampaigns" as Page;
            case "SalesLeadsDripCampaigns": return "SalesLeadsDripCampaigns" as Page;
            case "SalesLeadsOpportunities": return "SalesLeadsOpportunities" as Page;
            case "SalesLeadsPromotions": return "SalesLeadsPromotions" as Page;
            case "SalesAccountsOverview": return "SalesAccountsOverview" as Page;
            case "SalesAccountsActivities": return "SalesAccountsActivities" as Page;
            case "SalesAccountsBilling": return "SalesAccountsBilling" as Page;
            case "SalesAccountsContracts": return "SalesAccountsContracts" as Page;
            case "SalesOrdersOverview": return "SalesOrdersOverview" as Page;
            case "SalesOrdersActivities": return "SalesOrdersActivities" as Page;
            case "SalesOrdersPayments": return "SalesOrdersPayments" as Page;
            case "SalesOrdersCommissions": return "SalesOrdersCommissions" as Page;
            case "SalesSchedulingSchedule": return "SalesSchedulingSchedule" as Page;
            case "SalesSchedulingAppointments": return "SalesSchedulingAppointments" as Page;
            case "SalesSchedulingRecurring": return "SalesSchedulingRecurring" as Page;
            case "SalesSchedulingRoutes": return "SalesSchedulingRoutes" as Page;
            case "SalesSchedulingReminders": return "SalesSchedulingReminders" as Page;
            case "UserHome": return "UserHome" as Page;
            default: return "SalesHomeDashboard" as Page;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormPage(initial?: Page): GigaformPage {const initialVariant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome" = (initial as "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome") ?? "SalesHomeDashboard"; let currentVariant = $state<"SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome">(initialVariant); let data = $state<Page>(initial?? getDefaultForVariantPage(initialVariant)); let errors = $state<ErrorsPage>({}as ErrorsPage); let tainted = $state<TaintedPage>({}as TaintedPage); const variants: VariantFieldsPage = {SalesHomeDashboard: {
                    fields: {
                        
                    } as SalesHomeDashboardFieldControllersPage
                },
                SalesHomeProducts: {
                    fields: {
                        
                    } as SalesHomeProductsFieldControllersPage
                },
                SalesHomeServices: {
                    fields: {
                        
                    } as SalesHomeServicesFieldControllersPage
                },
                SalesHomePackages: {
                    fields: {
                        
                    } as SalesHomePackagesFieldControllersPage
                },
                SalesHomeTaxRates: {
                    fields: {
                        
                    } as SalesHomeTaxRatesFieldControllersPage
                },
                SalesLeadsOverview: {
                    fields: {
                        
                    } as SalesLeadsOverviewFieldControllersPage
                },
                SalesLeadsActivities: {
                    fields: {
                        
                    } as SalesLeadsActivitiesFieldControllersPage
                },
                SalesLeadsCampaigns: {
                    fields: {
                        
                    } as SalesLeadsCampaignsFieldControllersPage
                },
                SalesLeadsDripCampaigns: {
                    fields: {
                        
                    } as SalesLeadsDripCampaignsFieldControllersPage
                },
                SalesLeadsOpportunities: {
                    fields: {
                        
                    } as SalesLeadsOpportunitiesFieldControllersPage
                },
                SalesLeadsPromotions: {
                    fields: {
                        
                    } as SalesLeadsPromotionsFieldControllersPage
                },
                SalesAccountsOverview: {
                    fields: {
                        
                    } as SalesAccountsOverviewFieldControllersPage
                },
                SalesAccountsActivities: {
                    fields: {
                        
                    } as SalesAccountsActivitiesFieldControllersPage
                },
                SalesAccountsBilling: {
                    fields: {
                        
                    } as SalesAccountsBillingFieldControllersPage
                },
                SalesAccountsContracts: {
                    fields: {
                        
                    } as SalesAccountsContractsFieldControllersPage
                },
                SalesOrdersOverview: {
                    fields: {
                        
                    } as SalesOrdersOverviewFieldControllersPage
                },
                SalesOrdersActivities: {
                    fields: {
                        
                    } as SalesOrdersActivitiesFieldControllersPage
                },
                SalesOrdersPayments: {
                    fields: {
                        
                    } as SalesOrdersPaymentsFieldControllersPage
                },
                SalesOrdersCommissions: {
                    fields: {
                        
                    } as SalesOrdersCommissionsFieldControllersPage
                },
                SalesSchedulingSchedule: {
                    fields: {
                        
                    } as SalesSchedulingScheduleFieldControllersPage
                },
                SalesSchedulingAppointments: {
                    fields: {
                        
                    } as SalesSchedulingAppointmentsFieldControllersPage
                },
                SalesSchedulingRecurring: {
                    fields: {
                        
                    } as SalesSchedulingRecurringFieldControllersPage
                },
                SalesSchedulingRoutes: {
                    fields: {
                        
                    } as SalesSchedulingRoutesFieldControllersPage
                },
                SalesSchedulingReminders: {
                    fields: {
                        
                    } as SalesSchedulingRemindersFieldControllersPage
                },
                UserHome: {
                    fields: {
                        
                    } as UserHomeFieldControllersPage
                }}; function switchVariant(variant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome"): void {currentVariant = variant; data = getDefaultForVariantPage(variant); errors = {}as ErrorsPage; tainted = {}as TaintedPage;}function validate(): Result<Page, Array<{field: string; message: string}>>{return fromObjectPage(data);}function reset(overrides?: Partial<Page>): void {data = overrides ? overrides as typeof data : getDefaultForVariantPage(currentVariant); errors = {}as ErrorsPage; tainted = {}as TaintedPage;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataPage(formData: FormData): Result<Page, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "SalesHomeDashboard") {
                
            } else if (discriminant === "SalesHomeProducts") {
                
            } else if (discriminant === "SalesHomeServices") {
                
            } else if (discriminant === "SalesHomePackages") {
                
            } else if (discriminant === "SalesHomeTaxRates") {
                
            } else if (discriminant === "SalesLeadsOverview") {
                
            } else if (discriminant === "SalesLeadsActivities") {
                
            } else if (discriminant === "SalesLeadsCampaigns") {
                
            } else if (discriminant === "SalesLeadsDripCampaigns") {
                
            } else if (discriminant === "SalesLeadsOpportunities") {
                
            } else if (discriminant === "SalesLeadsPromotions") {
                
            } else if (discriminant === "SalesAccountsOverview") {
                
            } else if (discriminant === "SalesAccountsActivities") {
                
            } else if (discriminant === "SalesAccountsBilling") {
                
            } else if (discriminant === "SalesAccountsContracts") {
                
            } else if (discriminant === "SalesOrdersOverview") {
                
            } else if (discriminant === "SalesOrdersActivities") {
                
            } else if (discriminant === "SalesOrdersPayments") {
                
            } else if (discriminant === "SalesOrdersCommissions") {
                
            } else if (discriminant === "SalesSchedulingSchedule") {
                
            } else if (discriminant === "SalesSchedulingAppointments") {
                
            } else if (discriminant === "SalesSchedulingRecurring") {
                
            } else if (discriminant === "SalesSchedulingRoutes") {
                
            } else if (discriminant === "SalesSchedulingReminders") {
                
            } else if (discriminant === "UserHome") {
                
            } return fromStringifiedJSONPage(JSON.stringify(obj));}


export type UserRole =
    | /** @default */ 'Administrator'
    | 'SalesRepresentative'
    | 'Technician'
    | 'HumanResources'
    | 'InformationTechnology';

export function defaultValueUserRole(): UserRole {return 'Administrator';}

export function toStringifiedJSONUserRole(value: UserRole): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeUserRole(value, ctx));}export function toObjectUserRole(value: UserRole): unknown {const ctx = SerializeContext.create(); return __serializeUserRole(value, ctx);}export function __serializeUserRole(value: UserRole, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONUserRole(json: string, opts?: DeserializeOptions): Result<UserRole, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectUserRole(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectUserRole(obj: unknown, opts?: DeserializeOptions): Result<UserRole, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeUserRole(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "UserRole.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeUserRole(value: any, ctx: DeserializeContext): UserRole | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as UserRole | PendingRef;}const allowedValues = ['Administrator', 'SalesRepresentative', 'Technician', 'HumanResources', 'InformationTechnology', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for UserRole: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as UserRole; }export function isUserRole(value: unknown): value is UserRole {const allowedValues = ['Administrator', 'SalesRepresentative', 'Technician', 'HumanResources', 'InformationTechnology', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type AdministratorErrorsUserRole = { _errors: Option<Array<string>>;  };
        export type SalesRepresentativeErrorsUserRole = { _errors: Option<Array<string>>;  };
        export type TechnicianErrorsUserRole = { _errors: Option<Array<string>>;  };
        export type HumanResourcesErrorsUserRole = { _errors: Option<Array<string>>;  };
        export type InformationTechnologyErrorsUserRole = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type AdministratorTaintedUserRole = {  };
        export type SalesRepresentativeTaintedUserRole = {  };
        export type TechnicianTaintedUserRole = {  };
        export type HumanResourcesTaintedUserRole = {  };
        export type InformationTechnologyTaintedUserRole = {  }; /** Union error type */export type ErrorsUserRole = ({ _value: "Administrator" } & AdministratorErrorsUserRole) | ({ _value: "SalesRepresentative" } & SalesRepresentativeErrorsUserRole) | ({ _value: "Technician" } & TechnicianErrorsUserRole) | ({ _value: "HumanResources" } & HumanResourcesErrorsUserRole) | ({ _value: "InformationTechnology" } & InformationTechnologyErrorsUserRole); /** Union tainted type */export type TaintedUserRole = ({ _value: "Administrator" } & AdministratorTaintedUserRole) | ({ _value: "SalesRepresentative" } & SalesRepresentativeTaintedUserRole) | ({ _value: "Technician" } & TechnicianTaintedUserRole) | ({ _value: "HumanResources" } & HumanResourcesTaintedUserRole) | ({ _value: "InformationTechnology" } & InformationTechnologyTaintedUserRole); /** Per-variant field controller types */export interface AdministratorFieldControllersUserRole {  }
        export interface SalesRepresentativeFieldControllersUserRole {  }
        export interface TechnicianFieldControllersUserRole {  }
        export interface HumanResourcesFieldControllersUserRole {  }
        export interface InformationTechnologyFieldControllersUserRole {  } /** Union Gigaform interface with variant switching */export interface GigaformUserRole {readonly currentVariant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology"; readonly data: UserRole; readonly errors: ErrorsUserRole; readonly tainted: TaintedUserRole; readonly variants: VariantFieldsUserRole; switchVariant(variant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology"): void; validate(): Result<UserRole, Array<{field: string; message: string}>>; reset(overrides?: Partial<UserRole>): void;}/** Variant fields container */export interface VariantFieldsUserRole {readonly Administrator: { readonly fields: AdministratorFieldControllersUserRole };
            readonly SalesRepresentative: { readonly fields: SalesRepresentativeFieldControllersUserRole };
            readonly Technician: { readonly fields: TechnicianFieldControllersUserRole };
            readonly HumanResources: { readonly fields: HumanResourcesFieldControllersUserRole };
            readonly InformationTechnology: { readonly fields: InformationTechnologyFieldControllersUserRole };}/** Gets default value for a specific variant */function getDefaultForVariantUserRole(variant: string): UserRole {
        switch (variant) {
            case "Administrator": return "Administrator" as UserRole;
            case "SalesRepresentative": return "SalesRepresentative" as UserRole;
            case "Technician": return "Technician" as UserRole;
            case "HumanResources": return "HumanResources" as UserRole;
            case "InformationTechnology": return "InformationTechnology" as UserRole;
            default: return "Administrator" as UserRole;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormUserRole(initial?: UserRole): GigaformUserRole {const initialVariant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology" = (initial as "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology") ?? "Administrator"; let currentVariant = $state<"Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology">(initialVariant); let data = $state<UserRole>(initial?? getDefaultForVariantUserRole(initialVariant)); let errors = $state<ErrorsUserRole>({}as ErrorsUserRole); let tainted = $state<TaintedUserRole>({}as TaintedUserRole); const variants: VariantFieldsUserRole = {Administrator: {
                    fields: {
                        
                    } as AdministratorFieldControllersUserRole
                },
                SalesRepresentative: {
                    fields: {
                        
                    } as SalesRepresentativeFieldControllersUserRole
                },
                Technician: {
                    fields: {
                        
                    } as TechnicianFieldControllersUserRole
                },
                HumanResources: {
                    fields: {
                        
                    } as HumanResourcesFieldControllersUserRole
                },
                InformationTechnology: {
                    fields: {
                        
                    } as InformationTechnologyFieldControllersUserRole
                }}; function switchVariant(variant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology"): void {currentVariant = variant; data = getDefaultForVariantUserRole(variant); errors = {}as ErrorsUserRole; tainted = {}as TaintedUserRole;}function validate(): Result<UserRole, Array<{field: string; message: string}>>{return fromObjectUserRole(data);}function reset(overrides?: Partial<UserRole>): void {data = overrides ? overrides as typeof data : getDefaultForVariantUserRole(currentVariant); errors = {}as ErrorsUserRole; tainted = {}as TaintedUserRole;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataUserRole(formData: FormData): Result<UserRole, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "Administrator") {
                
            } else if (discriminant === "SalesRepresentative") {
                
            } else if (discriminant === "Technician") {
                
            } else if (discriminant === "HumanResources") {
                
            } else if (discriminant === "InformationTechnology") {
                
            } return fromStringifiedJSONUserRole(JSON.stringify(obj));}


export type Target =
    | /** @default */ Account
    | User
    | Employee
    | Appointment
    | Lead
    | TaxRate
    | Site
    | Route
    | Company
    | Product
    | Service
    | Order
    | Payment
    | Package
    | Promotion
    | Represents
    | Ordered;

export function defaultValueTarget(): Target {return defaultValueAccount();}

export function toStringifiedJSONTarget(value: Target): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeTarget(value, ctx));}export function toObjectTarget(value: Target): unknown {const ctx = SerializeContext.create(); return __serializeTarget(value, ctx);}export function __serializeTarget(value: Target, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONTarget(json: string, opts?: DeserializeOptions): Result<Target, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectTarget(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectTarget(obj: unknown, opts?: DeserializeOptions): Result<Target, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeTarget(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Target.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeTarget(value: any, ctx: DeserializeContext): Target | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Target | PendingRef;}if(typeof value!== "object" || value === null){throw new DeserializeError([{field: "_root" , message: "Target.__deserialize: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new DeserializeError([{field: "_root" , message: "Target.__deserialize: missing __type field for union dispatch" }]);}if(__typeName === "Account" ){return __deserializeAccount(value, ctx)as Target;}if(__typeName === "User" ){return __deserializeUser(value, ctx)as Target;}if(__typeName === "Employee" ){return __deserializeEmployee(value, ctx)as Target;}if(__typeName === "Appointment" ){return __deserializeAppointment(value, ctx)as Target;}if(__typeName === "Lead" ){return __deserializeLead(value, ctx)as Target;}if(__typeName === "TaxRate" ){return __deserializeTaxRate(value, ctx)as Target;}if(__typeName === "Site" ){return __deserializeSite(value, ctx)as Target;}if(__typeName === "Route" ){return __deserializeRoute(value, ctx)as Target;}if(__typeName === "Company" ){return __deserializeCompany(value, ctx)as Target;}if(__typeName === "Product" ){return __deserializeProduct(value, ctx)as Target;}if(__typeName === "Service" ){return __deserializeService(value, ctx)as Target;}if(__typeName === "Order" ){return __deserializeOrder(value, ctx)as Target;}if(__typeName === "Payment" ){return __deserializePayment(value, ctx)as Target;}if(__typeName === "Package" ){return __deserializePackage(value, ctx)as Target;}if(__typeName === "Promotion" ){return __deserializePromotion(value, ctx)as Target;}if(__typeName === "Represents" ){return __deserializeRepresents(value, ctx)as Target;}if(__typeName === "Ordered" ){return __deserializeOrdered(value, ctx)as Target;}throw new DeserializeError([{field: "_root" , message: "Target.__deserialize: unknown type \"" + __typeName + "\". Expected one of: Account, User, Employee, Appointment, Lead, TaxRate, Site, Route, Company, Product, Service, Order, Payment, Package, Promotion, Represents, Ordered" }]); }export function isTarget(value: unknown): value is Target {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "Account" || __typeName === "User" || __typeName === "Employee" || __typeName === "Appointment" || __typeName === "Lead" || __typeName === "TaxRate" || __typeName === "Site" || __typeName === "Route" || __typeName === "Company" || __typeName === "Product" || __typeName === "Service" || __typeName === "Order" || __typeName === "Payment" || __typeName === "Package" || __typeName === "Promotion" || __typeName === "Represents" || __typeName === "Ordered" ; }

/** Per-variant error types */export type AccountErrorsTarget = { _errors: Option<Array<string>>;  };
        export type UserErrorsTarget = { _errors: Option<Array<string>>;  };
        export type EmployeeErrorsTarget = { _errors: Option<Array<string>>;  };
        export type AppointmentErrorsTarget = { _errors: Option<Array<string>>;  };
        export type LeadErrorsTarget = { _errors: Option<Array<string>>;  };
        export type TaxRateErrorsTarget = { _errors: Option<Array<string>>;  };
        export type SiteErrorsTarget = { _errors: Option<Array<string>>;  };
        export type RouteErrorsTarget = { _errors: Option<Array<string>>;  };
        export type CompanyErrorsTarget = { _errors: Option<Array<string>>;  };
        export type ProductErrorsTarget = { _errors: Option<Array<string>>;  };
        export type ServiceErrorsTarget = { _errors: Option<Array<string>>;  };
        export type OrderErrorsTarget = { _errors: Option<Array<string>>;  };
        export type PaymentErrorsTarget = { _errors: Option<Array<string>>;  };
        export type PackageErrorsTarget = { _errors: Option<Array<string>>;  };
        export type PromotionErrorsTarget = { _errors: Option<Array<string>>;  };
        export type RepresentsErrorsTarget = { _errors: Option<Array<string>>;  };
        export type OrderedErrorsTarget = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type AccountTaintedTarget = {  };
        export type UserTaintedTarget = {  };
        export type EmployeeTaintedTarget = {  };
        export type AppointmentTaintedTarget = {  };
        export type LeadTaintedTarget = {  };
        export type TaxRateTaintedTarget = {  };
        export type SiteTaintedTarget = {  };
        export type RouteTaintedTarget = {  };
        export type CompanyTaintedTarget = {  };
        export type ProductTaintedTarget = {  };
        export type ServiceTaintedTarget = {  };
        export type OrderTaintedTarget = {  };
        export type PaymentTaintedTarget = {  };
        export type PackageTaintedTarget = {  };
        export type PromotionTaintedTarget = {  };
        export type RepresentsTaintedTarget = {  };
        export type OrderedTaintedTarget = {  }; /** Union error type */export type ErrorsTarget = ({ _type: "Account" } & AccountErrorsTarget) | ({ _type: "User" } & UserErrorsTarget) | ({ _type: "Employee" } & EmployeeErrorsTarget) | ({ _type: "Appointment" } & AppointmentErrorsTarget) | ({ _type: "Lead" } & LeadErrorsTarget) | ({ _type: "TaxRate" } & TaxRateErrorsTarget) | ({ _type: "Site" } & SiteErrorsTarget) | ({ _type: "Route" } & RouteErrorsTarget) | ({ _type: "Company" } & CompanyErrorsTarget) | ({ _type: "Product" } & ProductErrorsTarget) | ({ _type: "Service" } & ServiceErrorsTarget) | ({ _type: "Order" } & OrderErrorsTarget) | ({ _type: "Payment" } & PaymentErrorsTarget) | ({ _type: "Package" } & PackageErrorsTarget) | ({ _type: "Promotion" } & PromotionErrorsTarget) | ({ _type: "Represents" } & RepresentsErrorsTarget) | ({ _type: "Ordered" } & OrderedErrorsTarget); /** Union tainted type */export type TaintedTarget = ({ _type: "Account" } & AccountTaintedTarget) | ({ _type: "User" } & UserTaintedTarget) | ({ _type: "Employee" } & EmployeeTaintedTarget) | ({ _type: "Appointment" } & AppointmentTaintedTarget) | ({ _type: "Lead" } & LeadTaintedTarget) | ({ _type: "TaxRate" } & TaxRateTaintedTarget) | ({ _type: "Site" } & SiteTaintedTarget) | ({ _type: "Route" } & RouteTaintedTarget) | ({ _type: "Company" } & CompanyTaintedTarget) | ({ _type: "Product" } & ProductTaintedTarget) | ({ _type: "Service" } & ServiceTaintedTarget) | ({ _type: "Order" } & OrderTaintedTarget) | ({ _type: "Payment" } & PaymentTaintedTarget) | ({ _type: "Package" } & PackageTaintedTarget) | ({ _type: "Promotion" } & PromotionTaintedTarget) | ({ _type: "Represents" } & RepresentsTaintedTarget) | ({ _type: "Ordered" } & OrderedTaintedTarget); /** Per-variant field controller types */export interface AccountFieldControllersTarget {  }
        export interface UserFieldControllersTarget {  }
        export interface EmployeeFieldControllersTarget {  }
        export interface AppointmentFieldControllersTarget {  }
        export interface LeadFieldControllersTarget {  }
        export interface TaxRateFieldControllersTarget {  }
        export interface SiteFieldControllersTarget {  }
        export interface RouteFieldControllersTarget {  }
        export interface CompanyFieldControllersTarget {  }
        export interface ProductFieldControllersTarget {  }
        export interface ServiceFieldControllersTarget {  }
        export interface OrderFieldControllersTarget {  }
        export interface PaymentFieldControllersTarget {  }
        export interface PackageFieldControllersTarget {  }
        export interface PromotionFieldControllersTarget {  }
        export interface RepresentsFieldControllersTarget {  }
        export interface OrderedFieldControllersTarget {  } /** Union Gigaform interface with variant switching */export interface GigaformTarget {readonly currentVariant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"; readonly data: Target; readonly errors: ErrorsTarget; readonly tainted: TaintedTarget; readonly variants: VariantFieldsTarget; switchVariant(variant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void; validate(): Result<Target, Array<{field: string; message: string}>>; reset(overrides?: Partial<Target>): void;}/** Variant fields container */export interface VariantFieldsTarget {readonly Account: { readonly fields: AccountFieldControllersTarget };
            readonly User: { readonly fields: UserFieldControllersTarget };
            readonly Employee: { readonly fields: EmployeeFieldControllersTarget };
            readonly Appointment: { readonly fields: AppointmentFieldControllersTarget };
            readonly Lead: { readonly fields: LeadFieldControllersTarget };
            readonly TaxRate: { readonly fields: TaxRateFieldControllersTarget };
            readonly Site: { readonly fields: SiteFieldControllersTarget };
            readonly Route: { readonly fields: RouteFieldControllersTarget };
            readonly Company: { readonly fields: CompanyFieldControllersTarget };
            readonly Product: { readonly fields: ProductFieldControllersTarget };
            readonly Service: { readonly fields: ServiceFieldControllersTarget };
            readonly Order: { readonly fields: OrderFieldControllersTarget };
            readonly Payment: { readonly fields: PaymentFieldControllersTarget };
            readonly Package: { readonly fields: PackageFieldControllersTarget };
            readonly Promotion: { readonly fields: PromotionFieldControllersTarget };
            readonly Represents: { readonly fields: RepresentsFieldControllersTarget };
            readonly Ordered: { readonly fields: OrderedFieldControllersTarget };}/** Gets default value for a specific variant */function getDefaultForVariantTarget(variant: string): Target {
        switch (variant) {
            case "Account": return defaultValueAccount() as Target;
            case "User": return defaultValueUser() as Target;
            case "Employee": return defaultValueEmployee() as Target;
            case "Appointment": return defaultValueAppointment() as Target;
            case "Lead": return defaultValueLead() as Target;
            case "TaxRate": return defaultValueTaxRate() as Target;
            case "Site": return defaultValueSite() as Target;
            case "Route": return defaultValueRoute() as Target;
            case "Company": return defaultValueCompany() as Target;
            case "Product": return defaultValueProduct() as Target;
            case "Service": return defaultValueService() as Target;
            case "Order": return defaultValueOrder() as Target;
            case "Payment": return defaultValuePayment() as Target;
            case "Package": return defaultValuePackage() as Target;
            case "Promotion": return defaultValuePromotion() as Target;
            case "Represents": return defaultValueRepresents() as Target;
            case "Ordered": return defaultValueOrdered() as Target;
            default: return defaultValueAccount() as Target;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormTarget(initial?: Target): GigaformTarget {const initialVariant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" = "Account"; let currentVariant = $state<"Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered">(initialVariant); let data = $state<Target>(initial?? getDefaultForVariantTarget(initialVariant)); let errors = $state<ErrorsTarget>({}as ErrorsTarget); let tainted = $state<TaintedTarget>({}as TaintedTarget); const variants: VariantFieldsTarget = {Account: {
                    fields: {
                        
                    } as AccountFieldControllersTarget
                },
                User: {
                    fields: {
                        
                    } as UserFieldControllersTarget
                },
                Employee: {
                    fields: {
                        
                    } as EmployeeFieldControllersTarget
                },
                Appointment: {
                    fields: {
                        
                    } as AppointmentFieldControllersTarget
                },
                Lead: {
                    fields: {
                        
                    } as LeadFieldControllersTarget
                },
                TaxRate: {
                    fields: {
                        
                    } as TaxRateFieldControllersTarget
                },
                Site: {
                    fields: {
                        
                    } as SiteFieldControllersTarget
                },
                Route: {
                    fields: {
                        
                    } as RouteFieldControllersTarget
                },
                Company: {
                    fields: {
                        
                    } as CompanyFieldControllersTarget
                },
                Product: {
                    fields: {
                        
                    } as ProductFieldControllersTarget
                },
                Service: {
                    fields: {
                        
                    } as ServiceFieldControllersTarget
                },
                Order: {
                    fields: {
                        
                    } as OrderFieldControllersTarget
                },
                Payment: {
                    fields: {
                        
                    } as PaymentFieldControllersTarget
                },
                Package: {
                    fields: {
                        
                    } as PackageFieldControllersTarget
                },
                Promotion: {
                    fields: {
                        
                    } as PromotionFieldControllersTarget
                },
                Represents: {
                    fields: {
                        
                    } as RepresentsFieldControllersTarget
                },
                Ordered: {
                    fields: {
                        
                    } as OrderedFieldControllersTarget
                }}; function switchVariant(variant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void {currentVariant = variant; data = getDefaultForVariantTarget(variant); errors = {}as ErrorsTarget; tainted = {}as TaintedTarget;}function validate(): Result<Target, Array<{field: string; message: string}>>{return fromObjectTarget(data);}function reset(overrides?: Partial<Target>): void {data = overrides ? overrides as typeof data : getDefaultForVariantTarget(currentVariant); errors = {}as ErrorsTarget; tainted = {}as TaintedTarget;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataTarget(formData: FormData): Result<Target, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if (discriminant === "Account") {
                
            } else if (discriminant === "User") {
                
            } else if (discriminant === "Employee") {
                
            } else if (discriminant === "Appointment") {
                
            } else if (discriminant === "Lead") {
                
            } else if (discriminant === "TaxRate") {
                
            } else if (discriminant === "Site") {
                
            } else if (discriminant === "Route") {
                
            } else if (discriminant === "Company") {
                
            } else if (discriminant === "Product") {
                
            } else if (discriminant === "Service") {
                
            } else if (discriminant === "Order") {
                
            } else if (discriminant === "Payment") {
                
            } else if (discriminant === "Package") {
                
            } else if (discriminant === "Promotion") {
                
            } else if (discriminant === "Represents") {
                
            } else if (discriminant === "Ordered") {
                
            } return fromStringifiedJSONTarget(JSON.stringify(obj));}


export type RecurrenceEnd = /** @default(0) */ number | string;

export function defaultValueRecurrenceEnd(): RecurrenceEnd {return 0;}

export function toStringifiedJSONRecurrenceEnd(value: RecurrenceEnd): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeRecurrenceEnd(value, ctx));}export function toObjectRecurrenceEnd(value: RecurrenceEnd): unknown {const ctx = SerializeContext.create(); return __serializeRecurrenceEnd(value, ctx);}export function __serializeRecurrenceEnd(value: RecurrenceEnd, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONRecurrenceEnd(json: string, opts?: DeserializeOptions): Result<RecurrenceEnd, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectRecurrenceEnd(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectRecurrenceEnd(obj: unknown, opts?: DeserializeOptions): Result<RecurrenceEnd, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeRecurrenceEnd(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "RecurrenceEnd.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeRecurrenceEnd(value: any, ctx: DeserializeContext): RecurrenceEnd | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as RecurrenceEnd | PendingRef;}if(typeof value === "number" ){return value as RecurrenceEnd;}if(typeof value === "string" ){return value as RecurrenceEnd;}throw new DeserializeError([{field: "_root" , message: "RecurrenceEnd.__deserialize: expected number, string, got " + typeof value}]); }export function isRecurrenceEnd(value: unknown): value is RecurrenceEnd {return typeof value === "number" || typeof value === "string" ; }

/** Per-variant error types */export type NumberErrorsRecurrenceEnd = { _errors: Option<Array<string>>;  };
        export type StringErrorsRecurrenceEnd = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type NumberTaintedRecurrenceEnd = {  };
        export type StringTaintedRecurrenceEnd = {  }; /** Union error type */export type ErrorsRecurrenceEnd = ({ _type: "number" } & NumberErrorsRecurrenceEnd) | ({ _type: "string" } & StringErrorsRecurrenceEnd); /** Union tainted type */export type TaintedRecurrenceEnd = ({ _type: "number" } & NumberTaintedRecurrenceEnd) | ({ _type: "string" } & StringTaintedRecurrenceEnd); /** Per-variant field controller types */export interface NumberFieldControllersRecurrenceEnd {  }
        export interface StringFieldControllersRecurrenceEnd {  } /** Union Gigaform interface with variant switching */export interface GigaformRecurrenceEnd {readonly currentVariant: "number" | "string"; readonly data: RecurrenceEnd; readonly errors: ErrorsRecurrenceEnd; readonly tainted: TaintedRecurrenceEnd; readonly variants: VariantFieldsRecurrenceEnd; switchVariant(variant: "number" | "string"): void; validate(): Result<RecurrenceEnd, Array<{field: string; message: string}>>; reset(overrides?: Partial<RecurrenceEnd>): void;}/** Variant fields container */export interface VariantFieldsRecurrenceEnd {readonly number: { readonly fields: NumberFieldControllersRecurrenceEnd };
            readonly string: { readonly fields: StringFieldControllersRecurrenceEnd };}/** Gets default value for a specific variant */function getDefaultForVariantRecurrenceEnd(variant: string): RecurrenceEnd {
        switch (variant) {
            case "number": return 0 as RecurrenceEnd;
            case "string": return "" as RecurrenceEnd;
            default: return 0 as RecurrenceEnd;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormRecurrenceEnd(initial?: RecurrenceEnd): GigaformRecurrenceEnd {const initialVariant: "number" | "string" = "number"; let currentVariant = $state<"number" | "string">(initialVariant); let data = $state<RecurrenceEnd>(initial?? getDefaultForVariantRecurrenceEnd(initialVariant)); let errors = $state<ErrorsRecurrenceEnd>({}as ErrorsRecurrenceEnd); let tainted = $state<TaintedRecurrenceEnd>({}as TaintedRecurrenceEnd); const variants: VariantFieldsRecurrenceEnd = {number: {
                    fields: {
                        
                    } as NumberFieldControllersRecurrenceEnd
                },
                string: {
                    fields: {
                        
                    } as StringFieldControllersRecurrenceEnd
                }}; function switchVariant(variant: "number" | "string"): void {currentVariant = variant; data = getDefaultForVariantRecurrenceEnd(variant); errors = {}as ErrorsRecurrenceEnd; tainted = {}as TaintedRecurrenceEnd;}function validate(): Result<RecurrenceEnd, Array<{field: string; message: string}>>{return fromObjectRecurrenceEnd(data);}function reset(overrides?: Partial<RecurrenceEnd>): void {data = overrides ? overrides as typeof data : getDefaultForVariantRecurrenceEnd(currentVariant); errors = {}as ErrorsRecurrenceEnd; tainted = {}as TaintedRecurrenceEnd;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataRecurrenceEnd(formData: FormData): Result<RecurrenceEnd, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "number" | "string" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if (discriminant === "number") {
                
            } else if (discriminant === "string") {
                
            } return fromStringifiedJSONRecurrenceEnd(JSON.stringify(obj));}


export type OverviewDisplay = /** @default */ 'Card' | 'Table';

export function defaultValueOverviewDisplay(): OverviewDisplay {return 'Card';}

export function toStringifiedJSONOverviewDisplay(value: OverviewDisplay): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeOverviewDisplay(value, ctx));}export function toObjectOverviewDisplay(value: OverviewDisplay): unknown {const ctx = SerializeContext.create(); return __serializeOverviewDisplay(value, ctx);}export function __serializeOverviewDisplay(value: OverviewDisplay, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONOverviewDisplay(json: string, opts?: DeserializeOptions): Result<OverviewDisplay, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectOverviewDisplay(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectOverviewDisplay(obj: unknown, opts?: DeserializeOptions): Result<OverviewDisplay, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeOverviewDisplay(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "OverviewDisplay.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeOverviewDisplay(value: any, ctx: DeserializeContext): OverviewDisplay | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as OverviewDisplay | PendingRef;}const allowedValues = ['Card', 'Table', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for OverviewDisplay: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as OverviewDisplay; }export function isOverviewDisplay(value: unknown): value is OverviewDisplay {const allowedValues = ['Card', 'Table', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type CardErrorsOverviewDisplay = { _errors: Option<Array<string>>;  };
        export type TableErrorsOverviewDisplay = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type CardTaintedOverviewDisplay = {  };
        export type TableTaintedOverviewDisplay = {  }; /** Union error type */export type ErrorsOverviewDisplay = ({ _value: "Card" } & CardErrorsOverviewDisplay) | ({ _value: "Table" } & TableErrorsOverviewDisplay); /** Union tainted type */export type TaintedOverviewDisplay = ({ _value: "Card" } & CardTaintedOverviewDisplay) | ({ _value: "Table" } & TableTaintedOverviewDisplay); /** Per-variant field controller types */export interface CardFieldControllersOverviewDisplay {  }
        export interface TableFieldControllersOverviewDisplay {  } /** Union Gigaform interface with variant switching */export interface GigaformOverviewDisplay {readonly currentVariant: "Card" | "Table"; readonly data: OverviewDisplay; readonly errors: ErrorsOverviewDisplay; readonly tainted: TaintedOverviewDisplay; readonly variants: VariantFieldsOverviewDisplay; switchVariant(variant: "Card" | "Table"): void; validate(): Result<OverviewDisplay, Array<{field: string; message: string}>>; reset(overrides?: Partial<OverviewDisplay>): void;}/** Variant fields container */export interface VariantFieldsOverviewDisplay {readonly Card: { readonly fields: CardFieldControllersOverviewDisplay };
            readonly Table: { readonly fields: TableFieldControllersOverviewDisplay };}/** Gets default value for a specific variant */function getDefaultForVariantOverviewDisplay(variant: string): OverviewDisplay {
        switch (variant) {
            case "Card": return "Card" as OverviewDisplay;
            case "Table": return "Table" as OverviewDisplay;
            default: return "Card" as OverviewDisplay;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormOverviewDisplay(initial?: OverviewDisplay): GigaformOverviewDisplay {const initialVariant: "Card" | "Table" = (initial as "Card" | "Table") ?? "Card"; let currentVariant = $state<"Card" | "Table">(initialVariant); let data = $state<OverviewDisplay>(initial?? getDefaultForVariantOverviewDisplay(initialVariant)); let errors = $state<ErrorsOverviewDisplay>({}as ErrorsOverviewDisplay); let tainted = $state<TaintedOverviewDisplay>({}as TaintedOverviewDisplay); const variants: VariantFieldsOverviewDisplay = {Card: {
                    fields: {
                        
                    } as CardFieldControllersOverviewDisplay
                },
                Table: {
                    fields: {
                        
                    } as TableFieldControllersOverviewDisplay
                }}; function switchVariant(variant: "Card" | "Table"): void {currentVariant = variant; data = getDefaultForVariantOverviewDisplay(variant); errors = {}as ErrorsOverviewDisplay; tainted = {}as TaintedOverviewDisplay;}function validate(): Result<OverviewDisplay, Array<{field: string; message: string}>>{return fromObjectOverviewDisplay(data);}function reset(overrides?: Partial<OverviewDisplay>): void {data = overrides ? overrides as typeof data : getDefaultForVariantOverviewDisplay(currentVariant); errors = {}as ErrorsOverviewDisplay; tainted = {}as TaintedOverviewDisplay;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataOverviewDisplay(formData: FormData): Result<OverviewDisplay, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Card" | "Table" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "Card") {
                
            } else if (discriminant === "Table") {
                
            } return fromStringifiedJSONOverviewDisplay(JSON.stringify(obj));}


export type IntervalUnit = /** @default */ 'Day' | 'Week' | 'Month' | 'Year';

export function defaultValueIntervalUnit(): IntervalUnit {return 'Day';}

export function toStringifiedJSONIntervalUnit(value: IntervalUnit): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeIntervalUnit(value, ctx));}export function toObjectIntervalUnit(value: IntervalUnit): unknown {const ctx = SerializeContext.create(); return __serializeIntervalUnit(value, ctx);}export function __serializeIntervalUnit(value: IntervalUnit, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONIntervalUnit(json: string, opts?: DeserializeOptions): Result<IntervalUnit, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectIntervalUnit(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectIntervalUnit(obj: unknown, opts?: DeserializeOptions): Result<IntervalUnit, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeIntervalUnit(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "IntervalUnit.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeIntervalUnit(value: any, ctx: DeserializeContext): IntervalUnit | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as IntervalUnit | PendingRef;}const allowedValues = ['Day', 'Week', 'Month', 'Year', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for IntervalUnit: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as IntervalUnit; }export function isIntervalUnit(value: unknown): value is IntervalUnit {const allowedValues = ['Day', 'Week', 'Month', 'Year', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type DayErrorsIntervalUnit = { _errors: Option<Array<string>>;  };
        export type WeekErrorsIntervalUnit = { _errors: Option<Array<string>>;  };
        export type MonthErrorsIntervalUnit = { _errors: Option<Array<string>>;  };
        export type YearErrorsIntervalUnit = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type DayTaintedIntervalUnit = {  };
        export type WeekTaintedIntervalUnit = {  };
        export type MonthTaintedIntervalUnit = {  };
        export type YearTaintedIntervalUnit = {  }; /** Union error type */export type ErrorsIntervalUnit = ({ _value: "Day" } & DayErrorsIntervalUnit) | ({ _value: "Week" } & WeekErrorsIntervalUnit) | ({ _value: "Month" } & MonthErrorsIntervalUnit) | ({ _value: "Year" } & YearErrorsIntervalUnit); /** Union tainted type */export type TaintedIntervalUnit = ({ _value: "Day" } & DayTaintedIntervalUnit) | ({ _value: "Week" } & WeekTaintedIntervalUnit) | ({ _value: "Month" } & MonthTaintedIntervalUnit) | ({ _value: "Year" } & YearTaintedIntervalUnit); /** Per-variant field controller types */export interface DayFieldControllersIntervalUnit {  }
        export interface WeekFieldControllersIntervalUnit {  }
        export interface MonthFieldControllersIntervalUnit {  }
        export interface YearFieldControllersIntervalUnit {  } /** Union Gigaform interface with variant switching */export interface GigaformIntervalUnit {readonly currentVariant: "Day" | "Week" | "Month" | "Year"; readonly data: IntervalUnit; readonly errors: ErrorsIntervalUnit; readonly tainted: TaintedIntervalUnit; readonly variants: VariantFieldsIntervalUnit; switchVariant(variant: "Day" | "Week" | "Month" | "Year"): void; validate(): Result<IntervalUnit, Array<{field: string; message: string}>>; reset(overrides?: Partial<IntervalUnit>): void;}/** Variant fields container */export interface VariantFieldsIntervalUnit {readonly Day: { readonly fields: DayFieldControllersIntervalUnit };
            readonly Week: { readonly fields: WeekFieldControllersIntervalUnit };
            readonly Month: { readonly fields: MonthFieldControllersIntervalUnit };
            readonly Year: { readonly fields: YearFieldControllersIntervalUnit };}/** Gets default value for a specific variant */function getDefaultForVariantIntervalUnit(variant: string): IntervalUnit {
        switch (variant) {
            case "Day": return "Day" as IntervalUnit;
            case "Week": return "Week" as IntervalUnit;
            case "Month": return "Month" as IntervalUnit;
            case "Year": return "Year" as IntervalUnit;
            default: return "Day" as IntervalUnit;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormIntervalUnit(initial?: IntervalUnit): GigaformIntervalUnit {const initialVariant: "Day" | "Week" | "Month" | "Year" = (initial as "Day" | "Week" | "Month" | "Year") ?? "Day"; let currentVariant = $state<"Day" | "Week" | "Month" | "Year">(initialVariant); let data = $state<IntervalUnit>(initial?? getDefaultForVariantIntervalUnit(initialVariant)); let errors = $state<ErrorsIntervalUnit>({}as ErrorsIntervalUnit); let tainted = $state<TaintedIntervalUnit>({}as TaintedIntervalUnit); const variants: VariantFieldsIntervalUnit = {Day: {
                    fields: {
                        
                    } as DayFieldControllersIntervalUnit
                },
                Week: {
                    fields: {
                        
                    } as WeekFieldControllersIntervalUnit
                },
                Month: {
                    fields: {
                        
                    } as MonthFieldControllersIntervalUnit
                },
                Year: {
                    fields: {
                        
                    } as YearFieldControllersIntervalUnit
                }}; function switchVariant(variant: "Day" | "Week" | "Month" | "Year"): void {currentVariant = variant; data = getDefaultForVariantIntervalUnit(variant); errors = {}as ErrorsIntervalUnit; tainted = {}as TaintedIntervalUnit;}function validate(): Result<IntervalUnit, Array<{field: string; message: string}>>{return fromObjectIntervalUnit(data);}function reset(overrides?: Partial<IntervalUnit>): void {data = overrides ? overrides as typeof data : getDefaultForVariantIntervalUnit(currentVariant); errors = {}as ErrorsIntervalUnit; tainted = {}as TaintedIntervalUnit;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataIntervalUnit(formData: FormData): Result<IntervalUnit, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Day" | "Week" | "Month" | "Year" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "Day") {
                
            } else if (discriminant === "Week") {
                
            } else if (discriminant === "Month") {
                
            } else if (discriminant === "Year") {
                
            } return fromStringifiedJSONIntervalUnit(JSON.stringify(obj));}


export type Sector = /** @default */ 'Residential' | 'Commercial';

export function defaultValueSector(): Sector {return 'Residential';}

export function toStringifiedJSONSector(value: Sector): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeSector(value, ctx));}export function toObjectSector(value: Sector): unknown {const ctx = SerializeContext.create(); return __serializeSector(value, ctx);}export function __serializeSector(value: Sector, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONSector(json: string, opts?: DeserializeOptions): Result<Sector, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectSector(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectSector(obj: unknown, opts?: DeserializeOptions): Result<Sector, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeSector(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Sector.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeSector(value: any, ctx: DeserializeContext): Sector | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Sector | PendingRef;}const allowedValues = ['Residential', 'Commercial', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for Sector: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Sector; }export function isSector(value: unknown): value is Sector {const allowedValues = ['Residential', 'Commercial', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type ResidentialErrorsSector = { _errors: Option<Array<string>>;  };
        export type CommercialErrorsSector = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type ResidentialTaintedSector = {  };
        export type CommercialTaintedSector = {  }; /** Union error type */export type ErrorsSector = ({ _value: "Residential" } & ResidentialErrorsSector) | ({ _value: "Commercial" } & CommercialErrorsSector); /** Union tainted type */export type TaintedSector = ({ _value: "Residential" } & ResidentialTaintedSector) | ({ _value: "Commercial" } & CommercialTaintedSector); /** Per-variant field controller types */export interface ResidentialFieldControllersSector {  }
        export interface CommercialFieldControllersSector {  } /** Union Gigaform interface with variant switching */export interface GigaformSector {readonly currentVariant: "Residential" | "Commercial"; readonly data: Sector; readonly errors: ErrorsSector; readonly tainted: TaintedSector; readonly variants: VariantFieldsSector; switchVariant(variant: "Residential" | "Commercial"): void; validate(): Result<Sector, Array<{field: string; message: string}>>; reset(overrides?: Partial<Sector>): void;}/** Variant fields container */export interface VariantFieldsSector {readonly Residential: { readonly fields: ResidentialFieldControllersSector };
            readonly Commercial: { readonly fields: CommercialFieldControllersSector };}/** Gets default value for a specific variant */function getDefaultForVariantSector(variant: string): Sector {
        switch (variant) {
            case "Residential": return "Residential" as Sector;
            case "Commercial": return "Commercial" as Sector;
            default: return "Residential" as Sector;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormSector(initial?: Sector): GigaformSector {const initialVariant: "Residential" | "Commercial" = (initial as "Residential" | "Commercial") ?? "Residential"; let currentVariant = $state<"Residential" | "Commercial">(initialVariant); let data = $state<Sector>(initial?? getDefaultForVariantSector(initialVariant)); let errors = $state<ErrorsSector>({}as ErrorsSector); let tainted = $state<TaintedSector>({}as TaintedSector); const variants: VariantFieldsSector = {Residential: {
                    fields: {
                        
                    } as ResidentialFieldControllersSector
                },
                Commercial: {
                    fields: {
                        
                    } as CommercialFieldControllersSector
                }}; function switchVariant(variant: "Residential" | "Commercial"): void {currentVariant = variant; data = getDefaultForVariantSector(variant); errors = {}as ErrorsSector; tainted = {}as TaintedSector;}function validate(): Result<Sector, Array<{field: string; message: string}>>{return fromObjectSector(data);}function reset(overrides?: Partial<Sector>): void {data = overrides ? overrides as typeof data : getDefaultForVariantSector(currentVariant); errors = {}as ErrorsSector; tainted = {}as TaintedSector;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataSector(formData: FormData): Result<Sector, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Residential" | "Commercial" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "Residential") {
                
            } else if (discriminant === "Commercial") {
                
            } return fromStringifiedJSONSector(JSON.stringify(obj));}


export type Weekday =
    | /** @default */ 'Monday'
    | 'Tuesday'
    | 'Wednesday'
    | 'Thursday'
    | 'Friday'
    | 'Saturday'
    | 'Sunday';

export function defaultValueWeekday(): Weekday {return 'Monday';}

export function toStringifiedJSONWeekday(value: Weekday): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeWeekday(value, ctx));}export function toObjectWeekday(value: Weekday): unknown {const ctx = SerializeContext.create(); return __serializeWeekday(value, ctx);}export function __serializeWeekday(value: Weekday, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONWeekday(json: string, opts?: DeserializeOptions): Result<Weekday, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectWeekday(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectWeekday(obj: unknown, opts?: DeserializeOptions): Result<Weekday, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeWeekday(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Weekday.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeWeekday(value: any, ctx: DeserializeContext): Weekday | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Weekday | PendingRef;}const allowedValues = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for Weekday: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Weekday; }export function isWeekday(value: unknown): value is Weekday {const allowedValues = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type MondayErrorsWeekday = { _errors: Option<Array<string>>;  };
        export type TuesdayErrorsWeekday = { _errors: Option<Array<string>>;  };
        export type WednesdayErrorsWeekday = { _errors: Option<Array<string>>;  };
        export type ThursdayErrorsWeekday = { _errors: Option<Array<string>>;  };
        export type FridayErrorsWeekday = { _errors: Option<Array<string>>;  };
        export type SaturdayErrorsWeekday = { _errors: Option<Array<string>>;  };
        export type SundayErrorsWeekday = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type MondayTaintedWeekday = {  };
        export type TuesdayTaintedWeekday = {  };
        export type WednesdayTaintedWeekday = {  };
        export type ThursdayTaintedWeekday = {  };
        export type FridayTaintedWeekday = {  };
        export type SaturdayTaintedWeekday = {  };
        export type SundayTaintedWeekday = {  }; /** Union error type */export type ErrorsWeekday = ({ _value: "Monday" } & MondayErrorsWeekday) | ({ _value: "Tuesday" } & TuesdayErrorsWeekday) | ({ _value: "Wednesday" } & WednesdayErrorsWeekday) | ({ _value: "Thursday" } & ThursdayErrorsWeekday) | ({ _value: "Friday" } & FridayErrorsWeekday) | ({ _value: "Saturday" } & SaturdayErrorsWeekday) | ({ _value: "Sunday" } & SundayErrorsWeekday); /** Union tainted type */export type TaintedWeekday = ({ _value: "Monday" } & MondayTaintedWeekday) | ({ _value: "Tuesday" } & TuesdayTaintedWeekday) | ({ _value: "Wednesday" } & WednesdayTaintedWeekday) | ({ _value: "Thursday" } & ThursdayTaintedWeekday) | ({ _value: "Friday" } & FridayTaintedWeekday) | ({ _value: "Saturday" } & SaturdayTaintedWeekday) | ({ _value: "Sunday" } & SundayTaintedWeekday); /** Per-variant field controller types */export interface MondayFieldControllersWeekday {  }
        export interface TuesdayFieldControllersWeekday {  }
        export interface WednesdayFieldControllersWeekday {  }
        export interface ThursdayFieldControllersWeekday {  }
        export interface FridayFieldControllersWeekday {  }
        export interface SaturdayFieldControllersWeekday {  }
        export interface SundayFieldControllersWeekday {  } /** Union Gigaform interface with variant switching */export interface GigaformWeekday {readonly currentVariant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"; readonly data: Weekday; readonly errors: ErrorsWeekday; readonly tainted: TaintedWeekday; readonly variants: VariantFieldsWeekday; switchVariant(variant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"): void; validate(): Result<Weekday, Array<{field: string; message: string}>>; reset(overrides?: Partial<Weekday>): void;}/** Variant fields container */export interface VariantFieldsWeekday {readonly Monday: { readonly fields: MondayFieldControllersWeekday };
            readonly Tuesday: { readonly fields: TuesdayFieldControllersWeekday };
            readonly Wednesday: { readonly fields: WednesdayFieldControllersWeekday };
            readonly Thursday: { readonly fields: ThursdayFieldControllersWeekday };
            readonly Friday: { readonly fields: FridayFieldControllersWeekday };
            readonly Saturday: { readonly fields: SaturdayFieldControllersWeekday };
            readonly Sunday: { readonly fields: SundayFieldControllersWeekday };}/** Gets default value for a specific variant */function getDefaultForVariantWeekday(variant: string): Weekday {
        switch (variant) {
            case "Monday": return "Monday" as Weekday;
            case "Tuesday": return "Tuesday" as Weekday;
            case "Wednesday": return "Wednesday" as Weekday;
            case "Thursday": return "Thursday" as Weekday;
            case "Friday": return "Friday" as Weekday;
            case "Saturday": return "Saturday" as Weekday;
            case "Sunday": return "Sunday" as Weekday;
            default: return "Monday" as Weekday;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormWeekday(initial?: Weekday): GigaformWeekday {const initialVariant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday" = (initial as "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday") ?? "Monday"; let currentVariant = $state<"Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday">(initialVariant); let data = $state<Weekday>(initial?? getDefaultForVariantWeekday(initialVariant)); let errors = $state<ErrorsWeekday>({}as ErrorsWeekday); let tainted = $state<TaintedWeekday>({}as TaintedWeekday); const variants: VariantFieldsWeekday = {Monday: {
                    fields: {
                        
                    } as MondayFieldControllersWeekday
                },
                Tuesday: {
                    fields: {
                        
                    } as TuesdayFieldControllersWeekday
                },
                Wednesday: {
                    fields: {
                        
                    } as WednesdayFieldControllersWeekday
                },
                Thursday: {
                    fields: {
                        
                    } as ThursdayFieldControllersWeekday
                },
                Friday: {
                    fields: {
                        
                    } as FridayFieldControllersWeekday
                },
                Saturday: {
                    fields: {
                        
                    } as SaturdayFieldControllersWeekday
                },
                Sunday: {
                    fields: {
                        
                    } as SundayFieldControllersWeekday
                }}; function switchVariant(variant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"): void {currentVariant = variant; data = getDefaultForVariantWeekday(variant); errors = {}as ErrorsWeekday; tainted = {}as TaintedWeekday;}function validate(): Result<Weekday, Array<{field: string; message: string}>>{return fromObjectWeekday(data);}function reset(overrides?: Partial<Weekday>): void {data = overrides ? overrides as typeof data : getDefaultForVariantWeekday(currentVariant); errors = {}as ErrorsWeekday; tainted = {}as TaintedWeekday;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataWeekday(formData: FormData): Result<Weekday, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "Monday") {
                
            } else if (discriminant === "Tuesday") {
                
            } else if (discriminant === "Wednesday") {
                
            } else if (discriminant === "Thursday") {
                
            } else if (discriminant === "Friday") {
                
            } else if (discriminant === "Saturday") {
                
            } else if (discriminant === "Sunday") {
                
            } return fromStringifiedJSONWeekday(JSON.stringify(obj));}


export type Status = /** @default */ 'Scheduled' | 'OnDeck' | 'Waiting';

export function defaultValueStatus(): Status {return 'Scheduled';}

export function toStringifiedJSONStatus(value: Status): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeStatus(value, ctx));}export function toObjectStatus(value: Status): unknown {const ctx = SerializeContext.create(); return __serializeStatus(value, ctx);}export function __serializeStatus(value: Status, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONStatus(json: string, opts?: DeserializeOptions): Result<Status, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectStatus(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectStatus(obj: unknown, opts?: DeserializeOptions): Result<Status, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeStatus(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Status.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeStatus(value: any, ctx: DeserializeContext): Status | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Status | PendingRef;}const allowedValues = ['Scheduled', 'OnDeck', 'Waiting', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for Status: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Status; }export function isStatus(value: unknown): value is Status {const allowedValues = ['Scheduled', 'OnDeck', 'Waiting', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type ScheduledErrorsStatus = { _errors: Option<Array<string>>;  };
        export type OnDeckErrorsStatus = { _errors: Option<Array<string>>;  };
        export type WaitingErrorsStatus = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type ScheduledTaintedStatus = {  };
        export type OnDeckTaintedStatus = {  };
        export type WaitingTaintedStatus = {  }; /** Union error type */export type ErrorsStatus = ({ _value: "Scheduled" } & ScheduledErrorsStatus) | ({ _value: "OnDeck" } & OnDeckErrorsStatus) | ({ _value: "Waiting" } & WaitingErrorsStatus); /** Union tainted type */export type TaintedStatus = ({ _value: "Scheduled" } & ScheduledTaintedStatus) | ({ _value: "OnDeck" } & OnDeckTaintedStatus) | ({ _value: "Waiting" } & WaitingTaintedStatus); /** Per-variant field controller types */export interface ScheduledFieldControllersStatus {  }
        export interface OnDeckFieldControllersStatus {  }
        export interface WaitingFieldControllersStatus {  } /** Union Gigaform interface with variant switching */export interface GigaformStatus {readonly currentVariant: "Scheduled" | "OnDeck" | "Waiting"; readonly data: Status; readonly errors: ErrorsStatus; readonly tainted: TaintedStatus; readonly variants: VariantFieldsStatus; switchVariant(variant: "Scheduled" | "OnDeck" | "Waiting"): void; validate(): Result<Status, Array<{field: string; message: string}>>; reset(overrides?: Partial<Status>): void;}/** Variant fields container */export interface VariantFieldsStatus {readonly Scheduled: { readonly fields: ScheduledFieldControllersStatus };
            readonly OnDeck: { readonly fields: OnDeckFieldControllersStatus };
            readonly Waiting: { readonly fields: WaitingFieldControllersStatus };}/** Gets default value for a specific variant */function getDefaultForVariantStatus(variant: string): Status {
        switch (variant) {
            case "Scheduled": return "Scheduled" as Status;
            case "OnDeck": return "OnDeck" as Status;
            case "Waiting": return "Waiting" as Status;
            default: return "Scheduled" as Status;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormStatus(initial?: Status): GigaformStatus {const initialVariant: "Scheduled" | "OnDeck" | "Waiting" = (initial as "Scheduled" | "OnDeck" | "Waiting") ?? "Scheduled"; let currentVariant = $state<"Scheduled" | "OnDeck" | "Waiting">(initialVariant); let data = $state<Status>(initial?? getDefaultForVariantStatus(initialVariant)); let errors = $state<ErrorsStatus>({}as ErrorsStatus); let tainted = $state<TaintedStatus>({}as TaintedStatus); const variants: VariantFieldsStatus = {Scheduled: {
                    fields: {
                        
                    } as ScheduledFieldControllersStatus
                },
                OnDeck: {
                    fields: {
                        
                    } as OnDeckFieldControllersStatus
                },
                Waiting: {
                    fields: {
                        
                    } as WaitingFieldControllersStatus
                }}; function switchVariant(variant: "Scheduled" | "OnDeck" | "Waiting"): void {currentVariant = variant; data = getDefaultForVariantStatus(variant); errors = {}as ErrorsStatus; tainted = {}as TaintedStatus;}function validate(): Result<Status, Array<{field: string; message: string}>>{return fromObjectStatus(data);}function reset(overrides?: Partial<Status>): void {data = overrides ? overrides as typeof data : getDefaultForVariantStatus(currentVariant); errors = {}as ErrorsStatus; tainted = {}as TaintedStatus;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataStatus(formData: FormData): Result<Status, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Scheduled" | "OnDeck" | "Waiting" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "Scheduled") {
                
            } else if (discriminant === "OnDeck") {
                
            } else if (discriminant === "Waiting") {
                
            } return fromStringifiedJSONStatus(JSON.stringify(obj));}


export type NextStep = /** @default */ 'InitialContact' | 'Qualified' | 'Estimate' | 'Negotiation';

export function defaultValueNextStep(): NextStep {return 'InitialContact';}

export function toStringifiedJSONNextStep(value: NextStep): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeNextStep(value, ctx));}export function toObjectNextStep(value: NextStep): unknown {const ctx = SerializeContext.create(); return __serializeNextStep(value, ctx);}export function __serializeNextStep(value: NextStep, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONNextStep(json: string, opts?: DeserializeOptions): Result<NextStep, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectNextStep(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectNextStep(obj: unknown, opts?: DeserializeOptions): Result<NextStep, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeNextStep(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "NextStep.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeNextStep(value: any, ctx: DeserializeContext): NextStep | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as NextStep | PendingRef;}const allowedValues = ['InitialContact', 'Qualified', 'Estimate', 'Negotiation', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for NextStep: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as NextStep; }export function isNextStep(value: unknown): value is NextStep {const allowedValues = ['InitialContact', 'Qualified', 'Estimate', 'Negotiation', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type InitialContactErrorsNextStep = { _errors: Option<Array<string>>;  };
        export type QualifiedErrorsNextStep = { _errors: Option<Array<string>>;  };
        export type EstimateErrorsNextStep = { _errors: Option<Array<string>>;  };
        export type NegotiationErrorsNextStep = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type InitialContactTaintedNextStep = {  };
        export type QualifiedTaintedNextStep = {  };
        export type EstimateTaintedNextStep = {  };
        export type NegotiationTaintedNextStep = {  }; /** Union error type */export type ErrorsNextStep = ({ _value: "InitialContact" } & InitialContactErrorsNextStep) | ({ _value: "Qualified" } & QualifiedErrorsNextStep) | ({ _value: "Estimate" } & EstimateErrorsNextStep) | ({ _value: "Negotiation" } & NegotiationErrorsNextStep); /** Union tainted type */export type TaintedNextStep = ({ _value: "InitialContact" } & InitialContactTaintedNextStep) | ({ _value: "Qualified" } & QualifiedTaintedNextStep) | ({ _value: "Estimate" } & EstimateTaintedNextStep) | ({ _value: "Negotiation" } & NegotiationTaintedNextStep); /** Per-variant field controller types */export interface InitialContactFieldControllersNextStep {  }
        export interface QualifiedFieldControllersNextStep {  }
        export interface EstimateFieldControllersNextStep {  }
        export interface NegotiationFieldControllersNextStep {  } /** Union Gigaform interface with variant switching */export interface GigaformNextStep {readonly currentVariant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation"; readonly data: NextStep; readonly errors: ErrorsNextStep; readonly tainted: TaintedNextStep; readonly variants: VariantFieldsNextStep; switchVariant(variant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void; validate(): Result<NextStep, Array<{field: string; message: string}>>; reset(overrides?: Partial<NextStep>): void;}/** Variant fields container */export interface VariantFieldsNextStep {readonly InitialContact: { readonly fields: InitialContactFieldControllersNextStep };
            readonly Qualified: { readonly fields: QualifiedFieldControllersNextStep };
            readonly Estimate: { readonly fields: EstimateFieldControllersNextStep };
            readonly Negotiation: { readonly fields: NegotiationFieldControllersNextStep };}/** Gets default value for a specific variant */function getDefaultForVariantNextStep(variant: string): NextStep {
        switch (variant) {
            case "InitialContact": return "InitialContact" as NextStep;
            case "Qualified": return "Qualified" as NextStep;
            case "Estimate": return "Estimate" as NextStep;
            case "Negotiation": return "Negotiation" as NextStep;
            default: return "InitialContact" as NextStep;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormNextStep(initial?: NextStep): GigaformNextStep {const initialVariant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation" = (initial as "InitialContact" | "Qualified" | "Estimate" | "Negotiation") ?? "InitialContact"; let currentVariant = $state<"InitialContact" | "Qualified" | "Estimate" | "Negotiation">(initialVariant); let data = $state<NextStep>(initial?? getDefaultForVariantNextStep(initialVariant)); let errors = $state<ErrorsNextStep>({}as ErrorsNextStep); let tainted = $state<TaintedNextStep>({}as TaintedNextStep); const variants: VariantFieldsNextStep = {InitialContact: {
                    fields: {
                        
                    } as InitialContactFieldControllersNextStep
                },
                Qualified: {
                    fields: {
                        
                    } as QualifiedFieldControllersNextStep
                },
                Estimate: {
                    fields: {
                        
                    } as EstimateFieldControllersNextStep
                },
                Negotiation: {
                    fields: {
                        
                    } as NegotiationFieldControllersNextStep
                }}; function switchVariant(variant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void {currentVariant = variant; data = getDefaultForVariantNextStep(variant); errors = {}as ErrorsNextStep; tainted = {}as TaintedNextStep;}function validate(): Result<NextStep, Array<{field: string; message: string}>>{return fromObjectNextStep(data);}function reset(overrides?: Partial<NextStep>): void {data = overrides ? overrides as typeof data : getDefaultForVariantNextStep(currentVariant); errors = {}as ErrorsNextStep; tainted = {}as TaintedNextStep;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataNextStep(formData: FormData): Result<NextStep, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "InitialContact" | "Qualified" | "Estimate" | "Negotiation" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "InitialContact") {
                
            } else if (discriminant === "Qualified") {
                
            } else if (discriminant === "Estimate") {
                
            } else if (discriminant === "Negotiation") {
                
            } return fromStringifiedJSONNextStep(JSON.stringify(obj));}


export type LeadStage =
    | /** @default */ 'Open'
    | 'InitialContact'
    | 'Qualified'
    | 'Estimate'
    | 'Negotiation';

export function defaultValueLeadStage(): LeadStage {return 'Open';}

export function toStringifiedJSONLeadStage(value: LeadStage): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeLeadStage(value, ctx));}export function toObjectLeadStage(value: LeadStage): unknown {const ctx = SerializeContext.create(); return __serializeLeadStage(value, ctx);}export function __serializeLeadStage(value: LeadStage, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONLeadStage(json: string, opts?: DeserializeOptions): Result<LeadStage, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectLeadStage(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectLeadStage(obj: unknown, opts?: DeserializeOptions): Result<LeadStage, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeLeadStage(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "LeadStage.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeLeadStage(value: any, ctx: DeserializeContext): LeadStage | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as LeadStage | PendingRef;}const allowedValues = ['Open', 'InitialContact', 'Qualified', 'Estimate', 'Negotiation', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for LeadStage: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as LeadStage; }export function isLeadStage(value: unknown): value is LeadStage {const allowedValues = ['Open', 'InitialContact', 'Qualified', 'Estimate', 'Negotiation', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type OpenErrorsLeadStage = { _errors: Option<Array<string>>;  };
        export type InitialContactErrorsLeadStage = { _errors: Option<Array<string>>;  };
        export type QualifiedErrorsLeadStage = { _errors: Option<Array<string>>;  };
        export type EstimateErrorsLeadStage = { _errors: Option<Array<string>>;  };
        export type NegotiationErrorsLeadStage = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type OpenTaintedLeadStage = {  };
        export type InitialContactTaintedLeadStage = {  };
        export type QualifiedTaintedLeadStage = {  };
        export type EstimateTaintedLeadStage = {  };
        export type NegotiationTaintedLeadStage = {  }; /** Union error type */export type ErrorsLeadStage = ({ _value: "Open" } & OpenErrorsLeadStage) | ({ _value: "InitialContact" } & InitialContactErrorsLeadStage) | ({ _value: "Qualified" } & QualifiedErrorsLeadStage) | ({ _value: "Estimate" } & EstimateErrorsLeadStage) | ({ _value: "Negotiation" } & NegotiationErrorsLeadStage); /** Union tainted type */export type TaintedLeadStage = ({ _value: "Open" } & OpenTaintedLeadStage) | ({ _value: "InitialContact" } & InitialContactTaintedLeadStage) | ({ _value: "Qualified" } & QualifiedTaintedLeadStage) | ({ _value: "Estimate" } & EstimateTaintedLeadStage) | ({ _value: "Negotiation" } & NegotiationTaintedLeadStage); /** Per-variant field controller types */export interface OpenFieldControllersLeadStage {  }
        export interface InitialContactFieldControllersLeadStage {  }
        export interface QualifiedFieldControllersLeadStage {  }
        export interface EstimateFieldControllersLeadStage {  }
        export interface NegotiationFieldControllersLeadStage {  } /** Union Gigaform interface with variant switching */export interface GigaformLeadStage {readonly currentVariant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation"; readonly data: LeadStage; readonly errors: ErrorsLeadStage; readonly tainted: TaintedLeadStage; readonly variants: VariantFieldsLeadStage; switchVariant(variant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void; validate(): Result<LeadStage, Array<{field: string; message: string}>>; reset(overrides?: Partial<LeadStage>): void;}/** Variant fields container */export interface VariantFieldsLeadStage {readonly Open: { readonly fields: OpenFieldControllersLeadStage };
            readonly InitialContact: { readonly fields: InitialContactFieldControllersLeadStage };
            readonly Qualified: { readonly fields: QualifiedFieldControllersLeadStage };
            readonly Estimate: { readonly fields: EstimateFieldControllersLeadStage };
            readonly Negotiation: { readonly fields: NegotiationFieldControllersLeadStage };}/** Gets default value for a specific variant */function getDefaultForVariantLeadStage(variant: string): LeadStage {
        switch (variant) {
            case "Open": return "Open" as LeadStage;
            case "InitialContact": return "InitialContact" as LeadStage;
            case "Qualified": return "Qualified" as LeadStage;
            case "Estimate": return "Estimate" as LeadStage;
            case "Negotiation": return "Negotiation" as LeadStage;
            default: return "Open" as LeadStage;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormLeadStage(initial?: LeadStage): GigaformLeadStage {const initialVariant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation" = (initial as "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation") ?? "Open"; let currentVariant = $state<"Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation">(initialVariant); let data = $state<LeadStage>(initial?? getDefaultForVariantLeadStage(initialVariant)); let errors = $state<ErrorsLeadStage>({}as ErrorsLeadStage); let tainted = $state<TaintedLeadStage>({}as TaintedLeadStage); const variants: VariantFieldsLeadStage = {Open: {
                    fields: {
                        
                    } as OpenFieldControllersLeadStage
                },
                InitialContact: {
                    fields: {
                        
                    } as InitialContactFieldControllersLeadStage
                },
                Qualified: {
                    fields: {
                        
                    } as QualifiedFieldControllersLeadStage
                },
                Estimate: {
                    fields: {
                        
                    } as EstimateFieldControllersLeadStage
                },
                Negotiation: {
                    fields: {
                        
                    } as NegotiationFieldControllersLeadStage
                }}; function switchVariant(variant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void {currentVariant = variant; data = getDefaultForVariantLeadStage(variant); errors = {}as ErrorsLeadStage; tainted = {}as TaintedLeadStage;}function validate(): Result<LeadStage, Array<{field: string; message: string}>>{return fromObjectLeadStage(data);}function reset(overrides?: Partial<LeadStage>): void {data = overrides ? overrides as typeof data : getDefaultForVariantLeadStage(currentVariant); errors = {}as ErrorsLeadStage; tainted = {}as TaintedLeadStage;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataLeadStage(formData: FormData): Result<LeadStage, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "Open") {
                
            } else if (discriminant === "InitialContact") {
                
            } else if (discriminant === "Qualified") {
                
            } else if (discriminant === "Estimate") {
                
            } else if (discriminant === "Negotiation") {
                
            } return fromStringifiedJSONLeadStage(JSON.stringify(obj));}


export type AccountName = /** @default */ CompanyName | PersonName;

export function defaultValueAccountName(): AccountName {return defaultValueCompanyName();}

export function toStringifiedJSONAccountName(value: AccountName): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeAccountName(value, ctx));}export function toObjectAccountName(value: AccountName): unknown {const ctx = SerializeContext.create(); return __serializeAccountName(value, ctx);}export function __serializeAccountName(value: AccountName, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONAccountName(json: string, opts?: DeserializeOptions): Result<AccountName, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectAccountName(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectAccountName(obj: unknown, opts?: DeserializeOptions): Result<AccountName, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeAccountName(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "AccountName.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeAccountName(value: any, ctx: DeserializeContext): AccountName | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as AccountName | PendingRef;}if(typeof value!== "object" || value === null){throw new DeserializeError([{field: "_root" , message: "AccountName.__deserialize: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new DeserializeError([{field: "_root" , message: "AccountName.__deserialize: missing __type field for union dispatch" }]);}if(__typeName === "CompanyName" ){return __deserializeCompanyName(value, ctx)as AccountName;}if(__typeName === "PersonName" ){return __deserializePersonName(value, ctx)as AccountName;}throw new DeserializeError([{field: "_root" , message: "AccountName.__deserialize: unknown type \"" + __typeName + "\". Expected one of: CompanyName, PersonName" }]); }export function isAccountName(value: unknown): value is AccountName {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "CompanyName" || __typeName === "PersonName" ; }

/** Per-variant error types */export type CompanyNameErrorsAccountName = { _errors: Option<Array<string>>;  };
        export type PersonNameErrorsAccountName = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type CompanyNameTaintedAccountName = {  };
        export type PersonNameTaintedAccountName = {  }; /** Union error type */export type ErrorsAccountName = ({ _type: "CompanyName" } & CompanyNameErrorsAccountName) | ({ _type: "PersonName" } & PersonNameErrorsAccountName); /** Union tainted type */export type TaintedAccountName = ({ _type: "CompanyName" } & CompanyNameTaintedAccountName) | ({ _type: "PersonName" } & PersonNameTaintedAccountName); /** Per-variant field controller types */export interface CompanyNameFieldControllersAccountName {  }
        export interface PersonNameFieldControllersAccountName {  } /** Union Gigaform interface with variant switching */export interface GigaformAccountName {readonly currentVariant: "CompanyName" | "PersonName"; readonly data: AccountName; readonly errors: ErrorsAccountName; readonly tainted: TaintedAccountName; readonly variants: VariantFieldsAccountName; switchVariant(variant: "CompanyName" | "PersonName"): void; validate(): Result<AccountName, Array<{field: string; message: string}>>; reset(overrides?: Partial<AccountName>): void;}/** Variant fields container */export interface VariantFieldsAccountName {readonly CompanyName: { readonly fields: CompanyNameFieldControllersAccountName };
            readonly PersonName: { readonly fields: PersonNameFieldControllersAccountName };}/** Gets default value for a specific variant */function getDefaultForVariantAccountName(variant: string): AccountName {
        switch (variant) {
            case "CompanyName": return defaultValueCompanyName() as AccountName;
            case "PersonName": return defaultValuePersonName() as AccountName;
            default: return defaultValueCompanyName() as AccountName;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormAccountName(initial?: AccountName): GigaformAccountName {const initialVariant: "CompanyName" | "PersonName" = "CompanyName"; let currentVariant = $state<"CompanyName" | "PersonName">(initialVariant); let data = $state<AccountName>(initial?? getDefaultForVariantAccountName(initialVariant)); let errors = $state<ErrorsAccountName>({}as ErrorsAccountName); let tainted = $state<TaintedAccountName>({}as TaintedAccountName); const variants: VariantFieldsAccountName = {CompanyName: {
                    fields: {
                        
                    } as CompanyNameFieldControllersAccountName
                },
                PersonName: {
                    fields: {
                        
                    } as PersonNameFieldControllersAccountName
                }}; function switchVariant(variant: "CompanyName" | "PersonName"): void {currentVariant = variant; data = getDefaultForVariantAccountName(variant); errors = {}as ErrorsAccountName; tainted = {}as TaintedAccountName;}function validate(): Result<AccountName, Array<{field: string; message: string}>>{return fromObjectAccountName(data);}function reset(overrides?: Partial<AccountName>): void {data = overrides ? overrides as typeof data : getDefaultForVariantAccountName(currentVariant); errors = {}as ErrorsAccountName; tainted = {}as TaintedAccountName;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataAccountName(formData: FormData): Result<AccountName, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "CompanyName" | "PersonName" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if (discriminant === "CompanyName") {
                
            } else if (discriminant === "PersonName") {
                
            } return fromStringifiedJSONAccountName(JSON.stringify(obj));}


export type Priority = /** @default */ 'Medium' | 'High' | 'Low';

export function defaultValuePriority(): Priority {return 'Medium';}

export function toStringifiedJSONPriority(value: Priority): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializePriority(value, ctx));}export function toObjectPriority(value: Priority): unknown {const ctx = SerializeContext.create(); return __serializePriority(value, ctx);}export function __serializePriority(value: Priority, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONPriority(json: string, opts?: DeserializeOptions): Result<Priority, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectPriority(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectPriority(obj: unknown, opts?: DeserializeOptions): Result<Priority, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializePriority(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Priority.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializePriority(value: any, ctx: DeserializeContext): Priority | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Priority | PendingRef;}const allowedValues = ['Medium', 'High', 'Low', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for Priority: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Priority; }export function isPriority(value: unknown): value is Priority {const allowedValues = ['Medium', 'High', 'Low', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type MediumErrorsPriority = { _errors: Option<Array<string>>;  };
        export type HighErrorsPriority = { _errors: Option<Array<string>>;  };
        export type LowErrorsPriority = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type MediumTaintedPriority = {  };
        export type HighTaintedPriority = {  };
        export type LowTaintedPriority = {  }; /** Union error type */export type ErrorsPriority = ({ _value: "Medium" } & MediumErrorsPriority) | ({ _value: "High" } & HighErrorsPriority) | ({ _value: "Low" } & LowErrorsPriority); /** Union tainted type */export type TaintedPriority = ({ _value: "Medium" } & MediumTaintedPriority) | ({ _value: "High" } & HighTaintedPriority) | ({ _value: "Low" } & LowTaintedPriority); /** Per-variant field controller types */export interface MediumFieldControllersPriority {  }
        export interface HighFieldControllersPriority {  }
        export interface LowFieldControllersPriority {  } /** Union Gigaform interface with variant switching */export interface GigaformPriority {readonly currentVariant: "Medium" | "High" | "Low"; readonly data: Priority; readonly errors: ErrorsPriority; readonly tainted: TaintedPriority; readonly variants: VariantFieldsPriority; switchVariant(variant: "Medium" | "High" | "Low"): void; validate(): Result<Priority, Array<{field: string; message: string}>>; reset(overrides?: Partial<Priority>): void;}/** Variant fields container */export interface VariantFieldsPriority {readonly Medium: { readonly fields: MediumFieldControllersPriority };
            readonly High: { readonly fields: HighFieldControllersPriority };
            readonly Low: { readonly fields: LowFieldControllersPriority };}/** Gets default value for a specific variant */function getDefaultForVariantPriority(variant: string): Priority {
        switch (variant) {
            case "Medium": return "Medium" as Priority;
            case "High": return "High" as Priority;
            case "Low": return "Low" as Priority;
            default: return "Medium" as Priority;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormPriority(initial?: Priority): GigaformPriority {const initialVariant: "Medium" | "High" | "Low" = (initial as "Medium" | "High" | "Low") ?? "Medium"; let currentVariant = $state<"Medium" | "High" | "Low">(initialVariant); let data = $state<Priority>(initial?? getDefaultForVariantPriority(initialVariant)); let errors = $state<ErrorsPriority>({}as ErrorsPriority); let tainted = $state<TaintedPriority>({}as TaintedPriority); const variants: VariantFieldsPriority = {Medium: {
                    fields: {
                        
                    } as MediumFieldControllersPriority
                },
                High: {
                    fields: {
                        
                    } as HighFieldControllersPriority
                },
                Low: {
                    fields: {
                        
                    } as LowFieldControllersPriority
                }}; function switchVariant(variant: "Medium" | "High" | "Low"): void {currentVariant = variant; data = getDefaultForVariantPriority(variant); errors = {}as ErrorsPriority; tainted = {}as TaintedPriority;}function validate(): Result<Priority, Array<{field: string; message: string}>>{return fromObjectPriority(data);}function reset(overrides?: Partial<Priority>): void {data = overrides ? overrides as typeof data : getDefaultForVariantPriority(currentVariant); errors = {}as ErrorsPriority; tainted = {}as TaintedPriority;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataPriority(formData: FormData): Result<Priority, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Medium" | "High" | "Low" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "Medium") {
                
            } else if (discriminant === "High") {
                
            } else if (discriminant === "Low") {
                
            } return fromStringifiedJSONPriority(JSON.stringify(obj));}


export type Applications =
    | /** @default */ 'Sales'
    | 'Accounting'
    | 'Errand'
    | 'HumanResources'
    | 'Logistics'
    | 'Marketing'
    | 'Website';

export function defaultValueApplications(): Applications {return 'Sales';}

export function toStringifiedJSONApplications(value: Applications): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeApplications(value, ctx));}export function toObjectApplications(value: Applications): unknown {const ctx = SerializeContext.create(); return __serializeApplications(value, ctx);}export function __serializeApplications(value: Applications, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONApplications(json: string, opts?: DeserializeOptions): Result<Applications, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectApplications(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectApplications(obj: unknown, opts?: DeserializeOptions): Result<Applications, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeApplications(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Applications.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeApplications(value: any, ctx: DeserializeContext): Applications | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Applications | PendingRef;}const allowedValues = ['Sales', 'Accounting', 'Errand', 'HumanResources', 'Logistics', 'Marketing', 'Website', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for Applications: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Applications; }export function isApplications(value: unknown): value is Applications {const allowedValues = ['Sales', 'Accounting', 'Errand', 'HumanResources', 'Logistics', 'Marketing', 'Website', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type SalesErrorsApplications = { _errors: Option<Array<string>>;  };
        export type AccountingErrorsApplications = { _errors: Option<Array<string>>;  };
        export type ErrandErrorsApplications = { _errors: Option<Array<string>>;  };
        export type HumanResourcesErrorsApplications = { _errors: Option<Array<string>>;  };
        export type LogisticsErrorsApplications = { _errors: Option<Array<string>>;  };
        export type MarketingErrorsApplications = { _errors: Option<Array<string>>;  };
        export type WebsiteErrorsApplications = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type SalesTaintedApplications = {  };
        export type AccountingTaintedApplications = {  };
        export type ErrandTaintedApplications = {  };
        export type HumanResourcesTaintedApplications = {  };
        export type LogisticsTaintedApplications = {  };
        export type MarketingTaintedApplications = {  };
        export type WebsiteTaintedApplications = {  }; /** Union error type */export type ErrorsApplications = ({ _value: "Sales" } & SalesErrorsApplications) | ({ _value: "Accounting" } & AccountingErrorsApplications) | ({ _value: "Errand" } & ErrandErrorsApplications) | ({ _value: "HumanResources" } & HumanResourcesErrorsApplications) | ({ _value: "Logistics" } & LogisticsErrorsApplications) | ({ _value: "Marketing" } & MarketingErrorsApplications) | ({ _value: "Website" } & WebsiteErrorsApplications); /** Union tainted type */export type TaintedApplications = ({ _value: "Sales" } & SalesTaintedApplications) | ({ _value: "Accounting" } & AccountingTaintedApplications) | ({ _value: "Errand" } & ErrandTaintedApplications) | ({ _value: "HumanResources" } & HumanResourcesTaintedApplications) | ({ _value: "Logistics" } & LogisticsTaintedApplications) | ({ _value: "Marketing" } & MarketingTaintedApplications) | ({ _value: "Website" } & WebsiteTaintedApplications); /** Per-variant field controller types */export interface SalesFieldControllersApplications {  }
        export interface AccountingFieldControllersApplications {  }
        export interface ErrandFieldControllersApplications {  }
        export interface HumanResourcesFieldControllersApplications {  }
        export interface LogisticsFieldControllersApplications {  }
        export interface MarketingFieldControllersApplications {  }
        export interface WebsiteFieldControllersApplications {  } /** Union Gigaform interface with variant switching */export interface GigaformApplications {readonly currentVariant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website"; readonly data: Applications; readonly errors: ErrorsApplications; readonly tainted: TaintedApplications; readonly variants: VariantFieldsApplications; switchVariant(variant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website"): void; validate(): Result<Applications, Array<{field: string; message: string}>>; reset(overrides?: Partial<Applications>): void;}/** Variant fields container */export interface VariantFieldsApplications {readonly Sales: { readonly fields: SalesFieldControllersApplications };
            readonly Accounting: { readonly fields: AccountingFieldControllersApplications };
            readonly Errand: { readonly fields: ErrandFieldControllersApplications };
            readonly HumanResources: { readonly fields: HumanResourcesFieldControllersApplications };
            readonly Logistics: { readonly fields: LogisticsFieldControllersApplications };
            readonly Marketing: { readonly fields: MarketingFieldControllersApplications };
            readonly Website: { readonly fields: WebsiteFieldControllersApplications };}/** Gets default value for a specific variant */function getDefaultForVariantApplications(variant: string): Applications {
        switch (variant) {
            case "Sales": return "Sales" as Applications;
            case "Accounting": return "Accounting" as Applications;
            case "Errand": return "Errand" as Applications;
            case "HumanResources": return "HumanResources" as Applications;
            case "Logistics": return "Logistics" as Applications;
            case "Marketing": return "Marketing" as Applications;
            case "Website": return "Website" as Applications;
            default: return "Sales" as Applications;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormApplications(initial?: Applications): GigaformApplications {const initialVariant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website" = (initial as "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website") ?? "Sales"; let currentVariant = $state<"Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website">(initialVariant); let data = $state<Applications>(initial?? getDefaultForVariantApplications(initialVariant)); let errors = $state<ErrorsApplications>({}as ErrorsApplications); let tainted = $state<TaintedApplications>({}as TaintedApplications); const variants: VariantFieldsApplications = {Sales: {
                    fields: {
                        
                    } as SalesFieldControllersApplications
                },
                Accounting: {
                    fields: {
                        
                    } as AccountingFieldControllersApplications
                },
                Errand: {
                    fields: {
                        
                    } as ErrandFieldControllersApplications
                },
                HumanResources: {
                    fields: {
                        
                    } as HumanResourcesFieldControllersApplications
                },
                Logistics: {
                    fields: {
                        
                    } as LogisticsFieldControllersApplications
                },
                Marketing: {
                    fields: {
                        
                    } as MarketingFieldControllersApplications
                },
                Website: {
                    fields: {
                        
                    } as WebsiteFieldControllersApplications
                }}; function switchVariant(variant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website"): void {currentVariant = variant; data = getDefaultForVariantApplications(variant); errors = {}as ErrorsApplications; tainted = {}as TaintedApplications;}function validate(): Result<Applications, Array<{field: string; message: string}>>{return fromObjectApplications(data);}function reset(overrides?: Partial<Applications>): void {data = overrides ? overrides as typeof data : getDefaultForVariantApplications(currentVariant); errors = {}as ErrorsApplications; tainted = {}as TaintedApplications;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataApplications(formData: FormData): Result<Applications, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "Sales") {
                
            } else if (discriminant === "Accounting") {
                
            } else if (discriminant === "Errand") {
                
            } else if (discriminant === "HumanResources") {
                
            } else if (discriminant === "Logistics") {
                
            } else if (discriminant === "Marketing") {
                
            } else if (discriminant === "Website") {
                
            } return fromStringifiedJSONApplications(JSON.stringify(obj));}


export type JobTitle =
    | /** @default */ 'Technician'
    | 'SalesRepresentative'
    | 'HumanResources'
    | 'InformationTechnology';

export function defaultValueJobTitle(): JobTitle {return 'Technician';}

export function toStringifiedJSONJobTitle(value: JobTitle): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeJobTitle(value, ctx));}export function toObjectJobTitle(value: JobTitle): unknown {const ctx = SerializeContext.create(); return __serializeJobTitle(value, ctx);}export function __serializeJobTitle(value: JobTitle, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONJobTitle(json: string, opts?: DeserializeOptions): Result<JobTitle, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectJobTitle(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectJobTitle(obj: unknown, opts?: DeserializeOptions): Result<JobTitle, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeJobTitle(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "JobTitle.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeJobTitle(value: any, ctx: DeserializeContext): JobTitle | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as JobTitle | PendingRef;}const allowedValues = ['Technician', 'SalesRepresentative', 'HumanResources', 'InformationTechnology', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for JobTitle: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as JobTitle; }export function isJobTitle(value: unknown): value is JobTitle {const allowedValues = ['Technician', 'SalesRepresentative', 'HumanResources', 'InformationTechnology', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type TechnicianErrorsJobTitle = { _errors: Option<Array<string>>;  };
        export type SalesRepresentativeErrorsJobTitle = { _errors: Option<Array<string>>;  };
        export type HumanResourcesErrorsJobTitle = { _errors: Option<Array<string>>;  };
        export type InformationTechnologyErrorsJobTitle = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type TechnicianTaintedJobTitle = {  };
        export type SalesRepresentativeTaintedJobTitle = {  };
        export type HumanResourcesTaintedJobTitle = {  };
        export type InformationTechnologyTaintedJobTitle = {  }; /** Union error type */export type ErrorsJobTitle = ({ _value: "Technician" } & TechnicianErrorsJobTitle) | ({ _value: "SalesRepresentative" } & SalesRepresentativeErrorsJobTitle) | ({ _value: "HumanResources" } & HumanResourcesErrorsJobTitle) | ({ _value: "InformationTechnology" } & InformationTechnologyErrorsJobTitle); /** Union tainted type */export type TaintedJobTitle = ({ _value: "Technician" } & TechnicianTaintedJobTitle) | ({ _value: "SalesRepresentative" } & SalesRepresentativeTaintedJobTitle) | ({ _value: "HumanResources" } & HumanResourcesTaintedJobTitle) | ({ _value: "InformationTechnology" } & InformationTechnologyTaintedJobTitle); /** Per-variant field controller types */export interface TechnicianFieldControllersJobTitle {  }
        export interface SalesRepresentativeFieldControllersJobTitle {  }
        export interface HumanResourcesFieldControllersJobTitle {  }
        export interface InformationTechnologyFieldControllersJobTitle {  } /** Union Gigaform interface with variant switching */export interface GigaformJobTitle {readonly currentVariant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology"; readonly data: JobTitle; readonly errors: ErrorsJobTitle; readonly tainted: TaintedJobTitle; readonly variants: VariantFieldsJobTitle; switchVariant(variant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology"): void; validate(): Result<JobTitle, Array<{field: string; message: string}>>; reset(overrides?: Partial<JobTitle>): void;}/** Variant fields container */export interface VariantFieldsJobTitle {readonly Technician: { readonly fields: TechnicianFieldControllersJobTitle };
            readonly SalesRepresentative: { readonly fields: SalesRepresentativeFieldControllersJobTitle };
            readonly HumanResources: { readonly fields: HumanResourcesFieldControllersJobTitle };
            readonly InformationTechnology: { readonly fields: InformationTechnologyFieldControllersJobTitle };}/** Gets default value for a specific variant */function getDefaultForVariantJobTitle(variant: string): JobTitle {
        switch (variant) {
            case "Technician": return "Technician" as JobTitle;
            case "SalesRepresentative": return "SalesRepresentative" as JobTitle;
            case "HumanResources": return "HumanResources" as JobTitle;
            case "InformationTechnology": return "InformationTechnology" as JobTitle;
            default: return "Technician" as JobTitle;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormJobTitle(initial?: JobTitle): GigaformJobTitle {const initialVariant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology" = (initial as "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology") ?? "Technician"; let currentVariant = $state<"Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology">(initialVariant); let data = $state<JobTitle>(initial?? getDefaultForVariantJobTitle(initialVariant)); let errors = $state<ErrorsJobTitle>({}as ErrorsJobTitle); let tainted = $state<TaintedJobTitle>({}as TaintedJobTitle); const variants: VariantFieldsJobTitle = {Technician: {
                    fields: {
                        
                    } as TechnicianFieldControllersJobTitle
                },
                SalesRepresentative: {
                    fields: {
                        
                    } as SalesRepresentativeFieldControllersJobTitle
                },
                HumanResources: {
                    fields: {
                        
                    } as HumanResourcesFieldControllersJobTitle
                },
                InformationTechnology: {
                    fields: {
                        
                    } as InformationTechnologyFieldControllersJobTitle
                }}; function switchVariant(variant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology"): void {currentVariant = variant; data = getDefaultForVariantJobTitle(variant); errors = {}as ErrorsJobTitle; tainted = {}as TaintedJobTitle;}function validate(): Result<JobTitle, Array<{field: string; message: string}>>{return fromObjectJobTitle(data);}function reset(overrides?: Partial<JobTitle>): void {data = overrides ? overrides as typeof data : getDefaultForVariantJobTitle(currentVariant); errors = {}as ErrorsJobTitle; tainted = {}as TaintedJobTitle;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataJobTitle(formData: FormData): Result<JobTitle, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "Technician") {
                
            } else if (discriminant === "SalesRepresentative") {
                
            } else if (discriminant === "HumanResources") {
                
            } else if (discriminant === "InformationTechnology") {
                
            } return fromStringifiedJSONJobTitle(JSON.stringify(obj));}


export type ColorsConfig = Cardinal | Ordinal | Custom | /** @default */ Gradient;

export function defaultValueColorsConfig(): ColorsConfig {return defaultValueGradient();}

export function toStringifiedJSONColorsConfig(value: ColorsConfig): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeColorsConfig(value, ctx));}export function toObjectColorsConfig(value: ColorsConfig): unknown {const ctx = SerializeContext.create(); return __serializeColorsConfig(value, ctx);}export function __serializeColorsConfig(value: ColorsConfig, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONColorsConfig(json: string, opts?: DeserializeOptions): Result<ColorsConfig, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectColorsConfig(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectColorsConfig(obj: unknown, opts?: DeserializeOptions): Result<ColorsConfig, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeColorsConfig(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "ColorsConfig.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeColorsConfig(value: any, ctx: DeserializeContext): ColorsConfig | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as ColorsConfig | PendingRef;}if(typeof value!== "object" || value === null){throw new DeserializeError([{field: "_root" , message: "ColorsConfig.__deserialize: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new DeserializeError([{field: "_root" , message: "ColorsConfig.__deserialize: missing __type field for union dispatch" }]);}if(__typeName === "Cardinal" ){return __deserializeCardinal(value, ctx)as ColorsConfig;}if(__typeName === "Ordinal" ){return __deserializeOrdinal(value, ctx)as ColorsConfig;}if(__typeName === "Custom" ){return __deserializeCustom(value, ctx)as ColorsConfig;}if(__typeName === "Gradient" ){return __deserializeGradient(value, ctx)as ColorsConfig;}throw new DeserializeError([{field: "_root" , message: "ColorsConfig.__deserialize: unknown type \"" + __typeName + "\". Expected one of: Cardinal, Ordinal, Custom, Gradient" }]); }export function isColorsConfig(value: unknown): value is ColorsConfig {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "Cardinal" || __typeName === "Ordinal" || __typeName === "Custom" || __typeName === "Gradient" ; }

/** Per-variant error types */export type CardinalErrorsColorsConfig = { _errors: Option<Array<string>>;  };
        export type OrdinalErrorsColorsConfig = { _errors: Option<Array<string>>;  };
        export type CustomErrorsColorsConfig = { _errors: Option<Array<string>>;  };
        export type GradientErrorsColorsConfig = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type CardinalTaintedColorsConfig = {  };
        export type OrdinalTaintedColorsConfig = {  };
        export type CustomTaintedColorsConfig = {  };
        export type GradientTaintedColorsConfig = {  }; /** Union error type */export type ErrorsColorsConfig = ({ _type: "Cardinal" } & CardinalErrorsColorsConfig) | ({ _type: "Ordinal" } & OrdinalErrorsColorsConfig) | ({ _type: "Custom" } & CustomErrorsColorsConfig) | ({ _type: "Gradient" } & GradientErrorsColorsConfig); /** Union tainted type */export type TaintedColorsConfig = ({ _type: "Cardinal" } & CardinalTaintedColorsConfig) | ({ _type: "Ordinal" } & OrdinalTaintedColorsConfig) | ({ _type: "Custom" } & CustomTaintedColorsConfig) | ({ _type: "Gradient" } & GradientTaintedColorsConfig); /** Per-variant field controller types */export interface CardinalFieldControllersColorsConfig {  }
        export interface OrdinalFieldControllersColorsConfig {  }
        export interface CustomFieldControllersColorsConfig {  }
        export interface GradientFieldControllersColorsConfig {  } /** Union Gigaform interface with variant switching */export interface GigaformColorsConfig {readonly currentVariant: "Cardinal" | "Ordinal" | "Custom" | "Gradient"; readonly data: ColorsConfig; readonly errors: ErrorsColorsConfig; readonly tainted: TaintedColorsConfig; readonly variants: VariantFieldsColorsConfig; switchVariant(variant: "Cardinal" | "Ordinal" | "Custom" | "Gradient"): void; validate(): Result<ColorsConfig, Array<{field: string; message: string}>>; reset(overrides?: Partial<ColorsConfig>): void;}/** Variant fields container */export interface VariantFieldsColorsConfig {readonly Cardinal: { readonly fields: CardinalFieldControllersColorsConfig };
            readonly Ordinal: { readonly fields: OrdinalFieldControllersColorsConfig };
            readonly Custom: { readonly fields: CustomFieldControllersColorsConfig };
            readonly Gradient: { readonly fields: GradientFieldControllersColorsConfig };}/** Gets default value for a specific variant */function getDefaultForVariantColorsConfig(variant: string): ColorsConfig {
        switch (variant) {
            case "Cardinal": return defaultValueCardinal() as ColorsConfig;
            case "Ordinal": return defaultValueOrdinal() as ColorsConfig;
            case "Custom": return defaultValueCustom() as ColorsConfig;
            case "Gradient": return defaultValueGradient() as ColorsConfig;
            default: return defaultValueCardinal() as ColorsConfig;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormColorsConfig(initial?: ColorsConfig): GigaformColorsConfig {const initialVariant: "Cardinal" | "Ordinal" | "Custom" | "Gradient" = "Cardinal"; let currentVariant = $state<"Cardinal" | "Ordinal" | "Custom" | "Gradient">(initialVariant); let data = $state<ColorsConfig>(initial?? getDefaultForVariantColorsConfig(initialVariant)); let errors = $state<ErrorsColorsConfig>({}as ErrorsColorsConfig); let tainted = $state<TaintedColorsConfig>({}as TaintedColorsConfig); const variants: VariantFieldsColorsConfig = {Cardinal: {
                    fields: {
                        
                    } as CardinalFieldControllersColorsConfig
                },
                Ordinal: {
                    fields: {
                        
                    } as OrdinalFieldControllersColorsConfig
                },
                Custom: {
                    fields: {
                        
                    } as CustomFieldControllersColorsConfig
                },
                Gradient: {
                    fields: {
                        
                    } as GradientFieldControllersColorsConfig
                }}; function switchVariant(variant: "Cardinal" | "Ordinal" | "Custom" | "Gradient"): void {currentVariant = variant; data = getDefaultForVariantColorsConfig(variant); errors = {}as ErrorsColorsConfig; tainted = {}as TaintedColorsConfig;}function validate(): Result<ColorsConfig, Array<{field: string; message: string}>>{return fromObjectColorsConfig(data);}function reset(overrides?: Partial<ColorsConfig>): void {data = overrides ? overrides as typeof data : getDefaultForVariantColorsConfig(currentVariant); errors = {}as ErrorsColorsConfig; tainted = {}as TaintedColorsConfig;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataColorsConfig(formData: FormData): Result<ColorsConfig, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "Cardinal" | "Ordinal" | "Custom" | "Gradient" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if (discriminant === "Cardinal") {
                
            } else if (discriminant === "Ordinal") {
                
            } else if (discriminant === "Custom") {
                
            } else if (discriminant === "Gradient") {
                
            } return fromStringifiedJSONColorsConfig(JSON.stringify(obj));}


export type WeekOfMonth = /** @default */ 'First' | 'Second' | 'Third' | 'Fourth' | 'Last';

export function defaultValueWeekOfMonth(): WeekOfMonth {return 'First';}

export function toStringifiedJSONWeekOfMonth(value: WeekOfMonth): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeWeekOfMonth(value, ctx));}export function toObjectWeekOfMonth(value: WeekOfMonth): unknown {const ctx = SerializeContext.create(); return __serializeWeekOfMonth(value, ctx);}export function __serializeWeekOfMonth(value: WeekOfMonth, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONWeekOfMonth(json: string, opts?: DeserializeOptions): Result<WeekOfMonth, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectWeekOfMonth(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectWeekOfMonth(obj: unknown, opts?: DeserializeOptions): Result<WeekOfMonth, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeWeekOfMonth(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "WeekOfMonth.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeWeekOfMonth(value: any, ctx: DeserializeContext): WeekOfMonth | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as WeekOfMonth | PendingRef;}const allowedValues = ['First', 'Second', 'Third', 'Fourth', 'Last', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for WeekOfMonth: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as WeekOfMonth; }export function isWeekOfMonth(value: unknown): value is WeekOfMonth {const allowedValues = ['First', 'Second', 'Third', 'Fourth', 'Last', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type FirstErrorsWeekOfMonth = { _errors: Option<Array<string>>;  };
        export type SecondErrorsWeekOfMonth = { _errors: Option<Array<string>>;  };
        export type ThirdErrorsWeekOfMonth = { _errors: Option<Array<string>>;  };
        export type FourthErrorsWeekOfMonth = { _errors: Option<Array<string>>;  };
        export type LastErrorsWeekOfMonth = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type FirstTaintedWeekOfMonth = {  };
        export type SecondTaintedWeekOfMonth = {  };
        export type ThirdTaintedWeekOfMonth = {  };
        export type FourthTaintedWeekOfMonth = {  };
        export type LastTaintedWeekOfMonth = {  }; /** Union error type */export type ErrorsWeekOfMonth = ({ _value: "First" } & FirstErrorsWeekOfMonth) | ({ _value: "Second" } & SecondErrorsWeekOfMonth) | ({ _value: "Third" } & ThirdErrorsWeekOfMonth) | ({ _value: "Fourth" } & FourthErrorsWeekOfMonth) | ({ _value: "Last" } & LastErrorsWeekOfMonth); /** Union tainted type */export type TaintedWeekOfMonth = ({ _value: "First" } & FirstTaintedWeekOfMonth) | ({ _value: "Second" } & SecondTaintedWeekOfMonth) | ({ _value: "Third" } & ThirdTaintedWeekOfMonth) | ({ _value: "Fourth" } & FourthTaintedWeekOfMonth) | ({ _value: "Last" } & LastTaintedWeekOfMonth); /** Per-variant field controller types */export interface FirstFieldControllersWeekOfMonth {  }
        export interface SecondFieldControllersWeekOfMonth {  }
        export interface ThirdFieldControllersWeekOfMonth {  }
        export interface FourthFieldControllersWeekOfMonth {  }
        export interface LastFieldControllersWeekOfMonth {  } /** Union Gigaform interface with variant switching */export interface GigaformWeekOfMonth {readonly currentVariant: "First" | "Second" | "Third" | "Fourth" | "Last"; readonly data: WeekOfMonth; readonly errors: ErrorsWeekOfMonth; readonly tainted: TaintedWeekOfMonth; readonly variants: VariantFieldsWeekOfMonth; switchVariant(variant: "First" | "Second" | "Third" | "Fourth" | "Last"): void; validate(): Result<WeekOfMonth, Array<{field: string; message: string}>>; reset(overrides?: Partial<WeekOfMonth>): void;}/** Variant fields container */export interface VariantFieldsWeekOfMonth {readonly First: { readonly fields: FirstFieldControllersWeekOfMonth };
            readonly Second: { readonly fields: SecondFieldControllersWeekOfMonth };
            readonly Third: { readonly fields: ThirdFieldControllersWeekOfMonth };
            readonly Fourth: { readonly fields: FourthFieldControllersWeekOfMonth };
            readonly Last: { readonly fields: LastFieldControllersWeekOfMonth };}/** Gets default value for a specific variant */function getDefaultForVariantWeekOfMonth(variant: string): WeekOfMonth {
        switch (variant) {
            case "First": return "First" as WeekOfMonth;
            case "Second": return "Second" as WeekOfMonth;
            case "Third": return "Third" as WeekOfMonth;
            case "Fourth": return "Fourth" as WeekOfMonth;
            case "Last": return "Last" as WeekOfMonth;
            default: return "First" as WeekOfMonth;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormWeekOfMonth(initial?: WeekOfMonth): GigaformWeekOfMonth {const initialVariant: "First" | "Second" | "Third" | "Fourth" | "Last" = (initial as "First" | "Second" | "Third" | "Fourth" | "Last") ?? "First"; let currentVariant = $state<"First" | "Second" | "Third" | "Fourth" | "Last">(initialVariant); let data = $state<WeekOfMonth>(initial?? getDefaultForVariantWeekOfMonth(initialVariant)); let errors = $state<ErrorsWeekOfMonth>({}as ErrorsWeekOfMonth); let tainted = $state<TaintedWeekOfMonth>({}as TaintedWeekOfMonth); const variants: VariantFieldsWeekOfMonth = {First: {
                    fields: {
                        
                    } as FirstFieldControllersWeekOfMonth
                },
                Second: {
                    fields: {
                        
                    } as SecondFieldControllersWeekOfMonth
                },
                Third: {
                    fields: {
                        
                    } as ThirdFieldControllersWeekOfMonth
                },
                Fourth: {
                    fields: {
                        
                    } as FourthFieldControllersWeekOfMonth
                },
                Last: {
                    fields: {
                        
                    } as LastFieldControllersWeekOfMonth
                }}; function switchVariant(variant: "First" | "Second" | "Third" | "Fourth" | "Last"): void {currentVariant = variant; data = getDefaultForVariantWeekOfMonth(variant); errors = {}as ErrorsWeekOfMonth; tainted = {}as TaintedWeekOfMonth;}function validate(): Result<WeekOfMonth, Array<{field: string; message: string}>>{return fromObjectWeekOfMonth(data);}function reset(overrides?: Partial<WeekOfMonth>): void {data = overrides ? overrides as typeof data : getDefaultForVariantWeekOfMonth(currentVariant); errors = {}as ErrorsWeekOfMonth; tainted = {}as TaintedWeekOfMonth;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataWeekOfMonth(formData: FormData): Result<WeekOfMonth, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "First" | "Second" | "Third" | "Fourth" | "Last" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "First") {
                
            } else if (discriminant === "Second") {
                
            } else if (discriminant === "Third") {
                
            } else if (discriminant === "Fourth") {
                
            } else if (discriminant === "Last") {
                
            } return fromStringifiedJSONWeekOfMonth(JSON.stringify(obj));}


export type ActivityType = /** @default */ Created | Edited | Sent | Viewed | Commented | Paid;

export function defaultValueActivityType(): ActivityType {return defaultValueCreated();}

export function toStringifiedJSONActivityType(value: ActivityType): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeActivityType(value, ctx));}export function toObjectActivityType(value: ActivityType): unknown {const ctx = SerializeContext.create(); return __serializeActivityType(value, ctx);}export function __serializeActivityType(value: ActivityType, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONActivityType(json: string, opts?: DeserializeOptions): Result<ActivityType, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectActivityType(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectActivityType(obj: unknown, opts?: DeserializeOptions): Result<ActivityType, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeActivityType(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "ActivityType.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeActivityType(value: any, ctx: DeserializeContext): ActivityType | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as ActivityType | PendingRef;}if(typeof value!== "object" || value === null){throw new DeserializeError([{field: "_root" , message: "ActivityType.__deserialize: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new DeserializeError([{field: "_root" , message: "ActivityType.__deserialize: missing __type field for union dispatch" }]);}if(__typeName === "Created" ){return __deserializeCreated(value, ctx)as ActivityType;}if(__typeName === "Edited" ){return __deserializeEdited(value, ctx)as ActivityType;}if(__typeName === "Sent" ){return __deserializeSent(value, ctx)as ActivityType;}if(__typeName === "Viewed" ){return __deserializeViewed(value, ctx)as ActivityType;}if(__typeName === "Commented" ){return __deserializeCommented(value, ctx)as ActivityType;}if(__typeName === "Paid" ){return __deserializePaid(value, ctx)as ActivityType;}throw new DeserializeError([{field: "_root" , message: "ActivityType.__deserialize: unknown type \"" + __typeName + "\". Expected one of: Created, Edited, Sent, Viewed, Commented, Paid" }]); }export function isActivityType(value: unknown): value is ActivityType {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "Created" || __typeName === "Edited" || __typeName === "Sent" || __typeName === "Viewed" || __typeName === "Commented" || __typeName === "Paid" ; }

/** Per-variant error types */export type CreatedErrorsActivityType = { _errors: Option<Array<string>>;  };
        export type EditedErrorsActivityType = { _errors: Option<Array<string>>;  };
        export type SentErrorsActivityType = { _errors: Option<Array<string>>;  };
        export type ViewedErrorsActivityType = { _errors: Option<Array<string>>;  };
        export type CommentedErrorsActivityType = { _errors: Option<Array<string>>;  };
        export type PaidErrorsActivityType = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type CreatedTaintedActivityType = {  };
        export type EditedTaintedActivityType = {  };
        export type SentTaintedActivityType = {  };
        export type ViewedTaintedActivityType = {  };
        export type CommentedTaintedActivityType = {  };
        export type PaidTaintedActivityType = {  }; /** Union error type */export type ErrorsActivityType = ({ _type: "Created" } & CreatedErrorsActivityType) | ({ _type: "Edited" } & EditedErrorsActivityType) | ({ _type: "Sent" } & SentErrorsActivityType) | ({ _type: "Viewed" } & ViewedErrorsActivityType) | ({ _type: "Commented" } & CommentedErrorsActivityType) | ({ _type: "Paid" } & PaidErrorsActivityType); /** Union tainted type */export type TaintedActivityType = ({ _type: "Created" } & CreatedTaintedActivityType) | ({ _type: "Edited" } & EditedTaintedActivityType) | ({ _type: "Sent" } & SentTaintedActivityType) | ({ _type: "Viewed" } & ViewedTaintedActivityType) | ({ _type: "Commented" } & CommentedTaintedActivityType) | ({ _type: "Paid" } & PaidTaintedActivityType); /** Per-variant field controller types */export interface CreatedFieldControllersActivityType {  }
        export interface EditedFieldControllersActivityType {  }
        export interface SentFieldControllersActivityType {  }
        export interface ViewedFieldControllersActivityType {  }
        export interface CommentedFieldControllersActivityType {  }
        export interface PaidFieldControllersActivityType {  } /** Union Gigaform interface with variant switching */export interface GigaformActivityType {readonly currentVariant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid"; readonly data: ActivityType; readonly errors: ErrorsActivityType; readonly tainted: TaintedActivityType; readonly variants: VariantFieldsActivityType; switchVariant(variant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid"): void; validate(): Result<ActivityType, Array<{field: string; message: string}>>; reset(overrides?: Partial<ActivityType>): void;}/** Variant fields container */export interface VariantFieldsActivityType {readonly Created: { readonly fields: CreatedFieldControllersActivityType };
            readonly Edited: { readonly fields: EditedFieldControllersActivityType };
            readonly Sent: { readonly fields: SentFieldControllersActivityType };
            readonly Viewed: { readonly fields: ViewedFieldControllersActivityType };
            readonly Commented: { readonly fields: CommentedFieldControllersActivityType };
            readonly Paid: { readonly fields: PaidFieldControllersActivityType };}/** Gets default value for a specific variant */function getDefaultForVariantActivityType(variant: string): ActivityType {
        switch (variant) {
            case "Created": return defaultValueCreated() as ActivityType;
            case "Edited": return defaultValueEdited() as ActivityType;
            case "Sent": return defaultValueSent() as ActivityType;
            case "Viewed": return defaultValueViewed() as ActivityType;
            case "Commented": return defaultValueCommented() as ActivityType;
            case "Paid": return defaultValuePaid() as ActivityType;
            default: return defaultValueCreated() as ActivityType;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormActivityType(initial?: ActivityType): GigaformActivityType {const initialVariant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid" = "Created"; let currentVariant = $state<"Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid">(initialVariant); let data = $state<ActivityType>(initial?? getDefaultForVariantActivityType(initialVariant)); let errors = $state<ErrorsActivityType>({}as ErrorsActivityType); let tainted = $state<TaintedActivityType>({}as TaintedActivityType); const variants: VariantFieldsActivityType = {Created: {
                    fields: {
                        
                    } as CreatedFieldControllersActivityType
                },
                Edited: {
                    fields: {
                        
                    } as EditedFieldControllersActivityType
                },
                Sent: {
                    fields: {
                        
                    } as SentFieldControllersActivityType
                },
                Viewed: {
                    fields: {
                        
                    } as ViewedFieldControllersActivityType
                },
                Commented: {
                    fields: {
                        
                    } as CommentedFieldControllersActivityType
                },
                Paid: {
                    fields: {
                        
                    } as PaidFieldControllersActivityType
                }}; function switchVariant(variant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid"): void {currentVariant = variant; data = getDefaultForVariantActivityType(variant); errors = {}as ErrorsActivityType; tainted = {}as TaintedActivityType;}function validate(): Result<ActivityType, Array<{field: string; message: string}>>{return fromObjectActivityType(data);}function reset(overrides?: Partial<ActivityType>): void {data = overrides ? overrides as typeof data : getDefaultForVariantActivityType(currentVariant); errors = {}as ErrorsActivityType; tainted = {}as TaintedActivityType;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataActivityType(formData: FormData): Result<ActivityType, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if (discriminant === "Created") {
                
            } else if (discriminant === "Edited") {
                
            } else if (discriminant === "Sent") {
                
            } else if (discriminant === "Viewed") {
                
            } else if (discriminant === "Commented") {
                
            } else if (discriminant === "Paid") {
                
            } return fromStringifiedJSONActivityType(JSON.stringify(obj));}


export type RowHeight = 'ExtraSmall' | 'Small' | /** @default */ 'Medium' | 'Large';

export function defaultValueRowHeight(): RowHeight {return 'Medium';}

export function toStringifiedJSONRowHeight(value: RowHeight): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeRowHeight(value, ctx));}export function toObjectRowHeight(value: RowHeight): unknown {const ctx = SerializeContext.create(); return __serializeRowHeight(value, ctx);}export function __serializeRowHeight(value: RowHeight, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONRowHeight(json: string, opts?: DeserializeOptions): Result<RowHeight, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectRowHeight(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectRowHeight(obj: unknown, opts?: DeserializeOptions): Result<RowHeight, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeRowHeight(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "RowHeight.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeRowHeight(value: any, ctx: DeserializeContext): RowHeight | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as RowHeight | PendingRef;}const allowedValues = ['ExtraSmall', 'Small', 'Medium', 'Large', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for RowHeight: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as RowHeight; }export function isRowHeight(value: unknown): value is RowHeight {const allowedValues = ['ExtraSmall', 'Small', 'Medium', 'Large', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type ExtraSmallErrorsRowHeight = { _errors: Option<Array<string>>;  };
        export type SmallErrorsRowHeight = { _errors: Option<Array<string>>;  };
        export type MediumErrorsRowHeight = { _errors: Option<Array<string>>;  };
        export type LargeErrorsRowHeight = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type ExtraSmallTaintedRowHeight = {  };
        export type SmallTaintedRowHeight = {  };
        export type MediumTaintedRowHeight = {  };
        export type LargeTaintedRowHeight = {  }; /** Union error type */export type ErrorsRowHeight = ({ _value: "ExtraSmall" } & ExtraSmallErrorsRowHeight) | ({ _value: "Small" } & SmallErrorsRowHeight) | ({ _value: "Medium" } & MediumErrorsRowHeight) | ({ _value: "Large" } & LargeErrorsRowHeight); /** Union tainted type */export type TaintedRowHeight = ({ _value: "ExtraSmall" } & ExtraSmallTaintedRowHeight) | ({ _value: "Small" } & SmallTaintedRowHeight) | ({ _value: "Medium" } & MediumTaintedRowHeight) | ({ _value: "Large" } & LargeTaintedRowHeight); /** Per-variant field controller types */export interface ExtraSmallFieldControllersRowHeight {  }
        export interface SmallFieldControllersRowHeight {  }
        export interface MediumFieldControllersRowHeight {  }
        export interface LargeFieldControllersRowHeight {  } /** Union Gigaform interface with variant switching */export interface GigaformRowHeight {readonly currentVariant: "ExtraSmall" | "Small" | "Medium" | "Large"; readonly data: RowHeight; readonly errors: ErrorsRowHeight; readonly tainted: TaintedRowHeight; readonly variants: VariantFieldsRowHeight; switchVariant(variant: "ExtraSmall" | "Small" | "Medium" | "Large"): void; validate(): Result<RowHeight, Array<{field: string; message: string}>>; reset(overrides?: Partial<RowHeight>): void;}/** Variant fields container */export interface VariantFieldsRowHeight {readonly ExtraSmall: { readonly fields: ExtraSmallFieldControllersRowHeight };
            readonly Small: { readonly fields: SmallFieldControllersRowHeight };
            readonly Medium: { readonly fields: MediumFieldControllersRowHeight };
            readonly Large: { readonly fields: LargeFieldControllersRowHeight };}/** Gets default value for a specific variant */function getDefaultForVariantRowHeight(variant: string): RowHeight {
        switch (variant) {
            case "ExtraSmall": return "ExtraSmall" as RowHeight;
            case "Small": return "Small" as RowHeight;
            case "Medium": return "Medium" as RowHeight;
            case "Large": return "Large" as RowHeight;
            default: return "ExtraSmall" as RowHeight;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormRowHeight(initial?: RowHeight): GigaformRowHeight {const initialVariant: "ExtraSmall" | "Small" | "Medium" | "Large" = (initial as "ExtraSmall" | "Small" | "Medium" | "Large") ?? "ExtraSmall"; let currentVariant = $state<"ExtraSmall" | "Small" | "Medium" | "Large">(initialVariant); let data = $state<RowHeight>(initial?? getDefaultForVariantRowHeight(initialVariant)); let errors = $state<ErrorsRowHeight>({}as ErrorsRowHeight); let tainted = $state<TaintedRowHeight>({}as TaintedRowHeight); const variants: VariantFieldsRowHeight = {ExtraSmall: {
                    fields: {
                        
                    } as ExtraSmallFieldControllersRowHeight
                },
                Small: {
                    fields: {
                        
                    } as SmallFieldControllersRowHeight
                },
                Medium: {
                    fields: {
                        
                    } as MediumFieldControllersRowHeight
                },
                Large: {
                    fields: {
                        
                    } as LargeFieldControllersRowHeight
                }}; function switchVariant(variant: "ExtraSmall" | "Small" | "Medium" | "Large"): void {currentVariant = variant; data = getDefaultForVariantRowHeight(variant); errors = {}as ErrorsRowHeight; tainted = {}as TaintedRowHeight;}function validate(): Result<RowHeight, Array<{field: string; message: string}>>{return fromObjectRowHeight(data);}function reset(overrides?: Partial<RowHeight>): void {data = overrides ? overrides as typeof data : getDefaultForVariantRowHeight(currentVariant); errors = {}as ErrorsRowHeight; tainted = {}as TaintedRowHeight;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataRowHeight(formData: FormData): Result<RowHeight, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "ExtraSmall" | "Small" | "Medium" | "Large" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "ExtraSmall") {
                
            } else if (discriminant === "Small") {
                
            } else if (discriminant === "Medium") {
                
            } else if (discriminant === "Large") {
                
            } return fromStringifiedJSONRowHeight(JSON.stringify(obj));}


export type OrderStage = /** @default */ 'Estimate' | 'Active' | 'Invoice';

export function defaultValueOrderStage(): OrderStage {return 'Estimate';}

export function toStringifiedJSONOrderStage(value: OrderStage): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeOrderStage(value, ctx));}export function toObjectOrderStage(value: OrderStage): unknown {const ctx = SerializeContext.create(); return __serializeOrderStage(value, ctx);}export function __serializeOrderStage(value: OrderStage, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONOrderStage(json: string, opts?: DeserializeOptions): Result<OrderStage, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectOrderStage(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectOrderStage(obj: unknown, opts?: DeserializeOptions): Result<OrderStage, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeOrderStage(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "OrderStage.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeOrderStage(value: any, ctx: DeserializeContext): OrderStage | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as OrderStage | PendingRef;}const allowedValues = ['Estimate', 'Active', 'Invoice', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for OrderStage: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as OrderStage; }export function isOrderStage(value: unknown): value is OrderStage {const allowedValues = ['Estimate', 'Active', 'Invoice', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type EstimateErrorsOrderStage = { _errors: Option<Array<string>>;  };
        export type ActiveErrorsOrderStage = { _errors: Option<Array<string>>;  };
        export type InvoiceErrorsOrderStage = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type EstimateTaintedOrderStage = {  };
        export type ActiveTaintedOrderStage = {  };
        export type InvoiceTaintedOrderStage = {  }; /** Union error type */export type ErrorsOrderStage = ({ _value: "Estimate" } & EstimateErrorsOrderStage) | ({ _value: "Active" } & ActiveErrorsOrderStage) | ({ _value: "Invoice" } & InvoiceErrorsOrderStage); /** Union tainted type */export type TaintedOrderStage = ({ _value: "Estimate" } & EstimateTaintedOrderStage) | ({ _value: "Active" } & ActiveTaintedOrderStage) | ({ _value: "Invoice" } & InvoiceTaintedOrderStage); /** Per-variant field controller types */export interface EstimateFieldControllersOrderStage {  }
        export interface ActiveFieldControllersOrderStage {  }
        export interface InvoiceFieldControllersOrderStage {  } /** Union Gigaform interface with variant switching */export interface GigaformOrderStage {readonly currentVariant: "Estimate" | "Active" | "Invoice"; readonly data: OrderStage; readonly errors: ErrorsOrderStage; readonly tainted: TaintedOrderStage; readonly variants: VariantFieldsOrderStage; switchVariant(variant: "Estimate" | "Active" | "Invoice"): void; validate(): Result<OrderStage, Array<{field: string; message: string}>>; reset(overrides?: Partial<OrderStage>): void;}/** Variant fields container */export interface VariantFieldsOrderStage {readonly Estimate: { readonly fields: EstimateFieldControllersOrderStage };
            readonly Active: { readonly fields: ActiveFieldControllersOrderStage };
            readonly Invoice: { readonly fields: InvoiceFieldControllersOrderStage };}/** Gets default value for a specific variant */function getDefaultForVariantOrderStage(variant: string): OrderStage {
        switch (variant) {
            case "Estimate": return "Estimate" as OrderStage;
            case "Active": return "Active" as OrderStage;
            case "Invoice": return "Invoice" as OrderStage;
            default: return "Estimate" as OrderStage;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormOrderStage(initial?: OrderStage): GigaformOrderStage {const initialVariant: "Estimate" | "Active" | "Invoice" = (initial as "Estimate" | "Active" | "Invoice") ?? "Estimate"; let currentVariant = $state<"Estimate" | "Active" | "Invoice">(initialVariant); let data = $state<OrderStage>(initial?? getDefaultForVariantOrderStage(initialVariant)); let errors = $state<ErrorsOrderStage>({}as ErrorsOrderStage); let tainted = $state<TaintedOrderStage>({}as TaintedOrderStage); const variants: VariantFieldsOrderStage = {Estimate: {
                    fields: {
                        
                    } as EstimateFieldControllersOrderStage
                },
                Active: {
                    fields: {
                        
                    } as ActiveFieldControllersOrderStage
                },
                Invoice: {
                    fields: {
                        
                    } as InvoiceFieldControllersOrderStage
                }}; function switchVariant(variant: "Estimate" | "Active" | "Invoice"): void {currentVariant = variant; data = getDefaultForVariantOrderStage(variant); errors = {}as ErrorsOrderStage; tainted = {}as TaintedOrderStage;}function validate(): Result<OrderStage, Array<{field: string; message: string}>>{return fromObjectOrderStage(data);}function reset(overrides?: Partial<OrderStage>): void {data = overrides ? overrides as typeof data : getDefaultForVariantOrderStage(currentVariant); errors = {}as ErrorsOrderStage; tainted = {}as TaintedOrderStage;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataOrderStage(formData: FormData): Result<OrderStage, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Estimate" | "Active" | "Invoice" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "Estimate") {
                
            } else if (discriminant === "Active") {
                
            } else if (discriminant === "Invoice") {
                
            } return fromStringifiedJSONOrderStage(JSON.stringify(obj));}


export type Table =
    | /** @default */ 'Account'
    | 'Did'
    | 'Appointment'
    | 'Lead'
    | 'TaxRate'
    | 'Site'
    | 'Employee'
    | 'Route'
    | 'Company'
    | 'Product'
    | 'Service'
    | 'User'
    | 'Order'
    | 'Payment'
    | 'Package'
    | 'Promotion'
    | 'Represents'
    | 'Ordered';

export function defaultValueTable(): Table {return 'Account';}

export function toStringifiedJSONTable(value: Table): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeTable(value, ctx));}export function toObjectTable(value: Table): unknown {const ctx = SerializeContext.create(); return __serializeTable(value, ctx);}export function __serializeTable(value: Table, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONTable(json: string, opts?: DeserializeOptions): Result<Table, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectTable(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectTable(obj: unknown, opts?: DeserializeOptions): Result<Table, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeTable(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Table.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeTable(value: any, ctx: DeserializeContext): Table | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Table | PendingRef;}const allowedValues = ['Account', 'Did', 'Appointment', 'Lead', 'TaxRate', 'Site', 'Employee', 'Route', 'Company', 'Product', 'Service', 'User', 'Order', 'Payment', 'Package', 'Promotion', 'Represents', 'Ordered', ]as const; if(!allowedValues.includes(value)){throw new DeserializeError([{field: "_root" , message: "Invalid value for Table: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Table; }export function isTable(value: unknown): value is Table {const allowedValues = ['Account', 'Did', 'Appointment', 'Lead', 'TaxRate', 'Site', 'Employee', 'Route', 'Company', 'Product', 'Service', 'User', 'Order', 'Payment', 'Package', 'Promotion', 'Represents', 'Ordered', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type AccountErrorsTable = { _errors: Option<Array<string>>;  };
        export type DidErrorsTable = { _errors: Option<Array<string>>;  };
        export type AppointmentErrorsTable = { _errors: Option<Array<string>>;  };
        export type LeadErrorsTable = { _errors: Option<Array<string>>;  };
        export type TaxRateErrorsTable = { _errors: Option<Array<string>>;  };
        export type SiteErrorsTable = { _errors: Option<Array<string>>;  };
        export type EmployeeErrorsTable = { _errors: Option<Array<string>>;  };
        export type RouteErrorsTable = { _errors: Option<Array<string>>;  };
        export type CompanyErrorsTable = { _errors: Option<Array<string>>;  };
        export type ProductErrorsTable = { _errors: Option<Array<string>>;  };
        export type ServiceErrorsTable = { _errors: Option<Array<string>>;  };
        export type UserErrorsTable = { _errors: Option<Array<string>>;  };
        export type OrderErrorsTable = { _errors: Option<Array<string>>;  };
        export type PaymentErrorsTable = { _errors: Option<Array<string>>;  };
        export type PackageErrorsTable = { _errors: Option<Array<string>>;  };
        export type PromotionErrorsTable = { _errors: Option<Array<string>>;  };
        export type RepresentsErrorsTable = { _errors: Option<Array<string>>;  };
        export type OrderedErrorsTable = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type AccountTaintedTable = {  };
        export type DidTaintedTable = {  };
        export type AppointmentTaintedTable = {  };
        export type LeadTaintedTable = {  };
        export type TaxRateTaintedTable = {  };
        export type SiteTaintedTable = {  };
        export type EmployeeTaintedTable = {  };
        export type RouteTaintedTable = {  };
        export type CompanyTaintedTable = {  };
        export type ProductTaintedTable = {  };
        export type ServiceTaintedTable = {  };
        export type UserTaintedTable = {  };
        export type OrderTaintedTable = {  };
        export type PaymentTaintedTable = {  };
        export type PackageTaintedTable = {  };
        export type PromotionTaintedTable = {  };
        export type RepresentsTaintedTable = {  };
        export type OrderedTaintedTable = {  }; /** Union error type */export type ErrorsTable = ({ _value: "Account" } & AccountErrorsTable) | ({ _value: "Did" } & DidErrorsTable) | ({ _value: "Appointment" } & AppointmentErrorsTable) | ({ _value: "Lead" } & LeadErrorsTable) | ({ _value: "TaxRate" } & TaxRateErrorsTable) | ({ _value: "Site" } & SiteErrorsTable) | ({ _value: "Employee" } & EmployeeErrorsTable) | ({ _value: "Route" } & RouteErrorsTable) | ({ _value: "Company" } & CompanyErrorsTable) | ({ _value: "Product" } & ProductErrorsTable) | ({ _value: "Service" } & ServiceErrorsTable) | ({ _value: "User" } & UserErrorsTable) | ({ _value: "Order" } & OrderErrorsTable) | ({ _value: "Payment" } & PaymentErrorsTable) | ({ _value: "Package" } & PackageErrorsTable) | ({ _value: "Promotion" } & PromotionErrorsTable) | ({ _value: "Represents" } & RepresentsErrorsTable) | ({ _value: "Ordered" } & OrderedErrorsTable); /** Union tainted type */export type TaintedTable = ({ _value: "Account" } & AccountTaintedTable) | ({ _value: "Did" } & DidTaintedTable) | ({ _value: "Appointment" } & AppointmentTaintedTable) | ({ _value: "Lead" } & LeadTaintedTable) | ({ _value: "TaxRate" } & TaxRateTaintedTable) | ({ _value: "Site" } & SiteTaintedTable) | ({ _value: "Employee" } & EmployeeTaintedTable) | ({ _value: "Route" } & RouteTaintedTable) | ({ _value: "Company" } & CompanyTaintedTable) | ({ _value: "Product" } & ProductTaintedTable) | ({ _value: "Service" } & ServiceTaintedTable) | ({ _value: "User" } & UserTaintedTable) | ({ _value: "Order" } & OrderTaintedTable) | ({ _value: "Payment" } & PaymentTaintedTable) | ({ _value: "Package" } & PackageTaintedTable) | ({ _value: "Promotion" } & PromotionTaintedTable) | ({ _value: "Represents" } & RepresentsTaintedTable) | ({ _value: "Ordered" } & OrderedTaintedTable); /** Per-variant field controller types */export interface AccountFieldControllersTable {  }
        export interface DidFieldControllersTable {  }
        export interface AppointmentFieldControllersTable {  }
        export interface LeadFieldControllersTable {  }
        export interface TaxRateFieldControllersTable {  }
        export interface SiteFieldControllersTable {  }
        export interface EmployeeFieldControllersTable {  }
        export interface RouteFieldControllersTable {  }
        export interface CompanyFieldControllersTable {  }
        export interface ProductFieldControllersTable {  }
        export interface ServiceFieldControllersTable {  }
        export interface UserFieldControllersTable {  }
        export interface OrderFieldControllersTable {  }
        export interface PaymentFieldControllersTable {  }
        export interface PackageFieldControllersTable {  }
        export interface PromotionFieldControllersTable {  }
        export interface RepresentsFieldControllersTable {  }
        export interface OrderedFieldControllersTable {  } /** Union Gigaform interface with variant switching */export interface GigaformTable {readonly currentVariant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"; readonly data: Table; readonly errors: ErrorsTable; readonly tainted: TaintedTable; readonly variants: VariantFieldsTable; switchVariant(variant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void; validate(): Result<Table, Array<{field: string; message: string}>>; reset(overrides?: Partial<Table>): void;}/** Variant fields container */export interface VariantFieldsTable {readonly Account: { readonly fields: AccountFieldControllersTable };
            readonly Did: { readonly fields: DidFieldControllersTable };
            readonly Appointment: { readonly fields: AppointmentFieldControllersTable };
            readonly Lead: { readonly fields: LeadFieldControllersTable };
            readonly TaxRate: { readonly fields: TaxRateFieldControllersTable };
            readonly Site: { readonly fields: SiteFieldControllersTable };
            readonly Employee: { readonly fields: EmployeeFieldControllersTable };
            readonly Route: { readonly fields: RouteFieldControllersTable };
            readonly Company: { readonly fields: CompanyFieldControllersTable };
            readonly Product: { readonly fields: ProductFieldControllersTable };
            readonly Service: { readonly fields: ServiceFieldControllersTable };
            readonly User: { readonly fields: UserFieldControllersTable };
            readonly Order: { readonly fields: OrderFieldControllersTable };
            readonly Payment: { readonly fields: PaymentFieldControllersTable };
            readonly Package: { readonly fields: PackageFieldControllersTable };
            readonly Promotion: { readonly fields: PromotionFieldControllersTable };
            readonly Represents: { readonly fields: RepresentsFieldControllersTable };
            readonly Ordered: { readonly fields: OrderedFieldControllersTable };}/** Gets default value for a specific variant */function getDefaultForVariantTable(variant: string): Table {
        switch (variant) {
            case "Account": return "Account" as Table;
            case "Did": return "Did" as Table;
            case "Appointment": return "Appointment" as Table;
            case "Lead": return "Lead" as Table;
            case "TaxRate": return "TaxRate" as Table;
            case "Site": return "Site" as Table;
            case "Employee": return "Employee" as Table;
            case "Route": return "Route" as Table;
            case "Company": return "Company" as Table;
            case "Product": return "Product" as Table;
            case "Service": return "Service" as Table;
            case "User": return "User" as Table;
            case "Order": return "Order" as Table;
            case "Payment": return "Payment" as Table;
            case "Package": return "Package" as Table;
            case "Promotion": return "Promotion" as Table;
            case "Represents": return "Represents" as Table;
            case "Ordered": return "Ordered" as Table;
            default: return "Account" as Table;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormTable(initial?: Table): GigaformTable {const initialVariant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" = (initial as "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered") ?? "Account"; let currentVariant = $state<"Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered">(initialVariant); let data = $state<Table>(initial?? getDefaultForVariantTable(initialVariant)); let errors = $state<ErrorsTable>({}as ErrorsTable); let tainted = $state<TaintedTable>({}as TaintedTable); const variants: VariantFieldsTable = {Account: {
                    fields: {
                        
                    } as AccountFieldControllersTable
                },
                Did: {
                    fields: {
                        
                    } as DidFieldControllersTable
                },
                Appointment: {
                    fields: {
                        
                    } as AppointmentFieldControllersTable
                },
                Lead: {
                    fields: {
                        
                    } as LeadFieldControllersTable
                },
                TaxRate: {
                    fields: {
                        
                    } as TaxRateFieldControllersTable
                },
                Site: {
                    fields: {
                        
                    } as SiteFieldControllersTable
                },
                Employee: {
                    fields: {
                        
                    } as EmployeeFieldControllersTable
                },
                Route: {
                    fields: {
                        
                    } as RouteFieldControllersTable
                },
                Company: {
                    fields: {
                        
                    } as CompanyFieldControllersTable
                },
                Product: {
                    fields: {
                        
                    } as ProductFieldControllersTable
                },
                Service: {
                    fields: {
                        
                    } as ServiceFieldControllersTable
                },
                User: {
                    fields: {
                        
                    } as UserFieldControllersTable
                },
                Order: {
                    fields: {
                        
                    } as OrderFieldControllersTable
                },
                Payment: {
                    fields: {
                        
                    } as PaymentFieldControllersTable
                },
                Package: {
                    fields: {
                        
                    } as PackageFieldControllersTable
                },
                Promotion: {
                    fields: {
                        
                    } as PromotionFieldControllersTable
                },
                Represents: {
                    fields: {
                        
                    } as RepresentsFieldControllersTable
                },
                Ordered: {
                    fields: {
                        
                    } as OrderedFieldControllersTable
                }}; function switchVariant(variant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void {currentVariant = variant; data = getDefaultForVariantTable(variant); errors = {}as ErrorsTable; tainted = {}as TaintedTable;}function validate(): Result<Table, Array<{field: string; message: string}>>{return fromObjectTable(data);}function reset(overrides?: Partial<Table>): void {data = overrides ? overrides as typeof data : getDefaultForVariantTable(currentVariant); errors = {}as ErrorsTable; tainted = {}as TaintedTable;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataTable(formData: FormData): Result<Table, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" | null; if(!discriminant){return Result.err([{field: "_value" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._value = discriminant; if (discriminant === "Account") {
                
            } else if (discriminant === "Did") {
                
            } else if (discriminant === "Appointment") {
                
            } else if (discriminant === "Lead") {
                
            } else if (discriminant === "TaxRate") {
                
            } else if (discriminant === "Site") {
                
            } else if (discriminant === "Employee") {
                
            } else if (discriminant === "Route") {
                
            } else if (discriminant === "Company") {
                
            } else if (discriminant === "Product") {
                
            } else if (discriminant === "Service") {
                
            } else if (discriminant === "User") {
                
            } else if (discriminant === "Order") {
                
            } else if (discriminant === "Payment") {
                
            } else if (discriminant === "Package") {
                
            } else if (discriminant === "Promotion") {
                
            } else if (discriminant === "Represents") {
                
            } else if (discriminant === "Ordered") {
                
            } return fromStringifiedJSONTable(JSON.stringify(obj));}


export type Item = RecordLink<Product> | /** @default */ RecordLink<Service>;

export function defaultValueItem(): Item {return defaultValueRecordLink<Service>();}

export function toStringifiedJSONItem(value: Item): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeItem(value, ctx));}export function toObjectItem(value: Item): unknown {const ctx = SerializeContext.create(); return __serializeItem(value, ctx);}export function __serializeItem(value: Item, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONItem(json: string, opts?: DeserializeOptions): Result<Item, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectItem(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectItem(obj: unknown, opts?: DeserializeOptions): Result<Item, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeItem(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Item.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeItem(value: any, ctx: DeserializeContext): Item | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Item | PendingRef;}if(typeof value!== "object" || value === null){throw new DeserializeError([{field: "_root" , message: "Item.__deserialize: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new DeserializeError([{field: "_root" , message: "Item.__deserialize: missing __type field for union dispatch" }]);}if(__typeName === "RecordLink<Product>" ){return __deserializeRecordLink(value, ctx)as Item;}if(__typeName === "RecordLink<Service>" ){return __deserializeRecordLink(value, ctx)as Item;}throw new DeserializeError([{field: "_root" , message: "Item.__deserialize: unknown type \"" + __typeName + "\". Expected one of: RecordLink<Product>, RecordLink<Service>" }]); }export function isItem(value: unknown): value is Item {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "RecordLink<Product>" || __typeName === "RecordLink<Service>" ; }

/** Per-variant error types */export type RecordLinkProductErrorsItem = { _errors: Option<Array<string>>;  };
        export type RecordLinkServiceErrorsItem = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type RecordLinkProductTaintedItem = {  };
        export type RecordLinkServiceTaintedItem = {  }; /** Union error type */export type ErrorsItem = ({ _type: "RecordLink<Product>" } & RecordLinkProductErrorsItem) | ({ _type: "RecordLink<Service>" } & RecordLinkServiceErrorsItem); /** Union tainted type */export type TaintedItem = ({ _type: "RecordLink<Product>" } & RecordLinkProductTaintedItem) | ({ _type: "RecordLink<Service>" } & RecordLinkServiceTaintedItem); /** Per-variant field controller types */export interface RecordLinkProductFieldControllersItem {  }
        export interface RecordLinkServiceFieldControllersItem {  } /** Union Gigaform interface with variant switching */export interface GigaformItem {readonly currentVariant: "RecordLink<Product>" | "RecordLink<Service>"; readonly data: Item; readonly errors: ErrorsItem; readonly tainted: TaintedItem; readonly variants: VariantFieldsItem; switchVariant(variant: "RecordLink<Product>" | "RecordLink<Service>"): void; validate(): Result<Item, Array<{field: string; message: string}>>; reset(overrides?: Partial<Item>): void;}/** Variant fields container */export interface VariantFieldsItem {readonly "RecordLink<Product>": { readonly fields: RecordLinkProductFieldControllersItem };
            readonly "RecordLink<Service>": { readonly fields: RecordLinkServiceFieldControllersItem };}/** Gets default value for a specific variant */function getDefaultForVariantItem(variant: string): Item {
        switch (variant) {
            case "RecordLink<Product>": return defaultValueRecordLink<Product>() as Item;
            case "RecordLink<Service>": return defaultValueRecordLink<Service>() as Item;
            default: return defaultValueRecordLink<Product>() as Item;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormItem(initial?: Item): GigaformItem {const initialVariant: "RecordLink<Product>" | "RecordLink<Service>" = "RecordLink<Product>"; let currentVariant = $state<"RecordLink<Product>" | "RecordLink<Service>">(initialVariant); let data = $state<Item>(initial?? getDefaultForVariantItem(initialVariant)); let errors = $state<ErrorsItem>({}as ErrorsItem); let tainted = $state<TaintedItem>({}as TaintedItem); const variants: VariantFieldsItem = {"RecordLink<Product>": {
                    fields: {
                        
                    } as RecordLinkProductFieldControllersItem
                },
                "RecordLink<Service>": {
                    fields: {
                        
                    } as RecordLinkServiceFieldControllersItem
                }}; function switchVariant(variant: "RecordLink<Product>" | "RecordLink<Service>"): void {currentVariant = variant; data = getDefaultForVariantItem(variant); errors = {}as ErrorsItem; tainted = {}as TaintedItem;}function validate(): Result<Item, Array<{field: string; message: string}>>{return fromObjectItem(data);}function reset(overrides?: Partial<Item>): void {data = overrides ? overrides as typeof data : getDefaultForVariantItem(currentVariant); errors = {}as ErrorsItem; tainted = {}as TaintedItem;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataItem(formData: FormData): Result<Item, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "RecordLink<Product>" | "RecordLink<Service>" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if (discriminant === "RecordLink<Product>") {
                
            } else if (discriminant === "RecordLink<Service>") {
                
            } return fromStringifiedJSONItem(JSON.stringify(obj));}


export type RecordLink<T> = /** @default */ string | T;

export function defaultValueRecordLink<T>(): RecordLink<T> {return "";}

export function toStringifiedJSONRecordLink<T>(value: RecordLink<T>): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeRecordLink<T>(value, ctx));}export function toObjectRecordLink<T>(value: RecordLink<T>): unknown {const ctx = SerializeContext.create(); return __serializeRecordLink<T>(value, ctx);}export function __serializeRecordLink<T>(value: RecordLink<T>, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONRecordLink<T>(json: string, opts?: DeserializeOptions): Result<RecordLink<T>, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectRecordLink<T>(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectRecordLink<T>(obj: unknown, opts?: DeserializeOptions): Result<RecordLink<T>, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeRecordLink<T>(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "RecordLink.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeRecordLink<T>(value: any, ctx: DeserializeContext): RecordLink<T> | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as RecordLink<T> | PendingRef;}if(typeof value === "string" ){return value as RecordLink<T>;}return value as RecordLink<T>; throw new DeserializeError([{field: "_root" , message: "RecordLink.__deserialize: value does not match any union member" }]); }export function isRecordLink<T>(value: unknown): value is RecordLink<T> {if(typeof value === "string" )return true; return true; }


export type Actor = /** @default */ User | Employee | Account;

export function defaultValueActor(): Actor {return defaultValueUser();}

export function toStringifiedJSONActor(value: Actor): string {const ctx = SerializeContext.create(); return JSON.stringify(__serializeActor(value, ctx));}export function toObjectActor(value: Actor): unknown {const ctx = SerializeContext.create(); return __serializeActor(value, ctx);}export function __serializeActor(value: Actor, ctx: SerializeContext): unknown {if(typeof(value as any)?.__serialize === "function" ){return(value as any).__serialize(ctx);}return value;}

export function fromStringifiedJSONActor(json: string, opts?: DeserializeOptions): Result<Actor, Array<{field: string; message: string}>>{try {const raw = JSON.parse(json); return fromObjectActor(raw, opts);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function fromObjectActor(obj: unknown, opts?: DeserializeOptions): Result<Actor, Array<{field: string; message: string}>>{try {const ctx = DeserializeContext.create(); const resultOrRef = __deserializeActor(obj, ctx); if(PendingRef.is(resultOrRef)){return Result.err([{field: "_root" , message: "Actor.fromObject: root cannot be a forward reference" }]);}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return Result.ok(resultOrRef);}catch(e){if(e instanceof DeserializeError){return Result.err(e.errors);}const message = e instanceof Error? e.message: String(e); return Result.err([{field: "_root" , message}]);}}export function __deserializeActor(value: any, ctx: DeserializeContext): Actor | PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Actor | PendingRef;}if(typeof value!== "object" || value === null){throw new DeserializeError([{field: "_root" , message: "Actor.__deserialize: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new DeserializeError([{field: "_root" , message: "Actor.__deserialize: missing __type field for union dispatch" }]);}if(__typeName === "User" ){return __deserializeUser(value, ctx)as Actor;}if(__typeName === "Employee" ){return __deserializeEmployee(value, ctx)as Actor;}if(__typeName === "Account" ){return __deserializeAccount(value, ctx)as Actor;}throw new DeserializeError([{field: "_root" , message: "Actor.__deserialize: unknown type \"" + __typeName + "\". Expected one of: User, Employee, Account" }]); }export function isActor(value: unknown): value is Actor {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "User" || __typeName === "Employee" || __typeName === "Account" ; }

/** Per-variant error types */export type UserErrorsActor = { _errors: Option<Array<string>>;  };
        export type EmployeeErrorsActor = { _errors: Option<Array<string>>;  };
        export type AccountErrorsActor = { _errors: Option<Array<string>>;  }; /** Per-variant tainted types */export type UserTaintedActor = {  };
        export type EmployeeTaintedActor = {  };
        export type AccountTaintedActor = {  }; /** Union error type */export type ErrorsActor = ({ _type: "User" } & UserErrorsActor) | ({ _type: "Employee" } & EmployeeErrorsActor) | ({ _type: "Account" } & AccountErrorsActor); /** Union tainted type */export type TaintedActor = ({ _type: "User" } & UserTaintedActor) | ({ _type: "Employee" } & EmployeeTaintedActor) | ({ _type: "Account" } & AccountTaintedActor); /** Per-variant field controller types */export interface UserFieldControllersActor {  }
        export interface EmployeeFieldControllersActor {  }
        export interface AccountFieldControllersActor {  } /** Union Gigaform interface with variant switching */export interface GigaformActor {readonly currentVariant: "User" | "Employee" | "Account"; readonly data: Actor; readonly errors: ErrorsActor; readonly tainted: TaintedActor; readonly variants: VariantFieldsActor; switchVariant(variant: "User" | "Employee" | "Account"): void; validate(): Result<Actor, Array<{field: string; message: string}>>; reset(overrides?: Partial<Actor>): void;}/** Variant fields container */export interface VariantFieldsActor {readonly User: { readonly fields: UserFieldControllersActor };
            readonly Employee: { readonly fields: EmployeeFieldControllersActor };
            readonly Account: { readonly fields: AccountFieldControllersActor };}/** Gets default value for a specific variant */function getDefaultForVariantActor(variant: string): Actor {
        switch (variant) {
            case "User": return defaultValueUser() as Actor;
            case "Employee": return defaultValueEmployee() as Actor;
            case "Account": return defaultValueAccount() as Actor;
            default: return defaultValueUser() as Actor;
        }
    } /** Creates a new discriminated union Gigaform with variant switching */export function createFormActor(initial?: Actor): GigaformActor {const initialVariant: "User" | "Employee" | "Account" = "User"; let currentVariant = $state<"User" | "Employee" | "Account">(initialVariant); let data = $state<Actor>(initial?? getDefaultForVariantActor(initialVariant)); let errors = $state<ErrorsActor>({}as ErrorsActor); let tainted = $state<TaintedActor>({}as TaintedActor); const variants: VariantFieldsActor = {User: {
                    fields: {
                        
                    } as UserFieldControllersActor
                },
                Employee: {
                    fields: {
                        
                    } as EmployeeFieldControllersActor
                },
                Account: {
                    fields: {
                        
                    } as AccountFieldControllersActor
                }}; function switchVariant(variant: "User" | "Employee" | "Account"): void {currentVariant = variant; data = getDefaultForVariantActor(variant); errors = {}as ErrorsActor; tainted = {}as TaintedActor;}function validate(): Result<Actor, Array<{field: string; message: string}>>{return fromObjectActor(data);}function reset(overrides?: Partial<Actor>): void {data = overrides ? overrides as typeof data : getDefaultForVariantActor(currentVariant); errors = {}as ErrorsActor; tainted = {}as TaintedActor;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function fromFormDataActor(formData: FormData): Result<Actor, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "User" | "Employee" | "Account" | null; if(!discriminant){return Result.err([{field: "_type" , message: "Missing discriminant field" }]);}const obj: Record<string, unknown>= {}; obj._type = discriminant; if (discriminant === "User") {
                
            } else if (discriminant === "Employee") {
                
            } else if (discriminant === "Account") {
                
            } return fromStringifiedJSONActor(JSON.stringify(obj));}